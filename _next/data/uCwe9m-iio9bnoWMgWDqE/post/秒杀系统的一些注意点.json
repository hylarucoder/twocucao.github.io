{"pageProps":{"post":{"tags":["秒杀"],"path":"20190210_秒杀系统的一些注意点.md","title":"秒杀系统的一些注意点","slug":"秒杀系统的一些注意点","date":"2019-02-10","category":"系统设计","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"<h2 id=\"0x00-前言\"><a class=\"v-toc-item\" href=\"#0x00-前言\">#</a> 0x00 前言</h2>\n<h2 id=\"秒杀常见问题\"><a class=\"v-toc-item\" href=\"#秒杀常见问题\">#</a> 秒杀常见问题</h2>\n<h3 id=\"01-卖超问题\"><a class=\"v-toc-item\" href=\"#01-卖超问题\">#</a> 01 卖超问题</h3>\n<p>假设有 20 个商品要卖，1W 个请求打过来。</p>\n<ol>\n<li>SQL 加上数量判断，防止数量超掉</li>\n</ol>\n<p>应用层的检查，并发量上来，肯定要加行级锁，开销比较大。</p>\n<ol start=\"2\">\n<li>redis 集合预先缓存好相关的数量，然后从 redis 上进行应用层的数量检查。</li>\n</ol>\n<p>然后走异步队列。</p>\n<p>因为对于数据库来说，我只要 20 个请求即可，redis 起到了一个阻挡多余的请求穿透到 DB 中的作用。</p>\n<p>即便如此，redis 依然可能会出现一些意外的情况，比如为负数，这个时候多打进去几个请求，变成 24 个，这个时候 MQ 的作用就出来了。排好队伍。</p>\n<ol start=\"3\">\n<li>唯一索引</li>\n</ol>\n<p>数据库层的检查，可以从根本上防止问题</p>\n<h3 id=\"02-缓存问题\"><a class=\"v-toc-item\" href=\"#02-缓存问题\">#</a> 02 缓存问题</h3>\n<ol>\n<li>page 级别的缓存，由于 wsgi 协议本身在 flask 中返回的就是文本，所以，当作文本处理即可</li>\n<li>obj 级别的缓存</li>\n</ol>\n<p>能走内存的走内存，能走 redis 就走 redis, 能通过 mq 削减峰值的就走 mq, 能走 mongodb 的走 mongodb, 最后是数据库。</p>\n<h3 id=\"03-安全\"><a class=\"v-toc-item\" href=\"#03-安全\">#</a> 03 安全</h3>\n<ol>\n<li>验证码</li>\n<li>接口防刷限流</li>\n<li>秒杀接口隐藏</li>\n</ol>\n<h3 id=\"04-分布式锁\"><a class=\"v-toc-item\" href=\"#04-分布式锁\">#</a> 04 分布式锁</h3>\n<ol>\n<li>不加锁，并发起来资源浪费</li>\n<li>加锁，然而，线路抖动会导致不能及时释放锁</li>\n<li>加过期锁，或者加带有时间的锁，然后重新获取锁。</li>\n<li>redisson 封装好的方法</li>\n</ol>\n<h3 id=\"06-减少数据库访问时间\"><a class=\"v-toc-item\" href=\"#06-减少数据库访问时间\">#</a> 06 减少数据库访问时间</h3>\n<ol>\n<li>首先考虑在 where 和 order by 设计的列上建立索引</li>\n<li>索引越多，插入越慢，这个要做好平衡</li>\n<li>避免过长的事务级操作，提高并发能力</li>\n</ol>\n<p>其他的可以参考 MySQL 的一些优化原则，油管上很多。</p>\n<h3 id=\"07-分布式事务\"><a class=\"v-toc-item\" href=\"#07-分布式事务\">#</a> 07 分布式事务</h3>\n<p>分布式事务，准确来说，是分布式</p>\n<h2 id=\"0xee-参考\"><a class=\"v-toc-item\" href=\"#0xee-参考\">#</a> 0xEE 参考</h2>\n<h3 id=\"pep\"><a class=\"v-toc-item\" href=\"#pep\">#</a> PEP</h3>\n<ul>\n<li>\n<p>PEP 3107</p>\n</li>\n<li>\n<p>PEP 483</p>\n</li>\n<li>\n<p>PEP 3107</p>\n</li>\n<li>\n<p>PEP 3107</p>\n</li>\n<li>\n<p><a href=\"http://wphomes.soic.indiana.edu/jsiek/what-is-gradual-typing/\">关于 gradual typing</a></p>\n</li>\n</ul>\n<p><a href=\"https://mypy.readthedocs.io/en/latest/cheat_sheet_py3.html\">https://mypy.readthedocs.io/en/latest/cheat_sheet_py3.html</a></p>\n<p><a href=\"https://blog.zulip.org/2016/10/13/static-types-in-python-oh-mypy/\">https://blog.zulip.org/2016/10/13/static-types-in-python-oh-mypy/</a></p>\n<hr>\n<p>ChangeLog:</p>\n<ul>\n<li><strong>2018-11-25</strong> 初始化本文</li>\n</ul>\n","toc":"<ul class=\"v-article-toc\">\n<li>\n<ul>\n<li><a href=\"#0x00-%E5%89%8D%E8%A8%80\">0x00 前言</a></li>\n<li><a href=\"#%E7%A7%92%E6%9D%80%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98\">秒杀常见问题</a>\n<ul>\n<li><a href=\"#01-%E5%8D%96%E8%B6%85%E9%97%AE%E9%A2%98\">01 卖超问题</a></li>\n<li><a href=\"#02-%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98\">02 缓存问题</a></li>\n<li><a href=\"#03-%E5%AE%89%E5%85%A8\">03 安全</a></li>\n<li><a href=\"#04-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81\">04 分布式锁</a></li>\n<li><a href=\"#06-%E5%87%8F%E5%B0%91%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BF%E9%97%AE%E6%97%B6%E9%97%B4\">06 减少数据库访问时间</a></li>\n<li><a href=\"#07-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1\">07 分布式事务</a></li>\n</ul>\n</li>\n<li><a href=\"#0xee-%E5%8F%82%E8%80%83\">0xEE 参考</a>\n<ul>\n<li><a href=\"#pep\">PEP</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n"}},"__N_SSG":true}