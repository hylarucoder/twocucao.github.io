{"pageProps":{"post":{"tags":["Golang","CheatSheat"],"path":"20180829_GoLang.md","title":"写给 Pythonista 的 Golang 入门指北","slug":"写给 Pythonista 的 Golang 入门指北","date":"2018-08-29","category":"Golang","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"<p>原计划是去年 8 月份入 Golang 大法的，然后开一篇帖子进行写个入门指北来着。这一拖就拖到了今年。</p>\n<p>同样是快速上手教程，这篇文章和其他的文章的不同点在于，完全假设你是 Pythonista 的入门。</p>\n<h2 id=\"0x00-前言\"><a class=\"v-toc-item\" href=\"#0x00-前言\">#</a> 0x00 前言</h2>\n<h2 id=\"0x01-安装\"><a class=\"v-toc-item\" href=\"#0x01-安装\">#</a> 0x01 安装</h2>\n<p>Golang 安装</p>\n<pre><code># 如果你是在 mac 上，建议先安装下面的 SDK 以防不测\nopen /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg\n# 安装 golang\nbrew install golang\n# 配置环境变量\necho $GOPATH # /Users/twocucao/Codes/ReposGo\n\ncd /Users/twocucao/Codes/ReposPublic/\n\nmkcd thanos # mkdir &amp;&amp; cd\ngo mod init github.com/twocucao/thanos\ngit remote add origin git@github.com:twocucao/thanos.git\n</code></pre>\n<p>接下来，需要解决卡 <a href=\"http://golang.org\">golang.org</a> 的网络问题。</p>\n<pre><code>export GOPROXY=https://goproxy.io\ngo get -v -u github.com/hqpko/go-mod-tidy\ngo mod tidy\n</code></pre>\n<p>接下来就是随便找一些带有依赖库的代码。放到该文件夹下面。</p>\n<p>你也可以直接从这里 <a href=\"https://github.com/twocucao/thanos.git\">https://github.com/twocucao/thanos.git</a> 拉取代码</p>\n<h2 id=\"0x01-基本概念\"><a class=\"v-toc-item\" href=\"#0x01-基本概念\">#</a> 0x01 基本概念</h2>\n<h3 id=\"工具链\"><a class=\"v-toc-item\" href=\"#工具链\">#</a> 工具链</h3>\n<h3 id=\"文档\"><a class=\"v-toc-item\" href=\"#文档\">#</a> 文档</h3>\n<h3 id=\"社区\"><a class=\"v-toc-item\" href=\"#社区\">#</a> 社区</h3>\n<h3 id=\"书籍\"><a class=\"v-toc-item\" href=\"#书籍\">#</a> 书籍</h3>\n<h3 id=\"内置简单类型\"><a class=\"v-toc-item\" href=\"#内置简单类型\">#</a> 内置简单类型</h3>\n<p>对于一些基本的数据类型，操作为 加减乘除取余数位运算等等</p>\n<ul>\n<li>数字类型</li>\n<li>布尔类型</li>\n<li>字符串类型</li>\n<li>数组 / 列表</li>\n<li>字典</li>\n</ul>\n<h3 id=\"内置复杂类型\"><a class=\"v-toc-item\" href=\"#内置复杂类型\">#</a> 内置复杂类型</h3>\n<ul>\n<li>集合结构 : 串</li>\n<li>线性结构 : 线性表 （单链表，静态链表，循环链表，双向链表，<strong>栈，队列</strong>)</li>\n<li>树形结构 : 树（二叉树，B+ 树，红黑树）</li>\n<li>图形结构 : 图</li>\n</ul>\n<h3 id=\"对象\"><a class=\"v-toc-item\" href=\"#对象\">#</a> 对象</h3>\n<h3 id=\"字符串\"><a class=\"v-toc-item\" href=\"#字符串\">#</a> 字符串</h3>\n<h2 id=\"0x02-中级概念\"><a class=\"v-toc-item\" href=\"#0x02-中级概念\">#</a> 0x02 中级概念</h2>\n<h3 id=\"函数\"><a class=\"v-toc-item\" href=\"#函数\">#</a> 函数</h3>\n<h4 id=\"作用域\"><a class=\"v-toc-item\" href=\"#作用域\">#</a> 作用域</h4>\n<h3 id=\"模块\"><a class=\"v-toc-item\" href=\"#模块\">#</a> 模块</h3>\n<p>模块，这个概念，可大可小，大的时候，把一个程序说成是模块，小的时候，可以把一个文件，甚至你说这一个函数是一个模块，也行。</p>\n<p>这里的模块指的是一个包下的函数。</p>\n<h3 id=\"面向对象\"><a class=\"v-toc-item\" href=\"#面向对象\">#</a> 面向对象</h3>\n<p>面向对象有三大概念：</p>\n<ul>\n<li>封装</li>\n<li>继承</li>\n<li>多态</li>\n</ul>\n<h3 id=\"错误-调试测试\"><a class=\"v-toc-item\" href=\"#错误-调试测试\">#</a> 错误 / 调试测试</h3>\n<p>异常处理实际上可以考验一个程序员编写代码的健壮性。</p>\n<p>事实上来说，代码写的健壮是一个程序员必备的素养。但其实在开发过程中，出于对项目进行赶工上线，需要对程序的健壮性做出一定的取舍。并且，在编写客户端，服务端，网页前端的时候基本上都会遇到这个问题。什么时候选择健壮的程序，什么时候选择是还可以的程序。需要自己的经验。</p>\n<h3 id=\"io-编程\"><a class=\"v-toc-item\" href=\"#io-编程\">#</a> IO 编程</h3>\n<h3 id=\"进程和线程\"><a class=\"v-toc-item\" href=\"#进程和线程\">#</a> 进程和线程</h3>\n<h4 id=\"多线程\"><a class=\"v-toc-item\" href=\"#多线程\">#</a> 多线程</h4>\n<blockquote>\n<p>Go 多线程约等于并发。</p>\n</blockquote>\n<h4 id=\"多进程\"><a class=\"v-toc-item\" href=\"#多进程\">#</a> 多进程</h4>\n<h5 id=\"协同式多任务处理\"><a class=\"v-toc-item\" href=\"#协同式多任务处理\">#</a> 协同式多任务处理</h5>\n<p>如果有两个线程，同时进行 IO 请求，当其中一个线程连接之后，立即会<strong>主动让出 GIL</strong>, 其他线程就可以运行。</p>\n<blockquote>\n<p>当 N 个线程在网络 I/O 堵塞，或等待重新获取 GIL，而一个线程运行 Python。</p>\n</blockquote>\n<p>让出之后还要执行代码呀，所以要有个收回 GIL 的动作。</p>\n<h5 id=\"抢占式多任务处理\"><a class=\"v-toc-item\" href=\"#抢占式多任务处理\">#</a> 抢占式多任务处理</h5>\n<h5 id=\"线程安全\"><a class=\"v-toc-item\" href=\"#线程安全\">#</a> 线程安全</h5>\n<p>原子操作：sort 之类不需要<br>\n非原子操作：n=n+2 的字节码分为 加载 n , 加载 2 , 相加，存储 n, 四个步骤，由于不是原子性，很可能被由于 15 ms 而被打断。</p>\n<p>当然，懒人一向是 : <strong>优先级不决加括号，线程不决加 lock</strong></p>\n<p>对于 Java, 程序员努力在尽可能短的时间内加锁存取共享数据，减轻线程的争夺，实现最大并行。但 Python 中，线程无法并行运行，细粒度的锁就没有了优势。</p>\n<h3 id=\"正则表达式\"><a class=\"v-toc-item\" href=\"#正则表达式\">#</a> 正则表达式</h3>\n<h2 id=\"0x03-高级技巧\"><a class=\"v-toc-item\" href=\"#0x03-高级技巧\">#</a> 0x03 高级技巧</h2>\n<h2 id=\"0x04-标准库\"><a class=\"v-toc-item\" href=\"#0x04-标准库\">#</a> 0x04 标准库</h2>\n<h3 id=\"常用内建模块\"><a class=\"v-toc-item\" href=\"#常用内建模块\">#</a> 常用内建模块</h3>\n<h3 id=\"系统化模块\"><a class=\"v-toc-item\" href=\"#系统化模块\">#</a> 系统化模块</h3>\n<h2 id=\"0x05-第三方库\"><a class=\"v-toc-item\" href=\"#0x05-第三方库\">#</a> 0x05 第三方库</h2>\n<ul>\n<li>Requests : API 人性化</li>\n</ul>\n<h2 id=\"0x06-代码质量\"><a class=\"v-toc-item\" href=\"#0x06-代码质量\">#</a> 0x06 代码质量</h2>\n<h3 id=\"正确性\"><a class=\"v-toc-item\" href=\"#正确性\">#</a> 正确性</h3>\n<h3 id=\"可维护性\"><a class=\"v-toc-item\" href=\"#可维护性\">#</a> 可维护性</h3>\n<h3 id=\"可读性\"><a class=\"v-toc-item\" href=\"#可读性\">#</a> 可读性</h3>\n<h3 id=\"安全性\"><a class=\"v-toc-item\" href=\"#安全性\">#</a> 安全性</h3>\n<h3 id=\"性能\"><a class=\"v-toc-item\" href=\"#性能\">#</a> 性能</h3>\n<h2 id=\"0x07-常用命令\"><a class=\"v-toc-item\" href=\"#0x07-常用命令\">#</a> 0x07 常用命令</h2>\n<pre><code>go build\ngo install -v\ngo clean\ngo fmt\ngo get\ngo test\ngo tool fix . # 修复老代码到新版本\ngo tool vet directory|files\ngo tool yacc -o gopher.go -p parser gopher.y\ngodoc -http=:8080\ngo version 查看 go 当前的版本\ngo env 查看当前 go 的环境变量\ngo list 列出当前全部安装的 package\ngo run 编译并运行 Go 程序\n</code></pre>\n<h2 id=\"0xee-文章更新\"><a class=\"v-toc-item\" href=\"#0xee-文章更新\">#</a> 0xEE 文章更新</h2>\n<pre><code># 如果你是在 mac 上，建议先安装下面的 SDK 以防不测\nopen /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg\n\n</code></pre>\n<h1 id=\"golang\"><a class=\"v-toc-item\" href=\"#golang\">#</a> Golang</h1>\n<h2 id=\"模块-01go-语言实践-runtime\"><a class=\"v-toc-item\" href=\"#模块-01go-语言实践-runtime\">#</a> 模块 01：Go 语言实践 - Runtime</h2>\n<h3 id=\"goroutine-的调度原理\"><a class=\"v-toc-item\" href=\"#goroutine-的调度原理\">#</a> Goroutine 的调度原理</h3>\n<ul>\n<li>Goroutine 和线程的区别</li>\n<li>Goroutine 的实现、GPM 调度模型、调度状态及流转、调度原理、协作式抢占以及和网络库的协作</li>\n</ul>\n<p><a href=\"https://www.jianshu.com/p/105719434c29\">https://www.jianshu.com/p/105719434c29</a></p>\n<p><a href=\"https://zboya.github.io/post/go_scheduler/\">https://zboya.github.io/post/go_scheduler/</a></p>\n<p><a href=\"https://studygolang.com/articles/16407\">https://studygolang.com/articles/16407</a></p>\n<h3 id=\"内存模型\"><a class=\"v-toc-item\" href=\"#内存模型\">#</a> 内存模型</h3>\n<p>Go 的内存分配机制<br>\nGo 内存分配的内部结构和分配机制</p>\n<p><a href=\"https://deepu.tech/memory-management-in-golang/\">https://deepu.tech/memory-management-in-golang/</a></p>\n<p><a href=\"https://medium.com/a-journey-with-go/go-memory-management-and-allocation-a7396d430f44\">https://medium.com/a-journey-with-go/go-memory-management-and-allocation-a7396d430f44</a></p>\n<h3 id=\"gc垃圾回收的原理\"><a class=\"v-toc-item\" href=\"#gc垃圾回收的原理\">#</a> GC（垃圾回收）的原理</h3>\n<p>GC 三色标记算法</p>\n<p><a href=\"https://blog.golang.org/ismmkeynote\">https://blog.golang.org/ismmkeynote</a></p>\n<p>GC 介绍、三色标记的实现原理、GC 的流程以及 GC 的一些优化方案</p>\n<h3 id=\"channel-的消息通讯原理\"><a class=\"v-toc-item\" href=\"#channel-的消息通讯原理\">#</a> channel 的消息通讯原理</h3>\n<p>channel 的底层实现<br>\nchannel 的通讯机制、环形队列的结构、调度和唤醒的原理</p>\n<p><a href=\"https://stackoverflow.com/questions/19621149/how-are-go-channels-implemented\">https://stackoverflow.com/questions/19621149/how-are-go-channels-implemented</a></p>\n<h2 id=\"模块-02go-语言实践-并行编程\"><a class=\"v-toc-item\" href=\"#模块-02go-语言实践-并行编程\">#</a> 模块 02：Go 语言实践 - 并行编程</h2>\n<h3 id=\"memory-model\"><a class=\"v-toc-item\" href=\"#memory-model\">#</a> Memory Model</h3>\n<p>Go 中内存模型和同步语义</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/110032965\">https://zhuanlan.zhihu.com/p/110032965</a><br>\n<a href=\"https://golang.org/ref/mem\">https://golang.org/ref/mem</a><br>\n<a href=\"https://golang.org/doc/\">https://golang.org/doc/</a></p>\n<p>内存模型：Happens Before、同步语义、channel 通讯、锁</p>\n<h3 id=\"并发特性并发编程模式\"><a class=\"v-toc-item\" href=\"#并发特性并发编程模式\">#</a> 并发特性并发编程模式</h3>\n<p><a href=\"https://blog.golang.org/pipelines\">https://blog.golang.org/pipelines</a></p>\n<p>Timeout、Pipeline、Cancellation、Fanout、errgroup 等模式<br>\n利用 channel 完成并行开发的设计模式，包含超时控制、管道、扇出、errgroup 并发<br>\n无法熟练使用基于 channel 通讯方式的并行编程模式</p>\n<h3 id=\"context-的原理并掌握其使用方法\"><a class=\"v-toc-item\" href=\"#context-的原理并掌握其使用方法\">#</a> Context 的原理并掌握其使用方法</h3>\n<p>Context 传播式传递有什么意义<br>\n使用 Go 标准库 Context 的原理和最佳实践，包含超时控制、元数据传递、生命周期控制</p>\n<p><a href=\"https://blog.golang.org/context\">https://blog.golang.org/context</a><br>\n<a href=\"https://levelup.gitconnected.com/context-in-golang-98908f042a57\">https://levelup.gitconnected.com/context-in-golang-98908f042a57</a></p>\n<h2 id=\"模块-03go-语言实践-网络编程\"><a class=\"v-toc-item\" href=\"#模块-03go-语言实践-网络编程\">#</a> 模块 03：Go 语言实践 - 网络编程</h2>\n<h3 id=\"golang-tcp-网络编程\"><a class=\"v-toc-item\" href=\"#golang-tcp-网络编程\">#</a> Golang TCP 网络编程</h3>\n<p>Go 实现高性能的 TCP Server</p>\n<p>goim 项目了解 Go 语言中 TCP Server 的基础库和性能优化方案</p>\n<h3 id=\"golang-http-网络编程\"><a class=\"v-toc-item\" href=\"#golang-http-网络编程\">#</a> Golang HTTP 网络编程</h3>\n<p>HTTP 框架选型<br>\n针对业务需求对 HTTP 框架做针对性的扩展<br>\n结合 gin 项目了解 Go 语言中的 HTTP Server 的基础库和框架</p>\n<h2 id=\"模块-04go-语言实践-异常处理\"><a class=\"v-toc-item\" href=\"#模块-04go-语言实践-异常处理\">#</a> 模块 04：Go 语言实践 - 异常处理</h2>\n<h3 id=\"error-的处理方法\"><a class=\"v-toc-item\" href=\"#error-的处理方法\">#</a> error 的处理方法</h3>\n<h3 id=\"业务错误的处理方法\"><a class=\"v-toc-item\" href=\"#业务错误的处理方法\">#</a> 业务错误的处理方法</h3>\n<p>error 的处理复杂，不会正确使用<br>\n业务错误定义和 error 整合难度较高</p>\n<p>Go 语言中的 error 处理实践：检查错误、定义错误、追加上下文<br>\nGo 项目中的业务错误码如何结合 error 的最佳实践</p>\n<h2 id=\"模块-05go-工程化实践\"><a class=\"v-toc-item\" href=\"#模块-05go-工程化实践\">#</a> 模块 05：Go 工程化实践</h2>\n<h3 id=\"良好的项目目录组织原则和规范\"><a class=\"v-toc-item\" href=\"#良好的项目目录组织原则和规范\">#</a> 良好的项目目录组织原则和规范</h3>\n<h3 id=\"api-的设计方法和规范\"><a class=\"v-toc-item\" href=\"#api-的设计方法和规范\">#</a> API 的设计方法和规范</h3>\n<h3 id=\"package-的管理和设计方法\"><a class=\"v-toc-item\" href=\"#package-的管理和设计方法\">#</a> Package 的管理和设计方法</h3>\n<h3 id=\"单元测试\"><a class=\"v-toc-item\" href=\"#单元测试\">#</a> 单元测试</h3>\n<ol>\n<li>\n<p>Go 项目的标准化管理</p>\n</li>\n<li>\n<p>设计 API</p>\n</li>\n<li>\n<p>包管理</p>\n</li>\n<li>\n<p>良好的 Go 项目中的分层目录结构组织和代码规范</p>\n</li>\n<li>\n<p>Go 项目中 API 的设计原则和方法：定义、状态和业务错误码处理</p>\n</li>\n<li>\n<p>Go 项目中包的设计和最佳实践、go mod 的使用</p>\n</li>\n<li>\n<p>go test 工具链的使用方法、单元测试的最佳实践以及 Mock 技术</p>\n</li>\n</ol>\n<h2 id=\"模块-06go-架构实践-分布式架构前端负载均衡\"><a class=\"v-toc-item\" href=\"#模块-06go-架构实践-分布式架构前端负载均衡\">#</a> 模块 06：Go 架构实践 - 分布式架构（前端负载均衡）</h2>\n<h3 id=\"高可用-dns-的最佳实践\"><a class=\"v-toc-item\" href=\"#高可用-dns-的最佳实践\">#</a> 高可用 DNS 的最佳实践</h3>\n<h3 id=\"cdn-的架构和应用场景\"><a class=\"v-toc-item\" href=\"#cdn-的架构和应用场景\">#</a> CDN 的架构和应用场景</h3>\n<h3 id=\"深入理解-47-层负载均衡的原理\"><a class=\"v-toc-item\" href=\"#深入理解-47-层负载均衡的原理\">#</a> 深入理解 4/7 层负载均衡的原理</h3>\n<p>在线服务的全链路视野<br>\n应用服务上层的负载均衡</p>\n<p>DNS 的原理、防劫持的方法、HTTPDNS + IP 长连接<br>\nCDN 的系统架构、应用领域以及保证数据一致性的方法<br>\nLVS、Nginx 4/7 层负载均衡的原理和实践</p>\n<h2 id=\"模块-07go-架构实践-分布式架构数据分片\"><a class=\"v-toc-item\" href=\"#模块-07go-架构实践-分布式架构数据分片\">#</a> 模块 07：Go 架构实践 - 分布式架构（数据分片）</h2>\n<h3 id=\"数据-sharding-的设计原则\"><a class=\"v-toc-item\" href=\"#数据-sharding-的设计原则\">#</a> 数据 Sharding 的设计原则</h3>\n<h3 id=\"了解-hash-分片的算法和演进历史\"><a class=\"v-toc-item\" href=\"#了解-hash-分片的算法和演进历史\">#</a> 了解 Hash 分片的算法和演进历史</h3>\n<p>Sharding 的应用场景，不会合理使用<br>\nHash 算法的使用场景</p>\n<p>数据分片设计，如：分库分表、多活的 Shard 设计等等<br>\n分片算法的 Hash 实现和演进：Hash 求余、一致性 Hash、有界负载一致性 Hash、节点映射</p>\n<h2 id=\"模块-08go-架构实践-微服务微服务概览与治理\"><a class=\"v-toc-item\" href=\"#模块-08go-架构实践-微服务微服务概览与治理\">#</a> 模块 08：Go 架构实践 - 微服务（微服务概览与治理）</h2>\n<h3 id=\"微服务的演进历史及优缺点\"><a class=\"v-toc-item\" href=\"#微服务的演进历史及优缺点\">#</a> 微服务的演进历史及优缺点</h3>\n<h3 id=\"微服务的设计方法\"><a class=\"v-toc-item\" href=\"#微服务的设计方法\">#</a> 微服务的设计方法</h3>\n<h3 id=\"微服务中-rpc-的底层原理\"><a class=\"v-toc-item\" href=\"#微服务中-rpc-的底层原理\">#</a> 微服务中 RPC 的底层原理</h3>\n<p>微服务的服务角色：API Gateway、BFF 还是 Service？<br>\n微服务拆分<br>\nRPC 的原理，不知道如何进行微服务 RPC 框架的选型</p>\n<p>微服务的原理、概念，以及微服务的实现细节<br>\nAPI Gateway、BFF、Service 等概念精讲<br>\n微服务通讯 RPC 框架的细节和选型</p>\n<h2 id=\"模块-09go-架构实践-微服务可用性设计\"><a class=\"v-toc-item\" href=\"#模块-09go-架构实践-微服务可用性设计\">#</a> 模块 09：Go 架构实践 - 微服务（可用性设计）</h2>\n<h3 id=\"可用性设计的最佳实践\"><a class=\"v-toc-item\" href=\"#可用性设计的最佳实践\">#</a> 可用性设计的最佳实践</h3>\n<h3 id=\"可用性设计的几大关键点隔离-超时控制-过载保护-限流-容错-重试\"><a class=\"v-toc-item\" href=\"#可用性设计的几大关键点隔离-超时控制-过载保护-限流-容错-重试\">#</a> 可用性设计的几大关键点：隔离、超时控制、过载保护、限流、容错 &amp; 重试</h3>\n<p>如何设计高可用的分布式服务<br>\n何提升服务自愈能力</p>\n<p>微服务的隔离实现，以及架构设计中的隔离实现<br>\n进程内超时控制和跨进程超时控制<br>\n程序自保护避免过载，抛弃一定的流量完成自适应限流<br>\n单机限流、多租户场景的分布式限流<br>\n节点故障的容错逻辑、重试容错的策略和设计</p>\n<h2 id=\"模块-10go-架构实践-中间件日志-指标-链路追踪\"><a class=\"v-toc-item\" href=\"#模块-10go-架构实践-中间件日志-指标-链路追踪\">#</a> 模块 10：Go 架构实践 - 中间件（日志、指标、链路追踪）</h2>\n<h3 id=\"日志收集\"><a class=\"v-toc-item\" href=\"#日志收集\">#</a> 日志收集</h3>\n<h3 id=\"监控指标体系\"><a class=\"v-toc-item\" href=\"#监控指标体系\">#</a> 监控指标体系</h3>\n<h3 id=\"分布式链路追踪\"><a class=\"v-toc-item\" href=\"#分布式链路追踪\">#</a> 分布式链路追踪</h3>\n<p>如何解决微服务的可观测性难题<br>\n怎么做微服务的可视化和标准化<br>\n出故障后，难以对微服务进行问题诊断</p>\n<p>实现一个可以集中收集所有微服务实例的日志，并能统一查看和检索的日志采集架构<br>\n指标监控、使用 Prometheus 解决监控可视化、指标采集<br>\n微服务中的跨服务性能问题诊断，结合 Jaeger 实现分布式链路追踪</p>\n<h2 id=\"模块-11go-架构实践-中间件缓存-数据库\"><a class=\"v-toc-item\" href=\"#模块-11go-架构实践-中间件缓存-数据库\">#</a> 模块 11：Go 架构实践 - 中间件（缓存、数据库）</h2>\n<h3 id=\"redis-memcache-的原理和实战技巧\"><a class=\"v-toc-item\" href=\"#redis-memcache-的原理和实战技巧\">#</a> Redis、Memcache 的原理和实战技巧</h3>\n<h3 id=\"mysql-的常用设计和优化方法\"><a class=\"v-toc-item\" href=\"#mysql-的常用设计和优化方法\">#</a> MySQL 的常用设计和优化方法</h3>\n<ol>\n<li>\n<p>解决缓存的一致性问题</p>\n</li>\n<li>\n<p>怎样合理地设计 MySQL 的表</p>\n</li>\n<li>\n<p>Redis、Memcache 的应用场景、最佳实践，以及缓存的一致性设计</p>\n</li>\n<li>\n<p>MySQL 的表设计、常用优化手段，以及如何解决分布式事务</p>\n</li>\n</ol>\n<h2 id=\"模块-12go-架构实践-中间件消息队列-服务发现\"><a class=\"v-toc-item\" href=\"#模块-12go-架构实践-中间件消息队列-服务发现\">#</a> 模块 12：Go 架构实践 - 中间件（消息队列、服务发现）</h2>\n<h3 id=\"深入理解消息队列的原理掌握基于消息队列的架构设计方法\"><a class=\"v-toc-item\" href=\"#深入理解消息队列的原理掌握基于消息队列的架构设计方法\">#</a> 深入理解消息队列的原理，掌握基于消息队列的架构设计方法</h3>\n<h3 id=\"服务发现原理-选型策略以及服务发现实现的微服务多租户架构\"><a class=\"v-toc-item\" href=\"#服务发现原理-选型策略以及服务发现实现的微服务多租户架构\">#</a> 服务发现原理、选型策略，以及服务发现实现的微服务多租户架构</h3>\n<ol>\n<li>\n<p>消息解耦的架构设计</p>\n</li>\n<li>\n<p>如何实现服务发现对平滑发布的支持</p>\n</li>\n<li>\n<p>怎样利用多租户实现多测试环境</p>\n</li>\n<li>\n<p>Kafka 的实现原理、异步消息系统的架构设计</p>\n</li>\n<li>\n<p>RPC 服务发现、动态地址的选型和实现原理，以及基于服务发现的平滑重启和多租户架构</p>\n</li>\n</ol>\n<hr>\n<p>ChangeLog:</p>\n<ul>\n<li><strong>2018-08-22</strong> 初始化接口</li>\n</ul>\n","toc":"<ul class=\"v-article-toc\">\n<li>\n<ul>\n<li><a href=\"#0x00-%E5%89%8D%E8%A8%80\">0x00 前言</a></li>\n<li><a href=\"#0x01-%E5%AE%89%E8%A3%85\">0x01 安装</a></li>\n<li><a href=\"#0x01-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\">0x01 基本概念</a>\n<ul>\n<li><a href=\"#%E5%B7%A5%E5%85%B7%E9%93%BE\">工具链</a></li>\n<li><a href=\"#%E6%96%87%E6%A1%A3\">文档</a></li>\n<li><a href=\"#%E7%A4%BE%E5%8C%BA\">社区</a></li>\n<li><a href=\"#%E4%B9%A6%E7%B1%8D\">书籍</a></li>\n<li><a href=\"#%E5%86%85%E7%BD%AE%E7%AE%80%E5%8D%95%E7%B1%BB%E5%9E%8B\">内置简单类型</a></li>\n<li><a href=\"#%E5%86%85%E7%BD%AE%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B\">内置复杂类型</a></li>\n<li><a href=\"#%E5%AF%B9%E8%B1%A1\">对象</a></li>\n<li><a href=\"#%E5%AD%97%E7%AC%A6%E4%B8%B2\">字符串</a></li>\n</ul>\n</li>\n<li><a href=\"#0x02-%E4%B8%AD%E7%BA%A7%E6%A6%82%E5%BF%B5\">0x02 中级概念</a>\n<ul>\n<li><a href=\"#%E5%87%BD%E6%95%B0\">函数</a>\n<ul>\n<li><a href=\"#%E4%BD%9C%E7%94%A8%E5%9F%9F\">作用域</a></li>\n</ul>\n</li>\n<li><a href=\"#%E6%A8%A1%E5%9D%97\">模块</a></li>\n<li><a href=\"#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1\">面向对象</a></li>\n<li><a href=\"#%E9%94%99%E8%AF%AF-%E8%B0%83%E8%AF%95%E6%B5%8B%E8%AF%95\">错误 / 调试测试</a></li>\n<li><a href=\"#io-%E7%BC%96%E7%A8%8B\">IO 编程</a></li>\n<li><a href=\"#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B\">进程和线程</a>\n<ul>\n<li><a href=\"#%E5%A4%9A%E7%BA%BF%E7%A8%8B\">多线程</a></li>\n<li><a href=\"#%E5%A4%9A%E8%BF%9B%E7%A8%8B\">多进程</a>\n<ul>\n<li><a href=\"#%E5%8D%8F%E5%90%8C%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86\">协同式多任务处理</a></li>\n<li><a href=\"#%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86\">抢占式多任务处理</a></li>\n<li><a href=\"#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8\">线程安全</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F\">正则表达式</a></li>\n</ul>\n</li>\n<li><a href=\"#0x03-%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7\">0x03 高级技巧</a></li>\n<li><a href=\"#0x04-%E6%A0%87%E5%87%86%E5%BA%93\">0x04 标准库</a>\n<ul>\n<li><a href=\"#%E5%B8%B8%E7%94%A8%E5%86%85%E5%BB%BA%E6%A8%A1%E5%9D%97\">常用内建模块</a></li>\n<li><a href=\"#%E7%B3%BB%E7%BB%9F%E5%8C%96%E6%A8%A1%E5%9D%97\">系统化模块</a></li>\n</ul>\n</li>\n<li><a href=\"#0x05-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93\">0x05 第三方库</a></li>\n<li><a href=\"#0x06-%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F\">0x06 代码质量</a>\n<ul>\n<li><a href=\"#%E6%AD%A3%E7%A1%AE%E6%80%A7\">正确性</a></li>\n<li><a href=\"#%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7\">可维护性</a></li>\n<li><a href=\"#%E5%8F%AF%E8%AF%BB%E6%80%A7\">可读性</a></li>\n<li><a href=\"#%E5%AE%89%E5%85%A8%E6%80%A7\">安全性</a></li>\n<li><a href=\"#%E6%80%A7%E8%83%BD\">性能</a></li>\n</ul>\n</li>\n<li><a href=\"#0x07-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4\">0x07 常用命令</a></li>\n<li><a href=\"#0xee-%E6%96%87%E7%AB%A0%E6%9B%B4%E6%96%B0\">0xEE 文章更新</a></li>\n</ul>\n</li>\n<li><a href=\"#golang\">Golang</a>\n<ul>\n<li><a href=\"#%E6%A8%A1%E5%9D%97-01go-%E8%AF%AD%E8%A8%80%E5%AE%9E%E8%B7%B5-runtime\">模块 01：Go 语言实践 - Runtime</a>\n<ul>\n<li><a href=\"#goroutine-%E7%9A%84%E8%B0%83%E5%BA%A6%E5%8E%9F%E7%90%86\">Goroutine 的调度原理</a></li>\n<li><a href=\"#%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B\">内存模型</a></li>\n<li><a href=\"#gc%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%8E%9F%E7%90%86\">GC（垃圾回收）的原理</a></li>\n<li><a href=\"#channel-%E7%9A%84%E6%B6%88%E6%81%AF%E9%80%9A%E8%AE%AF%E5%8E%9F%E7%90%86\">channel 的消息通讯原理</a></li>\n</ul>\n</li>\n<li><a href=\"#%E6%A8%A1%E5%9D%97-02go-%E8%AF%AD%E8%A8%80%E5%AE%9E%E8%B7%B5-%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B\">模块 02：Go 语言实践 - 并行编程</a>\n<ul>\n<li><a href=\"#memory-model\">Memory Model</a></li>\n<li><a href=\"#%E5%B9%B6%E5%8F%91%E7%89%B9%E6%80%A7%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F\">并发特性并发编程模式</a></li>\n<li><a href=\"#context-%E7%9A%84%E5%8E%9F%E7%90%86%E5%B9%B6%E6%8E%8C%E6%8F%A1%E5%85%B6%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95\">Context 的原理并掌握其使用方法</a></li>\n</ul>\n</li>\n<li><a href=\"#%E6%A8%A1%E5%9D%97-03go-%E8%AF%AD%E8%A8%80%E5%AE%9E%E8%B7%B5-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B\">模块 03：Go 语言实践 - 网络编程</a>\n<ul>\n<li><a href=\"#golang-tcp-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B\">Golang TCP 网络编程</a></li>\n<li><a href=\"#golang-http-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B\">Golang HTTP 网络编程</a></li>\n</ul>\n</li>\n<li><a href=\"#%E6%A8%A1%E5%9D%97-04go-%E8%AF%AD%E8%A8%80%E5%AE%9E%E8%B7%B5-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86\">模块 04：Go 语言实践 - 异常处理</a>\n<ul>\n<li><a href=\"#error-%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95\">error 的处理方法</a></li>\n<li><a href=\"#%E4%B8%9A%E5%8A%A1%E9%94%99%E8%AF%AF%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95\">业务错误的处理方法</a></li>\n</ul>\n</li>\n<li><a href=\"#%E6%A8%A1%E5%9D%97-05go-%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%AE%9E%E8%B7%B5\">模块 05：Go 工程化实践</a>\n<ul>\n<li><a href=\"#%E8%89%AF%E5%A5%BD%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E7%BB%84%E7%BB%87%E5%8E%9F%E5%88%99%E5%92%8C%E8%A7%84%E8%8C%83\">良好的项目目录组织原则和规范</a></li>\n<li><a href=\"#api-%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%E5%92%8C%E8%A7%84%E8%8C%83\">API 的设计方法和规范</a></li>\n<li><a href=\"#package-%E7%9A%84%E7%AE%A1%E7%90%86%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95\">Package 的管理和设计方法</a></li>\n<li><a href=\"#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95\">单元测试</a></li>\n</ul>\n</li>\n<li><a href=\"#%E6%A8%A1%E5%9D%97-06go-%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5-%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E5%89%8D%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1\">模块 06：Go 架构实践 - 分布式架构（前端负载均衡）</a>\n<ul>\n<li><a href=\"#%E9%AB%98%E5%8F%AF%E7%94%A8-dns-%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5\">高可用 DNS 的最佳实践</a></li>\n<li><a href=\"#cdn-%E7%9A%84%E6%9E%B6%E6%9E%84%E5%92%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF\">CDN 的架构和应用场景</a></li>\n<li><a href=\"#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-47-%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E5%8E%9F%E7%90%86\">深入理解 4/7 层负载均衡的原理</a></li>\n</ul>\n</li>\n<li><a href=\"#%E6%A8%A1%E5%9D%97-07go-%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5-%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87\">模块 07：Go 架构实践 - 分布式架构（数据分片）</a>\n<ul>\n<li><a href=\"#%E6%95%B0%E6%8D%AE-sharding-%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99\">数据 Sharding 的设计原则</a></li>\n<li><a href=\"#%E4%BA%86%E8%A7%A3-hash-%E5%88%86%E7%89%87%E7%9A%84%E7%AE%97%E6%B3%95%E5%92%8C%E6%BC%94%E8%BF%9B%E5%8E%86%E5%8F%B2\">了解 Hash 分片的算法和演进历史</a></li>\n</ul>\n</li>\n<li><a href=\"#%E6%A8%A1%E5%9D%97-08go-%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A6%82%E8%A7%88%E4%B8%8E%E6%B2%BB%E7%90%86\">模块 08：Go 架构实践 - 微服务（微服务概览与治理）</a>\n<ul>\n<li><a href=\"#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%BC%94%E8%BF%9B%E5%8E%86%E5%8F%B2%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9\">微服务的演进历史及优缺点</a></li>\n<li><a href=\"#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95\">微服务的设计方法</a></li>\n<li><a href=\"#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%AD-rpc-%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86\">微服务中 RPC 的底层原理</a></li>\n</ul>\n</li>\n<li><a href=\"#%E6%A8%A1%E5%9D%97-09go-%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%8F%AF%E7%94%A8%E6%80%A7%E8%AE%BE%E8%AE%A1\">模块 09：Go 架构实践 - 微服务（可用性设计）</a>\n<ul>\n<li><a href=\"#%E5%8F%AF%E7%94%A8%E6%80%A7%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5\">可用性设计的最佳实践</a></li>\n<li><a href=\"#%E5%8F%AF%E7%94%A8%E6%80%A7%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%87%A0%E5%A4%A7%E5%85%B3%E9%94%AE%E7%82%B9%E9%9A%94%E7%A6%BB-%E8%B6%85%E6%97%B6%E6%8E%A7%E5%88%B6-%E8%BF%87%E8%BD%BD%E4%BF%9D%E6%8A%A4-%E9%99%90%E6%B5%81-%E5%AE%B9%E9%94%99-%E9%87%8D%E8%AF%95\">可用性设计的几大关键点：隔离、超时控制、过载保护、限流、容错 &amp; 重试</a></li>\n</ul>\n</li>\n<li><a href=\"#%E6%A8%A1%E5%9D%97-10go-%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5-%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%97%A5%E5%BF%97-%E6%8C%87%E6%A0%87-%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA\">模块 10：Go 架构实践 - 中间件（日志、指标、链路追踪）</a>\n<ul>\n<li><a href=\"#%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86\">日志收集</a></li>\n<li><a href=\"#%E7%9B%91%E6%8E%A7%E6%8C%87%E6%A0%87%E4%BD%93%E7%B3%BB\">监控指标体系</a></li>\n<li><a href=\"#%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA\">分布式链路追踪</a></li>\n</ul>\n</li>\n<li><a href=\"#%E6%A8%A1%E5%9D%97-11go-%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5-%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%BC%93%E5%AD%98-%E6%95%B0%E6%8D%AE%E5%BA%93\">模块 11：Go 架构实践 - 中间件（缓存、数据库）</a>\n<ul>\n<li><a href=\"#redis-memcache-%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E6%88%98%E6%8A%80%E5%B7%A7\">Redis、Memcache 的原理和实战技巧</a></li>\n<li><a href=\"#mysql-%E7%9A%84%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E5%92%8C%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95\">MySQL 的常用设计和优化方法</a></li>\n</ul>\n</li>\n<li><a href=\"#%E6%A8%A1%E5%9D%97-12go-%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5-%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0\">模块 12：Go 架构实践 - 中间件（消息队列、服务发现）</a>\n<ul>\n<li><a href=\"#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%8E%9F%E7%90%86%E6%8E%8C%E6%8F%A1%E5%9F%BA%E4%BA%8E%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95\">深入理解消息队列的原理，掌握基于消息队列的架构设计方法</a></li>\n<li><a href=\"#%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E5%8E%9F%E7%90%86-%E9%80%89%E5%9E%8B%E7%AD%96%E7%95%A5%E4%BB%A5%E5%8F%8A%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%A4%9A%E7%A7%9F%E6%88%B7%E6%9E%B6%E6%9E%84\">服务发现原理、选型策略，以及服务发现实现的微服务多租户架构</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n"}},"__N_SSG":true}