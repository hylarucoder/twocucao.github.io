{"pageProps":{"post":{"tags":["CheatSheet"],"path":"20180210_DockerCheatSheet.md","title":"Docker CheatSheet","slug":"Docker CheatSheet","date":"2018-02-10","category":"DevOps","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"<h2 id=\"0x00-前言\"><a class=\"v-toc-item\" href=\"#0x00-前言\">#</a> 0x00 前言</h2>\n<p>本文为 Cheatsheet 类型文章，用于记录我在日常编程中经常使用的 Docker 相关和命令。</p>\n<ul>\n<li>Docker 相关概念</li>\n<li>Docker 配套工具</li>\n<li>Django PostgreSQL RabbitMQ Redis ElasticSearch Sentry 集群 Docker 化</li>\n<li>Docker 踩坑记录</li>\n</ul>\n<p>不定期更新。</p>\n<!-- more -->\n<h2 id=\"0x01-docker-相关概念\"><a class=\"v-toc-item\" href=\"#0x01-docker-相关概念\">#</a> 0x01 Docker 相关概念</h2>\n<h3 id=\"11-docker-是什么\"><a class=\"v-toc-item\" href=\"#11-docker-是什么\">#</a> 1.1 Docker 是什么？</h3>\n<p>在认知 Docker 这种相对而言比较新概念的时候，只要从以往的经验中拿出一个词语来概括新词汇即可。</p>\n<p>于是，我们便可以这么理解：</p>\n<blockquote>\n<p>Docker 是一种比虚拟机轻量的用来存放职责比较单一的应用的容器。</p>\n</blockquote>\n<p>也就是三点：</p>\n<ul>\n<li>比虚拟机轻量</li>\n<li>用来存放职责单一的应用</li>\n<li>容器</li>\n</ul>\n<p>显然这是一种理解，而不是一种定义。</p>\n<h3 id=\"12-docker-是用来做什么的\"><a class=\"v-toc-item\" href=\"#12-docker-是用来做什么的\">#</a> 1.2 Docker 是用来做什么的？</h3>\n<p>新技术本质是什么？工具也。<br>\n每一个新的技术都是为了提升效率才被创造出来，那么，究竟 Docker 可以从哪些方面提升我们的效率呢？</p>\n<p>我们知道开发一个有些规模的网站的话，需要严格遵守如下的开发流程：</p>\n<ul>\n<li>编码</li>\n<li>测试</li>\n<li>集成到系统中</li>\n<li>部署</li>\n</ul>\n<p>但如果人员比较多，则会出现问题，有的人喜欢用 MacOS, 有的人喜欢用 Ubuntu, 开发测试环境怎么统一呢？如果开发人员明明使用的是某个版本的 PostgreSQL, 用了最新的功能，但是测试和运维用的就是老版本的功能怎么办？</p>\n<p>部署环境也会有问题，比如，开发部突然想使用更高版本的软件，比如突然需要更多的 Django 应用来负担海量请求的怎么办？Hadoop 不够用怎么办？</p>\n<p>当然，思路很简单，开发的时候使用虚拟机，拷贝给大家一起用，部署的时候多创建一些机器，然后上 Ansible 远程操控。即可。</p>\n<p>并不是不行，但是 Docker 由于更加轻量，操作粒度更加细腻，我可以销毁镜像，上传镜像，定制镜像，很轻松调整镜像包并且安装挂载文件。</p>\n<h2 id=\"0x02-docker-初始配置\"><a class=\"v-toc-item\" href=\"#0x02-docker-初始配置\">#</a> 0x02 Docker 初始配置</h2>\n<pre><code>docker-machine create --driver=virtualbox default\ndocker-machine ls\neval &quot;$(docker-machine env default)&quot;\n</code></pre>\n<h2 id=\"0x03-django-技术栈-docker-化\"><a class=\"v-toc-item\" href=\"#0x03-django-技术栈-docker-化\">#</a> 0x03 Django 技术栈 Docker 化</h2>\n<p>为了理解这个过程，下面我将我 Docker 化 django 应用的流程按照一定步骤演示出来。我将我使用 Django 的部分经验搞出来，做成了一个 django-bpc ，即 django best practice。如果诸位有兴趣研究的话，拿来看看源码倒是倒是非常好。</p>\n<pre><code class=\"language-bash\"># 演示环境为 <span class=\"token constant\">MAC</span><span class=\"token punctuation\">,</span> 在此之前，务必安装好 docker <span class=\"token keyword\">for</span> mac 以及 virualbox\n# xxxxxx 为 阿里云分配的容器 registry\ndocker<span class=\"token operator\">-</span>machine create <span class=\"token operator\">--</span>engine<span class=\"token operator\">-</span>registry<span class=\"token operator\">-</span>mirror<span class=\"token operator\">=</span>https<span class=\"token operator\">:</span><span class=\"token operator\">/</span><span class=\"token operator\">/</span>xxxxxx<span class=\"token punctuation\">.</span>mirror<span class=\"token punctuation\">.</span>aliyuncs<span class=\"token punctuation\">.</span>com <span class=\"token operator\">-</span>d virtualbox <span class=\"token keyword\">default</span>\n\n</code></pre>\n<pre><code class=\"language-bash\">├── <span class=\"token constant\">AUTHORS</span><span class=\"token punctuation\">.</span>md\n├── <span class=\"token constant\">HISTORY</span><span class=\"token punctuation\">.</span>md\n├── <span class=\"token constant\">LICENSE</span>\n├── <span class=\"token constant\">MANIFEST</span><span class=\"token punctuation\">.</span>in\n├── Makefile\n├── <span class=\"token constant\">README</span><span class=\"token punctuation\">.</span>md\n├── assets\n├── compose\n│   ├── django\n│   ├── elasticsearch\n│   ├── nginx\n│   ├── postgres\n│   ├── rabbitmq\n│   └── redis\n├── config\n│   ├── __init__<span class=\"token punctuation\">.</span>py\n│   ├── settings\n│   ├── urls<span class=\"token punctuation\">.</span>py\n│   └── wsgi<span class=\"token punctuation\">.</span>py\n├── dev<span class=\"token punctuation\">.</span>yml\n├── docker<span class=\"token operator\">-</span>compose<span class=\"token punctuation\">.</span>yml\n├── docs\n│   ├── Makefile\n│   ├── exts\n│   ├── make<span class=\"token punctuation\">.</span>bat\n│   ├── make_pdf<span class=\"token punctuation\">.</span>sh\n│   └── source\n├── manage<span class=\"token punctuation\">.</span>py\n├── pytest<span class=\"token punctuation\">.</span>ini\n├── requirements\n│   ├── base<span class=\"token punctuation\">.</span>txt\n│   ├── local<span class=\"token punctuation\">.</span>txt\n│   ├── production<span class=\"token punctuation\">.</span>txt\n│   └── test<span class=\"token punctuation\">.</span>txt\n├── scripts\n├── setup<span class=\"token punctuation\">.</span>cfg\n├── tests\n│   ├── __init__<span class=\"token punctuation\">.</span>py\n│   ├── conftest<span class=\"token punctuation\">.</span>py\n│   └── test_basics<span class=\"token punctuation\">.</span>py\n└── yadjangoblog\n    ├── __init__<span class=\"token punctuation\">.</span>py\n    ├── contrib\n    ├── <span class=\"token keyword\">static</span>\n    ├── templates\n    ├── yaaccounts\n    ├── yaadmin\n    ├── yaapi\n    ├── yablog\n    ├── yacommon\n    └── yataskapp\n</code></pre>\n<h3 id=\"31-开发时\"><a class=\"v-toc-item\" href=\"#31-开发时\">#</a> 3.1 开发时</h3>\n<h4 id=\"1-运行所需组件\"><a class=\"v-toc-item\" href=\"#1-运行所需组件\">#</a> 1. 运行所需组件</h4>\n<p>在开发时候需要使用几个后台的组件</p>\n<ul>\n<li>PostgreSQL 用于做数据存储</li>\n<li>Redis 用于做缓存 和 Session 等等</li>\n<li>RedditMQ 用于消息队列</li>\n<li>ElasticSearch 用于做搜索与推荐</li>\n</ul>\n<p>目录中的组件基本上都在这儿了。</p>\n<pre><code>├── compose\n│   ├── django\n│   ├── elasticsearch\n│   ├── nginx\n│   ├── postgres\n│   ├── rabbitmq\n│   └── redis\n</code></pre>\n<p>进行初步的封装和添加脚本，不直接采用官网的配置需要是因为添加一些的定制版本。</p>\n<h4 id=\"2-vuejs-运行环境\"><a class=\"v-toc-item\" href=\"#2-vuejs-运行环境\">#</a> 2. Vue.JS 运行环境</h4>\n<p>Vue.JS 使用 Vue-Cli 搭建的脚手架还是挺方便的，这个就无需 Docker 化了，需要注意的是，建议配置一下开发时候请求的 API 地址。</p>\n<p>我本人用于请求本地地址的 8080 端口，并且 8080 端口映射到 Docker 容器里面的 Django App</p>\n<h4 id=\"3-django-app\"><a class=\"v-toc-item\" href=\"#3-django-app\">#</a> 3. Django App</h4>\n<p>配置 Django, 我使用的是 ubuntu 16.04 基础镜像，然后安装必备的依赖。</p>\n<p>接着指定 workdir 为当前目录</p>\n<p>需要注意的是，Django App 里面需要等待 PostgreSQL 初始化完毕才能进行正常的运行接下来需要运行的命令，比如 runserver 之类的命令。</p>\n<p>entrypoint 的左右即是放在命令执行之前，这样的话，重写掉 entrypoint 文件，就可以实现上面的功能了</p>\n<pre><code class=\"language-python\"># 本段代码来自 cookiecutter Django\n<span class=\"token keyword\">function</span> <span class=\"token function\">postgres_ready</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\npython <span class=\"token operator\">&lt;&lt;</span> <span class=\"token constant\">END</span>\n<span class=\"token keyword\">import</span> sys\n<span class=\"token keyword\">import</span> psycopg2\n<span class=\"token keyword\">try</span><span class=\"token operator\">:</span>\n    conn <span class=\"token operator\">=</span> psycopg2<span class=\"token punctuation\">.</span><span class=\"token function\">connect</span><span class=\"token punctuation\">(</span>dbname<span class=\"token operator\">=</span><span class=\"token string\">\"$POSTGRES_USER\"</span><span class=\"token punctuation\">,</span> user<span class=\"token operator\">=</span><span class=\"token string\">\"$POSTGRES_USER\"</span><span class=\"token punctuation\">,</span> password<span class=\"token operator\">=</span><span class=\"token string\">\"$POSTGRES_PASSWORD\"</span><span class=\"token punctuation\">,</span> host<span class=\"token operator\">=</span><span class=\"token string\">\"postgres\"</span><span class=\"token punctuation\">)</span>\nexcept psycopg2<span class=\"token punctuation\">.</span>OperationalError<span class=\"token operator\">:</span>\n    sys<span class=\"token punctuation\">.</span><span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\nsys<span class=\"token punctuation\">.</span><span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n<span class=\"token constant\">END</span>\n<span class=\"token punctuation\">}</span>\n\nuntil postgres_ready<span class=\"token punctuation\">;</span> <span class=\"token keyword\">do</span>\n  <span class=\"token operator\">></span><span class=\"token operator\">&amp;</span><span class=\"token number\">2</span> echo <span class=\"token string\">\"Postgres is unavailable - sleeping\"</span>\n  sleep <span class=\"token number\">1</span>\ndone\n</code></pre>\n<p>最后封装一些命令到，比如启动 Celery 之类的。</p>\n<h4 id=\"4-celery-运行环境\"><a class=\"v-toc-item\" href=\"#4-celery-运行环境\">#</a> 4. Celery 运行环境</h4>\n<h4 id=\"5-其他零散的重要配置\"><a class=\"v-toc-item\" href=\"#5-其他零散的重要配置\">#</a> 5. 其他零散的重要配置</h4>\n<h3 id=\"32-具体开发\"><a class=\"v-toc-item\" href=\"#32-具体开发\">#</a> 3.2 具体开发</h3>\n<p>我编写了一整套 makefile 的命令，我会先进入项目 YaDjangoBlog , 然后执行 make ; 执行 make 之后，显示了我编写的一些便于开发测试的命令如下：</p>\n<pre><code>sep--sep-a           ========== 开发时命令 ==============\ndjango-build-up      build and compose up\nforce_djnago_build-up django / pg / es\ndjango-before-up     e.g pg / es / redis\ndjango-runserver     runserver\ndjango-celerybeat    celerybeat\ndjango-celeryworker  celeryworker\ndjango-just-up       build and up\ndjango-manager       Enter python manage.py\ndjango-console       Enter Django Console\nshell                Enter Shell\ndbshell              Enter psql as yadjangoweb\nsep--sep-b           ========== 测试与代码质量 ==============\nlint                 check style with flake8\ntest                 run tests quickly with the default Python\ncoverage             check code coverage quickly with the default Python\nsep--sep-c           ========== 文档生成相关 ==============\ndocs                 generate Sphinx HTML documentation, including API docs\nservedocs            compile the docs watching for changes\nsep--sep-d           ========== 程序发布相关 ==============\nrelease              package and upload a release\ndist                 builds source and wheel package\ninstall              install the package to the active Python's site-packages\nsep--sep-e           ========== Docker 镜像相关 ==============\nbuild-postgres       &gt; Postgres\nforce-build-postgres &gt; Postgres\nbuild-ubuntu         &gt; base ubuntu\nforce_build-ubuntu   &gt; base ubuntu\nbuild-django         &gt; base django\nforce_build-django   &gt; base django\nsep--sep-f           ========== 文件清理相关 ==============\nclean                remove all build, test, coverage and Python artifacts\nclean-build          remove build artifacts\nclean-pyc            remove Python file artifacts\nclean-test           remove test and coverage artifacts\n</code></pre>\n<h4 id=\"1-构建镜像\"><a class=\"v-toc-item\" href=\"#1-构建镜像\">#</a> 1. 构建镜像</h4>\n<p>执行 build 命令即可。</p>\n<h4 id=\"2-使用-tmuxinator-批量运行命令\"><a class=\"v-toc-item\" href=\"#2-使用-tmuxinator-批量运行命令\">#</a> 2. 使用 Tmuxinator 批量运行命令</h4>\n<p>现在，我有这么一个需求，就是在 iterm 中开启如下的终端：</p>\n<ul>\n<li>第 1 个终端，运行的命令是 Vue.JS 的启动命令 npm run dev。</li>\n<li>第 2 个终端，有两个分屏，其一用于构建 iconfont 字体文件的命令，其二用于 Gulp 动态编译 SCSS 文件的命令。</li>\n<li>第 3 个终端，运行的命令是 Django 的 runserver 的命令。</li>\n<li>第 4 个终端，有两个分屏，一个是 Django 容器的 bash 环境，另一个是 PostgreSQL 的 命令行环境。</li>\n<li>第 5 个终端，有两个分屏，一者运行 Celery Beat，另一者则是运行 Celery Worker.</li>\n</ul>\n<blockquote>\n<p>当然，目前没有添加 redis 和 RabbitMQ 的命令行环境</p>\n</blockquote>\n<h4 id=\"3-使用-pycharm-进行开发\"><a class=\"v-toc-item\" href=\"#3-使用-pycharm-进行开发\">#</a> 3. 使用 PyCharm 进行开发</h4>\n<h3 id=\"33-部署时\"><a class=\"v-toc-item\" href=\"#33-部署时\">#</a> 3.3 部署时</h3>\n<p>Docker 部署需要解决的问题，是裸机部署的 Docker 化。</p>\n<blockquote>\n<p>TODO: 目前 Docker 部署的脚本还在编写中，这部分的文字可能后期会调整</p>\n</blockquote>\n<h4 id=\"0-django-生产环境和开发环境之间的区别\"><a class=\"v-toc-item\" href=\"#0-django-生产环境和开发环境之间的区别\">#</a> 0. Django 生产环境和开发环境之间的区别</h4>\n<p>生产环境和开发环境除了一些文字配置上的不同，还有一些不同，比如：</p>\n<ol>\n<li>新增了 uwsgi / gunicorn 作为新的 web 容器</li>\n<li>新增了 Ngnix 作为反向代理</li>\n<li>Celery Worker 数量的变化</li>\n<li>Supervisor 进程守护</li>\n</ol>\n<p>首先说第一点带来的区别，我们使用 Django 内置的 runserver 的时候，其实这个命令可以用于做生产环境的 Web 服务器。</p>\n<p>比如，只需如此 python <a href=\"http://manage.py\">manage.py</a> runserver 0.0.0.0:8888</p>\n<p>可以用，但不推荐用。没什么负载量。这时候就需要 gunicorn 了。你可以理解 Gunicorn 是进阶的 runserver,</p>\n<p>可以参考：<a href=\"https://docs.djangoproject.com/en/2.0/howto/deployment/wsgi/gunicorn/\">https://docs.djangoproject.com/en/2.0/howto/deployment/wsgi/gunicorn/</a></p>\n<p>同时，Gunicorn 可以进行颗粒度更细致的操作，但负载量不如 uwsgi, 毕竟前者 python 写的，后者是 C 写的。</p>\n<p>一般 Gunicorn 也会配上 NGNIX,</p>\n<p>简单来说，Nginx 至少可以解决下面的问题：</p>\n<ul>\n<li>匹配域名</li>\n<li>转发请求\n<ul>\n<li>设置请求头</li>\n<li>转发本地的静态文件 (static / media）</li>\n<li>映射部分请求到 gunicorn , 然后 gunicorn 开启一个线程到 Django</li>\n<li>负载均衡</li>\n</ul>\n</li>\n</ul>\n<p>需要注意的是 gunicorn 这种关键性的进程，一定要用 Supervisor 进行守护，否则挂掉了就完蛋了，</p>\n<h4 id=\"1-裸机部署-django-程序\"><a class=\"v-toc-item\" href=\"#1-裸机部署-django-程序\">#</a> 1. 裸机部署 Django 程序</h4>\n<h4 id=\"2-docker-部署\"><a class=\"v-toc-item\" href=\"#2-docker-部署\">#</a> 2. Docker 部署</h4>\n<h2 id=\"0x04-docker-踩坑记录\"><a class=\"v-toc-item\" href=\"#0x04-docker-踩坑记录\">#</a> 0x04 Docker 踩坑记录</h2>\n<h3 id=\"41-postgresql-的初始化\"><a class=\"v-toc-item\" href=\"#41-postgresql-的初始化\">#</a> 4.1 PostgreSQL 的初始化</h3>\n<p>当 Docker 化 PostgreSQL 的时候，必须要把一些初始化脚本放在 docker-entrypoint-initdb.d 中，才能初始化，笔者在进行测试的时候多次发现无法进行初始化，究其原因，经过查找，如果没有及时删除 Volume 的话，则无论怎么初始化，或者 Build, 每一次都会挂载原来的文件夹。</p>\n<pre><code class=\"language-bash\"><span class=\"token constant\">ADD</span> init_django_db<span class=\"token punctuation\">.</span>sh <span class=\"token operator\">/</span>docker<span class=\"token operator\">-</span>entrypoint<span class=\"token operator\">-</span>initdb<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>init_django_db<span class=\"token punctuation\">.</span>sh\n</code></pre>\n<h3 id=\"42-清空所有-image\"><a class=\"v-toc-item\" href=\"#42-清空所有-image\">#</a> 4.2 清空所有 Image</h3>\n<pre><code class=\"language-bash\"># Delete all containers\ndocker rm <span class=\"token function\">$</span><span class=\"token punctuation\">(</span>docker ps <span class=\"token operator\">-</span>a <span class=\"token operator\">-</span>q<span class=\"token punctuation\">)</span>\n# Delete all images\ndocker rmi <span class=\"token function\">$</span><span class=\"token punctuation\">(</span>docker images <span class=\"token operator\">-</span>q<span class=\"token punctuation\">)</span>\n# Force <span class=\"token keyword\">delete</span>\ndocker rmi <span class=\"token function\">$</span><span class=\"token punctuation\">(</span>docker images <span class=\"token operator\">-</span>q<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span>f\n# Delete Unused Volume\ndocker volume prune\n</code></pre>\n<h3 id=\"43-时区\"><a class=\"v-toc-item\" href=\"#43-时区\">#</a> 4.3 时区</h3>\n<pre><code># Alpine\nRUN apk --no-cache add tzdata &amp;&amp; ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; echo &quot;Asia/Shanghai&quot; &gt; /etc/timezone\n# Ubuntu\nRUN echo &quot;Asia/Shanghai&quot; &gt; /etc/timezone &amp;&amp; dpkg-reconfigure -f noninteractive tzdata\n# Centos\nRUN echo &quot;Asia/shanghai&quot; &gt; /etc/timezone\n</code></pre>\n<h1 id=\"0xee-参考链接\"><a class=\"v-toc-item\" href=\"#0xee-参考链接\">#</a> 0xEE 参考链接</h1>\n<ul>\n<li><a href=\"https://github.com/wsargent/docker-cheat-sheet\">https://github.com/wsargent/docker-cheat-sheet</a></li>\n</ul>\n<hr>\n<p>ChangeLog:</p>\n<ul>\n<li><strong>2017-01-20</strong> 初始化本文</li>\n</ul>\n","toc":"<ul class=\"v-article-toc\">\n<li>\n<ul>\n<li><a href=\"#0x00-%E5%89%8D%E8%A8%80\">0x00 前言</a></li>\n<li><a href=\"#0x01-docker-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5\">0x01 Docker 相关概念</a>\n<ul>\n<li><a href=\"#11-docker-%E6%98%AF%E4%BB%80%E4%B9%88\">1.1 Docker 是什么？</a></li>\n<li><a href=\"#12-docker-%E6%98%AF%E7%94%A8%E6%9D%A5%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84\">1.2 Docker 是用来做什么的？</a></li>\n</ul>\n</li>\n<li><a href=\"#0x02-docker-%E5%88%9D%E5%A7%8B%E9%85%8D%E7%BD%AE\">0x02 Docker 初始配置</a></li>\n<li><a href=\"#0x03-django-%E6%8A%80%E6%9C%AF%E6%A0%88-docker-%E5%8C%96\">0x03 Django 技术栈 Docker 化</a>\n<ul>\n<li><a href=\"#31-%E5%BC%80%E5%8F%91%E6%97%B6\">3.1 开发时</a>\n<ul>\n<li><a href=\"#1-%E8%BF%90%E8%A1%8C%E6%89%80%E9%9C%80%E7%BB%84%E4%BB%B6\">1. 运行所需组件</a></li>\n<li><a href=\"#2-vuejs-%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83\">2. Vue.JS 运行环境</a></li>\n<li><a href=\"#3-django-app\">3. Django App</a></li>\n<li><a href=\"#4-celery-%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83\">4. Celery 运行环境</a></li>\n<li><a href=\"#5-%E5%85%B6%E4%BB%96%E9%9B%B6%E6%95%A3%E7%9A%84%E9%87%8D%E8%A6%81%E9%85%8D%E7%BD%AE\">5. 其他零散的重要配置</a></li>\n</ul>\n</li>\n<li><a href=\"#32-%E5%85%B7%E4%BD%93%E5%BC%80%E5%8F%91\">3.2 具体开发</a>\n<ul>\n<li><a href=\"#1-%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F\">1. 构建镜像</a></li>\n<li><a href=\"#2-%E4%BD%BF%E7%94%A8-tmuxinator-%E6%89%B9%E9%87%8F%E8%BF%90%E8%A1%8C%E5%91%BD%E4%BB%A4\">2. 使用 Tmuxinator 批量运行命令</a></li>\n<li><a href=\"#3-%E4%BD%BF%E7%94%A8-pycharm-%E8%BF%9B%E8%A1%8C%E5%BC%80%E5%8F%91\">3. 使用 PyCharm 进行开发</a></li>\n</ul>\n</li>\n<li><a href=\"#33-%E9%83%A8%E7%BD%B2%E6%97%B6\">3.3 部署时</a>\n<ul>\n<li><a href=\"#0-django-%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E5%92%8C%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB\">0. Django 生产环境和开发环境之间的区别</a></li>\n<li><a href=\"#1-%E8%A3%B8%E6%9C%BA%E9%83%A8%E7%BD%B2-django-%E7%A8%8B%E5%BA%8F\">1. 裸机部署 Django 程序</a></li>\n<li><a href=\"#2-docker-%E9%83%A8%E7%BD%B2\">2. Docker 部署</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#0x04-docker-%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95\">0x04 Docker 踩坑记录</a>\n<ul>\n<li><a href=\"#41-postgresql-%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96\">4.1 PostgreSQL 的初始化</a></li>\n<li><a href=\"#42-%E6%B8%85%E7%A9%BA%E6%89%80%E6%9C%89-image\">4.2 清空所有 Image</a></li>\n<li><a href=\"#43-%E6%97%B6%E5%8C%BA\">4.3 时区</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#0xee-%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\">0xEE 参考链接</a></li>\n</ul>\n"}},"__N_SSG":true}