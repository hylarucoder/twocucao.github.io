{"pageProps":{"category":{"name":"Python 项目代码健壮性和性能","posts":[{"tags":["Python","系列文章"],"path":"20190924_PyCode_08.md","title":"如何写出整洁的 Python 代码 下","slug":"如何写出整洁的 Python 代码 下","date":"2019-09-24","category":"Python 项目代码健壮性和性能","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n**本文是《提升你的 Python 项目代码健壮性和性能》系列的第八篇文章。**\n\n本文是《整洁下篇》，本文的诞生，要感谢我前公司的技术主管豪蔚老师和产品主管刚哥，在上海工作这几年，总是和能优秀的人工作，确实是我幸运的地方。\n\n这篇文章憋了很久，思考了许久，《整洁下篇》干脆就聊聊编程中，不是写代码的部分；\n\n如果说，写代码是硬技能，那么本期就是来聊软技能的。更确切的说，是复盘几年的工作经验中，我发现的一些有趣的，影响效率的事情以及我的解决方案。\n\n> 凡用兵之法，全国为上，破国次之；全军为上，破军次之；全旅为上，破旅次之；全卒为上，破卒次之；全伍为上，破伍次之。是故百战百胜，非善之善者也；不战而屈人之兵，善之善者也。 --- 《孙子兵法·谋攻篇》\n\n什么叫做有效率，不战而屈人之兵，善之善者也。\n\n> **最整洁的代码，是少写代码，甚至不写代码。**\n\n如何做到？\n\n几年的工作经验下来，我发现我**处理的往往不是技术问题，而是大量的非技术性问题以及伴随着非技术问题带来的成倍的技术问题**。\n\n1.  **因需求的变化的返工。**\n2.  **因追求完美而为了不必要优化的地方而优化。**\n3.  **因沟通不到位导致的加班加点。**\n4.  **因缺乏单元测试导致的重构没有底气，甚至懒得重构。**\n5.  **因缺乏话语权导致的被动开发。**\n6.  **因考虑不周到而导致的硬着头皮加班。**\n7.  **因命名不够规范，代码可维护性低下，导致后面定位问题的时间指数性上升。**\n\n应然如此？实然如此！\n\n## 0x01 处理需求的姿势\n\n以前呢，我自以为编程水平还算不错，撸起代码来像是一道春天的闪电。但时间长了，发现技术行，但总体产出不高效。为什么呢？\n\n比如有如下的问题：\n\n- 问题一：战术上很勤奋，一个需求过来，我的第一反应是把这个功能『通过系统』做出来。\n- 问题二：没有深入和产品运营沟通，于是后期被动的应对需求的变动\n- 问题三：没有三思而行，做项目没有计划性，想到哪里做到哪里。\n- 问题一的结果：这导致了很多时候，把这个功能『通过系统』做出来了，但是其实是个伪需求。或者，是个没必要做到系统里面的需求。\n- 问题二的结果：导致了一些过度设计或者过于粗糙的设计。最后忙于返工，以及各种数据迁移和逻辑修改\n- 问题三的结果：没有做好足够的规划，『码在当下』, 没有前瞻性。\n\n> 速度再快，也要返工，唯一不变的就是变化本身。\n\n我想了很久，才意识到，很多时候，产品在传递需求的时候是存在很多的信息损失的。\n\n背后的原因，可能来源于产品的态度和能力上，可能是产品的上一级需求传递过来的问题，也可能是团队对待产品以及自己的错误的态度上。\n\n经验告诉我，作为对项目负责的程序员千万不要跟着产品经理的思路走。\n\n如果是新功能，一定要就要展开一番对话。\n\n1.  问清楚为什么要做这个需求 / 变动，藏在后面的思路是什么。对于用户、对于产品有什么价值。\n2.  和产品经理互杠，用户的具体使用场景是什么。\n3.  看看是不是一定要放在系统里面解决。如果放在系统里面解决，那么应该怎么做。让产品方给出一个粗糙的方案。\n4.  化简这个方案后再次和产品互杠。\n5.  确定方案后分解安排任务。\n6.  任务上线之后如何确定这个功能是有效果的。\n\n还记得上面的话么？不战而屈人之兵。\n\n要做的需求，如果产品经理不能简单清晰的描述，做出来一定是一坨。\n\n作为合格的工程师，则是必须要将不清晰、不合理的、拍脑袋的需求拒掉。所谓上梁不正下梁歪，出题人的思路是混乱的，解答者的思路肯定不会清晰到哪里去。\n\n当然，这也存在一些例外的情况，如果你到了一个工作地方，没什么话语权，认真推进事情发展也没什么暖用的地方的话，好好反思一下自己为什么在这种地方干活，然后认真修炼自己。\n\n早些年，我还以为有时间不够的情况，后来也逐渐明白，没有开发不了的任务，**程序写到后面都是妥协，无非就多快好省的妥协**\n\n- 多 - 功能的数量和完成度\n- 快 - 完工时间\n- 好 - 软件最终质量，满意程度\n- 省 - 成本，花多少个人力和精力\n\n鱼和熊掌不能得兼\n\n- **如果产品说『反正下周要上线』, 你砍不了『快』，就砍『好』和『省』。**\n- **如果产品说『我要加需求』, 你砍不了『多』, 那就砍『快』和『省』**\n\n如何去做这些妥协，则是工程师的内力。\n\n还有，如果工程师本身不得势，也没有啥话语权，也就没办法推进你的产品了。\n\n**砍需求不是坏事情，树苗不也还是要经常剪去多余的枝桠来防止过度吸收养分。**\n\n## 0x02 敏捷开发\n\n国内的敏捷开发一般也称为『怎么方便怎么来的作坊式开发』\n\n### 看板和晨会\n\n一般会采用以下的做法来敏捷一些\n\n1.  使用看板来管理任务。看板上的卡片无非就是放在『需求确认』,『正在开发』,『正在测试』,『已发布』里面。\n2.  晨会，轮流发言讲解进度。\n\n任务的安排往往要细分到方便追踪。\n\n举例来说，如果是简单版本的『支付商城』的功能，则会有\n\n1.  支付模块\n2.  商品模块\n3.  订单模块\n4.  物流模块\n\n但是，商品模块和订单模块要和前后端交互，假设后端叫做小后，前端叫做小前，H5 端和 Admin 端的统一模块不是同一时间段完成的。\n\n如果放在一起的话，则会难以追踪。**会出现这个卡片属于『正在开发』或者『正在测试』的薛定谔状态。**\n\n于是这么细化会更加合理一些\n\n1.  支付模块\n2.  商品模块 - Admin\n3.  商品模块 - H5\n4.  订单模块 - Admin\n5.  订单模块 - H5\n\n如果是大一点的系统，则需要划分的更细致。务必不要出现薛定谔的状态卡片。\n\n一般如果看板划分的详细的话，晨会就很轻松了。\n\n### 敏捷的时间安排：周一到周五\n\n- 周一：**一周的开始，就应该发布新版本，选择这个时间段是因为团队都在一起，出问题可以及时修复。**\n- 周二 / 周三：复盘以下迭代过程中出现的一些问题。同时进行本周任务的开发。\n- 周四：产品负责人与技术负责人等相关人员规划下周的任务，并且过一遍需求评审。\n- 周五：在预发布环境完成本周功能的测试。留待下周进行正式版本的发布。\n\n### 人员安排\n\n《人月神话》这本书里面有一个观点，\n\n> **需要写作沟通的人员数量影响着开发成本，人数越多，沟通和交流次数越多，更正沟通不当所引起的不良结果也就越多。**\n\n对此，我的解决方案是：\n\n1.  减少人数。做业务的人选择全栈，从前端到后端负责。这样即便是前后端分离之后，也不会有扯皮的情况。\n2.  做基础架构的选择专才。\n3.  精英制度。点子最好都由几个立场上需要对产品负责的人来想。如果异想天开的人和做\n    事的人不是同一个人，则往往就很麻烦。当然，也需要给予推进产品的人一定的鼓励。\n\n## 0x03 代码全局观\n\n我遇到过的代码问题大致分为两类\n\n1.  给你的变量，函数，模块，类等等起个好名字的问题。\n2.  理解本质复杂度（Essential Complexity）和偶然复杂度（Accident Complexity）的问题。\n\n### 起个好名字\n\n对于工程师来说，第一点非常非常重要。\n\n因为，这需要你非常理解业务逻辑并且在某个上下文中用准确的变量名来命名。代码是写给\n人看的，顺带着能在机器上运行。并且，尽量跟着业务来命名 （参考 DDD\\)，这点也就不再赘述了。\n\n当然，其实这也是整洁前两篇讲的东西，也就不再赘述了。\n\n### 本质复杂度和偶然复杂度\n\n第二点，这是师从我的技术主管豪蔚老师之后获取的最大经验。\n\n- **本质复杂度，就是不管你怎么搞，A 点到 B 点，没有捷径可走的，该踩的坑一个都逃不了。**\n- **偶然复杂度，就是 A 点到 B 点，命名走几步就到了，但偏偏走了不少弯路。**\n\n写程序之前，**务必要做到尽可能的规避掉偶然复杂度**。\n\n> **Less Is More**\n\n## 0xEE 后记\n\n本文简单说了一些我知道的可以规避掉成吨的技术问题的一些非技术性技巧，本文还是不够全面，比如就没有介绍自动化的工具，没有介绍 CI, 没有用实例介绍怎么应对产品经理的不合理要求，这些就留待以后吧\n\n本想着，《整洁下》的这篇可以多写点编程技巧上的东西的。但想了半天，还是选择了从软技能方面入手。**与其说是为了写好代码，倒不如说是为了好写代码。**\n\n所谓**汝果欲学诗，工夫在诗外。**写代码之外的活，其实很重要。\n\n---\n\nChangeLog:\n\n- **2019-09-24** 重修文字\n\nPhoto by [Larm Rmah](https://link.zhihu.com/?target=https%3A//unsplash.com/%40larm%3Futm_source%3Dunsplash%26utm_medium%3Dreferral%26utm_content%3DcreditCopyText) on [Unsplash](https://link.zhihu.com/?target=https%3A//unsplash.com/s/photos/girl%3Futm_source%3Dunsplash%26utm_medium%3Dreferral%26utm_content%3DcreditCopyText)\n"},{"tags":["Python","系列文章"],"path":"20190526_PyCode_07.md","title":"如何写出整洁的 Python 代码 中","slug":"如何写出整洁的 Python 代码 中","date":"2019-05-26","category":"Python 项目代码健壮性和性能","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n本文是《提升你的 Python 项目代码健壮性和性能》系列的第七篇文章。\n\n上篇《如何写出整洁的代码 上》 从变量命名 / 函数 / 注释整洁 / 格式整洁上写出干净的代码\n\nhttps://zhuanlan.zhihu.com/p/59510165\n\n本文还是通过代码上的一些小技巧和一些原则来让代码更加整齐。\n\n## 0x01 避免过深的缩进\n\n场景，你在做一个 B2B2C 的商城系统。商家的活动需要在某些比较严格的条件下才能参与（假设有五个字段吧）。\n\n如果不动手捋一捋判断的路径，上来就动手写代码，则很容易写出如下的代码。\n\n```python\nif cond1:\n\tdosomething()\n\tif cond2:\n\t\tdosomething()\n\t\tif cond3 and cond4:\n\t\t\tdosomething()\n\t\t\telse:\n\t\t\t\tdosomething()\n\t\t\tif condx:\n\t\t\tdosomething()\nelse:\n\tif cond2:\n\t\tdosomething()\n\t\tif cond3 and cond4:\n\t\t\tdosomething()\n\t\t\tif condx:\n\t\t\tdosomething()\n\n```\n\n想想你这个时候才判断了 5 个字段... 如果想都不想就开始写这种代码的话，就做好修改的时候崩溃吧。\n\n当你写出 if 超过两层缩进的时候，代码的复杂度就值得注意了。\n\n这个时候，应该火速的拿出纸和笔出来，快速的捋一捋所有的变量和情况，\n\n『以减少缩进为目标』\n\n能提前判断掉的就提前判断掉\n\n```python\n# 能提前判断掉的就提前判断掉\nif cond2:\n\traise AlreadPaid():\nif cond3:\n\traise ActivityExhaused():\nif cond4:\n\traise ActivityCancel():\n```\n\n代码的缩进越浅，代表着代码越容易维护，用学长的话说，老手才知道『九浅一深』的奥妙......\n\n## 0x02 使用异常\n\n使用异常而不是状态码，这点重点点名一下 Go 语言的状态码....\n\n遇到异常返回状态码写业务的话，很容易抓狂。如果你在深层抛出一个错误，使用状态码的话，必须一层一层的返回状态码。\n\n1. 遇到问题，抛出异常，raise ApiException 。就可以在上层捕获错误进行处理。这样的\n   话，就没有必要每次都在函数签名上返回状态码了。\n2. 让代码更佳清晰的是 try except finally 机制。try 块定义了一个范围，try 中的结果可以看执行中有没有遇到一些奇奇怪怪的情况，然后把 try 块里面的东西取消掉。甚至抛出一个错误，丢到 catch 里面执行。这种接近于事务的做法是状态码机制没法比的。\n\n拿第一小节的代码来说，可以在最深层抛出异常，然后在最外面统一处理异常，有些异常可能只是报 apiexception, 有的异常可能还要针对情况打日志，或者有的情况是你在写代码的时候没有考虑到的情况，都可以进行各种灵活的处理。\n\n这样的话，代码就非常的清晰了。\n\n## 0x03 类与 OOP\n\n注意！\n\n1. OOP 语言让封装 / 继承 / 多态更佳方便快捷安全。\n2. 封装 / 多态 / 继承 并不是 OOP 对象的专利，实际上利用指针 C 也可以写出来具备封装 / 继承 / 多态的程序。只是相对危险一些罢了。\n\n比如，你有这么个场景，计算购物车里面东西的价格：\n\n1. 面向过程思考方式，用户我选了一些商品，然后把商品放到购物车里，然后我算一下物品价格。\n2. OOP 思考方式，用户我需要一个购物车，帮我把这些物品放到购物车里面，购物车告诉我价格。这个时候，你封装一个购物车类会比较合适。\n\n你这个时候就问了，这不就是一个 calcPrice(cart) 和 cart.calcPrice 的区别么？\n\n区别在哪？\n\n1. 『真实世界建模』购物车的是一个对真实世界的建模。\n2. 『职责转移』。计算价格这件事情就是『购物车』这个 Object 的事情了。\n3. 封装性：我不需要维护一个物品集合。都交给购物车来做这件事情。\n\n什么情况下需要类，用 OOP 的方式思考是合理的，明显的，清晰的，就可以了。\n\n当然，采用了 OOP, 可以更快的结合继承 / 多态来完成『依赖反转』。\n\n这个名词听起来不明觉厉，但其实很简单。\n\n```python\n# base.py\nclass Human:\n\tdef perform(self):\n\t\tpass\n\n# foo/man.py\nclass Man(Human):\n\tdef perform(self):\n\t\tprint(\"大哥，真不会唱歌\")\n\n# bar/woman.py\nclass Woman(Human):\n\tdef perform(self):\n\t\tprint(\"大哥，真不会跳舞\")\n```\n\n如果老大哥让你跳舞，就必须要把你的代码给 import 到老大哥的源代码里面。\n\n```python\n# bar/bigbother.py\nfrom foo.man import man_instance\nfrom bar.woman import woman_instance\n\nman_instance.perform()\nwoman_instance.perform()\n\n```\n\n这样会带来一个问题，产生了源代码上面的依赖。这样带来结果是老大哥依赖于几个具体 man 和 woman, 这是不合理的，应该是铁打的老大哥，流水的 man 和 woman\n\n```python\n# 源码不依赖 bigbother.py\n\ndef order_perform(h):\n\th.perform()\n\nhumans = scan_humans()\n\nfor human in humans:\n\torder_perform(human)\n\n```\n\n利用多态，则将这个问题完美的解决了。当然，考虑到动态语言，本身就可以很『多态』.... 你甚至\n都不需要继承了...\n\n策略层与实现完美分离。甚至可以分开进行独立部署。\n\n结论：\n\n1. 对真实世界的建模\n2. 代码清晰为主，如果能用简单函数解决的事情，就不要封装成类。\n3. 以多态为手段对源代码中的依赖关系进行控制的能力。借此，可以构建\n   出插件式架构，让高层策略性组件和底层实现性组件分离。底层实现可以编译成插件，实\n   现独立于高层组件的开发和部署。\n\n## 0x04 SOLID 设计原则\n\n- SRP 单一职责 原则\n- OCP 开闭原则\n- LSP 里式替换原则\n- ISP 接口隔离原则\n- DIP 依赖反转原则\n\n原则是原则，是追求，是启迪思路的思想，但也要随机应变。\n\n1. 假如你不了解业务，强行用依赖反转原则写了抽象层，后面 PM 过来说，我有这么一个思路。那么，你的代码写起来就很痛苦了。\n2. 假如你不了解场景，在使用单一职责的时候，往往就会业务区分不明确。\n\n在现实场景中，往往是先保持足够的清晰简单的代码，随着代码的演进，用上面的原则再次思\n考一下可不可以做的更好。\n\n### 单一职责\n\n比如说，单一职责原则听起来很简单，一个函数只完成一个功能（事情）。\n\n但现实情况是这种往往只是一个追求，站在不同的角度有不同的看法：\n\n比如说，\n\n1. 你说，你今天想学习。这是一件事情。\n2. 你说，你今天上午想学习数学。这是一件事情。\n3. 你说，你今天上午想学习高数第三章，接着做完笔记，回头抽卡默背一遍公式。这是三\n   件事情，并且也可以是一件事情。\n\n你的拆分粒度决定了一件事情的指代范围。\n\n### 开闭原则\n\n开闭原则强调的事情是计算机系统应该在不需要修改的前提下被扩展。将系统划分为一系列组件，并且将这些组件的依赖关系按照层次结构进行组织，使得高阶组件不会因为低阶组件被修改而受到影响\n\n### 里氏替换原则\n\n在不改变软件行为的基础上，衍生类可以替换掉基类\n\n### 接口隔离原则\n\n任何层次的软件设计如果依赖了它并不需要的东西的时候，就会带来意料之外的麻烦。\n\n### 依赖反转原则\n\n什么叫做依赖反转？\n\n依赖反转就是设计软件的时候设计稳定的抽象层。针对抽象的东西编程。\n\n## 0x05 边界和第三方库的挑选\n\n在软件包膨胀的今天，应该如何挑选第三方库呢？\n\n我给出几个挑选的原则。\n\n1. 靠谱依赖原则：如果 flask 是靠谱的，那么，flask 依赖的 click 包，werkzeuk 包一定是靠谱的。\n2. 浓缩精华原则：如果一个库依赖少，代码清晰简单，那么可以采用。\n3. 活跃维护原则：如果维护很活跃，证明前景相对较好。\n4. 多人维护原则：如果是多人维护，则不会因一个人的喜好和个人状态而断了维护。别问我怎么知道的，都是泪\n\n挑选有这个原则，那么，使用有什么原则么？\n\n就一条，尽量减少依赖库对你现有代码的侵入性。\n\n比如，你用了 cryptography 之后，应该封装一个接口用来调用 cryptography 防止以后这个项目挂了，这样你可以只修改该接口，和 pycrypto 对接。\n\n这和里氏替换的思路也是比较类似的\n\n## 0xDD 结论\n\n> 所谓『不能谋万世者不能谋一时，不能谋全局者不能谋一隅』\n\n在软件开发中，其实最重要的过程是梳理流程，流程梳理的足够清楚，代码就足够简单。\n\n不管是避免深缩进，还是使用异常，还是 Solid 原则。都是建立在全局观足够高，对当前的流程非常熟悉的基础上的。\n\n当然，考虑到需求变更的不确定性，代码还是足够简单清晰为上策。\n\n## 0xEE 参考\n\n- 《架构整洁之道》\n- 《代码整洁之道》\n- Photo by Joseph Kellner on Unsplash\n"},{"tags":["Python","系列文章"],"path":"20190525_PyCode_06.md","title":"如何写出整洁的 Python 代码 上","slug":"如何写出整洁的 Python 代码 上","date":"2019-05-25","category":"Python 项目代码健壮性和性能","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n本文是《提升你的 Python 项目代码健壮性和性能》系列的第六篇文章。\n\n接下来的三篇，围绕另一个主题\n\n> 如何写出整洁的代码\n\n『整洁』三篇是基于**『代码整洁之道』和『架构整洁之道』**的一些切身的理解和体会。\n\n感谢这两本书的作者 Bob 大叔。\n\n> PPS: 某东读书 VIP 会员有不少 IT 资源类的书籍可以免费看，比如『代码整洁之道』\n\n## 0x00 前言\n\n### 软件系统的腐败之路\n\n随着项目代码行数的增加，不可避免的遇到软件架构腐败的问题。\n\n具体表现为：**随着每一次产品版本的发布，对现有流程进行优化和修改就格外的费事和吃力。工程师的生产力就开始直线下降。**\n\n![](https://pic2.zhimg.com/v2-8c681642ce7e6a9230ce7f45d3e92cf5_b.jpg)\n\n所谓\n\n> **眼看他起朱楼，眼看他宴宾客，眼看他楼塌了。 清 孔尚任《桃花扇》**\n\n## 0x01 讨论\n\n### 为什么会出现腐败的系统\n\n原因可能是多方面的，比如常见的场景：\n\n```bash\n步骤 1. 领域建模的人对业务里概念的理解不到位，流程不深入了解。\n步骤 2. 工程师在实现的时候，按照自己的理解，没有梳理整个流程。就开始动手实现。并且全程人肉测试。\n步骤 3. 需求变动，流程更改。\n```\n\n**第一步容易埋下坑点：**\n\n1.  对『该领域』理解的不到位，导致『流程』就不清晰，也导致原型设计等同于 Axure 画的『表单』。\n2.  『关键概念』没有解释，『关键字段』没有解释，也没有『流程图』，也没有关于业务主体『状态图』，前后端面向表单开发。\\(Form Oriented Programming\\)\n\n接着，领域理解不到位就会带来另一个问题。\n\n1.  对于需要『建模的实施者』一般是后端工程师，将花费比较多的时间来梳理流程。\n2.  前后端代码结构不清晰。比如，前端页面的路由命名不清晰，Page 组件命名不清晰，请求 API 接口不清晰。比如，后端路由命名不清晰，view func 不清晰，serializer 不清晰，table 命名不清晰。\n\n经验老道的程序员会通过一些手段，比如让这些命名不清晰的东西统一一下，然后等概念清晰了。再改回来。\n\n**第二步容易埋下坑点：**\n\n1.  全程口头对需求，『没有文档』落下来，产品之间和开发之间**『缺乏共通的文档理解指南』**。\n\n当更改已有流程或者是出问题的时候，除了一脸懵逼就还剩下甩锅了。\n\n**第三步容易继续在坑里埋坑：**\n\n**资本市场里，树欲静而风不止，想重构而时不我待。**\n\n1.  领域建模的产品经理会继续叠加新的功能，至于是否已经牵扯到了已有功能，最多和工程师口头说明一下，是不会考虑落实到具体文档里面的。\n2.  工程师需要不断的去满足需求，而疯狂叠加代码。不但要搬砖，而且要快速的把方螺丝强行拧到圆螺母里面。\n\n**最后，**\n\n> **屠龙少年变成了恶龙，而产品和工程师们经过不懈努力，终于堆出了『代码屎山』-- 腐败系统**\n\n### 衡量系统的两个指标\n\n腐败系统有一句成语可以概括，叫做**金玉其外，败絮其中。**\n\n什么是外，什么是中？\n\n- **所谓外，就是软件的行为价值 -- 软件系统的行为是否正常运行，是否满足需求**\n- **所谓内，就是软件的架构价值 -- 软件系统的架构是否清晰，是否灵活，是否可维护**\n\n看起来有点抽象，打个比方就清晰多了。\n\n所谓软件系统，可以比作是人。\n\n- 所谓外，就是人的能力 -- 即革命的本事。\n- 所谓内，就是人的健康 -- 即革命的本钱。\n\n身体是革命的本钱，所以，要经常锻炼身体。同理可知系统也是如此。\n\n业务方和管理层仅在意软件系统的外在。\n\n优秀的软件工程师，做的就是平衡这两者。必要的时候，需要和业务方以及管理层进行沟通。\n\n### 代码是写出来的吗？\n\n不一定。\n\n假如你是做业务逻辑的。\n\n首先，好代码可能是聊出来的。\n\n比如需求确认这一块，多问多画流程图少动手。就可以减少后期很多麻烦事情。\n如果在没有理解透需求的情况下动了手，就会做得越多，错的越多。我相信很多工程师都有\n这种感觉。\n\n当然，这是基本上不怎么可控的外部条件。所以，不在本文的讨论范围之内。\n\n其次，好代码可能是边读边写出来的。\n\n回顾一下一天的工作，你会发现，不管是，你写文章，或者是做一些其他的东西。\n\n1.  **读代码，大部分都是跳转代码，文件内跳转，文件外跳转，分屏浏览。**\n2.  **在这个过程中不断整理和梳理原有的概念。最后落实到代码上。**\n3.  **代码的直接修改。占到你很少的时间。**\n\n最后，好代码是改出来的。\n\n### 好代码的标准\n\n我们只讨论如何保持代码的清晰整洁\n\n> 什么是好的代码？\n\n引用 C++ 创始人的说法，我喜欢优雅而高效的代码，\n\n1.  **代码逻辑应该直截了当，叫缺陷难以隐藏；**\n2.  **尽量减少依赖关系，使之便于维护；**\n3.  **依据某种分层战略完善错误处理代码；**\n4.  **性能调至最优，省的引诱别人做没规矩的优化。**\n5.  **整洁的代码只做好一件事情。**\n\n其实还有一些保证代码整洁的手段：\n\n> 比如本系列的文章讲解\n\n## 0x02 变量命名之道\n\n> **名不正，则言不顺；言不顺，则事不成。事不成，则礼乐不兴；**\n\n写代码就是这样。\n\n### 使用业务领域命名\n\n对于具体业务而言，**起不好名字有一半的锅都是产品经理的锅，因为这是概念认知不清晰的表现。**不要小看这一点，产品经理对项目的理解不到位会在编写代码的过程中被放大。\n\n遇到这种情况，务必要把产品经理拉过来认认真真的扯扯犊子。\n\n### 代码命名\n\n对于实际代码而言，\n\n- 涉及到具体业务名称，起不好名字就是程序员的锅，因为这是跟着产品经理犯傻，继续坚持概念认知不清晰的表现。\n- 涉及到非业务的名称，务必要统一，比如 Button 就是 Button, 如果团队统一叫做 Btn 那就统一叫做 Btn.\n\n> 务必不要用单字母命名，取名字要准确，如无必要，也尽量规避掉缩写。\n\n```python\n# 差\nd = Column # 消逝的时间\n\n# 好\nelapsedTimeInDays\ndaysSinceCreation\ndaysSinceModification\nfileAgeInDays\n```\n\n- 一个单词一个意思，假设你需要往 group 里面添加 member, 那么出现 add/insert/append 三个词的意义就应该完全不一致。\n\n> 不要做无意义的区分\n\n```python\nfetchAccountList 就不如 fetchAccounts\nfetchAccountRecord / fetchAccountInfo / fetchAccountData 就不如 fetchAccount\n```\n\n> 变量是名词，路由是名词，方法是动宾结构。\n\n**即便是名字起的不好，也应该很统一。**\n\n## 0x03 函数整洁之道\n\n### 短小精悍\n\n每个函数都要做到短小精悍\n\n1.  短小\n2.  只做一件事（无副作用）\n3.  一个函数一个抽象层级\n\n### 调用层次清晰\n\n不同抽象层级\n\n```python\ndef 日常 ():\n\t用 XX 点外卖 ()\n\t去厨房拿筷子 ()\n\t等小哥送来外卖 ()\n\n\t睡觉 ()\n\t打豆豆 ()\n```\n\n为什么是不同抽象层级呢？ 点外卖不一定是日常。可能自己偶尔也会做饭。\n\n并且，从业务角度来说，吃饭，睡觉，打豆豆比较符合业务人员的认知。\n\n同一抽象层级\n\n```python\ndef 点外卖吃饭 ():\n\t用 XX 点外卖 ()\n\t去厨房拿筷子 ()\n\t等小哥送来外卖 ()\n\ndef 吃饭 ()\n\tif 今天比较懒：\n\t\t点外卖吃饭 ()\n\ndef 日常 ():\n\t吃饭 ()\n\t睡觉 ()\n\t打豆豆 ()\n```\n\n这样写出来的函数，比较符合自顶向下的阅读方式。\n\n### 控制参数\n\n参数尽量不要超过三个。\n\n因为超过三个之后，就很难用几个单词把这个方法的意义给概括出来。\n\n如果超过三个，这就需要谨慎的考虑将其中的一部分参数是封装为结构体或者是类。\n\n### 如何写函数\n\n1.  不要为了炫技而炫技。\n2.  先写对函数。\n3.  然后打磨函数，即修改名称，消除重复，适当重构\n\n## 0x04 注释整洁之道\n\n1.  注释不能美化糟糕的代码。\n2.  适当解释意图。有的时候 hardcode 却是最好的解决方案。\n3.  能用变量名 / 方法名 / 函数名表达清楚的，就不要讲废话。\n\n## 0x05 格式整洁之道\n\n### 排版整齐\n\n代码一定要排版整齐\n\n- 缩进\n- 每行最大字符串数？\n- 字符串选择单引号还是双引号？\n- 团队协作 diff 同一段代码的时候还是 diff 出来不同的效果。\n\n反正是我记不住 pep8 里面要求的那些标准的。当然，flake8 为你提供了比较好的 lint 标准。\n\n在这里推荐两个工具：\n\n1.  flake8\n2.  black [https://github.com/ambv/black](https://link.zhihu.com/?target=https%3A//github.com/ambv/black)\n\n至于 black, 是类似于 javascript 圈里面的 prettier 的存在。\n\n在每次 commit 的时候，执行 flake8 和 black, 让你的代码整整齐齐。\n\n### 上下文相关\n\n1.  如果我使用了一个方法，如果不是从其他文件里使用，一般会在我编写的代码块的上方不远处。\n2.  如果我使用了一个变量，应该只在起到作用的作用域里。\n3.  如果我针对一个概念编写方法，那么在这个文件里，相关概念的代码应该是放在一起的。\n\n## 0xEE 参考连接\n\n- 《代码整洁之道》\n- 《架构整洁之道》\n"},{"tags":["Python","系列文章"],"path":"20190216_PyCode_02.md","title":"如何通过测试提升 Python 代码的健壮性","slug":"如何通过测试提升 Python 代码的健壮性","date":"2019-03-23","category":"Python 项目代码健壮性和性能","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n本文是《提升你的 Python 项目代码健壮性和性能》系列的第二篇文章。\n\n本文的测试更多专注于 Python 后端的程序员。\n\n在上一篇文章中，我提到了代码覆盖率，即测试的一种指标。\n\n本期就聊聊测试这件小事情。\n\n## 0x01 测试的分类\n\n测试有很多种，\n\n按照测试设计的方法可以分为：\n\n1\\. 黑盒\n2\\. 白盒\n\n按照测试目的：\n\n1\\. 功能测试\n\n```bash\n单元测试\n\t功能测试\n\t集成测试\n\t场景测试\n\tA/B 测试\n\n2. 非功能测试\n\n\t压力测试\n\t安全性测试\n\t可访问性测试\n```\n\n其他\n\n```bash\n回归测试\n易用性测试\n还有不少，懒得去整理了.....\n```\n\n代码覆盖率顾名思义，就是测试用例覆盖运行代码的比重。\n\n### 后端主要关注哪些测试\n\n- 单元测试\n- 功能测试\n- 端对端测试\n- 性能测试\n\n## 0x02 为什么要写测试\n\n来讲讲测试的优点。\n\n为什么要写测试来覆盖代码。\n\n1.  **适当的测试可以让发布代码的时候更加有底气。**\n2.  **适当的测试可以让新手更快的了解代码。**\n3.  **适当的测试可以让程序更容易重构。**\n4.  **适当的测试可以加快团队的开发速度。**\n\n既不是不写，也不是狂写一气。看到这里你可能有些疑惑？写测试还加快速度？Are you kidding\\?\n\n一个一个来解释吧。\n\n举个简化版本的例子，『用户下单』到『用户收货』。\n\n1.  用户『查询产品』\n2.  用户『使用优惠券』下单\n3.  用户『在线支付』。当然，用户也可以让不付款，让订单失效。或者直接取消订单。\n4.  商家『确认发货』。\n5.  物流公司更新运单『发货中』。\n6.  用户『确认收货』。当然，用户也可以发起退款。\n\n### 让新手更快的了解代码\n\n测试用例里的数据，往往是能跑通某段代码的最佳测试数据集合。\n\n假如，有个程序员写了 『下单-在线支付-确认收货』的集成测试。作为刚接手这段代码的人。可以在最短的时间内，通过阅读测试代码从而理解整个流程。\n\n有 fixture, 新手可以在很短的时间内知道 setup 能让项目跑起来的基本数据\n\n当然，如果过多的写了测试，也会导致阅读起来比较困难。\n\n### 让发布代码的时候更加有底气\n\n写测试，是为了验证代码运行正确。\n\n一个流程，通常包含若干个子流程，子流程是对的，整个流程才是对的。\n\n如果不写测试对一些关键的流程进行全面的覆盖，则会导致\n\n1.  修改或者新增了一个子流程，需要重新跑个流程进行人肉测试。\n2.  如果人肉测试太费事，则一般程序员就会跳过这个步骤导致线上出问题。\n\n### 让程序更容易重构\n\n当你知道写测试代码有这么多优点的之后，你的第一反应是，这我都知道，但是，写测试还能加快开发速度？\n\n> 当然，你要知道，一个需要去维护的有价值的产品，往往需要不断的修改流程。\n\n一开始，PM 告诉你只需要下单买个东西，后来，要加上满减券，再后来要加上各种类型的券，然后你要对接第三方服务，接下来你要对付各种不按照你设定的流程出牌的用户....\n\n写测试，则是通过不断的补充一些测试，实现整个流程的测试自动化。形成一套测试该项目的测试代码。流程长的令人发指，你指望全靠人肉来测试？\n\n1.  当我修改或者新增子流程的时候，在已经构建出来的测试代码上，可以花少量的代码直接保证修改或者新增的子流程输入和输出被测试到位。\n2.  多人合作的时候，如果 A 原先维护了一套子流程，而 B 来改了一波 A 写的子流程。在有适当的测试的情况下，基本上改出问题来，都会跑不过测试的。\n\n当然，前提是\n\n1.  A 用心写了测试，而不是写了仅仅能让 A 的代码跑的过去的测试。\n2.  是测试如果写过多的话，也会造成团队精力的分散。这下面谈到测试的缺点的时候就会知道。\n\n### 加快团队的开发速度\n\n虽然说，我写的是加快团队的开发速度，但实际上，也适用于个人。\n\n> **除非，你是写渲染页面的.... 所见即所得。无需任何测试**\n\n## 0x03 为什么不要写测试\n\n依照软件界著名的『没有银弹』理论，说完了测试的优越性，也要来说说测试的局限性，主要有三点：\n\n1.  **测试不能解决什么问题？**\n2.  **不适当的测试，往往是负担。**\n3.  **并不是所有地方都容易测试的。**\n\n### 测试不能解决的问题\n\n> 测试能确保代码的运行质量，但无法确保代码编写质量，也无法保证产品设计逻辑上的问题。\n\n也就是说\n\n1.  **代码写的烂，测试代码只能确保编写代码是可以正常运行的。并不能改善代码质量。最多给烂代码的重构提供比较好的运行保证。**\n2.  **产品设计逻辑上的问题，测试代码也只能保证这个设计逻辑落地。**\n\n> 当你觉得测试代码写起来比较难受的时候，你应该考虑重构一下你的程序了。\n\n### 不适当的测试为什么是负担\n\n人总要习惯的是：\n\n1.  东西，学，是学不完的。未知的东西永远存在。新的事物总是在出现，老的事物也不断在演进。\n2.  时间有限，精力有限\n\n> **放到测试上来说，测试，也是测不完的。**\n\n写了一个 IF ELSE , 你需要测两组，多写了一个 IF ELSE, 你就要测四组。如果是一个比较复杂的流程的话，基本上全面测试就很难写完了。\n\n**我的想法是：**\n\n1.  **挑选关键的地方进行测试**\n2.  **减少用户不必要的数据获取**\n\n### 并不是所有地方都容易测试的\n\n并不是所有地方都容易测试的。\n\n1.  特别依赖其他服务商的业务。比如，支付宝 / 微信的预支付。微信小程序的登陆。\n2.  跨端的业务。\n\n这类业务如果做的比较深入，需要 Mock 掉很多逻辑。\n\n## 0x04 写 Python 测试的一些注意事项\n\n### 项目的环境隔离\n\n从整体项目角度，代码的运行环境应该区分 Local/Test/Stage/Prod 四种环境。\n\n- 本地环境：开发者电脑上的环境\n- 测试环境：开发者电脑上 / 持续集成上的环境，之前比较喜欢用 GitlabCI, 后来 团队上了 jenkins, 用起来也还行。\n- 预发布环境：预发布环境，对后端来说，通常情况下就是前端可以通过调用 API 的环境。\n- 生产环境：生产环境。\n\n之所以要做这种区分，是因为不同的环境侧重点不同。\n\n- Local 环境 针对开发者设置的，这个环境的代码变更比较频繁。Web 应用 / Worker / Beat / Deamon 在本地环境中，一般报错比较多，一般我会在禁掉日志。\n- Test 环境 用于执行 make lint \\&\\& make test，用于检查 lint 相关代码并运行测试。\n- Stage 环境\n- Prod 环境 和 Stage 环境就比较接近了。但也不完全一致。比如生产环境的组织或商家的一些开发资料。\n\n### 测试的基本环境\n\n一般起一个 Docker-Compose 文件，来快速初始化测试环境。\n\n比如 WebApp / Celery Worker / Celery Beats / Redis / RabbitMQ / MySQL 可以 make start 直接起这些服务。\n\n### 单测 / 功测 / 端对端\n\n之前说，后端需要注意下面的测试\n\n- **单元测试**\n- **功能测试**\n- **端对端测试**\n- 性能测试\n\n> 性能测试一般可以通过监控来提前对系统在哪些地方有瓶颈。看场景，一般观察监控会更加容易预测系统的瓶颈，这个更多偏向于调优，放到后面来说吧。\n\n框架假设我们使用 Flask , 再假设有这么一个 BBS（我知道你想吐槽为什么又拿博客 /BBS 举例子，懒得交代过多的业务场景背景知识了，逃...）\n\n1.  **组织 Organization 发布了一个 Thread**\n2.  **用户 User 在这个 Thread 进行了 Reply 『未注册的用户能看见』**\n3.  **管理员 Admin 发现了 User 似乎发布了不该发布的信息。删 Reply。『未注册的用户看不见 / 所有者是能看见的』**\n4.  **最后 User 进行申诉，Admin 发现其实发布的东西挺 OK 的，给予通过。『未注册的用户能看见』**\n\n```bash\ntests # 测试文件目录\n├── __init__.py\n├── conftest.py # 这里存放可能被子目录引用到的集合\n├── e2e # 『端对端测试』\n│   ├── __init__.py\n│   ├── test_viewer.py\n│   ├── test_user.py\n│   ├── test_admin.py\n│   └── test_organization.py\n├── functional # 『功能测试』\n│   ├── __init__.py\n│   ├── test_do_simple_reply.py\n│   ├── test_do_complex_reply.py\n│   └── test_helper.py\n├── unit # 『单元测试』\n|   ├── __init__.py\n|   ├── test_auth.py\n|   └── test_calc_some_thing.py\n├── test_auth_helper.py # 存放基本的用于切换身份的代码\n├── test_const.py\n└── test_factory_helper.py # 可以用来批量初始化数据\n```\n\n这个流程并不算复杂，但足以写测试了。\n\n1.  **在 test_factory_helper 完成数据的基本初始化。**\n2.  **在端对端测试中简单测试浏览。包含未注册用户 viewer 的访问，user/admin/org 的带有效 / 无效 / 过期登陆凭据访问**\n3.  **在 unit 中测试一些和业务联系不紧密的逻辑。比如，计算时间**\n4.  **在 functional 进行比较独立的测试。有的时候也会把几个功能拉起来做测试。相对独立的测试，就是新建一个 User 的 Thread, 删除 Reply, 拉起来测试就是 1/2/3/4 一个测试就完了。**\n\n前者比较简单，后者相对而言更加靠近集成测试。各有利弊。我一般在关键流程上多做几个拉起来测试的代码。\n\n但拉起来测试要解决的问题就多了一个，即，用户登陆认证。你调用某个 Service 的时候，是以匿名用户 / 用户身份 / Admin / Org 调用的。\n\n即在调用不同的 Service 解决问题的时候，你可能需要快速的切换身份。切换完身份再速\n度切换回来。于是，test auth helper 出来了。helper 里面有个 switch as 函数，每次需\n要切换身份的时候，把 g 变量里面的登陆快照 g.user g.admin [http://g.org](https://link.zhihu.com/?target=http%3A//g.org) push 到 LocalStack 栈里 \\(from werkzeug.local import LocalStack\\), 调用完 Service 再 Pop 出来。\n\n拉起来测试的效果是这样子的。\n\n```python\ndef test_complex_process(org, user, admin):\n\twith switch_as_org(org) as org:\t\t# 1. 组织 Organization 发布了一个 Thread\n\t\tthread = publish_thread_by_org()\n\t\twith switch_as_user(user) as user: # 2. 用户 User 在这个 Thread 进行了 Reply\n\t\t\treply = reply_thread(thread)\n\t\t\tassert reply\n\t\t\twith switch_as_anonymous() as anonymous_user:\n\t\t\t\t_thread = see_thread(thread)\n\t\t\t\tassert reply in _thread.replies # 『未注册的用户能看见』\n\t\t\twith switch_as_admin() as admin: # 3. 管理员 Admin 发现了 User 似乎发布了不该发布的信息。删 Reply。\n\t\t\t\tdelete_reply(reply)\n\t\t\t\tassert reply.deleled\n\t\t\twith switch_as_anonymous() as anonymous_user:『未注册的用户看不见』\n\t\t\t\t_thread = see_thread(thread)\n\t\t\t\tassert reply not in _thread.replies\n\t\t\t# 在这里，我的身份还是 user\n\t\t\t_thread = see_thread(thread)\n\t\t\tassert reply in _thread.replies # 『Ower 用户能看见』\n\t\t# 4. 最后 User 进行申诉，Admin 发现其实发布的东西挺 OK 的，给予通过。『未注册的用户能看见』\n```\n\n作为开发者，你只需要让这个测试跑通就基本开发完毕了。在这个过程中，你也可以更好的梳理你的代码。\n\n### 如何处理外部服务\n\n在拉起来做测试的时候，假如我们多了一个流程，用户可以通过微信支付赞赏 reply, 这就不得不依赖于外部的服务。\n\n而拉起来做测试的时候，就会遇到一个非常尴尬的问题，因为我上面的接口都粒度都比较大，是赞赏这个流程里面的非常小的流程，必须要走微信的 http 请求。\n\n解决方式也很简单。 mock 掉请求微信的函数。手动调用一下支付回调函数，即可。\n\n当然，对于 http 请求，也可以使用 **responses** 这个神器来快速 mock 神器 requests 的 response\n\n大致的用法如下\n\n```python\ndef mock_success_pay():\n    def request_callback(request):\n        headers = {}\n        dispatch_callback(data=data)\n        return 200, headers, resp_body\n\n    responses.add_callback(\n        responses.POST,\n        PAY_URL,\n        callback=request_callback,\n        content_type=\"application/json\",\n    )\n\n@responses.activate\ndef test_pay(user):\n    mock_success_pay()\n\t\tswitch_as_user(user) as u:\n\t\t\torder = pay_order(u)\n\t\tassert order.status == \"PAID\"\n```\n\n### 其他 Pytest 小技巧\n\n有的时候 ipdb 比 pdb 用起来不止好了一点点。如何在 pytest 里用上呢？\n\n```bash\npytest -v --pdb --pdbcls=IPython.terminal.debugger:Pdb\n```\n\n## 0xEE 参考\n\n- [https://www.zhihu.com/question/21017354/answer/589574939](https://www.zhihu.com/question/21017354/answer/589574939)\n- [https://www.zhihu.com/question/312395573/answer/604772703](https://www.zhihu.com/question/312395573/answer/604772703)\n"},{"tags":["Python","系列文章"],"path":"20190310_PyCode_05.md","title":"为你的项目快速搭建 ELKFA 日志系统","slug":"为你的项目快速搭建 ELKFA 日志系统","date":"2019-03-10","category":"Python 项目代码健壮性和性能","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n本文是《提升你的 Python 项目代码健壮性和性能》系列的第五篇文章。\n\n讲的是日志系统 ELKFA 的搭建\n\n## 0x00 前言\n\n什么是 ELKFA\\?\n\n这五个字母分别代表着五个开源软件\n\n- **E - ElasticSearch**\n- **L - Logstash**\n- **K - Kibana**\n- **F - FileBeat**\n- **A - APM-Server**\n\n利用这五个软件的组合，我们可以在比较短的时间打造两个系统：\n\n1.  日志系统，分析 Nginx 日志，Gunicorn 日志，Flask 日志，Django 日志\n2.  APM 系统，解决两个问题\n    2.1 Metric 分析：Flask 是否正常运行，接口请求信息定期发送到 APMServer 这边，方便我观察服务是否正常，接口和业务逻辑的执行的时间是否在预期范围内。\n    2.2 Trouble Shooting: 如果程序报了异常，我想把需要报的异常堆栈信息打出。方便我快速的 Trouble Shooting\n\n## 0x01 任务 1: 分析 Nginx 日志\n\nNginx 众所周知，Nginx 日志是个宝库，所以本文选取了 Nginx 作为日志分析的案例。\n\n对于 Nginx 日志，可以采用 FileBeat 上传到 Logstash, 由 Logstash 对文件进行解析，并存储到 ElasticSearch\n\n然后从 Kibana 进行分析。\n\n### 第一步：配置 Nginx\n\n首先，让 Nginx 的配置输出的日志符合某种模式，方便软件进行解析。\n\n```text\nlog_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n\t\t\t\t\t\t\t'$status $body_bytes_sent \"$http_referer\" '\n\t\t\t\t\t\t\t'\"$http_user_agent\" \"$http_x_forwarded_for\"';\n\naccess_log /var/log/nginx/access.log main;\n```\n\n然后重启 nginx\n\n### 第二步：拉取 Nginx 日志\n\n一天后，从 Nginx 服务器上拉一下 access.log 放到\n\nelastic-labs/logs/prod/nginx 下\n\n### 第三步：开启 ELFKA\n\n```text\ngit clone git@github.com:twocucao/elastic-labs.git\ncd elastic-labs\ndocker-compose up\n```\n\n> 啥、? 不会搭 Docker\\? 见文末\n> 啥、? 不知道 ElasticSearch 怎么用、? 见文末\n\n如果运行正常，终端应该是这样的\n\n![](https://pic1.zhimg.com/v2-15a6f7c35277ca34f035a0996ed1d23c_b.jpg)\n\n打开 kibana 进行观察\n\nhttp://localhost:5601/\n\n![](https://pic2.zhimg.com/v2-52689881c9e9610d37c0fb88016ed5b5_b.jpg)\n\n### 第四步：日志探秘\n\n默认情况下，每一天的 Nginx 日志会在 ES 里创建一个 Index, 所以，你需要用 Index Pattern 来进行统计\n\n![](https://pic2.zhimg.com/v2-52d45736112286a549e1e216fa0dab95_b.jpg)\n\n来看看我们可以得到哪些内容\n\n![](https://pic1.zhimg.com/v2-341fb82fdf1615c6180fea381bca8c44_b.jpg)\n\n1.  用户 IP 以及通过 GeoIP 得到的大致地理位置。\n2.  OS 的类型 \\(Win/Mac/Linux/IOS/Android\\)\n3.  客户端的类型，浏览器 / 小程序 / 客户端\n4.  访问的接口，类型，频率\n5.  访问服务的频率\n6.  还有很多其他可以深挖的地方，比如通过用户访问的次序推断用户的使用姿势和思考方式等等\n\n对于第六点，有些人可能有些疑惑，这也能？\n\n> **当然咯，假设用户在搜索引擎里面，先搜索了『美女』, 然后搜索了『雪白』, 然后又搜索了『白-洁』, 那基本上这个人搜索的三个词就具备一定的关联性，想搜索的这个雪白就不是『雪白』的意思** > **而是你懂的。**\n\n### 第五步：扩展思考，日志解决方案\n\n上面四个步骤是为了解决分析 Nginx 日志的问题\n\n一条日志从打印出来，到能在 Kibana 进行分析，需要经过如下的步骤：\n\n1.  按照某种日志格式写到文件里，然后被 FileBeat 接收，FB 判断为『 Nginx 模块的日志之后』上传到 Logstash\n2.  Logstash 按照一个端口一个类型的方式接受该类型的日志。通过 filters 和插件进行匹配和修改，比如 grok 的 pattern 来匹配每一条日志（类似于正则匹配）, 抽出需要独立成字段的部分。比如通过 geoip 进行地址匹配，比如对字段进行 convert\n3.  输出匹配结果到 ElasticSearch\n4.  Kibana 通过更加边界的工具来查询 ElasticSearch\n\n如果你想要自定义日志获得更加完美的解决方案，那就需要对这几个流程进行进行细化。\n\n比如你想通过 Flask 的日志来达到更好的用户操作定位。这就需要读者自行依照自己的理解来 hack 了\n\n## 0x02 任务 2: 监控 Flask App 的 APM\n\n### 第一步：开启 ELFKA\n\n同任务一的启动方式\n\n### 第二步：开启 flask app\n\n```bash\npip3 install poetry # 比 pip / pipenv 更好的依赖管理和构建工具\npoetry install -vvv\npoetry shell\nflask run\n```\n\n写一个简单的管理和依赖工具\n\n```bash\nfrom flask import Flask\nfrom elasticapm.contrib.flask import ElasticAPM\n\napp = Flask(__name__)\n\napp.config[\"ELASTIC_APM\"] = {\n    \"SERVICE_NAME\": \"dev-flask\",\n    'SECRET_TOKEN': '',\n}\napm = ElasticAPM(app)\n\n@app.route(\"/\")\ndef hello():\n    return \"Hello, World!\"\n\n@app.route(\"/home\")\ndef home():\n    return \"home!\"\n\n@app.route(\"/<int:num>\")\ndef hello_num(num):\n    import random\n    if random.randint(1, 100) > 95:\n        raise Exception(f\"num\") # 有接近 1/5 的概率会故意抛出异常\n    return f\"Hello, {num}!\"\n```\n\n随手写一个脚本 20 分钟内持续不断的访问接口\n\n```bash\nSECONDS=0\nwhile [[ SECONDS -lt 1200 ]] ; do\n\tfor (( i = 0; i < 20; i++ )); do\n\t\tcurl \"http://localhost:5000/$i\"\n\t\tcurl \"http://localhost:5000/$i\"\n\t\tcurl \"http://localhost:5000/$i\"\n\t\tcurl \"http://localhost:5000/$i\"\n\t\tcurl \"http://localhost:5000/$i\"\n\t\tcurl \"http://localhost:5000/$i\"\n\t\tcurl \"http://localhost:5000/$i\" &\n\t\tcurl \"http://localhost:5000/$i\" &\n\t\tcurl \"http://localhost:5000/$i\" &\n\t\tcurl \"http://localhost:5000/$i\" &\n\t\tcurl \"http://localhost:5000/$i\" &\n\t\tcurl \"http://localhost:5000/$i\" &\n\t\tcurl \"http://localhost:5000/$i\" &\n\t\tcurl \"http://localhost:5000/$i\" &\n\tdone\ndone\n```\n\n### 第三步：APM 探秘\n\n20 分钟过去了，我们可以获知到什么呢？\n\n1.  Metric 分析：Flask 是否正常运行，接口请求信息定期发送到 APMServer 这边，方便我观察服务是否正常，接口和业务逻辑的执行的时间是否在预期范围内。\n2.  Trouble Shooting: 如果程序报了异常，我想把需要报的异常堆栈信息打出。方便我快速的 Trouble Shooting\n\n先设置时间为最近 30 分钟\n\n![](https://pic4.zhimg.com/v2-8076c883c59df6d2ff0821d82c2b1f7f_b.jpg)\n\n在这里可以看到接口的访问情况\n\n![](https://pic2.zhimg.com/v2-776f3bf0834fc827edf2264ca76049f1_b.jpg)\n\n先看 Metric 分析\n\n![](https://pic1.zhimg.com/v2-9352ae0740081699d5692df34df9f724_b.jpg)\n\n这里可以看到接口的稳定性，服务器的基本负载，以及 Error 的出现频次。\n\n再看 Error\n\n![](https://pic2.zhimg.com/v2-1d63b7048a6144cdbf14e8543fb31225_b.jpg)\n\n**看到这里简直泪目 这就是 ELK 版本的 Sentry 啊**\n\n> **Time Saving \\&\\& 防脱发利器**\n\n### 第四步：扩展思考\n\n从 App 被监控到能在 Kibana 进行分析，需要经过如下的步骤：\n\n1.  在原有的 Flask App 里面进行添加 elastc-apm 的 agent \\(apm-client\\)\n2.  agent 会定期将收集完毕的性能信息以及异常信息，发到 apm-server\n3.  输出结果到 ElasticSearch\n4.  Kibana 通过更加边界的工具来查询 ElasticSearch\n\n如果你想要自定义日志获得更加完美的解决方案，那就需要对这前两个流程进行进行细化。\n\n比如公司用 Graphql 的接口，那么，在这种情况下，自带的 contrib 下的 flask 包的路由基本就是废掉的，你需要再 Hack 一下。\n\n## 0xDD 结论\n\n本来这篇文章打算写日志的最佳实践的，结果在查找资料的时候发现了一篇更好的文章\n\n- [https://zhuanlan.zhihu.com/p/27363484](https://zhuanlan.zhihu.com/p/27363484)\n\n看完之后打消了这个念头，转而写如何使用 ELK 的系统落实这种日志分析系统\n\n代码见 [twocucao/elastic-labs](https://link.zhihu.com/?target=https%3A//github.com/twocucao/elastic-labs)\n\n> **欢迎点赞 / 关注 /star 文明三连**\n\n## 0xEE 参考链接\n\n- [https://zhuanlan.zhihu.com/p/27363484](https://zhuanlan.zhihu.com/p/27363484)\n- Photo by[Tan Kaninthanond](https://link.zhihu.com/?target=https%3A//unsplash.com/photos/rr8DvtQL9X8%3Futm_source%3Dunsplash%26utm_medium%3Dreferral%26utm_content%3DcreditCopyText)on[Unsplash](https://link.zhihu.com/?target=https%3A//unsplash.com/%3Futm_source%3Dunsplash%26utm_medium%3Dreferral%26utm_content%3DcreditCopyText)\n- **关于 elasticsearch 可以参考我以前的文章** [Django 全栈教程系列番外篇 - ElasticSearch CheatSheet](https://zhuanlan.zhihu.com/p/35143409)\n- 关于 **docker 的搭建** 可以参考我以前的文章 [Django 全栈教程系列之一 - YaDjangoBlog 开发环境配置](https://zhuanlan.zhihu.com/p/33920401)\n"},{"tags":["Python","系列文章"],"path":"20190308_PyCode_03.md","title":"如何保证 Django 项目的数据一致性","slug":"如何保证 Django 项目的数据一致性","date":"2019-03-08","category":"Python 项目代码健壮性和性能","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n本文是《提升你的 Python 项目代码健壮性和性能》系列的第三篇文章。\n\n- **第一篇，讲的是如何 [用 Type Annotation 提升你的 Python 代码健壮性](https://zhuanlan.zhihu.com/p/56863684)**\n- **第二篇，讲的是[如何通过测试提升 Python 代码的健壮性](https://zhuanlan.zhihu.com/p/57510222)**\n\n第三篇，即本文，我们来谈谈 Django 项目并发可能带来的问题以及如何保持 Django 项目的数据一致性。\n\n本文目录如下：\n\n```text\n   0x00 前言 : section\n▼ 0x01 背景知识 : section\n\t\t并发会带来数据不一致 : section\n▼ 0x02 Django 项目如何解决项目 : section\n\t\t悲观的方式 : section\n\t\t乐观的方式 : section\n\t\t没有银弹 : section\n\t0x03 解决超卖问题 : section\n▼ 0x04 番外篇 数据库隔离级别 : section\n\t\tREAD-UNCOMMITTED : section\n\t\tREAD-COMMITTED : section\n\t\tREPEATABLE-READ : section\n\t\tSERIALIZABLE : section\n\t0xEE 参考链接 : section\n```\n\n本文讨论的场景如下：\n\n**一个简单的秒杀系统，商品还剩 200 件。有一些用户来访问并下单。**\n\n这个项目的接口的简单写法就是：\n\n```text\n@db_transaction\ndef user_order_by_product(user,product):\n    if product.quantity > 0:\n        product.quantity = product.quantity - 1\n        make_order(user,product)\n        product.save()\n```\n\n显然，这个写法确实简洁。\n\n但问题就来了。\n\n> **商品会超卖**, 除非你的应用没什么人访问。\n\n为什么呢？\n\n## 0x01 背景知识\n\n### 并发会带来数据不一致\n\n看图\n\n![](https://pic1.zhimg.com/v2-c016d0d69ca5facc17cdc5cbadc5bac0_b.jpg)\n\n知道问题出在哪儿了吧？\n\n- **理解了？**\n- **你确定理解了？**\n- **你确定你真的理解了？**\n\n![](https://pic2.zhimg.com/v2-f766e78611ac56f55e8984f950a94149_b.jpg)\n\n其实是我给读者挖了一个坑，**我画的这张图其实是有预设的，比如 NOTE2 处确保了 B 用户读到的是 2。**\n\n如果数据库隔离级别是 read uncommitted, NOTE2 处读到的也有可能是 1 ,\n\n本文仅仅针对于 read committed 隔离级别下的 **MYSQL** **/ PostgreSQL**。\n\n在上图中。\n\n一般人写程序\n\n1.  **往往不是**用 Django 的 F 表达式，来实现 update balance = balance - 20 的操作。 **update balance = balance - 20 where id = 1**\n2.  **而是计算** 出新的 balance 然后 user.balance = 80, 接着 user.save\\(\\)\n\n> **这就会放大了问题**\n\n在低并发量的情况下，这个用户手动不断的下单，下单到 200 的时候，后端准时的报卖完了。\n\n假如我现在是 20 个用户同时在下单，很可能机会出现上图的情况。\n\n> **出了问题要解决问题 看到问题就要想法子**\n\n- **鲁迅说过，一见短袖子，立刻想到白臂膊，立刻想到全 X 体，立刻想到....**\n- **我也说过，提到并发，就想到锁，就想到乐观锁，就想到悲观锁。**\n\n## 0x02 Django 项目如何解决项目\n\n有乐观的方式和悲观的方式，即所谓的乐观锁和悲观锁。是不是有高下之分呢、? 不一定。\n\n> 这就好比乐观和悲观本身也并不见的有高下之分。如同有的人乐观，并不见得一定就是乐观，搞不好是傻乐呵，有的人的悲观，只是底色比较悲凉，但内心还是积极向上的。\n\n本小节内容依照自己的理解厚颜无耻的援引了这篇文章的代码\n\n[https://medium.com/\\@hakibenita/how-to-manage-concurrency-in-django-models-b240fed4ee2](https://link.zhihu.com/?target=https%3A//medium.com/%40hakibenita/how-to-manage-concurrency-in-django-models-b240fed4ee2)\n\n### 悲观的方式\n\n悲观的方式就是锁住某个资源，不让其他人使用（排他），直到完成工作后释放。\n\n为什么使用数据库的锁（准确来说是关系型数据库的锁）\n\n1.  数据库非常擅长处理锁来完成数据一致性。\n2.  数据库级别的锁可以保护其他进程修改数据。\n\n```text\n@classmethod\ndef deposit(cls, id, amount):\n   with transaction.atomic():\n       account = (\n           cls.objects\n           .select_for_update()\n           .get(id=id)\n       )\n\n       account.balance += amount\n       account.save()\n    return account\n\n@classmethod\ndef withdraw(cls, id, amount):\n   with transaction.atomic():\n       account = (\n           cls.objects\n           .select_for_update()\n           .get(id=id)\n       )\n\n       if account.balance < amount:\n           raise errors.InsufficentFunds()\n       account.balance -= amount\n       account.save()\n\n   return account\n```\n\n使用 select_for_update 锁住这个 object 直到事务结束\n\n在使用悲观锁的情况下，存钱和取钱流程如下\n\n![](https://pic2.zhimg.com/v2-1c75458108c69d13bcb0d07bdacab0c5_b.jpg)\n\n### 乐观的方式\n\n乐观的方式就是新建一个 version column, 每次修改余额的时候，版本增 1\n\n同样我厚颜无耻的援引了 hakibenita 的代码\n\n```text\ndef deposit(self, id, amount):\n   updated = Account.objects.filter(\n       id=self.id,\n       version=self.version,\n   ).update(\n       balance=balance + amount,\n       version=self.version + 1,\n   )\n   return updated > 0\n\ndef withdraw(self, id, amount):\n   if self.balance < amount:\n       raise errors.InsufficentFunds()\n\n   updated = Account.objects.filter(\n       id=self.id,\n       version=self.version,\n   ).update(\n       balance=balance - amount,\n       version=self.version + 1,\n   )\n\n   return updated > 0\n```\n\ndjango 默认会返回修改成功的行数，于是，是不是存取成功，就看 updated 是否大于 0 了\n\n### 没有银弹\n\n计算机世界里面，多快好省的场景就不存在。一切看场景。\n\n同样在并发量大的情况下\n\n1\\. 如果对某几行修改比较频繁，版本更新频繁，可能乐观锁的 retry 就比较浪费了。\n2\\. 如果是对整张表的更新比较频繁，而不是频繁修改某几行。乐观锁，就比较合适了。\n\n- 乐观方式在应用层，无法阻拦数据库的操作。不会存在死锁的问题。\n- 悲观方式是数据库实现，他阻止数据库写操作。\n\n## 0x03 如何解决超卖问题\n\n1.  把数量和已卖放到 redis 里面呢？\n2.  交给 deamon 呢？\n3.  用 celery 然后排个队异步任务呢？\n\n搞个再复杂一点点的，\n\n1.  在 Redis 里面直接生成 200 个订单号\n2.  然后用户来一个取走一个订单号码\n3.  通过 Celery 削峰 排队走异步任务\n4.  最后通过数据表的 uniq 约束来防止下单超过 200 个。\n\n嗯，就是这么简单。\n\n## 0x04 番外篇 数据库隔离级别\n\n提到了数据库隔离级别，就利用上面的例子顺手讲解一下数据库隔离级别吧。\n\n### READ-UNCOMMITTED\n\n![](https://pic1.zhimg.com/v2-739b559c1747e1d7365187d00a7e3b78_b.jpg)\n\n### READ-COMMITTED\n\n![](https://pic4.zhimg.com/v2-5750ab71fb047d99465912af95a6d323_b.jpg)\n\n### REPEATABLE-READ\n\n![](https://pic4.zhimg.com/v2-200ffcc69005fe5d6e37034f72c4a5f3_b.jpg)\n\n### SERIALIZABLE\n\n这个就不放图了。没啥好讲的。性能太低.... 我是基本上没怎么使用过的\n\n性能上 RU > RC > RR > S\n\n一般人用 RC 和 RR 会多一些，比如我的项目里就使用了 RC , 但什么时候我可能会考虑用 RR 呢、? 比如，我想在一个 Session 里面选两次 最近两个月的用户数据，但是并不希望 出现新的用户。\n\n## 0x05 番外篇 Django ORM\n\n**评论区**\n\n[\\@灵魂对撞机](//www.zhihu.com/people/f4ca959f981c310af429ca25b3b4721d)\n\n提出了防止超卖的另一种解决方案\n\n```python3\n先做订单记录，在直接 sql 改数量，前提库存大于 0，失败一个就事务回滚，抢购失败。\n\n即如下\n\ndef do_order(product):\n   with transaction.atomic():\n       order = make_order(product)\n       # 他的思路 是 RawSQL\n       # updated = sqlexecute(f\"update from product set quantity = quantity - 1 where id = {product.id} and quantity > 0 \")\n       # 在这个基础上，其实可以写出 django orm 对应的语句\n       updated = Product.objects.filter(\n           id=id,\n           quantity_gt=0\n       ).update(\n           quantity=quantity - 1,\n       )\n       if updated == 0:\n           transaction.rollback()\n```\n\n面向业务设计的表，和面向数据分析的表应该是两种设计思路。orm 是实体和记录的映射，比较适合面向业务设计的表。\n\n[\\@灵魂对撞机](//www.zhihu.com/people/f4ca959f981c310af429ca25b3b4721d)\n\n也提到**表关联查询太痛苦了**\n\n**在我的认知里**\n\n1.  **Django 本身是支持 RawSQL 查询的**\n2.  当你想要的 object 和 row 是一一对应关系的时候，ORM 写起来特别舒服\n\n```text\n- django orm 写过滤条件是很舒服的。（抛开性能来说）\n- 针对 Object 的修改也很方便，比如商品数量减少。比如自增 update。\n```\n\n这也是 orm 的不足之处，显式多表连续 join 的话过滤条件就很麻烦。\n\n如果需要**关联查询**这也应该看情况\n\n1.  **如果一般的多表连续 join 如果能使用 nested queries 的话，用 Django 写起来也是特别的舒服。（如果你不是使用 mysql 这种对 nested query 几乎无优化的数据库）**\n\n```python\nVoteActivity.objects.filter\\(category=obj.category, user\\_\\_name\\_contains\\(\"王\"\\), user\\_\\_city\\_\\_type=\"一线城市\"\\) # 伪代码\n```\n\n**2\\. 或许是应该走 ETL 或者是把数据丢到 ES 或者针对查询优化的表会更加合适、?**\n\n当然，这也就看具体的情况了。\n\n## 0xEE 参考链接\n\n1.  [https://www.cnblogs.com/huanongying/p/7021555.html](https://link.zhihu.com/?target=https%3A//www.cnblogs.com/huanongying/p/7021555.html)\n2.  [Django and MySQL](https://link.zhihu.com/?target=https%3A//ewencp.org/blog/django-and-mysql-isolation-levels/index.html)\n3.  [https://medium.com/\\@hakibenita/how-to-manage-concurrency-in-django-models-b240fed4ee2](https://link.zhihu.com/?target=https%3A//medium.com/%40hakibenita/how-to-manage-concurrency-in-django-models-b240fed4ee2)\n"},{"tags":["Python","系列文章"],"path":"20190309_PyCode_04.md","title":"这几招，让你快速提升 Python 项目的性能","slug":"这几招，让你快速提升 Python 项目的性能","date":"2019-03-05","category":"Python 项目代码健壮性和性能","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n本文是《提升你的 Python 项目代码健壮性和性能》系列的第四篇文章。\n\n本文讲的是\n\n```\n**当你觉得某个地方运行比较慢了，此时此刻的你，有哪些小技巧可以快速的帮**\n**你定位性能问题。**\n```\n\n## 0x00 前言\n\n本文主要目的在于介绍一些 Python 项目常规的性能优化的姿势与技巧。\n\n优化的最简单的途径就是，**没用户 + 调用次数少**\n\n嗯？但这种优化方式...... 实在是没什么好说的。\n\n- **优化口诀 1: 先做对，布监控，再做好。**\n- **优化口诀 2: 过早优化是万恶之源。**\n- **优化口诀 3: 去优化那些需要优化的地方。**\n\n即\n\n- Step 1. Get it right.\n- Step 2. Test it's right.\n- Step 3. Monitor.\n- Step 4. Profile if slow.\n- Step 5. Try Optimize.\n- Step 6. Repeat from 2.\n\n有的人站出来说，**我写程序就是要一步到位，把能优化的点一次性搞定。**\n\n请不要听他的，因为优化是无止境的。唯快不破\n\n**能一次写出优雅清晰而且性能高的代码的人，一般很少见到。毕竟需要考虑的点太多了。**\n\n基于上面的认知，**代码的可维护性是第一位的。**\n\n- 写代码的首先应该是代码很清晰，非常容易维护。\n- 然后在没有过分降低可维护性的情况下，作出性能的优化。\n\n## 0x01 Python 优化的五件武器\n\n钟声响起归家的讯号，刚回到家。\n\n公司群响起加班的讯号，用户反应服务响应总是超时。\n\n你打开电脑，隐隐约约觉得是某个函数的问题。这个函数的功能比较多，调试了很久才调试通。\n\n浏览代码。大致定位了这个问题可能会在下面的几个函数中。\n\n```text\ndef red_packet_calculation_algorithm():\n\tpass\n\ndef user_stats_calculation_algorithm():\n\tpass\n\ndef dashboard_calculation_algorithm():\n\tpass\n```\n\n**如何确定是哪个函数需要优化呢？**\n\n很简单，到 IPython 里面执行一下就就知道了。感觉慢的就是目标函数。\n\n**总觉得执行一下这个操作有点不稳定。如果有个工具，可以直接执行很多次，然后作出统计就好了。**\n\n这就是 Python 代码优化第一件武器 timeit\n\n### 第一件武器 timeit\n\n通常某段代码有问题，最直接的方法就是跑一下这段代码。\n\n在 IPython 里执行\n\n```text\n# ipython\n%time your-algorithm\n```\n\ntimeit 将代码执行多次，取均值\n\n一般这个时候，你就可以初步定位问题所在了。\n\n> **比如，发现 user_stats_calculation_algorithm 在 一个 for 循环里面走了数据库查询。**\n\n也有一些函数并不是那么容易定位。\n\n即，通过这个 timeit 知道了某个函数执行比较慢，但那个函数 里面还有很多函数，通过肉眼观察，还是没有办法来解决呀。\n\n这个时候你想了，如果能看到哪些语句执行的次数多一些，耗时长一些，就好了。\n\n这就是 Python 代码优化第二件武器 profile 。\n\n### 第二件武器 profile 与 cprofile\n\n在 ipython 中运行\n\n![](https://pic4.zhimg.com/v2-e71500556d16329b6c785611297364ab_b.jpg)\n\n这么一看，耗时操作一览无遗。\n\n语句级别的 Profile 有了，但其实，很多时候也并不能解决你的问题。\n\n**如果能有这么个东西，即，能在代码旁边注释一下，执行次数和耗时就好了。**\n\n这就是 Python 代码优化第三件武器 line profile。\n\n### 第三件武器 line profiler\n\n能在代码旁边注释，执行次数和耗时。如下\n\n```bash\nPystone(1.1) time for 50000 passes = 2.48\nThis machine benchmarks at 20161.3 pystones/second\nWrote profile results to pystone.py.lprof\nTimer unit: 1e-06 s\n\nFile: pystone.py\nFunction: Proc2 at line 149\nTotal time: 0.606656 s\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents\n==============================================================\n   149                                           @profile\n   150                                           def Proc2(IntParIO):\n   151     50000        82003      1.6     13.5      IntLoc = IntParIO + 10\n   152     50000        63162      1.3     10.4      while 1:\n   153     50000        69065      1.4     11.4          if Char1Glob == 'A':\n   154     50000        66354      1.3     10.9              IntLoc = IntLoc - 1\n   155     50000        67263      1.3     11.1              IntParIO = IntLoc - IntGlob\n   156     50000        65494      1.3     10.8              EnumLoc = Ident1\n   157     50000        68001      1.4     11.2          if EnumLoc == Ident1:\n   158     50000        63739      1.3     10.5              break\n   159     50000        61575      1.2     10.1      return IntParIO\n```\n\n这个可谓是 Python 世界里时间性能优化的顶级工具了。\n\n### 第四件武器 memory profiler\n\n**说完了时间上的优化，再说说空间上的优化。**\n\n如何检查内存呢？\n\n这需要 Python 代码优化第四件武器 memory profiler。\n\n这个工具用于查看 Python 程序的内存占用情况\n\n但，知道了执行某些代码之后，内存是多少又能如何呢？\n\n不见得能定位出来是什么东西\n\n内存中这么多 objects 我上哪看去？\n\n**假设内存泄漏了，我再怎么 profile, 内存都是一直泄漏的呀。**\n\n总要想办法定位出是哪些类型的有问题。\n\n### 第五件武器 pympler\n\n这需要 Python 代码优化第五件武器 pympler。这是我从雨痕的《 Python 学习笔记 》里看到的\n\n**这个工具特别适合给当前所有的 objects 的内存占用情况做简单统计。**\n\n之前的一次线上代码出内存泄漏，检查了自己的代码确定没有问题之后，将目光放在了第三\n方库上。\n\n但第三方库也有不少，检查半天依旧没有什么进展。\n\n```text\nfrom pympler import tracker\n\n# 在多处打点，并且将结果打到日志里。\nmemory_tracker = tracker.SummaryTracker()\n```\n\n每次打印出来的结果大致是这样子的。\n\n```text\ntypes |   # objects |   total size\n================== | =========== | ============\n              dict |           1 |     280    B\n              list |           1 |     176    B\n  _sre.SRE_Pattern |           1 |      88    B\n             tuple |           1 |      80    B\n               str |           0 |       7    B\n```\n\n刚开始都还挺正常，**运行了一段时间之后，日志中的部分涉及到 flask-sqlalchemy**\n**的 objects 和 total size 保持了坚挺的增长。**\n\n最后发现 flask-sqlalchemy 如果 设置了 SQLALCHEMY_RECORD_QUERIES 为 True 的话，\n\n每次查询都会往 current_app.sqlalchemy_queries 里增加 DebugQueryTuple, 很快就内存泄漏了。\n\n```text\nqueries = _app_ctx_stack.top.sqlalchemy_queries\nqueries.append(_DebugQueryTuple((\n\t\tstatement, parameters, context._query_start_time, _timer(),\n\t\t_calling_context(self.app_package)\n)))\n```\n\n### 其他神器\n\n可视化调用\n\n当然，也有一些比较方便的工具是用来查看函数的调用信息的\n\n效果大概是这样子\n\n![](https://pic1.zhimg.com/v2-58d927fe1a204ec13df79ef255749830_b.jpg)\n\n当然，也有其他的工具\n\n[https://stackoverflow.com/questions/582336/how-can-you-profile-a-python-script](https://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/582336/how-can-you-profile-a-python-script)\n\n## 0x02 优化 Web 项目\n\n### 提前优化\n\n在使用 Django 项目的时候，我必须要安装的第三方库就是 djangodebugtools\n\n这个工具用起来有多舒服呢？\n\n可以直接 Profile SQL 语句\n\n![](https://pic2.zhimg.com/v2-84e70f363b220d0560191d53338e6961_b.jpg)\n\n甚至可以直接 explain sql 以及 查看缓存情况\n\n![](https://pic3.zhimg.com/v2-fbfd51e4936fe23a158f41840cd22f36_b.jpg)\n\n![](https://pic1.zhimg.com/v2-6dc91c81ed6a76c02493b152e4ae8a3c_b.jpg)\n\n### 做好监控\n\n如何监控，监控什么指标？这属于日志的范畴了。\n\n日志的道术器分别是什么，这将在下一篇文章来具体介绍一下如何打日志。\n\n## 0x03 性能优化建议\n\n笔者列了一些大方向上的优化建议，具体是要靠积累。\n\n### 建议 1. 务必了解 Python 里面的负优化常识\n\n1.  不要在 for loop 里面不断的链接 string, 用列表 +JOIN 的方式会更加合适。\n\n### 建议 2. 能用内置的模块就不要手动实现\n\n1.  比如，当你想做一些字符串上的变动的时候，不防先查看一下 string / textwrap / re / difflib 里是不是满足你的要求了\n2.  比如你操作一组比较类似的数据类型，可以考虑看下 enum / collection / itertools / array\n    / heapq 里面是不是已经满足你的要求了。\n\n笔者在 [https://zhuanlan.zhihu.com/p/32504320](https://zhuanlan.zhihu.com/p/32504320) 中曾经遇到过统计的问题。\n\n当时遇到的问题场景是\n\n有 400 组 UUID 集合，每个列表数量在 1000000 左右，列表和列表之间重复部分并不是很大。我想拿到去重之后的所有 UUID，应该怎么处理\n\n```text\n# 版本一，运行遥遥无期\nlist_of_uuid_set = [ set1 , set2 ... set400 ]\nall_uuid_set = reduce(lambda x: x | y, list_of_uuid_set)\n\n# 版本二，运行遥遥无期\n\ndef merge(list1,list2):\n    list1.append(list2)\n    return list1\n\nlist_of_uuid_list = [ list1 , list2 ... list400 ]\nall_uuid_set = set(reduce(merge, list_of_uuid_list))\n\n# 版本三，5s\n\nlist_of_uuid_list = [ list1 , list2 ... list400 ]\nall_uuid_set = set(list(itertools.chain(*list_of_uuid_list)))\n```\n\n合适的数据结构和合适的算法，确实能让代码变得清晰，高效，优雅。\n\n### 建议 3. 能用优质的第三方库就不要手动实现\n\n除了一些内置的模块，\n\n- 一些优秀的软件所依赖的第三方包也是非常值得留意的。\n- 一般能上 C 库的，用于解析的依赖包性能不错，比如 LXML/Numpy 这类包\n\n## 0xDD 结论\n\n> **本文讲的是，当你觉得某个地方运行比较慢了，此时此刻的你，有哪些小技巧可以快速的帮** > **你定位性能问题。**\n\n其实还有很多悬而未决的问题：\n\n1.  定位了问题，如何解决问题？\n2.  如何觉察到某个地方运行比较慢呢？\n\n对于第一点，还是得多看多搜多练。用《亮剑》中的李云龙的话说：\n\n> **真正的神枪手是战场上用子弹喂出来的。打得多了，感觉就有了，眼到手就到，抬枪就有，弹弹咬肉，这就叫神枪手。**\n\n对于第二点，就是下一篇文章需要解决的问题了。\n\n1.  通过日志来判断。\n2.  通过打点和结合 APMServer 来判断。\n\n## 0xEE 参考链接\n\n- [https://zhuanlan.zhihu.com/p/32504320](https://zhuanlan.zhihu.com/p/32504320)\n- [https://pynash.org/2013/03/06/timing-and-profiling/](https://link.zhihu.com/?target=https%3A//pynash.org/2013/03/06/timing-and-profiling/)\n- [https://wiki.python.org/moin/PythonSpeed/PerformanceTips](https://link.zhihu.com/?target=https%3A//wiki.python.org/moin/PythonSpeed/PerformanceTips)\n- Photo by[Tim van der Kuip](https://link.zhihu.com/?target=https%3A//unsplash.com/photos/CPs2X8JYmS8%3Futm_source%3Dunsplash%26utm_medium%3Dreferral%26utm_content%3DcreditCopyText)on[Unsplash](https://link.zhihu.com/?target=https%3A//unsplash.com/t/business-work%3Futm_source%3Dunsplash%26utm_medium%3Dreferral%26utm_content%3DcreditCopyText)\n"}],"total":7}},"__N_SSG":true}