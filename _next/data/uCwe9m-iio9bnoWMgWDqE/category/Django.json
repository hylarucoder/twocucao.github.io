{"pageProps":{"category":{"name":"Django","posts":[{"tags":["Django"],"path":"20180516_PyConDjango.md","title":"PyCon 2018 之 Django 专题","slug":"PyCon 2018 之 Django 专题","date":"2018-05-16","category":"Django","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\nPyCon 2018 有很多精彩的演讲，今天的文章里，挑出 Django 的几篇演讲大致讲讲。\n\n> 注意：为什么是大致讲讲呢？因为即便是你看了我的这篇文章，依然需要多下点功夫自己去看演讲，自己去查资料，自己去消化。我的这篇文章只不过是我看演讲查资料慢慢消化过程中的产物而已。\n\n## 0x01 演讲 1 - Taking Django Async\n\n本演讲其实就是为了推广 Django 的新库。django-channels\n\n这个库从 2015 年首发，现在已经经过了三年的进程。应该算是相对成熟了。\n\n这个库有什么不走寻常路的地方吗？答案是有的：\n\n1. 使得 Django 增加了异步协议，比如说 WebSocket 协议\n2. 使得 Django 可运行后台任务。\n\n作为 v2 版本的核心开发，作者必然是要吐槽一下 v1 版本，然后推荐一下 v2 版本。\n\nv1 版本的架构设计是这样的。\n\n核心开发给出了这样的评价：\n\n1. 在 Python2.7 的时候，就只能这么搞了。\n2. 需要维护的东西太多\n3. 没有 asyncio support\n4. 搬砖时候一不小心容易砸到脚\n\n> TODO : 补充一些其他的缺点\n\n异步与同步接口耦合\n\n作者认为此并非长久之计。\n\nv2 时候，\n\n重写 75% 的代码\n\n异步与同步接口分离\n\n这么设计的话，需要解决接下来的一个问题，同步转异步，异步转同步。\n\n比如，我访问 view, 实际上是 async 转 sync, 然后才能调用 django 相关的方法，接着返回响应内容的时候，我还需要 sync 转 async.\n再比如，我使用 websocket, 访问一条数据，但 ORM 是 sync 的方法，我还是要 async 转 sync 再转 async\n\n这个 async 和 sync 的相互转换应该怎么做呢？\n\n于是，两个适配方法就诞生了：\n\n- sync_to_async : 接收一个 async 的 function, 使之 awaitable, 然后使之在后台线程里运行。\n- async_to_sync : 接收一个 awaitable 的 coroutine , 使之转化成一个同步的 function, 该 function 暂停你调用的当前的线程，跳转到包含 eventloop 的主线程执行完毕，然后跳转回来。\n\nhttps://www.aeracode.org/2018/02/19/python-async-simplified/\n\n### WSGI 如何运行 async\n\n### ASGI 如何运行 A\n\n### 这对 Django 意味着什么？\n\n### 如何保持兼容性\n\n## 0x02 演讲 2 - Beyond Django Basic\n\n作为一名有一定经验的 Django 开发者，用快进的方式看完了这个演讲。毕竟，我已经不是 Django 新手了。\n\n> 毕竟这篇演讲只是给那些学完 tutorial 的人\n\n想深入了解 Django, 多刷几遍文档比什么都好。\n\n嗯，就不介绍了。\n\n## 0x03 演讲 3 - Introduction to TDD with Django && Intermediate testing with Django\n\n本演讲主要内容是 TDD 测试和 Mock 的技巧。\n\n建议熟手直接看演讲者的书吧，本视频本人仅仅匆匆倍速看了一遍，估计并没有超出他的书的范围。\n\n简单介绍了以下内容\n\n- 单元测试和功能性测试\n- 通过 Selenium browser 进行自动化测试\n- unittest 标准库\n- Django models, views and templates\n- 测试前后端代码\n- 基于测试的重构\n- TDD workflow\n\n地址如下\n\nhttps://www.obeythetestinggoat.com/book/praise.harry.html\n\n说说个人对测试和 TDD 测试的基本态度，我觉得测试是好事，适当的测试是可以提升代码质量和程序稳定性的。\n\n说测试会降低开发速度的，八成是没有善用测试。如果测试拖慢了你的开发速度，只能说明没有进行合适的测试，比如对一些无关紧要的功能进行测试。\n\n但，这篇演讲和配套资料很好，不过有些美中不足。 这里基本上都还在用 Django 的 MTV 这一套。\n\n> 我反正是不用这一套了。这个年头流行 SPA 呀。\n\n所以，我们这篇演讲指的关注的内容就变成如下内容了。\n\n- 单元测试和功能性测试\n- unittest 标准库\n- Django models\n- 基于测试的重构\n- TDD workflow\n\n而且，对于 API 的测试，现在基本上流行 POSTMAN\n\n用 POSTMAN 的优点就在于可以把参数缓存下来下次接着用。有个小技巧就是从 chrome 拷贝一下 curl 到 postman 中。非常好用。\n\n既然流行 SPA, 那么本次有没有介绍开 API 的利器呢？\n\n## 0x04 演讲 4 - API-Driven Django\n\n嗯，Django + django-rest-framework 实在是开 WebAPI 的神器。\n\n这篇演讲，算是普及了一下常识。并没有想象当中的深入。\n\n想用 Django 和 DjangoRestFramework 搞事情的，可以过来看我这篇文章。\n\nhttps://zhuanlan.zhihu.com/p/33903527\n\n> 需要注意的是，本次 PyCon 中有很多人已经用上了 pipenv 了。\n\n## 0x05 演讲 5 - pipenv 未来的 Python 包管理工具\n\nKenneth Reitz 出品，必属精品。\n\n### Python 打包历史\n\n刚开始，我们是这样安装包的。\n\n```\ncurl http://pypi.python.org/packages/alsdasdl/requests.tar.gz | tar zxf\ncd requests/\npython setup.py install\n```\n\n这个问题初看起来不是问题，但是随着你安装程序的增多就知道有多么痛苦了。\n\n1. 有的依赖库依赖别的库你怎么解决？比如 pandas 需要安装 numpy\n2. 有的依赖库依赖 c 库怎么办？比如 LXML\n3. 在 python2.6.5 下，如果我需要安装两个不同版本的 Django 开发不同的软件怎么办？难道只能动态复制文件到 site-packages 里面？\n\n后来，我们是这样安装包的。\n\n```\neasy_install requests\n```\n\n我们可以直接从 pypi 进行安装了。但尼玛，为什么 easy_install 安装很 easy, 但是没有 easy_uninstall?\n\n好，2010 年后，我们继续前进：\n\n- 可以通过 pip 替代 easy_install 了。\n- 可以通过 virtualenv 管理项目的依赖库了。虽然说，还是不能像 ruby gem 一样同时把多个版本的的软件装在同一个系统里。\n- 可以通过 requirements 锁依赖了。\n\n但，其他编程语言社区分别出现了如下的包管理工具：\n\n- node -> yarn && npm , 有 lockfile\n- php -> composer , 有 lockfile\n- rust -> cargo , 有 lockfile\n- ruby -> bundler , 有 lockfile\n\n而生命苦短一方居然\n\n- python -> pip && virtualenv/venv , 无 lockfile\n\n> PS: Python3.3 之后，默认可以直接使用 venv 模块，不需要再安装 virtualenv 了。但还是需要手动，并且用起来比较反直觉。\n\n关于 requirements.txt\n\n- 如果你使用 pip freeze 来形成这个文件，则不直观，完全看不出来哪个依赖库依赖哪个依赖。\n- 如果你直接手动指定你所需要的库，比如 flask 的话，似乎又有些太直观了。\n\n如果能有一个东西，既可以表示 freeze 的结果 (what you want)，又可以表示你需要的库 (what you need). 就好了。\n\n> 这当然可以考虑用两份 requirements 来解决。先安装 what you need 用来开发，然后 freeze 为 what you want 去部署。\n\n当然，铺垫了这么多 K 神肯定是来介绍他的 pipenv 的。\n\n比如说，我想查看，本项目的依赖库，直接 pipenv graph\n\n```\ncoverage==4.5.1\nfabric==2.0.1\n  - cryptography [required: >=1.1, installed: 2.2.2]\n    - asn1crypto [required: >=0.21.0, installed: 0.24.0]\n    - cffi [required: >=1.7, installed: 1.11.5]\n      - pycparser [required: Any, installed: 2.18]\n    - idna [required: >=2.1, installed: 2.6]\n    - six [required: >=1.4.1, installed: 1.11.0]\n  - invoke [required: <2.0,>=1.0, installed: 1.0.0]\n  - paramiko [required: >=2.4, installed: 2.4.1]\n    - bcrypt [required: >=3.1.3, installed: 3.1.4]\n      - cffi [required: >=1.1, installed: 1.11.5]\n        - pycparser [required: Any, installed: 2.18]\n      - six [required: >=1.4.1, installed: 1.11.0]\n    - cryptography [required: >=1.5, installed: 2.2.2]\n      - asn1crypto [required: >=0.21.0, installed: 0.24.0]\n      - cffi [required: >=1.7, installed: 1.11.5]\n        - pycparser [required: Any, installed: 2.18]\n      - idna [required: >=2.1, installed: 2.6]\n      - six [required: >=1.4.1, installed: 1.11.0]\n    - pyasn1 [required: >=0.1.7, installed: 0.4.2]\n    - pynacl [required: >=1.0.1, installed: 1.2.1]\n      - cffi [required: >=1.4.1, installed: 1.11.5]\n        - pycparser [required: Any, installed: 2.18]\n      - six [required: Any, installed: 1.11.0]\nflake8==3.5.0\n  - mccabe [required: >=0.6.0,<0.7.0, installed: 0.6.1]\n  - pycodestyle [required: <2.4.0,>=2.0.0, installed: 2.3.1]\n  - pyflakes [required: >=1.5.0,<1.7.0, installed: 1.6.0]\n# 其他省略\n```\n\n如何尝鲜？我最近更新到了之前写的一个库（代码写的惨不忍赌，最近准备重构）\n\n```\ngit clone git@github.com:twocucao/YaPyLib.git\ncd YaPyLib/\nbrew install pipenv\npipenv --three\npipenv install --dev\npipenv shell\n```\n\n至于其他的功能，参考官网自己摸索吧。\n\n> 在用 npm 和 yarn 的时候，我有这么一个想法，希望 python 圈子里面能出一个类似于包管理工具。今年 2 月份的时候把自己的项目迁移过来，发现 pipenv 用起来很挺舒服的。\n\n> pipenv 是未来。火速用上吧。\n\n## 0xEE 参考链接\n\n---\n\nChangeLog:\n\n- **2018-03-09** 重修文字\n"},{"tags":["Django","ORM"],"path":"20180428_DjangoORMCheatSheet.md","title":"DjangoORM CheatSheet","slug":"DjangoORM CheatSheet","date":"2018-04-28","category":"Django","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n本文是《Python ORM 三部曲的第二部 - Django ORM 的用法 / 原理 / 优化》\n\n上一部的地址为《Python ORM 三部曲的第一部 - Python ORM 的三种实现模式》\n\n本文基于最新 Django 版本\n\n1. 模型定义\n2. Create/Update/Delete\n3. 各种查询 / 链式调用 / F 表达式 / Window 函数 /Lazy Loading / Eager Loading\n4. Join\n5. DEBUG 和 Profile 技巧\n\n本文是《Python ORM 三部曲的第一部 - Python 的三种数据源架构模式》\n\n本文适用于：\n\n1. 好奇 or 喜欢折腾的程序员\n2. 想深入了解 ORM 的程序员\n\n本文将解决你以下的疑惑：\n\n1. 能不能不用 ORM?\n2. ORM 为什么在某些场景下会胜于写 SQL\n3. 不同的 ORM 实现机制会带来什么差异？\n\n## 0x00 前言\n\n新工作的技术栈是以 Flask 为主，SQLAlchemy 是 许多玩 Flask 的人的标配。好，文档读起来，笔记搞起来。\n\n> 所以，本文记录的是 Django ORM\n\n逃。\n\n这篇文章也是我对比 SqlAlchemy 以及 DjangoORM 的产物\n\n## 0x01 如何快速上手\n\nDjango 世界里面，Django 的文档每次刷都会有新的发现。\n\n## 0x02 DjangoORM 的基本功能\n\n### 2.1 模型定义 Model\n\n```\nfrom django.db import models\n\nclass Musician(models.Model):\n    first_name = models.CharField(max_length=50) # Field\n    last_name = models.CharField(max_length=50)\n    instrument = models.CharField(max_length=100)\n\nclass Album(models.Model):\n    artist = models.ForeignKey(Musician, on_delete=models.CASCADE)\n    name = models.CharField(max_length=100)\n    release_date = models.DateField()\n    num_stars = models.IntegerField()\n\n    class Meta: # Model Meta\n        order_with_respect_to = 'question'\n```\n\n可以看出，包含如下的部分：\n\n1. Model 与 Model 内部的 Meta\n2. Field 与 Field 内部的 Options\n3. Model 与 Model 之间的关系\n4. 其他，比如索引\n\n#### Models 与 Meta\n\n> DjangoORM 是 ActivityRecord 模式的一种实现，在该模式下，Model 与 session 耦合。\n\n#### Field 与 Field Options\n\n##### Field\n\n- AutoField\n- BigAutoField\n- BigIntegerField\n- BinaryField\n- BooleanField\n- CharField\n- DateField\n- DateTimeField\n- DecimalField\n- DurationField\n- EmailField\n- FileField\n- FileField and FieldFile\n- FilePathField\n- FloatField\n- ImageField\n- IntegerField\n- GenericIPAddressField\n- NullBooleanField\n- PositiveIntegerField\n- PositiveSmallIntegerField\n- SlugField\n- SmallIntegerField\n- TextField\n- TimeField\n- URLField\n- UUIDField\n\n虽然有这么多东东，其实常用的如下\n\n- BigIntegerField\n- BooleanField\n- CharField\n- DateField\n- DateTimeField\n- DecimalField\n- IntegerField\n- TextField\n- TimeField\n\n有的字段属于那种，有也可以，没有也可以的。\n\nFileField 之类的 往往现在都被 CDN 取代\n\n##### Field Options\n\n- null\n- blank\n- choices\n  - p.shirt_size\n  - p.get_shirt_size_display()\n- db_column\n- db_index\n- db_tablespace\n- default\n- editable\n- error_messages\n- help_text\n- primary_key\n- unique\n- unique_for_date\n- unique_for_month\n- unique_for_year\n- verbose_name\n- validators\n\n如此可见，Django 的 ORM 比起 SQLAlchemy 做了不少应用层的校验，一些 help_text\n\n#### Relationship\n\n表和表之间的关系\n\n1. A 表和 B 表 一对多 / 多对一\n2. A 表和 B 表 一对一 （特殊的一对多）\n3. A 表和 B 表 简单多对多 （借助中间的 Mapping 表进行映射）\n4. A 表和 B 表 复杂多对多\n5. A 表和 B 表 一对多\n\n```\nfrom django.db import models\n\nclass Manufacturer(models.Model):\n    # ...\n    pass\n\nclass Car(models.Model):\n    manufacturer = models.ForeignKey(Manufacturer, on_delete=models.CASCADE)\n    # ...\n```\n\n```\nfrom django.db import models\n\nclass Topping(models.Model):\n    # ...\n    pass\n\nclass Pizza(models.Model):\n    # ...\n    toppings = models.ManyToManyField(Topping)\n```\n\n```\nfrom django.db import models\n\nclass Person(models.Model):\n    name = models.CharField(max_length=128)\n\n    def __str__(self):\n        return self.name\n\nclass Group(models.Model):\n    name = models.CharField(max_length=128)\n    members = models.ManyToManyField(Person, through='Membership')\n\n    def __str__(self):\n        return self.name\n\nclass Membership(models.Model):\n    person = models.ForeignKey(Person, on_delete=models.CASCADE)\n    group = models.ForeignKey(Group, on_delete=models.CASCADE)\n    date_joined = models.DateField()\n    invite_reason = models.CharField(max_length=64)\n```\n\n```\nModels across files\n```\n\n```\nobjects\n```\n\n```\nModels 重写方法\n```\n\n```\nModels 继承\nhttps://docs.djangoproject.com/en/2.0/topics/db/models/#model-inheritance\n```\n\n```\n组织代码 - 以及应对循环引用\n```\n\n### 2.2 QuerySet\n\n#### Create\n\n```\nc = Child(name=\"苏轼\")\nc.save()\np = Parent(name=\"苏辙\")\np.best_child = c\np.children.add([c,c2,c3,c4])\np.save()\n```\n\n#### Retrieve\n\n过滤\n\nfilter(**kwargs)\nexclude(**kwargs)\n.all()\n\n##### 跨关系（跨表）查询\n\nBlog.objects.filter(entry**headline**contains='Lennon')\n\nhttps://docs.djangoproject.com/en/2.0/topics/db/queries/#lookups-that-span-relationships\n\nhttps://docs.djangoproject.com/en/2.0/topics/db/queries/#spanning-multi-valued-relationships\n\n##### prefetch_related && select_related\n\n```\nselect_related\n\n生成 join 的 SQL, 可以用来减少 N+1 , 不过仅仅支持一对多，和一对一\n\nprefetch_related\n```\n\n##### Limit / Offset / 分页\n\nBlog.objects.filter(entry**headline**contains='Lennon')[30:20]\n\n##### 链式调用\n\nquery = query.filter(**kwargs)\nquery = query.exclude(**kwargs)\n\n##### 表达式\n\nDjango 里面最强大的就是其 Q 表达式了\n\nQ(question**startswith='Who') | Q(question**startswith='What')\n\nPoll.objects.get(\nQ(question\\_\\_startswith='Who'),\nQ(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6))\n)\n\n这个表达式甚至可以嵌套超级深从而完成一个比较深的跨表查询。\n\n> 并且，这种 API 查询反而在写前端 API 的时候，可以传入 question\\_\\_startswith 这类参数，从而直接完成一组搜索。\n\nQ / F\n\n##### 执行查询\n\n需要注意的的是，SQLAlchemy 必须显式执行查询，而 Django 不一定。\n\nhttps://docs.djangoproject.com/en/2.0/ref/models/querysets/#when-querysets-are-evaluated\n\n在 Django 内部实现的时候，一个 queryset 创建 / 过滤 / 切片 / 传送，**除非这个 queryset 被 evaluated 了**, 否则不会做数据库的操作。\n\n- iteration\n- Slicing\n- Pickling/Caching\n- repr\n- len\n- list\n- bool\n\n```\nall()\nfirst()\nlast()\nexist()\n```\n\n##### 比较\n\n- pk\n- model\n\n##### 复制 实例\n\n```\nblog = Blog(name='My blog', tagline='Blogging is easy')\nblog.save() # blog.pk == 1\n\nblog.pk = None\nblog.save() # blog.pk == 2\n\n# 但这个并不拷贝外键？???\nhttps://docs.djangoproject.com/en/2.0/topics/db/queries/#copying-model-instances\n```\n\n##### 其他\n\n```\n# 默认查询的是所有字段，但我希望查询部分字段\n# TODO: 阿萨德\n# Distinct\n# OrderBy\n\n```\n\n##### 缓存机制\n\nhttps://docs.djangoproject.com/en/2.0/topics/db/queries/#caching-and-querysets\n\n#### Update\n\n单个 object 更新\n\n```\nblog.title = \"大宝天天见\"\nblog.save()\n```\n\n批量更新\n\n```\nquery.update(headline=F('blog__name'))\n```\n\n一对多的更新（类似于 Set 操作）\n\n```\nadd(obj1, obj2, ...)\ncreate(**kwargs)\nremove(obj1, obj2, ...)\nclear()\nset(objs)\n```\n\n#### Delete\n\n##### ForeignKey\n\n```\nclass Car(models.Model):\n    manufacturer = models.ForeignKey(\n        'production.Manufacturer', # 用来解决循环 circular import\n        on_delete=models.CASCADE,\n    )\n```\n\non_delete 的情况\n\n- PROTECT 阻止\n- CASCADE 应用层的级联删除\n- SET_NULL 应用层的级联 SET_NULL\n- SET_DEFAULT\n- DO_NOTHING\n- SET() 一个 callback\n\n#### 聚集查询\n\nhttps://docs.djangoproject.com/en/2.0/topics/db/aggregation/\n\n```\nBook.objects.all().aggregate(Max('price'))\nBook.objects.aggregate(price_diff=Max('price', output_field=FloatField()) - Avg('price'))\nBook.objects.annotate(num_authors=Count('authors'))\nBook.objects.annotate(num_authors=Count('authors')).aggregate(Avg('num_authors')) # {'num_authors__avg': 1.66}\n```\n\n#### Search\n\nhttps://docs.djangoproject.com/en/2.0/topics/db/search/\n\n#### Window Function\n\n```\nOption.objects.annotate(\n\t\trank_num=Window(\n\t\t\t\texpression=Rank(),\n\t\t\t\tpartition_by=F(\"vote_id\"),\n\t\t\t\torder_by=[F(\"current_vote_count\").desc(), F(\"id\").desc()],\n\t\t),\n\t\tlag_vote_num=Window(\n\t\t\t\texpression=Lag(\"current_vote_count\"),\n\t\t\t\tpartition_by=F(\"vote_id\"),\n\t\t\t\torder_by=[F(\"current_vote_count\").desc(), F(\"id\").desc()],\n\t\t),\n)\n.filter(vote=obj.vote)\n.order_by(\"-current_vote_count\", \"id\")\n.values(\"id\", \"rank_num\", \"current_vote_count\", \"lag_vote_num\")\n```\n\n### 2.2 Model Instances\n\nhttps://docs.djangoproject.com/en/2.0/ref/models/instances/\n\n### 2.3 模型实例\n\n### 2.4 迁移机制\n\n1. 加 INSTALLED_APPS\n\n## 0x03 Django ORM 的高级功能\n\n### maneger\n\nhttps://docs.djangoproject.com/en/2.0/topics/db/managers/\n\n### raw sql\n\nhttps://docs.djangoproject.com/en/2.0/topics/db/sql/\n\n#### database-fuction\n\nhttps://docs.djangoproject.com/en/2.0/ref/models/database-functions/\n\n## 0x04 Database Access Optimization\n\n### 4.1 使用连接池\n\n连接池是一种永远在线模型的实现\n\n连接池：驱动程序类型\n\n连接池：代理类型\n\n### 4.2 减少对 MySQL 的访问\n\n```\nselect count(*) from pg_stat_activity where pid <> pg_backend_pid() and usename = current_user;\n\n```\n\n### Before\n\n```\nselect count(*) from pg_stat_activity where pid <> pg_backend_pid() and usename = current_user;\n\n```\n\n### Profile First\n\n1. django-extentions\n2. django-debug-toolbar\n\n手动\n\n```\nqueryset.explain\n\nfrom django.db import connection\nconnection.queries\n\nfrom django.db import reset_queries\nreset_queries()\n```\n\n## 0x05 Django ORM Under The Hood\n\n### 理解 QuerySet\n\n- querysets-are-lazy when-querysets-are-evaluated\n  - Iteration\n  - Slicing\n  - Pickling/Caching\n  - len\n  - repr\n  - list\n  - bool\n\n```\nobj == nobj # obj.id == nobj.id\n```\n\n- caching-and-querysets\n\n### 理解 cached attributes\n\n```\n>>> entry = Entry.objects.get(id=1)\n>>> entry.blog   # Blog object is retrieved at this point\n>>> entry.blog   # cached version, no DB access\n\n>>> entry = Entry.objects.get(id=1)\n>>> entry.authors.all()   # query performed\n>>> entry.authors.all()   # query performed again\n```\n\n## 0xEE 参考链接\n\n---\n\nChangeLog:\n\n- **2018-03-09** 重修文字\n"},{"tags":["Python","Django","YaDjangoBlog"],"path":"20180224_YaDjangoBlog之前端VueJS篇.md","title":"YaDjangoBlog 之 前端 VueJS 篇","slug":"YaDjangoBlog 之 前端 VueJS 篇","date":"2018-02-25","category":"Django","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n本文是 Django 全栈开发教程的第四篇\n\n目录在这里，已经更新的文章如下\n\n- Django 全栈开发教程 - 2018 年不容错过的 Django 全栈项目 -- 目录篇\n- Django 全栈开发教程 - YaDjangoBlog 的开发环境配置\n\n本文需要完成三件事情：\n\n- 第一件事情，介绍为什么选择 VueJS？\n- 第二件事情，介绍 Vue 项目的一些注意点。\n- 第三件事情，蜻蜓点水搬的带大家过一编，YaDjangoBlog 前端的项目结构，静态资源管理，路由以及组件。\n\n## 0x01 为什么是 VueJS\n\n国产框架 + 语法简洁是我入坑 VueJS 初衷。\n\n后来却是 Vue 的丰富的生态和简洁的语法吸引了继续用下去。\n\n这里要感谢为 VueJS 持续贡献代码的人，从 Vue 本身，到 VueCLI, 到 Router, 到 VueX, 如果没有那么多人为之贡献代码，可能今天这一小节就变成了，『为什么是 React 了』逃。\n\nVue 自称为 Vue 渐进式 JavaScript 框架。\n\n什么是渐进式？\n\n就是你可以逐步按照 Vue 的方式逐渐引入一些 Vue 的组件到项目中。没有必要上来就是 Vue 全家桶，依据场景逐步引入。\n\n参考链接 https://www.zhihu.com/question/51907207\n\n然而，依据我的经验，vue 全家桶用起来还是很舒服的。这里必须要感谢 Vue 社区。\n\n模板语法，数据驱动，双向绑定。写起代码来简直就是一个字，爽。\n\n## 0x02 Vue 项目的一些注意点\n\n从项目角度，我们想想前端项目有哪些地方是需要注意的：\n\n1. 开发环境和线上环境区分\n2. 前端资源打包\n\n- Vue 项目资源打包\n- DLL 打包\n- 字体文件打包\n\n3. CSS/JS 如何管理\n4. 有哪些必要的依赖，如何引入第三方库\n5. 有哪些页面级组件，有哪些小组件？应该安排这些组件？组件与组件应该怎么通讯？\n6. 路由怎么管理\n7. 状态怎么管理\n8. 登录，鉴权怎么做\n\n限于篇幅，我就不一一讲解了。挑在 YaDjangoBlog 中使用到的技术简单介绍一下。\n\n再次感谢 Vue 社区出品的 VueCLI 以及 Webpack 模板。\n\n下面依次介绍：\n\n1. 项目结构\n2. 静态资源管理\n3. 路由\n4. 组件\n\n## 0x03 项目结构\n\n首先，YaDjangoBlog 文件的前端目录如下：\n\n```bash\n.\n├── README.md\n├── build\n│   ├── build.js\n│   ├── build_iconfont.js # 构建 iconfont 脚本\n│   ├── check-versions.js\n│   ├── logo.png\n│   ├── utils.js\n│   ├── vue-loader.conf.js\n│   ├── webpack.base.conf.js\n│   ├── webpack.dev.conf.js # 增加了 AutoDllPlugin 用于自动打包 DLL\n│   └── webpack.prod.conf.js\n├── config\n│   ├── dev.env.js # 可以在这里添加开发环境的环境变脸\n│   ├── index.js\n│   ├── prod.env.js\n│   └── test.env.js\n├── extra\n│   └── svg-icon # 这里存放需要生成 iconfont 的字体文件。\n├── index.html\n├── package.json # 这里添加了一些构建脚本\n├── packages\n│   └── theme-future # 注意，这里是另一个子项目，使用 Gulp 构建的纯 CSS 子项目。\n├── src\n│   ├── App.vue\n│   ├── api # 对 axios 进行初步封装\n│   ├── assets # 从使用 Gulp 生成的 CSS 可以放在这里。\n│   ├── components # 跨页面的组件放在这里\n│   ├── directives # 指令\n│   ├── filters    # 过滤器\n│   ├── main.js    # 初始化 Vue 实例\n│   ├── pages      # 页面\n│   ├── router     # 路由\n│   ├── store      # vuex\n│   └── utils      # 常用工具类\n├── static\n│   ├── hightlight # hightlight 脚本\n│   ├── iconfont   # 本地构建的 iconfont\n│   ├── images\n│   └── js\n├── test           # 没写测试，大家开源项目不要学我.... 逃\n│   ├── e2e\n│   └── unit\n└── yarn.lock\n```\n\n## 0x04 静态资源管理\n\n静态资源管理，主要涉及到 JS/CSS/ 图片 / 字体\n\n首先，由于使用了 VueCli 的模板，所以大可以按照 VueCli 提供的写法来写。\n\n```html\n<template>\n  <div id=\"app\">\n    <header></header>\n    <router-view />\n    <footer></footer>\n  </div>\n</template>\n\n<script>\n  export default {\n    name: \"app\",\n    components: {\n      Header: () => import(\"./pages/commons/Header.vue\"),\n      Footer: () => import(\"./pages/commons/Footer.vue\"),\n    },\n  }\n</script>\n\n<style lang=\"scss\">\n  $primary-color: #37b24d;\n  $dark-color: #2b5732;\n  $body-bg: #f9f9f9;\n  @import \"~spectre.css/src/spectre-icons.scss\";\n  @import \"~spectre.css/src/spectre.scss\";\n  @import \"~spectre.css/src/spectre-exp.scss\";\n  @import \"./assets/theme-future/index.css\";\n  a {\n    &:focus,\n    &:hover,\n    &:active,\n    &.active {\n      text-decoration: none;\n      box-shadow: 0 0 0 0;\n    }\n  }\n  #app {\n  }\n</style>\n```\n\n依据我个人经验，做了一部分的微调：\n\n**第一** 在代码中新建一个主题 CSS, 单独用于处理 SCSS 编译 CSS. 即除了 App.vue, 其他地方的 CSS 直接写在同一个地方。\n\n**第二** 对于字体文件，不引入 IconFont 在线字体，而是使用 SVG 本地编译字体。这样减少对 iconfont cdn 的依赖，可以以后直接迁移这个字体到其他 CDN 上。\n\n**第三** 对于依赖库管理，分为 npm 依赖库和外部 JS 依赖库两种\n\n对于 NPM 依赖库，如果有使用过 ECharts3.0 的 SPA 开发者应该对于万恶的 DLL 非常熟悉了。最早的时候，我们是这样做的：\n\n- 先写一个编译脚本，指定相关依赖包，打包出 dll 和一个 manifest 文件\n- 然后从 index.html 里引入打包好的 dll.\n- 再从 webpack 的配置文件中引入这个文件。\n\n这种恶心的配置随着 autodll-webpack-plugin 的出现从而得到缓解，于是现在的你只需要配置：\n\n```JavaScript\n    new AutoDllPlugin({\n      inject: true, // will inject the DLL bundles to index.html\n      debug: true,\n      filename: '[name]_[hash].js',\n      entry: {\n        vendor: [\n          '@antv/data-set',\n          '@antv/g2',\n          '@antv/g6',\n          'highlight.js',\n          'markdown-it',\n          'markdown-it-abbr',\n          'markdown-it-deflist',\n          'markdown-it-emoji',\n          'markdown-it-footnote',\n          'markdown-it-ins',\n          'markdown-it-katex',\n          'markdown-it-mark',\n          'markdown-it-sub',\n          'markdown-it-sup',\n          'markdown-it-task-lists',\n          'markdown-it-toc-and-anchor',\n          'typed.js',\n          'vue',\n          'vue-router',\n          'vuex'\n        ]\n      },\n      plugins: [new webpack.optimize.UglifyJsPlugin()],\n    })\n```\n\n当然，如果你用了 ECharts, 有的时候会出现莫名其妙的\n\n```\n__DEV__ is not defined\n```\n\n解决方法就是在这上面的插件里面加个插件定义一个 Global 的变量\n\n```\n  new webpack.DefinePlugin({\n    __DEV__: false\n  }),\n```\n\n> PS: 去年的版本由于依赖库的一个路径问题导致 autodll-webpack-plugin 不能在 Windows 上使用，今年可以啦。还不快快用起来？\n\n对于外部的 JS/CSS 依赖库：\n\n1. 直接拷贝到 static 下面，然后从 index.html 引入即可。\n2. 动态创建 script 标签（比如动态引入高德地图）\n\n## 0x04 路由\n\n博客项目，实际上路由比较简单。\n\n```\nexport default new Router({\n  mode: 'history',\n  base: '/',\n  // 注释掉这里是因为和引入的 smooth-scroll 冲突\n  // scrollBehavior (to, from, savedPosition) {\n  //   return { x: 0, y: 0 }\n  // },\n  routes: [\n    {\n      path: '/',\n      name: 'home',\n      component: () => import('../pages/Home.vue')\n    },\n    // 解决手贱带来的问题\n    {\n      path: '/index:suffix*',\n      name: 'index',\n      component: () => import('../pages/Home.vue')\n    },\n    {\n      path: '/blog',\n      name: 'blog',\n      component: () => import('../pages/Blog.vue')\n    },\n    {\n      path: '/blog/post/:title',\n      name: 'post',\n      component: () => import('../pages/Blog/ArticlePost.vue')\n    },\n    {\n      path: '/blog/:category(category/\\\\d+)?/:tags(tags/\\\\d+)?/:page(page/\\\\d+)?',\n      name: 'blogposts',\n      component: () => import('../pages/Blog.vue')\n    },\n    {\n      path: '/archive',\n      name: 'archive',\n      component: () => import('../pages/Archive.vue')\n    },\n    {\n      path: '/gallery',\n      name: 'gallery',\n      component: () => import('../pages/Gallery.vue')\n    },\n    {\n      path: '/works',\n      name: 'works',\n      component: () => import('../pages/Works.vue')\n    },\n    {\n      path: '/about',\n      name: 'about',\n      component: () => import('../pages/About.vue')\n    }\n  ]\n})\n```\n\n除了 import 语法之外，需要注意的就是 '/blog/:category(category/\\\\d+)?/:tags(tags/\\\\d+)?/:page(page/\\\\d+)?' 这个奇怪的表达式。\n\n这个表达式可以用于匹配下面的路由\n\n```bash\n/blog/category/1/tags/2/page/3\n/blog/category/1/page/3\n/blog/tags/3/page/3\n/blog/page/3\n```\n\n匹配完毕之后，就可以拿到 categroy tags page 的值然后提交数据库拿数据咯。\n\n## 0x05 组件\n\n博客里面需要注意的就三个组件\n\n- ArticlePost 组件\n- 分页组件\n- 打字终端组件\n\n第一个，ArticlePost 组件\n\n```html\n<template>\n  <div class=\"p-article-post\">\n    <div class=\"columns\">\n      <div class=\"col-1 hide-xl\"></div>\n      <div class=\"col-2 col-xl-3\">\n        <div class=\"g-sidebar\">\n          <h4>本文目录</h4>\n          <div v-html=\"articleToc\"></div>\n        </div>\n      </div>\n      <div class=\"col-6 col-xl-8\">\n        <ArticleCard\n          :article=\"article\"\n          @articleTocReady=\"initArticleToc\"\n        ></ArticleCard>\n      </div>\n      <div class=\"col-2 col-xl-3\">\n        <div class=\"g-sidebar\">\n          <h4>公告</h4>\n          <div>\n            <p>MG 的编程小屋，其实就是我整理笔记，写写文章的地方。</p>\n            <p>\n              专注 Python / JavaScript , 爱折腾的全干工程师 (Full Stuff\n              Engineer)\n            </p>\n            <p>如果我的文章给您的日常开发带来很大帮助的话</p>\n            <p>您可以关注我的公众号</p>\n            <div>\n              <img\n                src=\"/static/images/mp_wechat.jpg\"\n                alt=\"\"\n                style=\"width: 200px\"\n              />\n            </div>\n            <p>也可以扫描二维码进行投喂</p>\n            <div>\n              <img\n                src=\"/static/images/tips_wechat.jpeg\"\n                alt=\"\"\n                style=\"width: 200px\"\n              />\n            </div>\n            <p>听说关注或者进行投喂的人，技术都越来越牛咯。</p>\n          </div>\n        </div>\n      </div>\n      <div class=\"col-1 hide-xl\"></div>\n    </div>\n  </div>\n</template>\n\n<script>\n  import { fetchBlogPost } from \"../../api/blog\"\n  export default {\n    name: \"BlogPage\",\n    components: {\n      ArticleCard: () => import(\"../../components/Common/ArticleCard.vue\"),\n    },\n    data() {\n      return {\n        article: \"\",\n        articleToc: undefined,\n      }\n    },\n    watch: {\n      \"$route.params\": function () {\n        this.initArticle()\n      },\n    },\n    created() {\n      this.initArticle()\n    },\n    mounted() {},\n    methods: {\n      initArticleToc: function (v) {\n        this.articleToc = v\n      },\n      initArticle: function () {\n        let title = this.$route.params.title\n        fetchBlogPost(title).then(res => {\n          this.article = res\n        })\n      },\n    },\n  }\n</script>\n```\n\n嗯，其实就是监听 url, 如果匹配上 url 的话，从 url 中取 title, 然后发送请求，接着取回响应的内容交给子组件处理。子组件处理完毕会 emit 出一个 toc 的值，将这个值赋值给左侧 toc 即可。\n\n- 分页组件\n\n见地址吧 https://github.com/twocucao/YaVueBlog/blob/master/src/components/Common/Pagination.vue\n\n- 打字终端组件\n\n终端的样式，当然是抄别人的 CSS, 打字效果，来源于 typed.js 依赖库\n\n## 0x06. 扩展\n\n对于其他的实现，自然是要多多看代码咯。\n\n其实前端工程化是一个很广的概念，本文没有提到代码风格、团队开发工作流、CSS 编写规范、组件优化、Webpack 详细配置等等。这都需要在日常开发中多多练习的。\n\n笔者最近换了份工作，以 React 为技术栈。 加上篇幅和精力有限，也就是不在以 Vue 为前端这一块详细展开了。\n\n下面的文章还是聚焦在后端上面。\n\n## 0xEE. 参考链接\n\n还犹豫啥，Django 前后端分离最佳实践，点赞后，快上车吧\n\n- 前端代码 https://github.com/twocucao/YaVueBlog\n- 后端代码 https://github.com/twocucao/YaDjangoBlog\n\n---\n\nChangeLog:\n\n- **2018-03-18** 重修文字\n"},{"tags":["Python","Django","YaDjangoBlog"],"path":"20180224_YaDjangoBlog的前后端初步设计.md","title":"YaDjangoBlog 的前后端设计","slug":"YaDjangoBlog 的前后端设计","date":"2018-02-24","category":"Django","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n本文是 Django 全栈开发教程的第二篇\n\n目录在这里，已经更新的文章如下\n\n- Django 全栈开发教程 - 2018 年不容错过的 Django 全栈项目 -- 目录篇\n- Django 全栈开发教程 - YaDjangoBlog 的开发环境配置\n\n本文需要完成两件事情：\n\n- 第一件事情，回答一个问题：为什么要选择博客系统作为教程而不是别的？\n- 第二件事情，简单说说 YaDjangoBlog 的前后端设计。\n\n## 0x01 为什么是博客系统\n\n在目录评论区，有个读者问：\n\n为什么选择博客系统？而不是别的系统？\n\n一言以蔽之：因为合适。\n\n为什么说合适？\n\n1. 第一点：代码量相对合适，业务逻辑大家都很清楚，博客系统说简单也简单，说复杂也复杂，待会我们就可以谈到。简单的例子反而是入门和深入了解 Django 技术栈（而不是设计一个优秀的程序）的最佳案例。\n2. 第二点：言简意赅，知识点覆盖全面，注意，我们要学习的 Django 技术栈，Django 技术栈，Django 技术栈。不是学高可用架构设计，不是超级复杂系统的设计，不是业务逻辑设计。\n3. 第三点：日常开发都是见招拆招，依据业务逻辑来，作为开发者，总不能直接把公司的业务代码上传的 Github 上吧？\n\n不妨想想，其实写个博客系统压根就不需要这么麻烦的使用各种组件来给自己的博客系统贴金。那么，我为何还是要『为赋新词强说愁』呢？\n\n答案是『醉翁之意不在酒，在乎山水之间』。通过这个简单的博客，来带大家过一遍 Django 技术栈，具体能学的多好，看个人努力。\n\n当然，借此也吐槽一下，有的人认为，博客系统简单，不就是 Blog / Category / Tag / Comment，有啥可练手的？\n\n其实不然，设计一个博客系统完全可以按照复杂系统的高标准来设计，举例来说：\n\n1. ORM 设计：如果我想把 Category/Tags/Comment 变成通用的，即可以对 Blog 进行分类 / 标签 / 评论，对新建的 Product 模型 也可以进行分类 / 标签 / 评论。\n2. 数据库设计：Category 可能有三到四级子分类怎么办？ Comment 支持评论区互相回复评论。这里的不但要通用，还要用树形结构实现放在一张表里面。\n3. 全文搜索：Blog 的 content 字段是长文对吧？这个总不能每次搜索都是 like 查询吧？Elasticsearch 怎么搞。\n4. 缓存和定时任务：PV 和 UV 量总不能每次访问都更新一次数据库吧？为什么不用 Redis 呢？用上了 Redis, 为什么不加上定时任务呢帮忙把 PV/UV 以及点赞数量啥的定期更新到数据库中？\n5. Celery ：定时任务为啥不用神器 Celery 呢？\n6. 其他问题：如何对某个接口进行 profile? 如果逻辑比较复杂，是不是要补上单元测试。Django 单实例如何使用多域名？\n\n那一套太祖长拳从宋兵甲手里使出来，不过是威力平平；\n\n> 如果是从那乔峰手里使出来，那威力如何？\n\n## 0x02 前后端分离\n\n### 前后端分离的必要性\n\n为什么前后端分离？\n\n- 一是需求：简简单单的套模板已经不够了，还要富交互，代码量上去了。\n- 二是技术条件成熟：NodeJS 横空出世，使得 JS 成了不仅仅可以在浏览器中运行的语言，成了一门和 Java,Python,Ruby 一样的客户端语言。\n- 三是生态：轮子多，这车轱辘如你所愿。\n\n前端的职责变重，代码量则上来了，相应的，模块化工具就自然出来了。\n\n> PS: 前后端分离也不是啥新概念，当年开发客户端的不也是前后端分离？ 当然，这里的前后端分离指的是浏览器与服务器的前后端分离。\n\n前后端分离之后，依旧是前端发送请求，后端返回对应的数据。\n\n那么，哪里变了？我认为，主要有两点：\n\n1. 前后端流程可以并行开发，即前后端可以同时干活。并且责任明确。\n2. JS 可以干客户端语言干的事情。\n\n以前，我们都是由美工设计页面，前端开发模板，后端开发 API, 前端再套 API, 再交给后端，后端接过前端的页面套模板。一切看起来是那么的和谐。\n\n但是，就是这么一个看起来一个简单的套模板 / 开发 API，就是一个时间黑洞。\n\n比如说：\n\n- 小美（美工）设计好设计稿，交给小钱（前端）\n- 小钱完成前端页面的设计，\n- 小侯（后端）开发 API,\n- 小钱套 API 后，完成页面设计，并将这个页面交给小侯\n- 小侯要做的事情，把小钱的前端页面切分成模板引擎里面的语法，从数据库里面取数据，交给模板引擎渲染，完成套前端页面流程。\n\n接着，产品经理跳出来，指出页面设计中有两个地方需要优化，于是：\n\n大家面临的选择就只有两个：\n\n1. 合起伙来，解决掉产品经理\n2. 大家在反反复复，迂迂回回的需求变更、BUG 解决、调试中，浪费了一些不应该浪费的时间。\n\n那么前后端分离了，前后端的开发就如同客户端开发和服务端开发一样：\n\n- 前端 / 客户端 负责路由，负责什么时候请求什么 API, 该去优化性能就去优化性能。\n- 后端 / 服务端 负责折腾后端组件，优化性能。\n\n- 如果调页面，直接找前端去就好了。\n- 如果是数据或者 API 有问题，直接找后端就好了。\n\n这么一分，其实职责就好界定了很多，由于修改与优化不会引发两个工种的交叉合作（前端改完，后端套模板）,BUG 率就减少了很多。\n\n> PS: 其实职责好界定很多，但不能避免推锅。\n\n由于本博客只关注 Django 技术栈，而所谓使用 JavaScript 前后端通吃的『大前端』, 则不在我们的讨论范围之内。\n\n> 比起使用一门语言前后端通吃，笔者还是比较倾向于『见人说人话，见鬼说鬼话』, 即使用多种语言，去处理合适的问题的。\n\n### 前后端分离的成本\n\n前后端分离并不是没有代价的。\n\n对于前端：\n\n- 首次页面 Loading 速度\n- JWT 认证请求\n- 在特定场景下，有些看起来在多页面开发过程中比较简单的事情，反而比较复杂。\n- 需要注意内存的使用率。\n\n对于后端：\n\n- JWT 认证响应，以前是 session 认证，而且 Django 都给你实现好了。现在变了，往往大家使用的都是 JWT 作为认证。\n\n但这些成本相比与节省的开发时间相比都是微不足道的。\n\n当然，我会在本系列的后面抽出一篇教程来专门讲解 Django 内置用户的扩展和前后端分离的登录认证。\n\n## 0x03 博客系统设计\n\n这个博客最初要解决的问题是：\n\n1. hexo 用腻了，想自己写一个简单的博客系统。\n2. 这个博客要可以导入文章，我不需要编辑器功能，在本地编辑完毕之后，导入数据库就好。\n\n### 页面构成\n\n1. 首页\n2. 博客列表页\n3. 博客存档页\n4. 博客历史页\n5. 博客详情页\n6. 关于我页面\n\n### 模型构成\n\n首先 M 模型层\n\n1. PostgreSQL : 博文 / 博文类型 / 博文标签\n2. Elasticsearch : 博文\n3. Redis : 每篇博文的阅读量，点赞量\n\n这里需要注意的是：\n\n- 第一：博文类型-博文：1 对多，博文标签-博文：多对多\n- 第二：博文中的 content 为文章内容，即可以在 Elasticsearch 中作为全文搜索的字段。具体降到 Elasticsearch 的时候我们会详细说明。\n- 第三：博文中的 阅读量和点赞量放在 Redis 里面，由 Celery 的定时任务定期刷到内存中。\n\n再考虑 VT 视图模板层，VT 层，会根据情况 DjangorestFramework 来进行序列化和反序列化。\n\n在设计模型的时候，尽量将涉及到模型的操作放在模型内。\n\n关于如何设计更好的模型，在以后的文章将会讲解，先挖个坑。\n\n### 架构图\n\n理想环境中，我们的架构图如下：\n\n哦，不好意思，放错图了，是这样的。\n\n但这样的架构应该有专门的人来维护。\n\n于是在人力有限的情况下，本项目的架构图是这样的。\n\n哦，不好意思，放错图了，是这样的。\n\n## 0xEE. 参考链接\n\n还犹豫啥，Django 前后端分离最佳实践，点赞后，快上车吧\n\n- 前端代码 https://github.com/twocucao/YaVueBlog\n- 后端代码 https://github.com/twocucao/YaDjangoBlog\n\n---\n\nChangeLog:\n\n- **2018-02-22** 开启本文\n- **2018-02-27** 重修文字\n"},{"tags":["Python","Django","YaDjangoBlog"],"path":"20180223_YaDjangoBlog前后端分离篇.md","title":"YaDjangoBlog 之前后端分离篇","slug":"YaDjangoBlog 之前后端分离篇","date":"2018-02-23","category":"Django","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n本文是 Django 全栈开发教程的第三篇 YaDjangoBlog 之前后端分离\n\n目录在这里，已经更新的文章如下\n\n- Django 全栈开发教程 - 2018 年不容错过的 Django 全栈项目 -- 目录篇\n- Django 全栈开发教程 - YaDjangoBlog 的开发环境配置\n- Django 全栈开发教程 - YaDjangoBlog 的前后端设计\n\n**本文需要成四件事情：**\n\n- 第一件事情，解读 DjangoRestFramework, 通过简单的例子来引入用 DRF 的必要性，并且简单介绍 DRF 的 CBV 实现。\n- 第二件事情，简单介绍 DRF 在本项目 YaDjangoBlog 中的使用\n- 第三件事情，简单聊聊 RESTFULAPI 规范，并给出最佳实践参考。\n- 第四件事情，简单解读一下 Django 处理请求流程代码。\n\nPS: 为了打字方便，下面的：\n\n- DRF 指的是 DjangoRestFramework\n- CBV 指的是 Class Based View\n- FBV 指的是 Function Based View\n\n> 坐稳了，开车了。\n\n## 0x01 DjangorestFramework 解读\n\n### 为什么要用 DRF 呢？\n\n使用一个库的原因，无非就是为了：\n\n1. 节省开发者自己造轮子的时间。\n2. 有利于代码的可维护性 / 或者程序的健壮性。\n\n具体落实到 DRF, 有哪些具体的优点呢？\n\n1. 可直接浏览调试的界面。让前端调试起来欲罢不能的功能。\n2. 用 DRF 的方式快速批量开接口\n3. 分页、序列化、校验、登录、权限、Web 附加文档、限流，高度的可扩展性。哪里不爽扩展哪里，so easy\n4. 算的上是 Django 社区最好的 RESTFUL 框架的轮子了。\n5. 完善的社区支持，比如 guardian/django-filter 等等结合。\n\n### 不使用 DRF 应该如何写 WebAPI 做呢？\n\n我们先看看，不使用 DRF 的时代，API 是如何编写的。\n\n这里我们用 function based view 来简单说明。\n\n```python\n# 最简单版本\ndef simple_hello(request):\n    return JsonResponse({\n        \"这就是 key\": \"这就是 value\",\n        \"时间\": time.time()\n    })\n```\n\n刚开始学 DRF 的时候，我也有这种疑惑，这有必要需要一个 RESTFULAPI 的框架嘛？捋起袖子，JSON API 甩起来开咯。\n\n之所以得出这个结论，是因为这个例子实在是过于简单。\n\n当涉及到一定复杂程度的 API 的时候，问题就来了：\n\n1. 权限是否需要区分？\n2. 分页需不需要做？\n3. 前端人员提交 Form 表单时，只能通过命令行或者是 POSTMAN 之类的工具提交参数，这会不会带来不便？后端人员写这些表单的各个字段，也是很手酸的事情。\n4. 拼接字典或者是字符串倒也还好，能不能有个序列器帮我直接序列化这模型，并且如果模型和模型之间有联系，最好也可以帮我完成模型和模型之间的关联。\n5. Profile API 应该如何做？\n\n这都是我们需要考虑的。\n\n如果不用 DRF, 而是由后端程序员直接写这些代码的话，也不是不行。\n\n1. 对于第一点，可以直接在 fbv 上面加装饰器。\n2. 对于第二点，分页的时候可以直接将逻辑写在 fbv 里面。\n3. 前端 er 直接使用 PostMan 之类的工具就好了。\n4. 序列化，可以借助内置的序列化方法。\n5. Profile 可以在提交参数的时候，附加一个参数比如 debug, 渲染的时候，将使用 HTML 里面内置一个 JSON 字符串的方式渲染出来。这样的话，就可以使用 Django Debug Tools 进行 Profile 了。\n\n很显然，这是个系统性的活。 假如接下来还要考虑限流、RESTFULAPI 的设计，这就相当蛋疼了。\n\n显然，我们的 FBV 就会是这样：\n\n```python\n@a_authority\ndef complex_hello(request):\n    params = getParams(request)\n    .....\n    query_results = SomeModels.some_query()\n    .....\n    results = SomeModelsSerial(query_results)\n    .....\n    return JsonResponse(results)\n```\n\n看起来似乎是有规律可循的，既然有规律可循，就能封装一下，减轻负担。FBV 已经这样了，显然只能每次都要硬编码这些取参数，查询，序列化。当然，如果用生成器也能简化一部分函数代码。yield 实现方法太丑还是弃用吧。\n\n我们试试 CBV 看看如何。\n\n```python\n# 继承并重写方法\nfrom django.views.generic import View\nclass APIView(View):\n\n    def get(self,request):\n        query_results = SomeModels.some_query()\n        .....\n        results = SomeModelsSerial(query_results)\n        .....\n        return results\n\n    def post(self,request):\n        query_results = SomeModels.some_query()\n        .....\n        results = SomeModelsSerial(query_results)\n        .....\n        return results\n\n    .....\n\n    # 这里相当于 view 函数\n    def dispatch(request, *args, **kwargs):\n        # 这里处理正式处理之前的逻辑，比如权限判断。\n        # 如果是 GET 方法，则调用\n        results = self.get(request, *args, **kwargs):\n        # 这里处理正式处理之后的逻辑，比如统计 list 的 total 值，加上时间戳\n        return JsonResponse(results)\n```\n\n于是，除了使用 FBV 进行硬编码之外，还可以使用 CBV 的基类 进行扩展定制。\n\n我们思考一下：\n\n1. 假如我想渲染某个模型的 JSON 列表，就可以定制一个 ListViewAPI 出来。如果需要一个 DetailViewAPI, 就定制一个 DetailViewAPI 出来。\n2. 我们再声明一些 Permission 类，序列化类，模型，然后在 dispatch 中直接使用这些东西的话，就只需要在 get 和 post 里面编写一些最核心的逻辑了。\n3. 甚至，指定了分页器和查询，都完全不需要再 get 和 post 里面写代码。\n\n恭喜你，读到这里，你已经可以写一个极简的 DRF 出来了。\n\n但写成 DRF 这种量级的程序，还需要做很多很多事情。\n\n### DRF 处理请求的流程\n\n要知道 DRF 的处理请求的流程，就要先知道 Django 的处理请求流程。\n\n宏观来看\n\n1. 请求先经过 MiddleWare , 接着判断 urlconf （默认为 ROOT_URLCONF),\n2. 匹配 URL, 将请求上下文 dispatch 到具体的 view.\n3. 处理完毕，经过 MiddleWare\n\nhttps://docs.djangoproject.com/en/2.0/topics/http/urls/\n\n在本文的结尾的时候，我也将带大家从源码角度过一下，涉及到这个流程的相关的源码。这里先跳过。\n\n那么，DRF 是如何处理一个请求的呢？我们忽略路由之类的东西，直接看对应的 CBV 的源码\n\n```python\nclass APIView(View):\n\n    renderer_classes = api_settings.DEFAULT_RENDERER_CLASSES\n    parser_classes = api_settings.DEFAULT_PARSER_CLASSES\n    authentication_classes = api_settings.DEFAULT_AUTHENTICATION_CLASSES\n    throttle_classes = api_settings.DEFAULT_THROTTLE_CLASSES\n    permission_classes = api_settings.DEFAULT_PERMISSION_CLASSES\n    content_negotiation_class = api_settings.DEFAULT_CONTENT_NEGOTIATION_CLASS\n    metadata_class = api_settings.DEFAULT_METADATA_CLASS\n    versioning_class = api_settings.DEFAULT_VERSIONING_CLASS\n\n    # ...... 其他方法\n\n    # Dispatch methods\n\n    def initialize_request(self, request, *args, **kwargs):\n        \"\"\"\n        Returns the initial request object.\n        \"\"\"\n        parser_context = self.get_parser_context(request)\n\n        return Request(\n            request,\n            parsers=self.get_parsers(),\n            authenticators=self.get_authenticators(),\n            negotiator=self.get_content_negotiator(),\n            parser_context=parser_context\n        )\n\n    def initial(self, request, *args, **kwargs):\n        \"\"\"\n        Runs anything that needs to occur prior to calling the method handler.\n        \"\"\"\n        self.format_kwarg = self.get_format_suffix(**kwargs)\n\n        # Perform content negotiation and store the accepted info on the request\n        neg = self.perform_content_negotiation(request)\n        request.accepted_renderer, request.accepted_media_type = neg\n\n        # Determine the API version, if versioning is in use.\n        version, scheme = self.determine_version(request, *args, **kwargs)\n        request.version, request.versioning_scheme = version, scheme\n\n        # Ensure that the incoming request is permitted\n        self.perform_authentication(request)\n        self.check_permissions(request)\n        self.check_throttles(request)\n\n    # Note: Views are made CSRF exempt from within `as_view` as to prevent\n    # accidental removal of this exemption in cases where `dispatch` needs to\n    # be overridden.\n    def dispatch(self, request, *args, **kwargs):\n        \"\"\"\n        `.dispatch()` is pretty much the same as Django's regular dispatch,\n        but with extra hooks for startup, finalize, and exception handling.\n        \"\"\"\n        self.args = args\n        self.kwargs = kwargs\n        # 这里需要注意\n        request = self.initialize_request(request, *args, **kwargs)\n        self.request = request\n        self.headers = self.default_response_headers  # deprecate?\n\n        try:\n            # 这里需要注意\n            self.initial(request, *args, **kwargs)\n\n            # Get the appropriate handler method\n            if request.method.lower() in self.http_method_names:\n                handler = getattr(self, request.method.lower(),\n                                  self.http_method_not_allowed)\n            else:\n                handler = self.http_method_not_allowed\n\n            response = handler(request, *args, **kwargs)\n\n        except Exception as exc:\n            response = self.handle_exception(exc)\n\n        self.response = self.finalize_response(request, response, *args, **kwargs)\n        return self.response\n```\n\n可以看出，当请求到达 dispatch 的时候，DRF 添加了一些钩子函数，用于开始 / 结束 / 错误控制。\n\n1. 在 initialize_request 的时候，对 request 进行封装，添加上 parser / auth / negoriator / parser context\n2. 接着在 initial 方法里面校验了版本，进行了认证和鉴权，检查了限流\n\n一看，其实与我们之前想封装 APIView 的想法不谋而合，而我们只是想想，DRF 是详细实现。\n\n## 0x02 DjangorestFramework 的使用案例\n\n### 如何开 WebAPI 接口\n\n回到我们的 yadjangoblog 上面来。这个时候我们想开一个博文列表 API:\n\n```python\n# 1. 定义序列器，用于序列化查询的每一条。\nclass BlogPostListSerializer(serializers.ModelSerializer):\n    category = BlogCategorySerializer(read_only=True)\n    tags = BlogTagSerializer(many=True, read_only=True)\n    title = serializers.CharField()\n    id = serializers.IntegerField()\n\n    class Meta:\n        model = BlogPost\n        fields = ('id', 'title', 'char_num', 'vote_num', 'category', 'tags', 'publish_date')\n\n# 2. 定义过滤器，可以通过过滤器进行查询\nclass BlogPostFilter(filters.FilterSet):\n    title = filters.CharFilter(lookup_expr='contains')\n    having_tags = filters.Filter(name=\"tags\", lookup_expr='in')\n\n    class Meta:\n        model = BlogPost\n        fields = ('title', 'char_num', 'category', 'tags')\n\n# 3. 指定其他设置，具体大家看源码就好了。\nclass BlogPostListAPIView(generics.ListAPIView):\n    \"\"\"\n    依照 category , tags , 时间 （年 / 月 / 日  年 / 月 年）\n    \"\"\"\n    queryset = BlogPost.objects.all()\n    serializer_class = BlogPostListSerializer\n    filter_backends = (filters.DjangoFilterBackend, OrderingFilter,)\n    filter_class = BlogPostFilter\n    ordering_fields = ('publish_date',)\n    ordering = ('publish_date',)\n    permission_classes = (permissions.AllowAny,)\n    pagination_class = SmallResultsSetPagination\n```\n\n在指定上面的操作之后，一个接口就快速的开出来了。\n\n: TODO 插入一张图\n\n当然，DRF 认认真真通读一遍的话，还是可以给自己节省不少时间的。\n\n这是开接口，似乎，还少了什么，比如 Restful API.\n\n### 前端如何使用 WebAPI 接口\n\n什么是 CORS 可以参考阮一峰的文章 http://www.ruanyifeng.com/blog/2016/04/cors.html\n\n在调试的时候，我们肯定是使用 ajax / fetch 方式请求。这就会遇到一个问题：\n\n- 跨域\n\n解决方式也很简单，服务端只要服务器实现了 CORS 接口，就可以跨源通信。\n\n安装 django-cors-headers, 并在 settings 中开启 CORS_ORIGIN_ALLOW_ALL = True 即可。\n\n这里参考了临书的解决方案，要感谢 @临书 , 附上参考地址 https://zhuanlan.zhihu.com/p/24893786\n\n对于本项目而言，使用了 axios 请求库，直接 get 即可。详细看前端代码即可。\n\n## 0x03 RESTFUL API 设计\n\n开发过程中，尽量靠近 RESTFUL API 的设计，而不是照搬。\n\n举个其他领域的例子，有的人表述美就只有：\n\n- 已撸\n\n但是不同的美各有各的模样：\n\n- 手如柔荑，肤如凝脂，领如蝤蛴，齿如瓠犀，螓首蛾眉，巧笑倩兮，美目盼兮。\n\n同样，放在 RESFUL 的时候确实也出现了这种情况：\n\n几乎所有的业务逻辑最后会落实到数据表的 CURDE, 但是所有业务逻辑并不能完全使用 CRUDE 描述。\n\n我们看下面的例子\n\n### 关于请求\n\n举个例子，RESTFUL 适合纯粹 CURDE 的设计风格。\n\n比如，新增博客，更新博客，查询博客，删除博客，查看是否含有博客\n\n但语义在某些场景下表述不足， 比如，设计订单的时候，\n\n```bash\nURL: /api/v1/user/some_user/orders\n你查看订单集合，这个好理解。get 方法\n你新增订单，这个好理解。put 方法\nURL: /api/v1/user/some_user/order/xxxxxxx\n你删除订单，这个好理解。delete 方法\n你获取订单，这个好理解。get 方法\n你修改订单，这个好理解。post 方法\n\n但修改订单，有的时候可能会比较复杂，有可能是取消订单，有可能是评价订单，有可能是其他。而 RESTFUL 表达这种情况就有些语义不足了。\n```\n\n当然，个人经验是，字段越多，越难靠近 RESTFUL 规范\n\n这个时候，就需要设计者做好 RESTFULAPI 的设计与语义化的平衡了。\n\n### 关于响应\n\n关于响应设计，主要有两点需要注意：\n\n- 状态码 (HTTP 状态码，也业务逻辑通用状态码）\n- 响应内容 包含 业务逻辑通用状态码，剩下的视具体情况而定。\n\nHTTP 状态码用于标记资源情况，比如：\n\n```\n200 表示获取资源\n404 表示 NOT FOUND\n```\n\n但有时候也存在语义表达不足问题，一般前后端也会约定一个通用的状态码\n\n```\n通用状态码 错误信息 含义 HTTP 状态码\n999\t    unknow_v2_error\t未知错误\t400\n1000\tneed_permission\t需要权限\t403\n1001\turi_not_found\t资源不存在\t404\n1002\tmissing_args\t参数不全\t400\n1003\timage_too_large\t上传的图片太大\t400\n....\n```\n\n至于响应内容，一般都是见招拆招的。建议查看文章末尾的 Douban 的相关 API 规范来提升姿势。\n\n## 0x04 Django 的处理请求流程代码解读\n\n这小节属于一时兴起写的番外篇。和本文主体内容没啥必要的关联。不感兴趣的可以直接跳转到文章末尾点赞哈。\n\nWSGI 全称叫做 web 服务器网关接口，通常情况下，gunicorn 或者 uwsgi 接收来自 nginx 转发来的请求之后，向 web app 提供了环境信息（叫请求上下文会不会好些）以及一个 callback. 这样的话，web app 就可以接收这个环境信息，处理完毕，通过回调函数处理请求，并返回响应。一个极简的 webapp 如下：\n\n```python\ndef app(environ, start_response):\n    \"\"\"Simplest possible application object\"\"\"\n    data = 'Hello, World!\\n'\n    status = '200 OK'\n    response_headers = [\n        ('Content-type','text/plain'),\n        ('Content-Length', str(len(data)))\n    ]\n    start_response(status, response_headers)\n    return iter([data])\n```\n\n现在我们看看 django 中是如何处理请求的。首先查看相关的 wsgi.py\n\n```python\n# wsgi.py\nimport os\nfrom django.core.wsgi import get_wsgi_application\nos.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"config.settings\")\napplication = get_wsgi_application()\n\n# 接着查看 get_wsgi_application\nimport django\nfrom django.core.handlers.wsgi import WSGIHandler\n\ndef get_wsgi_application():\n    \"\"\"\n    The public interface to Django's WSGI support. Return a WSGI callable.\n\n    Avoids making django.core.handlers.WSGIHandler a public API, in case the\n    internal WSGI implementation changes or moves in the future.\n    \"\"\"\n    django.setup(set_prefix=False)\n    return WSGIHandler()\n\n# 于是自然而言的看到了 WSGIHandler\nclass WSGIHandler(base.BaseHandler):\n    request_class = WSGIRequest\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.load_middleware()\n\n    def __call__(self, environ, start_response):\n        # 有木有看到 environ 和 start_response ?? 这就是极简 web app 中的 webapp 核心方法。\n        set_script_prefix(get_script_name(environ))\n        signals.request_started.send(sender=self.__class__, environ=environ)\n        request = self.request_class(environ)\n        # 注意这一行，有请求处理逻辑 具体要见下面代码\n        response = self.get_response(request)\n        # ......\n        return response\n```\n\n嗯，看到了子类，就要看看基类\n\n```python\nclass BaseHandler:\n    _request_middleware = None\n    _view_middleware = None\n    _template_response_middleware = None\n    _response_middleware = None\n    _exception_middleware = None\n    _middleware_chain = None\n\n    def load_middleware(self):\n        \"\"\"\n        注册 MiddleWare, 并赋值 _middleware_chain 方法，使之调用的时候可以先按照顺序从 setting 的 middleware 里面处理 requests\n        并在处理 request 的最后调用 私有方法 _get_response\n        \"\"\"\n        self._request_middleware = []\n        self._view_middleware = []\n        self._template_response_middleware = []\n        self._response_middleware = []\n        self._exception_middleware = []\n\n        handler = convert_exception_to_response(self._get_response)\n        # 注意，这里面是倒着来的 代码中越在前面，实际运行的时候处理就越在后面\n        for middleware_path in reversed(settings.MIDDLEWARE):\n            # 依次添加 view middleware / template middleware / exception middleware\n            middleware = import_string(middleware_path)\n            mw_instance = middleware(handler)\n            handler = convert_exception_to_response(mw_instance)\n\n        # We only assign to this when initialization is complete as it is used\n        # as a flag for initialization being complete.\n        self._middleware_chain = handler\n\n    .....\n\n    def get_response(self, request):\n        \"\"\"Return an HttpResponse object for the given HttpRequest.\"\"\"\n        # Setup default url resolver for this thread\n        set_urlconf(settings.ROOT_URLCONF)\n\n        response = self._middleware_chain(request)\n        # ......\n        return response\n\n    def _get_response(self, request):\n        \"\"\"\n        Resolve and call the view, then apply view, exception, and\n        template_response middleware. This method is everything that happens\n        inside the request/response middleware.\n        \"\"\"\n        response = None\n\n        # 1. 接着判断 urlconf （默认为 ROOT_URLCONF), 可以通过 middleware 进行设置\n        if hasattr(request, 'urlconf'):\n            urlconf = request.urlconf\n            set_urlconf(urlconf)\n            resolver = get_resolver(urlconf)\n        else:\n            resolver = get_resolver()\n\n        resolver_match = resolver.resolve(request.path_info)\n        callback, callback_args, callback_kwargs = resolver_match\n        request.resolver_match = resolver_match\n\n        # Apply view middleware....\n        # 注意，这个就是 view 函数\n        wrapped_callback = self.make_view_atomic(callback)\n        response = wrapped_callback(request, *callback_args, **callback_kwargs)\n        # Complain if the view returned None (a common error).\n        return response\n\n    def process_exception_by_middleware(self, exception, request):\n        # ......\n```\n\n上面代码比较表达的意思比较简单，值得注意的地方我都加了注释。\n\n需要特别注意的就是 middleware_chain 这个属性（实际上是一个方法）, 正是这个方法使得注册的 middleware （在 load_middleware 方法里）可以在 fbv 或者 cbv 处理 request 之前，通过对 request 进行处理。\n\n## 0xEE. 参考链接\n\n还犹豫啥，Django 前后端分离最佳实践，点赞后，快上车吧\n\n- 前端代码 https://github.com/twocucao/YaVueBlog\n- 后端代码 https://github.com/twocucao/YaDjangoBlog\n- 扩展阅读之 douban restful api 设计 https://developers.douban.com/wiki/?title=api_v2\n\n---\n\nChangeLog:\n\n- **2018-02-22** 开启本文\n- **2018-03-04** 重修文字\n"},{"tags":["Python","Django","YaDjangoBlog"],"path":"20180222_YaDjangoBlog开发环境配置.md","title":"YaDjangoBlog 开发环境配置","slug":"YaDjangoBlog 开发环境配置","date":"2018-02-22","category":"Django","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n本文是 Django 全栈开发教程的第一篇，上一篇是第零篇，目录会随时更新，地址在这里 2018 年不容错过的 Django 全栈项目 https://zhuanlan.zhihu.com/p/33903527\n\n> 为什么是第零篇，因为程序员从零计数呀。笑~~\n\n本文需要完成两件事情：\n\n- 配置基本的开发环境\n- 让代码先运行一下\n\n如果你使用的 macOS, 那么可以跟着下文一步一步走。如果是 linux/window 用户，可能稍微需要在配置环境上多花点时间。\n\n> 本文默认你至少会在 iTerm2 下面使用基本的 bash 命令与 git , 如果使用的 ohmyzsh 就更好了。 建议先参考请查看我之前的文章里面的配置环境 如何优雅地使用 macOS https://zhuanlan.zhihu.com/p/29892969\n\n## 0x01 Python 开发环境配置\n\n本小节的目的就是配置好基本的 python 开发环境\n\n使用了神器 pyenv\n\n> BTW: 为什么不直接用 pipenv ? 因为网络不通畅，如若不然，pipenv 比 pyenv 更适合用来做 python 依赖包管理。\n\n```python\n# 新开终端\ngit clone https://github.com/yyuu/pyenv.git ~/.pyenv\ngit clone https://github.com/yyuu/pyenv-virtualenv.git ~/.pyenv/plugins/pyenv-virtualenv\necho 'export PYENV_ROOT=\"$HOME/.pyenv\"' >> ~/.zshrc\necho 'export PATH=\"$PYENV_ROOT/bin:$PATH\"' >> ~/.zshrc\necho 'eval \"$(pyenv init -)\"' >> ~/.zshrc\necho 'eval \"$(pyenv virtualenv-init -)\"' >> ~/.zshrc\n\n# 接着另开终端\n# 不喜写兼容代码，所有代码均向 3.5+ 靠拢\nv=3.5.2|wget http://mirrors.sohu.com/python/$v/Python-$v.tar.xz -P ~/.pyenv/cache/;pyenv install $v\nv=3.6.0|wget http://mirrors.sohu.com/python/$v/Python-$v.tar.xz -P ~/.pyenv/cache/;pyenv install $v\nv=2.7.11|wget http://mirrors.sohu.com/python/$v/Python-$v.tar.xz -P ~/.pyenv/cache/;pyenv install $v\n\n# 设置 Global Python 为 2.7.11, 备注：尽量不要把 Py3 设置为全局，否则由于 Homebrew 本身有一些依赖是依赖于 Py2 的，这样容易出现一些奇怪的问题。\npyenv global 2.7.11\npip install -i https://pypi.doubanio.com/simple requests\n# 下面这个是用于安装基本的代码补全功能\npip install -i https://pypi.doubanio.com/simple --upgrade \"jedi>=0.9.0\" \"json-rpc>=1.8.1\" \"service_factory>=0.1.5\" flake8 pytest autoflake hy\n\n# 创建最常用 Py3 虚拟环境\npyenv virtualenv 3.5.2 py3-daily\npyenv activate py3-daily\npip install -i https://pypi.doubanio.com/simple requests\npip install -i https://pypi.doubanio.com/simple beatutifulsoup4\npip install -i https://pypi.doubanio.com/simple ipython[notebook]\npip install -i https://pypi.doubanio.com/simple jupyter\n# 下面这个是用于安装基本的代码补全功能\npip install -i https://pypi.doubanio.com/simple --upgrade \"jedi>=0.9.0\" \"json-rpc>=1.8.1\" \"service_factory>=0.1.5\" flake8 pytest autoflake hy\n```\n\n好，Python 环境就安装完毕了。\n\n## 0x02 JavaScript 开发环境配置\n\n> 本小节的目的就是配置好基本的 JS 开发环境，但估计 JSer 看了本小节依旧可以在配置上少一些麻烦。\n\nJS 可以前后端通吃，社区生态很丰富。ES6 之后从 python 和 ruby 里面借鉴了不少语法糖。现在写起来还是比较愉悦的。\n\nJavaScript 不管开发前端应用还是后端应用，都需要安装 node 环境。\n\n```bash\n# 先安装 nvm\ncurl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash\n# 新开终端\nnvm install 8\nnvm use 8\nnvm alias default 8\n\nnpm install cnpm\ncnpm install yarn -g\n# 设置镜像\nyarn config set registry https://registry.npm.taobao.org\n```\n\n编辑 ~/.npmrc 配置文件，输入下文再配置各种奇奇怪怪的镜像地址。\n\n```bash\nregistry=https://registry.npm.taobao.org/\nchromedriver_cdnurl=http://cdn.npm.taobao.org/dist/chromedriver\ndisturl=https://npm.taobao.org/dist\noperadriver_cdnurl=http://cdn.npm.taobao.org/dist/operadriver\nphantomjs_cdnurl=http://cdn.npm.taobao.org/dist/phantomjs\nfse_binary_host_mirror=https://npm.taobao.org/mirrors/fsevents\nsass_binary_site=http://cdn.npm.taobao.org/dist/node-sass\nelectron_mirror=http://cdn.npm.taobao.org/dist/electron/\n```\n\n配置完毕\n\n## 0x03 Docker 安装与配置\n\n> 本小节主要解决一个最蛋疼的问题，就是网络问题\n\n下载并安装 docker for mac 地址如下 https://docs.docker.com/docker-for-mac/install/\n\n```bash\n# 安装成功后运行命令\ndocker run hello-world\n```\n\n如果一切正常，则会显示如下\n\n```bash\n$ docker run hello-world\nUnable to find image 'hello-world:latest' locally\nlatest: Pulling from library/hello-world\nca4f61b1923c: Pull complete\nDigest: sha256:083de497cff944f969d8499ab94f07134c50bcf5e6b9559b27182d3fa80ce3f7\nStatus: Downloaded newer image for hello-world:latest\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n\nTo generate this message, Docker took the following steps:\n 1. The Docker client contacted the Docker daemon.\n 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.\n    (amd64)\n 3. The Docker daemon created a new container from that image which runs the\n    executable that produces the output you are currently reading.\n 4. The Docker daemon streamed that output to the Docker client, which sent it\n    to your terminal.\n\nTo try something more ambitious, you can run an Ubuntu container with:\n $ docker run -it ubuntu bash\n\nShare images, automate workflows, and more with a free Docker ID:\n https://cloud.docker.com/\n\nFor more examples and ideas, visit:\n https://docs.docker.com/engine/userguide/\n```\n\n好，配置到这里。\n\n你以为你已经配置好了，还先别激动，网络问题还没解决呢。小的镜像可以直接从 Docker 上直接拖下来，几百兆的镜像可就没这么容易了。\n\n这里我们使用了阿里云的 Docker 容器镜像。\n\n登录阿里云，到控制台，找到容器镜像服务，镜像加速器，\n\n如下图：\n\n右键点击桌面顶栏的 docker 图标，选择 Preferences ，在 Daemon 标签（Docker 17.03 之前版本为 Advanced 标签）下的 Registry mirrors 列表中将 https://your-url.mirror.aliyuncs.com 加到\"registry-mirrors\"的数组里，点击 Apply & Restart 按钮，等待 Docker 重启并应用配置的镜像加速器。\n\nDocker 配置完毕。\n\n## 0x04 项目试运行\n\n运行项目之前，保持你我的工作环境基本一致\n\n- 创建一些必须的目录\n- clone 项目\n\n```bash\nmkdir -p ~/Codes/YaBlog/DockerVolume/YaDjangoBlog/PostgreSQL/data\nmkdir -p ~/Codes/YaBlog/DockerVolume/YaDjangoBlog/Redis/data\nmkdir -p ~/Codes/YaBlog/DockerVolume/YaDjangoBlog/Backups\ncd ~/Codes/YaBlog/\ngit clone git@github.com:twocucao/YaVueBlog.git\ngit clone git@github.com:twocucao/YaDjangoBlog.git\n```\n\n克隆下来项目之后还需要稍微折腾一下（没办法，CURD 开发 = 折腾折腾折腾 + 搬砖搬砖搬砖）\n\n- 运行 Vue 开发环境\n- 运行 Docker 化的 django 环境\n\n```bash\n# 新开一个终端 用于运行 Vue 应用\n# 前端环境不放在 Docker 环境中。（因为开发环境没必要，生产环境才需要）\ncd ~/Codes/YaBlog/YaVueBlog/ && yarn && cd -\ncd ~/Codes/YaBlog/YaVueBlog/packages/theme-future/ && yarn && cd -\ncd ~/Codes/YaBlog/YaVueBlog/\nnpm run build:theme\nnpm run dev\n```\n\n```bash\n# 新开一个终端\ncd ~/Codes/YaBlog/YaDjangoBlog/\nmake\n```\n\n看到下图，包含所有的命令。\n\n这是我用 Makefile 编写的一系列命令，方便我在开发过程将主要的精力花在业务逻辑上而不是花时间在强记大量的琐碎的命令。\n\n```bash\ncd ~/Codes/YaBlog/YaDjangoBlog/\nmake build-all\n# 等待运行后端所有组件\n```\n\n然后，读者可以先去泡杯咖啡点个外卖吃个饭之类的。等待构建完毕。\n\n需要注意的是，务必配置好 docker 镜像加速地址，否则根据国内情况，你可能需要多去泡几杯咖啡，多吃几顿饭。\n\n好，接下来我们运行后端程序，首次运行需要花费不少时间\n\n```bash\ncd ~/Codes/YaBlog/YaDjangoBlog/\nmake django-just-up\n```\n\n运行之后，终端结果如下：\n\n可以发现，服务已经都开始启动了。\n\n但不要冲动，先等等，因为一次开了如下的服务：\n\n- postgres\n- redis\n- elasticsearch\n- mailhog\n- django\n- celerybeat\n- celeryworker\n- celeryflower\n\n需要多等会儿时间到各个服务运行正常。直到出现下图：\n\n这意味着基本上所有的程序都运行正常了。如果有服务挂掉，欢迎到 github 的 issue 上提一下。\n\n```bash\n# 接着再新开一个终端 用于导入基础数据\ncd ~/Codes/YaBlog/YaDjangoBlog/\nmake django-import-articles\n```\n\n好，那么，我们来验证一下如下几个地址：\n\n- 接口地址 http://localhost:8000/api/v1/archive\n- Vue 地址 http://localhost:8080/\n- 在搜索框内输入 elasticsearch 查看接口是否正常返回数据\n- 查看 celery 的 task 是否正确\n\n如果一切正常，则所有的截图应该如下\n\n## 0x05 Tmux 和 Tmuxinator\n\n我们在上文中可以发现有个极其蛋疼菊紧的问题。\n\n当我们运行 make django-just-up 这个命令的时候，所有服务运行的同时，所有的标准输入都打印到一个终端。\n\n这个和我们日常开发不太相同\n\n1. 在 django 开发的时候，我们运行 runserver, 肯定是只想在那个终端里看到 runserver 的运行情况。而不是 Redis,Elasticsearch,PGsql 之类的 log。\n2. 并且，django 的热加载会有些小问题，有些错误只能 ctrl+c 关掉 runserver, 然后重启。但当我们想 ctrl+c 关掉 runserver 的时候，却把所有的的服务都关掉了。\n\n解决方式也简单：\n\n对于暂时不想在开发时看到日志的服务，干脆直接放后台运行，执行我封装的命令 make django-before-up 把部分服务直接放在后台里，然后再开四个终端，运行下面的命令。\n\n- make django-runserver # 运行 runserver , 并只把该容器的 log 打印出来。下面三者同上。\n- make django-celerybeat\n- make django-celeryworker\n- make django-celeryflower\n\n显然还是很麻烦，我这种懒人可是能少写几行代码就少些几行代码的。\n\n那么我们还可以更省事（懒一些）么？\n\n我之前写了一篇简单的 tmux 与 Tmuxinator 教程 https://zhuanlan.zhihu.com/p/33369297 , 具体配置步骤参考文中即可。\n\n配置好 Tmuxinator 之后\n\n```bash\n# 先软连接一下\nln -svf ~/Codes/YaBlog/YaDjangoBlog/yadjangoblog.yml ~/.tmuxinator/yadjangoblog.yml\n```\n\n当我需要运行的所有服务的时候，我只需要\n\n```bash\ntmuxinator start yadjangoblog\n```\n\n就可以开启所有命令。\n\nyadjangoblog.yml 的内容如下\n\n```\nwindows:\n  - \"前端-页面开发\":\n      root: ~/Codes/YaBlog/YaVueBlog/\n      layout: main-vertical\n      panes:\n        - \"前端页面 DEV\":\n          - \"npm run dev\"\n  - \"前端-CSS 与字体文件\":\n      root: ~/Codes/YaBlog/YaVueBlog/\n      layout: main-vertical\n      panes:\n        - \"npm run dev:theme\"\n        - \"npm run dev:iconfont\"\n  - \"后端-Django 及其服务\":\n      root: ~/Codes/YaBlog/YaDjangoBlog/\n      layout: main-vertical\n      panes:\n        - \"make django-before-up && make django-runserver\"\n  - \"后端-数据库相关\":\n      layout: main-vertical\n      root: ~/Codes/YaBlog/YaDjangoBlog/\n      panes:\n        - \"sleep 20 && make dbshell\"\n        - \"sleep 20 && make shell\"\n  - \"后端-Celery\":\n      layout: main-vertical\n      root: ~/Codes/YaBlog/YaDjangoBlog/\n      panes:\n        - \"sleep 20 && make django-celerybeat\"\n        - \"sleep 20 && make django-celeryworker\"\n```\n\n## 0x06 PyCharm 基本设置\n\n> 大家应该都用 PyCharm 进行开发了吧。 如果是的话，不看本小节可能会让你栽个跟头\n\n```bash\n# 这步是给 pycharm 打开代码做准备\npyenv activate py3-daily\npip install -i https://pypi.doubanio.com/simple -r requirements/local.txt\n```\n\n务必完成下面两个步骤\n\n1. 在 Preferences -> project -> interpreter 选择对应的 py3-daily 虚拟环境。\n2. 在侧边栏把 yadjangoblog , 注意小写的。右键标记为 sources root\n\n这样的标记相当于告诉 PyCharm , 这个项目的 PYTHONPATH 是 yadjangoblog/ , 否则使用 PyCharm 导入 AModel 会自动导入 from yadjangoblog.yaadmin.models from AModel 而不是 from yaadmin.models import AModel , 这会导致程序运行错误。\n\n> PS: 包括后面跑单元测试的时候，均手动设置了 PYTHONPATH 变量。\n\n## 0x07 开发流程\n\n本小节，从笔者开机开始，回顾一下环境配置好之后，笔者是如何进入开发状态的：\n\n1. 开机。输入密码进入桌面。\n2. 打开 Iterm, 运行 tmuxinator start yadjangoblog 开启项目。打开 PyCharm 和 WebStorm\n3. 开发\n\n- 在 WebStorm 中写写前端代码，在 http://localhost:8080 和 tmux 里的第一个 window 查看状态\n- 在 PyCharm 中写写后端代码，在第三个 window 查看 runserver 状态，在第四个 window 的两个 Panel 运行 python manage.py 相关命令。\n- 在 Chrome Elasticsearch Head 扩展里调试 Elasticsearch 语法\n- 在 http://localhost:8000/api/your-api-path 里调试前后端 API\n- 在 http://localhost:5555 通过 flower 查看相关\n- .....\n- 当然，你也可以新开一个终端里面，执行 make 查看相关还可以执行哪些命令。\n\n那么，具体执行这些命令背后究竟发生了什么？\n\n- 数十服务为何突然启动\n- 数百个任务为何半夜消失\n- 正常运行的服务为何屡屡崩溃\n- 这一切的背后！是工程师的人性扭曲还是码畜的道德沦丧？是内存的爆发还是处理器的无奈？\n- 敬请关注本专栏 『MG 的编程小屋』或者 Github 频道，让我们跟随教程走进全干工程师的代码世界。\n\n> 不好意思，顺手打了个硬广，防止别人把我的文章砍头去尾直接扒过去。\n\n## 0xEE. 参考链接\n\n还犹豫啥，点赞后，快上车吧\n\n- 前端代码 https://github.com/twocucao/YaVueBlog\n- 后端代码 https://github.com/twocucao/YaDjangoBlog\n\n---\n\nChangeLog:\n\n- **2018-02-22** 重修文字\n"},{"tags":["Python","Django","YaDjangoBlog"],"path":"20180221_FullStackDjangoDevOps.md","title":"2018 年不容错过的 Django 全栈项目","slug":"2018 年不容错过的 Django 全栈项目","date":"2018-02-21","category":"Django","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n> 写在前面的话：不好意思，标题难以免俗，起了个很俗气的名字。\n\n这是我的一个全栈类型 Django 开源项目的系列讲解教程的目录。\n\n为什么写这系列的文章呢？目的总的来说有两个：\n\n1. 一是希望更多的人通过本系列的教程更好的认识 Django 开发技术栈或者说是 Web 开发技术栈，让更多的 Pythonist 更顺畅的进入 Django 开发的世界。\n2. 二是希望借由这个持续更新的过程让自己更加深入理解 Django 技术栈 Django / DjangoRestFramework / Docker / Vue.JS / Celery / PostgreSQL / Redis / RabbitMQ\n\n为什么说这个项目你不容错过？\n\n- 新！新！新！保持最新的软件开发版本，E.G: Django 2.0 + Vue.JS 2.5 + PostgreSQL 10 + Celery 4.1.0\n- Django 框架：Django 及其 强大的生态圈\n- 后端组件：PostgreSQL RabbitMQ Redis Ngnix\n- 前端技术：单页应用 前后端分离 (VueJS+Webpack+DjangoRestFramework), 自动化部署\n- Django 社区最佳实践：从配置 / 开发 / 测试 / 部署 **全干**工程师 (Full Stuff Engineer) 的最新的 DevOps 思考成果。\n- 基本覆盖了进阶 Django 开发所需要的各种组件与操作。\n- 只需要适当的调整，本项目就可以成为你新开项目的最佳脚手架。\n\n本系列文章的面向读者：\n\n- 目标是 DevOps 的 Pythonist\n- 爱瞎几把折腾的 Pythonist\n- 前后端分离的实践者\n\n> 生命苦短，赶快上车\n\n> Life is Short , I Use Python\n\n## 0x01 项目介绍\n\nYaDjangoBlog 是另一个关于博客的轮子，但是其野心并不在于仅仅多造一个博客系统，还有通过本项目做 Django 全栈开发的最佳实践。\n\n### 1.1 项目地址\n\n- 前端代码 https://github.com/twocucao/YaVueBlog\n- 后端代码 https://github.com/twocucao/YaDjangoBlog\n\n### 1.2 项目技术栈\n\n- 开发与部署环境为 Docker\n- Python 3.5.2\n- 前端 Vue + Webpack + ES2015 + axios\n- 后端 [Django 2.0](https://github.com/django/django) + [DjangoRestFramework](https://github.com/tomchristie/django-rest-framework/) + Celery\n- 自动化部署选用工具 Ansible 以及 Docker\n- 后端组件\n  - ElasticSearch 用于搜索和推荐\n  - PostgreSQL 用于数据持久化\n  - Redis 用于 Session / 和缓存\n  - RabbitMQ 分布式队列 / 定时任务\n  - Nginx 用于反向代理\n\n### 1.3 特别感谢\n\n- ansible django stack: https://github.com/jcalazan/ansible-django-stack\n- cookiecutter-django: https://github.com/pydanny/cookiecutter-django\n- djangopackages: https://github.com/djangopackages/djangopackages\n- 董伟明 关于 ElasticSearch 的几篇文章 http://www.dongwm.com/archives/%E7%9F%A5%E4%B9%8ELive%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E4%B9%8B%E4%BD%BF%E7%94%A8Elasticsearch%E6%90%9C%E7%B4%A2/\n- 各个组件的开发者们\n  - ElasticSearch\n  - PostgreSQL\n  - Redis\n  - RabbitMQ\n  - Nginx\n  - Docker\n\n### 1.4 项目截图\n\n好，讲了半天有的没的，还是贴点图吧，毕竟我不是 Markdown 程序员\n\n> 我们先看看能看得见的前端页面\n\n主页\n\n![](https://user-gold-cdn.xitu.io/2018/2/21/161b6ba50ddaa85f?w=3344&h=1822&f=png&s=1504757)\n\n博客详情\n\n![](https://user-gold-cdn.xitu.io/2018/2/21/161b6c3e3a0b8dd4?w=3342&h=1846&f=png&s=1021166)\n![](https://user-gold-cdn.xitu.io/2018/2/21/161b6c31db9c8d5c?w=3350&h=1804&f=png&s=1016132)\n\n这是一个很普通的 Archive 页面\n\n![](https://user-gold-cdn.xitu.io/2018/2/21/161b6bfa8c121ed4?w=3312&h=1818&f=png&s=425859)\n\n这是以 Elasticsearch 为支持的 搜索功能\n\n![](https://user-gold-cdn.xitu.io/2018/2/21/161b6bc0a967a3e1?w=3348&h=1840&f=png&s=1582839)\n\nDjango 自带后台\n\n![](https://user-gold-cdn.xitu.io/2018/2/21/161b6c47b50b6827?w=3356&h=1768&f=png&s=365303)\n\n前后端分离怎么能少的了 rest api 的实现与便捷的前端调试？\n\n![](https://user-gold-cdn.xitu.io/2018/2/21/161b6c5522e83368?w=3346&h=1840&f=png&s=486772)\n![](https://user-gold-cdn.xitu.io/2018/2/21/161b6c7ad6641b0a)\n\nDjango Debug Tools 帮你迅速调优接口\n\n![](https://user-gold-cdn.xitu.io/2018/2/21/161b6c782bf2a593?w=3348&h=1838&f=png&s=735083)\n\n> 我们再先看看能看得见的开发界面\n\n在终端执行 tmuxinator start yavueblog 就可以自动运行所有任务\n\n前端运行状态\n\n![](https://user-gold-cdn.xitu.io/2018/2/21/161b6d2d904bb3aa?w=3360&h=2054&f=png&s=539522)\n![](https://user-gold-cdn.xitu.io/2018/2/21/161b6d7172d15be3?w=3360&h=2054&f=png&s=2446065)\n\n后端运行状态\n![](https://user-gold-cdn.xitu.io/2018/2/21/161b6d5933c52727?w=3360&h=2054&f=png&s=3296514)\n![](https://user-gold-cdn.xitu.io/2018/2/21/161b6d8ce415395c?w=3360&h=2054&f=png&s=2720324)\n![](https://user-gold-cdn.xitu.io/2018/2/21/161b6d9ff1f2efb1?w=3360&h=2054&f=png&s=3932296)\n\n当然，你可以直接用客户端连接到对应的服务商检查组件的运行状态\n\n![](https://user-gold-cdn.xitu.io/2018/2/21/161b6db1754b4e8b?w=3352&h=1430&f=png&s=640103)\n![](https://user-gold-cdn.xitu.io/2018/2/21/161b6d949bd83c81?w=3352&h=1126&f=png&s=532337)\n\n## 0x02 系列教程目录\n\n### 2.1 教程注意项\n\n1. 本文的开发环境配置仅仅限于 macOS 上，如果读者使用的是 Windows / 可能需要自己搞定环境的配置。不过笔者使用了 Docker 进行环境配置，应该配置环境会省事很多。\n2. 在阅读本教程，请读者至少跟着 Django 官方的教程跟着走一遍。不要零基础一通瞎搞。\n3. 如果在使用过程中出现问题，请在 ISSUE 提供尽可能多的信息，将问题描述清楚。\n\n本系列教程并不按照一步一步增加代码的方式写教程。\n\n我先带着大家搭建好整个项目框架，然后从不同的视角开介绍这个项目，比如：\n\n1. 某个模块的 models 是如何设计的？有哪些卧槽居然可以这么用的写代码方式。\n2. Django User 如何做扩展？同样在 Django 的生态圈里面，哪些场景有哪些值得围观的包，比如 guardian\n3. Restful API 应该如何写，Django 里面的 Rest API 应该如何写？会有哪些生产效率 guangguangguang 提升上去的使用方法？权限怎么做？限流怎么搞？\n4. Py.test TDD 测试驱动开发了解一下？\n5. 使用 Tmux 等合理工具的优雅的单终端多开。\n\n### 2.2 教程目录\n\n- Django 全栈开发教程 - 2018 年不容错过的 Django 全栈项目 -- 目录篇\n- Django 全栈开发教程 - YaDjangoBlog 的开发环境配置\n- Django 全栈开发教程 - YaDjangoBlog 的后端组件配置\n- Django 全栈开发教程 - YaDjangoBlog 的前后端初步设计\n- Django 全栈开发教程 - YaDjangoBlog 的后端初步实现\n- Django 全栈开发教程 - YaDjangoBlog 的前端实现 YaVueBlog\n- Django 全栈开发教程 - YaDjangoBlog 的后端组件之 Redis\n- Django 全栈开发教程 - YaDjangoBlog 的后端组件之 PostgreSQL\n- Django 全栈开发教程 - YaDjangoBlog 的后端组件之 Elasticsearch\n- Django 全栈开发教程 - YaDjangoBlog 的后端组件之 RabbitMQ\n- Django 全栈开发教程 - YaDjangoBlog 的生产环境部署\n\n## 0xEE. 参考链接\n\n还犹豫啥，快上车吧\n\n- 前端代码 https://github.com/twocucao/YaVueBlog\n- 后端代码 https://github.com/twocucao/YaDjangoBlog\n\n---\n\nChangeLog:\n\n- **2018-02-21** 重修文字\n"},{"tags":["Python","Django","YaDjangoBlog"],"path":"20180220_UnKnownCheatSheet.md","title":"Unknown Cheatsheet","slug":"Unknown Cheatsheet","date":"2018-02-20","category":"Django","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n> 写在前面的话：不好意思，标题难以免俗，起了个很俗气的名字。\n\n这是我的一个全栈类型 Django 开源项目的系列讲解教程的目录。目的总的来说有两个：\n\n1. 一是希望更多的人通过本系列的教程更好的认识 Django 开发技术栈或者说是 Web 开发技术栈，让更多的 Pythonist 更顺畅的进入 Django 开发的世界。\n2. 二是希望借由这个持续更新的过程让自己更加深入理解 Django 技术栈 Django / DjangoRestFramework / Docker / Vue.JS / Celery / PostgreSQL / Redis / RabbitMQ\n\n> 生命苦短，我用 Python\n\n为什么说这个项目你不容错过？\n\n- 新！新！新！保持最新的软件开发版本，E.G: Django 2.0 + Vue.JS 2.5 + PostgreSQL 10 + Celery 4.1.0\n- Django 框架：Django 及其 强大的生态圈\n- 后端组件：PostgreSQL RabbitMQ Redis Ngnix\n- 前端技术：单页应用 前后端分离 (VueJS+Webpack+DjangoRestFramework), 自动化部署\n- Django 社区最佳实践：从配置 / 开发 / 测试 / 部署 **全干**工程师 (Full Stuff Engineer) 的最新的 DevOps 思考成果。\n- 基本覆盖了进阶 Django 开发所需要的各种组件与操作。\n- 只需要适当的调整，本项目就可以成为你新开项目的最佳脚手架。\n\n本系列文章的面向读者：\n\n- 目标是 DevOps 的 Pythonist\n- 爱瞎几把折腾的 Pythonist\n- 前后端分离的实践者\n\n> 生命苦短，赶快上车\n\n## 0x01 项目介绍\n\nYaDjangoBlog 是另一个关于博客的轮子，但是其野心并不在于仅仅多造一个博客系统，还有通过本项目做 Django 全栈开发的最佳实践。\n\n### 1.1 项目地址\n\n- 前端代码 https://github.com/twocucao/YaVueBlog\n- 后端代码 https://github.com/twocucao/YaDjangoBlog\n\n### 1.2 项目技术栈\n\n- 开发与部署环境为 Docker\n- Python 3.5.2\n- 前端 Vue + Webpack + ES2015 + axios\n- 后端 [Django 2.0](https://github.com/django/django) + [DjangoRestFramework](https://github.com/tomchristie/django-rest-framework/) + Celery\n- 自动化部署选用工具 Ansible 以及 Docker\n- 后端组件\n  - ElasticSearch 用于搜索和推荐\n  - PostgreSQL 用于数据持久化\n  - Redis 用于 Session / 和缓存\n  - RabbitMQ 分布式队列 / 定时任务\n  - Nginx 用于反向代理\n\n### 1.3 特别感谢\n\n- ansible django stack: https://github.com/jcalazan/ansible-django-stack\n- cookiecutter-django: https://github.com/pydanny/cookiecutter-django\n- djangopackages: https://github.com/djangopackages/djangopackages\n- 董伟明 关于 ElasticSearch 的几篇文章 http://www.dongwm.com/archives/%E7%9F%A5%E4%B9%8ELive%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E4%B9%8B%E4%BD%BF%E7%94%A8Elasticsearch%E6%90%9C%E7%B4%A2/\n- 各个组件的开发者们\n  - ElasticSearch\n  - PostgreSQL\n  - Redis\n  - RabbitMQ\n  - Nginx\n  - Docker\n\n## 0x02 系列教程目录\n\n### 2.1 教程注意项\n\n1. 本文的开发环境配置仅仅限于 macOS 上，如果读者使用的是 Windows / 可能需要自己搞定环境的配置。不过笔者使用了 Docker 进行环境配置，应该配置环境会省事很多。\n2. 在阅读本教程，请读者至少跟着 Django 官方的教程跟着走一遍。不要零基础一通瞎搞。\n3. 如果在使用过程中出现问题，请在 ISSUE 提供尽可能多的信息，将问题描述清楚。\n\n> 本系列教程并不按照一步一步增加代码的方式写教程。我先带着大家搭建好整个项目框架，然后从不同的视角开介绍这个项目，比如：\n\n1. 某个模块的 models 是如何设计的？有哪些卧槽居然可以这么用的方式。\n2. Django User 如何做扩展？同样在 Django 的生态圈里面，哪些场景有哪些值得围观的包，比如 guardian\n3. Rest API 应该如何写，Django 里面的 Rest API 应该如何写？会有哪些生产效率 guangguangguang 提升上去的使用方法？权限怎么做？限流怎么搞？\n4. Py.test TDD 测试驱动开发了解一下？\n\n### 2.2 教程目录\n\n- Django 全栈开发教程 - Python 和 Docker 环境配置\n- Django 全栈开发教程 - YaDjangoBlog 博客的后端组件配置\n- Django 全栈开发教程 - YaDjangoBlog 博客的前后端初步设计\n- Django 全栈开发教程 - YaDjangoBlog 博客的后端初步实现\n- Django 全栈开发教程 - YaDjangoBlog 博客的前端实现 YaVueBlog\n- Django 全栈开发教程 - YaDjangoBlog 博客的后端组件之 Redis\n- Django 全栈开发教程 - YaDjangoBlog 博客的后端组件之 PostgreSQL\n- Django 全栈开发教程 - YaDjangoBlog 博客的后端组件之 Elasticsearch\n- Django 全栈开发教程 - YaDjangoBlog 博客的后端组件之 RabbitMQ\n- Django 全栈开发教程 - YaDjangoBlog 博客的部署\n\n于是，本文的内容就如下：\n\n- 前后端分离\n- 自动化部署\n- 数据库相关\n- 其他踩坑经历\n\n<!-- more -->\n\n## 0x01 前后端分离\n\n前后端分离是提高团队开发的一个重要的开发策略，前后端分离之后，后端和前端交流好 JSON 格式，并行开发，局域网中放置一台服务器，后端写好一个功能，推送代码，由 gitlab 触发 Runner 自动交付到局域网的服务器上。这样的话，前后端可以并行开发，从而摆脱每一次开发过程不可避免，前端编写模板，然后由后端套用模板，出了问题，前端修改模板，后端接着修改模板... 循环往复，不曾更改的问题，在这种职责分明的情况下也不会出现背锅侠的问题。\n\n在往常的开发过程中，而如果 Ajax 比较多或者前端写的代码质量稍微低一些，那么倒霉的事情就发生了，后端和前端的沟通成本那是相当的高。推锅的事情也会发生。\n\n而新的开发过程中，如果上级有界面上的需求，基本上只需要前端更新一下代码，推送，就可以立即看到效果。\n同样的，后端也是如此。\n\n> 这就是我选择前后端分离的初衷 -- 将主要的精力放在开发上面。而不是套用模板和编辑 Ajax 过程中带来的沟通问题。\n\n在前后端配合上：\n\n- 后端选择 Django,Restful 框架选择了 DjangoRestFramework, DRF 的优点在于可以自动生成 API 界面，让前端对照着表单进行请求接口的测试。于是局域网的那一台可以配置为 Debug 模式，生产机器就可以关闭 DEBUG 模式。\n- 前端选择 VueJS, 选择这个小而精美的框架一方面是基于团队的开发水平考虑，如果使用太激进的框架 React, 可能遇到问题无法在短时间内解决。由于选用了 VueJS, 也就选用了 Vue 全家桶，通过 Webpack2 进行配置完成基本的打包任务，通过 config 读取环境变量进行生产环境和发布环境的 apiurl 的分离\n- 代码提交选择 Coding.NET 用于提交代码，在局域网中选择 Gitlab 用于提交代码，配上 Gitlab CI 进行持续集成，每次提交代码直接直接构建本地发布。前后端合作亲密无间。\n\n前后端分离有什么缺点呢？\n\n1. 必须强行升级 Https\n2. 开发时候需要关掉 Django 的同源策略\n3. IE8-- 不兼容\n\n### 1.1 Django 和 他的小伙伴们\n\nDjango 适用于快速开发，对于创业公司来说，是不错的快速开发语言。\n\n不仅仅是因为 Python 表达力比较强，更重要的是 Django 有很多高质量的包可以使用。\n\n- Django Debug Toolbar\n- DjangoRestFramework\n- Django Extensions\n\n### 1.4 Django 的奇技淫巧\n\n#### Django Model\n\n- [Save If Changed](http://stackoverflow.com/questions/1355150/django-when-saving-how-can-you-check-if-a-field-has-changed)\n\n## 0x02 自动化部署\n\n写程序 一般就是开发测试部署。\n\n话虽然这么时候，但是在具体的实践过程中，还是有很多很多坑需要注意的。\n\n比如，仅仅就开发环节来说，团队协作怎么搞？你说可以用 GIT 作为版本管理工具，代码托管。那我问你，这个 Web 开发过程中前端开发模板，后端套用模板怎么搞？你说，前后端分离，那前后端分离后 Http 请求被劫持怎么办，跨站攻击怎么搞......\n甚至如果是一个人开发的话，直接拉一台服务器做做部署，定期更新到网站上就行了。但如果是团队协作呢？前端提交了代码，产品经理过来说，你更新一下服务器，后端提交了代码，前端过来说，你更新一下服务器，过程琐碎而耗时。大量的时间就浪费在了这种枯燥的事情上了。两个后端，一个前端的情况下，每天本地发布（交付）的次数就已经是相当惊人（大概是前后端每天提交 5 次左右），如果以后是 3 个后端，三个前端，那我作为主程，每天就写不了代码了，这种情况是断不能忍的。\n\n这个时候，就需要想着把团队协作开发流程优化好：\n\n在我刚开始进行开发的时候，使用 bash 配合 Ansible 在本地和上线的 Ubuntu 16.04 上面自动化能够自动化的大部分工作，程序员在本地开发的时候，只需要进行开发，然后推送代码到 repo, 剩下的诸如自动化测试集成到系统中，则全部自动化。\n\n### 2.1 使用场景\n\n经过研究，我确定了理想中的使用场景：\n\n> 前端与后端提交代码到代码托管上面的时候，直接集成，构建，Stage 到服务器。\n\n> 到上线的时候，由我执行 Ansible 进行上线。\n\n### 2.2 实施方案\n\n在这个流程中，我需要安装如下的软件：\n\n- Gitlab Gitlab-CI-Runner : 用于解决代码托管，项目的基本成长，以及持续化集成\n- PostgreSQL\n- MongoDB\n- Redis\n- RabbitMQ\n- Nginx\n- Python 以及 Python 扩展的依赖包\n- 其他\n\n配置文件为 3 类：\n\n- test\n- stage\n- production\n\n硬件设备 3 台：\n\n1. 第一台为 Gitlab 部署的软件\n2. 第二台为 Stage 环境 （本地局域网持续交付）的机器\n3. 第三台为 Server （阿里云） 机器\n\n> 注：最初使用 Ubuntu 机器，最终确定使用 Docker 镜像进行构建\n\n### 2.3. 持续交付\n\n当前端工程师 Push Master 分支到 Repo 上的时候，执行 Job 更新网站\n当后端工程师 Push Master 分支到 Repo 上的时候，执行 Job 更新网站\n\nPush Master 分支，这个自然无需多说，问题是怎么执行 Job 呢？\n\n> **Gitlab CI Multi Runner**\n\n在一台 stage 的机器上安装 gitlab ci multi runner , 并且在该机器上注册 runner 为 shell , 这意味着 runner 会以 gitlab-runner 用户的权限进行测试 , 你需要 uninstall\n然后 install --user=root 一下，然后重启，即可在 gitlab-ci.yml 上。\n\n修改文件\n\n```bash\n\ngitlab-runner register # 然后填入相关信息\nvim /etc/gitlab-runner/config.toml # 接着进行修改\n```\n\n```bash\nconcurrent = 1\ncheck_interval = 0\n\n[[runners]]\n  name = \"yadjangoweb\"\n  url = \"http://192.168.1.139/ci\"\n  token = \"325asd65f4e7xa9faasda8da\"\n  executor = \"shell\"\n  [runners.cache]\n```\n\n### 2.4. Dockerize Application\n\nDocker 以其轻量级和类似于版本管理的软件方式吸引了我。于是，准备将所有的 Service 都 Docker 化。\n\n拿 Django 程序来说，首先 Django 程序依赖三个组件 redis / postgresql / rabbitmq , 完成这些组件的安装之后才能进行下一步的操作。\n\n## 0x03 数据库相关\n\n### 1. 数据库设计\n\nPostgreSQL Array 在爬虫方面可以用来标记一个 Record 的处理状态\nPostgreSQL Range 用来判断范围也是一个比较高效的选择（用空间 gist 索引取代两个索引）\n\nGeoDjango 和 PostGIS 非常配\n\n### 2. 数据迁移\n\n#### 1.1. 第一次数据迁移之 MySQL 转 PostgreSQL\n\n第一次数据迁移的时候基于 PostgreSQL 社区里面有个大杀器，叫做 PostGIS, 通过 PostGIS, 可以很方便的拥有和国内一些地图公司匹敌的算法。抛开算法实现的效率问题，基本上可以满足日常的开发需求，当时数据量不算大，使用 mysqldump 下来也就 500M 左右，而且行数大约 700W 条，于是使用了一个很笨的方法，就是将数据库使用 Django 命令 dump 成 json, 接着修改配置重新导入新数据库。\n\n这种方式的缺点就是效率低而且太吃内存了，当时 16G 的服务器满内存，满交换内存地搞了一个上午。\n\n#### 1.2. 第二次数据迁移之重新 makemigrations\n\n为什么要重新 makemigrations 呢，因为糟糕的事情发生了。\n\n有个需求，需要重新定制用户登录认证系统。用户登录认证系统是最最应该在项目开始的时候编写的，这就是项目的基石，这个需求就恰似在房子盖到第三层的时候突然要把地基给加固。\n\nDjango 中如果使用了 auth 模块，则 auth.user 是最先被迁移到数据库中的，而如果你经过权衡继承 AbstractUser 并且 makemigrations 生成个迁移文件 0001_initial.py 后，在正常的情况下不容易将 migration 修改应用到数据库中。\n\n> 如果我偏要勉强呢？\n\n当然是可以勉强的，删掉数据库中已经记录下来的 auth.user migration 的相关记录即可。\n\n那我为什么还是需要重新编写 migration 呢？\n\n1. 因为之前对数据库的结构调整比较频繁，多达 138 次，而在 138 次调整数据结构之后，再去撤销第一次数据表的迁移操作的时候，则无异于厨子做菜要把牛排做 8 分熟，但是厨子做到 7 分熟的时候，突然顾客说，我要 5 分熟的牛排。那只能重新来了。\n2. 顺手精简掉 138 个文件。\n\n如何做呢？\n\n1. 数据的迁移在没有表与表之间的关联的时候是很好办的，CSV, 标准 SQL 文件。\n2. 有表关联的情况下则需要权衡数据量来进行迁移，假如数据量在 10 来个 G 的时候，读到内存中，按照数据表的依赖关系，自下而上逐层迁移即可。\n3. 数据量大的时候，则需要去约束，去索引，然后转 CSV/SQL, 迁移到数据表中。如果表依赖不复杂的话，直接 psql 命令重定向数据也可以。\n\n但是呢，由于使用了 Django, 在数据量不大的时候，完全可以使用 Django 的 ORM 来做迁移。\n\n我在 Google 了一下，发现下面一个脚本，于是设置数据库为新数据库 default 和 depressed\n\n```python\ndef batch_migrate(model):\n    # remove data from destination db before copying\n    # to avoid primary key conflicts or mismatches\n    if model.objects.using('default').exists():\n        model.objects.using('default').all().delete()\n\n    # get data form the source database\n    items = model.objects.using('depressed').order_by(\"pk\").all()\n    count = len(items)\n    # process in chunks, to handle models with lots of data\n    for i in range(0, count, 10000):\n        chunk_items = items[i:i + 10000]\n        print(\"已经迁移数据\", i)\n        model.objects.using('default').bulk_create(chunk_items)\n\n    # many-to-many fields are NOT handled by bulk create; check for\n    # them and use the existing implicit through models to copy them\n    for m2mfield in model._meta.many_to_many:\n        m2m_model = getattr(model, m2mfield.name).through\n        batch_migrate(m2m_model)\n```\n\n按照表与表之间的依赖关系，逐个迁移到数据库中搞定。\n\n### 1.3 sequence 问题\n\n在写 Django 的时候发现的时候无论如何都无法保存新的 item.\n\n原来的代码为：\n\n```python\nitem = Item.objects.get_or_create()\nitem.foo = 1\nitem.save()\n```\n\n报错信息是 Integrety, 报 duplicated 错误（下面的代码当然是打了马赛克了）\n\n```python\ndjango.db.utils.IntegrityError: duplicate key value violates unique constraint \"foo_item_pkey\"\nDETAIL:  Key (id)=(111111) already exists.\n```\n\n那么，问题来了：\n\n> ~~挖掘技术哪家强？~~\n\n啊，不是\n\n> How To Solve This?\n\n经过猜测，而 get 到已有的 item 设置并且保存的话，并不会出现这个问题。问题主要出在 create 上面。\n\n于是编写代码验证一下是不是猜想正确\n\n```python\ntry:\n    item = Item.objects.get()\nexcept Exception:\n    item = Item.objects.create()\n\n# do something\n\nitem.save()\n```\n\nduplicate 的问题肯定是多次存同样的不能重复的字段。\n\n**但尼玛，我之前做测试的时候考虑过这个逻辑呀？**换而言之，这种问题不应该出现，如果出现了问题，八成是 ORM 用的不对。\n\n印象中这种问题 Google 一下 Integrety Duplicate Django PostgreSQL 一般就能出来了。\n\n最后找到解决方案：http://centoshowtos.org/web-services/django-and-postgres-duplicate-key/\n\n在终端进入 psql 查询 sequence 最新值\n\n```sql\nselect start_value, last_value, max_value from dt_crawler_item_item_id_seq;\n\n start_value | last_value |      max_value\n-------------|------------|---------------------\n           1 |    111110 | 9223372036854775807\n```\n\n而我们查看一下 item_id 的最大值\n\n```\nselect max(item_id) from app_model_item;\n\n   max\n---------\n 111111\n```\n\n重置 sequence last_value 值到最新即可。\n\n```\nalter sequence app_model_item_item_id_seq restart with 111111;\n```\n\n> 当数据库每次插入一条非指定主键的记录，则获取 last_value(111110), 加 1 得到当前的主键接着插入。但这个过程无异于数据库中已经有了一个 pk 为 111111 的记录，再插入一条。于是报错。\n\n回顾这个问题，该问题是由于 PostGres 的 sequence 造成 pkey 相等，换而言之，postgres 应该在有一个 pk 值为 111111 的时候，插入一个无主键的记录，PostgreSQL 获取 sequence+1(111110 + 1) 得到它认为当前的主键值，接着再一次插入了主键为 111111 的这个值。\n\n这个过程相当于依次插入两个条 ID 相同的记录。\n\n```sql\nINSERT INTO table(id, column2, …) VALUES (111111, value2, …);\nINSERT INTO table(id, column2, …) VALUES (111111, value2, …);\n```\n\n> sequence 避免了每一次 max 查找带来的性能损失，一方面带来了方便，也带来了隐藏的坑。\n\n如果以后这个问题比较多的话，参考下面的源码对文本进行修改。\n\nhttps://github.com/ASKBOT/django-postgresql-fix-sequences/blob/master/postgresql_sequence_utils/utils.py\n\n## 0x04 WebServer\n\n目前使用的 WebServer 是用 Nginx 做反向代理，将请求通过 unix socket 转发到 gunicorn，gunicorn 作为 django 实际上的 webserver。\n\n### unix socket 和 gunicorn 的 REMOTE_ADDR 问题\n\nDjango Admin 模块在访问 某个页面的时候特别特别慢，而在我的机器上一切正常，我怀疑的是数据库的问题，于是，那么首先要知道数据库的查询语句，于是想借用 django debug toolbar 来 profiling, 于是问题来了，我在局域网模拟真机环境，结果无论如何都无法呈现 Django Debug Toolbar,\n\n问题八成出现在 Django 配置环境 或者 Nginx 上面（当然，最后发现是 Gunicorn 的锅）. 在\n\n经过一段时间的排查，认为是 Nginx 的问题，在相关配置添加下面设置 Header,\n\n```python\nproxy_set_header X-Forwarded-For $remote_addr;\n```\n\n结果依旧无法获取 request.Meta[\"REMOTE-ADDR\"]\n\n经过搜索发现不止我一个人的问题：https://github.com/benoitc/gunicorn/issues/797\n\n最后发现是 Http 请求从 nginx 这儿经过 unix socket 转发到 gunicorn.sock 下默认是没有赋值 REMOTE-ADDR 的，\n\n那么，这个在 HTTP Header 层次的东西，没有在 gunicorn 层次解决，那就只能在 django 层次解决。\n\n给 Django 添加中间件如下，放在 djangodebugtools 的前面。\n\n```python\nclass XForwardedForMiddleware(MiddlewareMixin):\n    def process_request(self, request):\n        if request.META.get(\"HTTP_X_FORWARDED_FOR\", False):\n            request.META[\"HTTP_X_PROXY_REMOTE_ADDR\"] = request.META[\"REMOTE_ADDR\"]\n            parts = request.META[\"HTTP_X_FORWARDED_FOR\"].split(\",\", 1)\n            request.META[\"REMOTE_ADDR\"] = parts[0]\n```\n\n解决。\n\n### Nginx Gzip 压缩\n\n当 json 数据量比较大的时候，则必须要考虑开启压缩。一般情况下，虽然这个可以在 Django 层次完成，但是这么做还不如在 nginx 层次完成。\n\n```python\n    gzip on;\n    gzip_disable \"msie6\";\n    gzip_vary on;\n    gzip_proxied any;\n    gzip_comp_level 6;\n    gzip_buffers 16 8k;\n    gzip_http_version 1.1;\n    gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;\n```\n\n开启之后，我这边的 一个 220k 的数据缩减到 54k\n\n## 0x04. 其他踩坑相关\n\n### 4.1 奇怪的文件问题\n\n在某一天遇到了一个问题 往常的时候，当文件上传到 Django 中的时候，都可以正常的解析，但是这两天居然不能用了。\n\n```python\n# 问题代码出现在\ndf = pd.read_excel(file_obj)\n# 报这个问题 google 几乎没有什么解决方案\nInvalid file path or buffer object type\n<class 'django.core.files.uploadedfile.InMemoryUploadedFile'>\n```\n\n更加糟糕的问题出现了，我本人的开发环境和服务器的开发环境基本一致，但，但，但为什么不能用呢？\n\n分别回滚代码，Nginx 设置，在线上打 Log, 最终确定了是 Pandas 从 0.19 升级到了 0.20 之后出现的一个小问题。最终还原线上 python 安装环境，搞定。\n\n## 0xEE. 参考链接\n\n---\n\nChangeLog:\n\n- **2018-02-21** 重修文字\n"}],"total":8}},"__N_SSG":true}