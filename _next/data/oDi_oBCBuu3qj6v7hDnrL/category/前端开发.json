{"pageProps":{"category":{"name":"前端开发","posts":[{"tags":["React"],"path":"20201202_React_Stack.md","title":"我的 React 技术栈","slug":"我的 React 技术栈","date":"2020-12-02","category":"前端开发","lastMod":"2020-12-01","description":"未描述","thumbnail":"","content":"\n# 我的 React 技术栈\n\n## 0x00 前言\n\n16 年 ~ 20 年先后折腾过\n\n1. vue 2\n2. angular 4\n3. react class component\n4. angular 4\n5. react hooks\n6. vue 3\n\n综合考虑了\n\n- 开发工具链\n- 社区生态\n- 跨端方案\n- 与 Typescript 的结合程度\n\n最后形成了较为稳定的 react 技术栈\n\n## 0x01 桌面端\n\nhttps://github.com/twocucao/react-starter\n\n- react hooks\n- typescript\n- mobx\n- css tailwindcss\n- format with prettier\n- lint with eslint\n\n## 0x02 移动端\n\nhttps://github.com/twocucao/react-starter\n\n## 0x03 小程序端\n\nhttps://github.com/twocucao/react-starter-remaxjs\n\nhttps://github.com/twocucao/react-starter-taro\n\n- All Feature Supported By RemaxJS\n- Type Hint - Typescript for better multi-user developing experience\n- style management - tailwind like utils which called minimal.css\n- store management - mobx-react-lite\n- components management - mostly functional components plus react hooks\n- auto lint && format by eslint && prettier && husky\n- optimized only for wechat mini-app\n\n## 0x04 RN\n\n> 无完整上线经历，不做评论\n\n## 0x05 桌面 electron\n\n> 热更新速度很快\n\n---\n\nChangeLog:\n\n- **2020-12-01** 重修文字\n"},{"tags":["VueJS","项目经验"],"path":"20180801_VueProjectTalking.md","title":"Vue 项目漫谈 2018 版","slug":"Vue 项目漫谈 2018 版","date":"2018-08-01","category":"前端开发","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n之前草草整理过一些 Vue 的小技巧，最近温习了一遍文档，重聊一遍。\n\n鉴于 VueCLI 越做越臃肿，我最后还是选择了自己搭架子。\n\nhttps://github.com/twocucao/vue-starter-kit\n\n## 0x01 项目结构\n\n```bash\n# 根文件\npublic/ # 部署文件\nsrc/ # 源码\n.babelrc\n.editorconfig\n.eslintignore\n.eslintrc\n.gitignore\n.postcssrc.js\nLICENSE\nREADME.md\njsconfig.json\npackage-lock.json\npackage.json\nwebpack.common.js\nwebpack.dev.js\nwebpack.dll.js\nwebpack.prod.js\n```\n\n<!-- more -->\n\n```bash\n# 在 src 文件夹下面\n\napi # 相关的 Web API 定义\nassets # 静态资源，对于已经压缩的，还是直接放在 Static 下面\ncomponents # 公用组件\nmixins # mixin\ndirectives # 定义指令，比如 v-loading\npages # 页面\nstore # Store\nApp.vue # CORE 组件\nconsts.js #定义常量名称\nindex.js # 用于初始化项目，注册组件等等\nroutes.js # 路由\nutils # 工具方法\n```\n\n值得一提的就是 index.js 应该要做的事情\n\n- 注册全局组件和过滤器\n- 给 Vue 实例加戏，哦，说错了，给实例加一些全局性的方法，比如 $comfirm 等对话框 $verbose $warning 等日志\n- 完成刷新界面之后的从 localStorage 的重新赋值\n- 注册路由切换的时候的调用的各类方法\n\n## 0x02 开发技巧\n\n### 1. 登录，登录校验以及权限\n\n通过路由的 meta 属性来区分\n\n### 8. 日志管理\n\n我觉得日志管理也应该是比较重要的部分，不管是调试程序，还是用于检查用户浏览器这块的错误日志，甚至是埋点。\n\n依据具体技术栈可以考虑上个 sentry 或者 ELK\n\n### 7. 首屏 Loading\n\n这个可以放在 index.html 里面\n\n### 4. 路由管理与嵌套路由\n\n路由管理\n\n嵌套路由有什么优点？\n\n1. 使得子路由里的页面可以复用父级路由的页面的组件\n2. 减少手动硬编码 meta 和 props 的代码量\n3. 便于定制面包屑组件\n4. 其他\n\n## 0x03 构建技巧\n\n### 3.1 离线 IconFont\n\n经常需要离线调试网页，顺手写了这个脚本。\n\n之前在研究某个网站的反爬机制的时候发现时动态生成 iconfont, 然后通过 unicode 码来实现数字的显示，从而让爬虫小白无法爬取。研究了一下他们的 iconfont, 知道了 font-carrier, 然后调用 node 脚本打包字体文件，并在这个过程中自动生成对应的 iconfont.css\n\n最后的结果就是，当我放一个文件到 svg 文件夹下面的时候，比如 bank.svg , 我执行一下脚本，生成对应的字体文件，在 html 里面编写脚本\n\n```\n<span class=\"iconfont iconfont-bank\" ></span>\n```\n\n然后对应图标就呈现出来了。\n\n### 3.2 Webpack 构建工具\n\n日常开发用的是 VueCli, 配置还是非常人性化的。开箱即用。\n\n#### 开发环境与部署环境\n\nVueCLI 内置了变量的管理，你可以定义 config/dev.js\n\n```javascript\nmodule.exports = merge(prodEnv, {\n  NODE_ENV: '\"development\"',\n  API_ROOT: '\"http://dev-data.twocucao.xyz\"',\n})\n```\n\n其实，开发的环境用一组变量是不行的。比如，开发的人分为纯前端，纯后端，我这样的前后都会一些的人，每个对于环境的配置都是不太一样的。\n\n- 对于前端 Windowser 直接执行 npm run dev 对接到局域网服务器\n- 对于单个人同时调试后端和前端的时候，一般要把 Web API 对应到本地的机器上。可是使用环境便来配置不同的 DEBUG_MODE=True npm run dev\n\n```javascript\n\n```\n\n#### DLL 打包\n\n大约在半年前，开发过程中突然在使用 ECharts 后，仅仅不到 10M 大小的项目居然开发 build 的时间需要 5MIN, 打包出来的文件超级大。居然接近了 100 多 M\n\n震惊之余，差点准备写一篇骗点击量的文章：**看完震惊了！！前端和后端男程序员都无法忍受的大小！**, 然后文章内就介绍 Webpack 打包文件居然没有避免重复引入依赖库导致打包文件太大提出抗议。\n\n回到主题，使用 npm run analyze 发现问题出现在 ECharts 上， 每一个图表组件都是依赖于 ECharts, 而每一个组件都包含了一个完整的 ECharts 库的大小。\n\n于是，我一边吐槽 webpack 考虑不周，另一方面寻找解决方案。最后找到了 DLL 方案\n\n这个方案的原理大致是：\n\n- 编写独立的脚本，把几个需要复用的库一个配置文件 (manifest.json), 以及打包库到一个 JS 文件中。\n- 然后从 index.html 引入这个 JS 文件。\n- 接着在 webpack 配置中使之每次引入一个库的时候，避免重复引入。\n\n> 但这不应该是 Webpack 本身就应该做的吗？为嘛还要配置，还要不伦不类的生成一个配置文件和一个 JS 文件，再从 index.html 里面导入？\n\n当然，Webpack 生态还是很丰富的，后来出来了一个 https://github.com/asfktz/autodll-webpack-plugin 尝试了之后。感觉很赞。\n\n```javascript\n\n```\n\n可惜在 mac 上一切安好，Windows 上晴天霹雳，debug 了一下，发现是这个库的一个依赖库对 windows 的路径处理好像还有点小问题。而公司的前端小伙伴是 Windowser, 只好作罢。\n\nMacer 可以先用试试，至于 Windowser, 那就去这个 ISSUE 下面催催作者吧... 哈哈哈\n\n> update: 现在 windows 已经可以用了。\n\n## 0x03 代码质量工程管理\n\n### 1. 语义化与可读性\n\n### 2. 提取公共逻辑（通过 Service, Mixin 来）\n\n### 3. CSS 管理\n\n在项目中，我采用 SCSS 来管理 CSS 代码，\n\n过去的时候有两种 css 的代码命名方法\n\n第一种，我管他叫做**配置式写法**，通过将 CSS 语法的几个片段转化成名称，从而实现快速配置出效果的的 CSS\n\n```css\n.fl {\n  float: left\n}\n\n.fr {\n  float: right\n}\n.mr10 {\n  margin-right: 10px\n}\n\n.pb10 {\n  padding-bottom: 10px\n}\n....\n```\n\n这种写法对于简单页面来说确实也是可以使用的。缺点就是当页面变得复杂一些的时候，则比较难控制这种短小精捍（不直观）的变量。比如\n\n```css\n.tmd01{\n  padding-bottom: 10px\n  font-size: 16px;\n  position: relative;\n  top: 0;\n  color: #2d3c48;\n  line-height: 1.6;\n}\n```\n\n> 请脑补一下我的黄人问号脸\n\n当然，如果用得好的话，自然是 OK, 如果用不好的话，\n\n后来进入了嵌套写法时代（感谢伟大的 Rails 社区出的 SASS）, 下面的语法都是 SCSS.\n\n第二种写法就变成了这样\n\n```scss\n.actions {\n  .card_wrapper {\n    .card {\n      .title {\n      }\n      .content {\n        .list {\n          .fa {\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n外加变量和 mixin 以及函数的话，基本上就可以完成代码的组织了。\n\n这种写法倒是比原来不知道高到哪里去了，但问题依旧存在，比如 title,content 这些玩意太多，完完全全的看不懂。更加糟糕的事情是，有的小伙伴直接是乱用嵌套，也不用伪类和伪选择器，从而达到单页面调出来小伙比较快，但因为代码不能重用，调多个页面的时候速度巨慢无比。\n\n```\n.apage {\n  bbizlogic {\n    .actions {\n      .card_wrapper {\n        .card {\n          .title {\n          }\n          .content {\n            .list {\n              .fa {\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n我本人推荐（其实我是写 Python Web 后端的，逃... ) 代码风格比较倾向于 BEM 命名，关于 BEM 的介绍，请参考简单心理团队的教程。\n\n- https://jiandanxinli.github.io/2016-08-11.html\n- https://juejin.im/post/58d0e5caa22b9d00643e8b51\n\n然而，最好的方式，就是读一个非常使用 SCSS 来组织项目的 CSS 代码的成熟项目。\n\n我推荐两个：\n\n- BOOTSTRAP V4: Bootstrap V4 使用 SCSS 来写\n- ELEMENT UI: 饿了么的团队出的，前段时间从 v1 版本升级到 v2 版本，发现网站大部分样式都没有出现大变动，在这里给个赞。\n\n#### 0. 先从整体上设计好骨架\n\n接着才是 HTML, 然后才是 CSS\n\n现在前端入行的人越来越多，很多的新手前端 er 会用比较快的思维来编写，这就导致代码质量奇差无比。\n\n- 哎，我看看，面粉加多了，我加点水，水加多了，我再加点面粉。\n- 哎，我看看，面粉又加多了，我加点水，水加多了，我再加点面粉。\n- 哎，我看看，面粉又加多了，我加点水，水加多了，我再加点面粉。\n- 哎，我看看，面粉又加多了，我加点水，水加多了，我再加点面粉。\n- 哎，我看看，面粉又加多了，我加点水，水加多了，我再加点面粉。\n\n当设计出来的网页本身的 HTML 写的就很混乱，CSS 能写的好在哪里呢？\n\n命名都很混乱，遑论代码可维护性？\n\n可以多去参考一些成熟的项目的 CSS 是怎么命名的呀，HTML 是怎么设计的呀\n\n#### 1. Scoped 的滥用\n\n我印象中，有个小伙伴把一个比较大的 CSS 库多次 import 到被 Scoped 的组件中，于是开发时猛然发现 head 处多了大量的 style 标签，除了 css 选择器后面随机的属性 hash, 文件内容都一样。\n\n> 公共组件往往可以通过嵌套和加前缀的方式来防止污染。如果 scoped 的属性里面有成吨的 style, 慎用 import.\n\n还有小伙伴喜欢在很多七七八八的组件各种 import scss. 其实对于中小型项目，完全可以直接全局一个文件 style 即可。\n\n我现在的做法，是直接在 src 的上方直接用 gulp 搭建一个只用来编译 SCSS 到 CSS 的项目，每次编译后输出到页面里面。\n\n如果项目是小项目，建议直接在 app.vue 里面 import pages\n\n```\n├── common\n├── fonts\n├── global.scss\n├── index.scss\n├── mixins\n├── pages.scss\n└── reset.scss\n```\n\n#### 2. 保持代码的通用性\n\n一般，当同一段逻辑出现三次的时候，是要停下来重构一下的，这样的话，就可以节省很多时间。\n\n套用在 CSS 的样式上也是如此。\n\n## 0x04 Tmux 和 Tmuxnator 打造工作流\n\n具体参考我的文章 [用 Tmux 和 Tmuxnator 打造工作流](l)\n\n---\n\nChangeLog:\n\n- **2017-09-25** 初始化本文\n"},{"tags":["Frontend"],"path":"20171228_AllStuffAboutCSS.md","title":"关于 CSS 你应该知道的一切","slug":"关于 CSS 你应该知道的一切","date":"2017-12-28","category":"前端开发","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n本笔记诞生于很久前零零散散记录的笔记，拿出来发布一下。\n\n## 0x01 CSS 是如何工作的？\n\nHTML 是元素的标记语言。\n\nCSS 被用来 样式和网页布局的。\n\n样式和布局都有哪些呢？\n\n- 字体\n- 颜色\n- 大小\n- 内容间距\n- 多列\n- 动画\n\n通过 DOM 树的节点和样式节点结合，生成渲染树，然后交给浏览器进行渲染从而使得外观发生变化。\n\n## 0x02 CSS 基本语法\n\nCSS 基本语法有三个组成部分：\n\n1. 规则\n2. 选择器\n3. 属性\n\n### 2.1 CSS 规则\n\n```css\nh1 {\n  colour: blue;\n  background-color: yellow;\n  border: 1px solid black;\n}\n\n// @规则\n\n@import @charset @media @font-face\n  /* in shorthand like padding and margin, the values are applied\nin the order top, right, bottom, left (the same order as an analog clock). There are also other\nshorthand types, for example two values, which set for example\nthe padding for top/bottom, then left/right */ padding: 10px 15px 15px 5px;\n```\n\n### 2.2 选择器\n\n```\n// Simple selectors: Match one or more elements based on element type, class, or id.\n/* All div elements are blue */\ndiv {\n    color: blue;\n}\n\nh1 {\n    color: red;\n    text-shadow: 1px 1px 1px black;\n    background: linear-gradient(to bottom, rgba(0,0,0,0.25), rgba(0,0,0,0.1));\n    padding: 3px;\n    text-align: center;\n    box-shadow: inset 2px 2px 5px rgba(0,0,0,0.5), inset -2px -2px 5px rgba(255,255,255,0.5);\n}\n\n// Attribute selectors: Match one or more elements based on their attributes/attribute values.\n/* All elements with the attribute \"data-vegetable\"\nare given green text */\n\n[data-vegetable] {\n    color: green;\n}\n\n/* All elements with the attribute \"data-vegetable\"\nwith the exact value \"liquid\" are given a golden\nbackground color */\n\n[data-vegetable=\"liquid\"] {\n    background-color: goldenrod;\n}\n\n/* All elements with the attribute \"data-vegetable\",\ncontaining the value \"spicy\", even among others,\nare given a red text color */\n\n[data-vegetable~=\"spicy\"] {\n    color: red;\n}\n\n// Pseudo-classes: Match one or more elements that exist in a certain state, such as an element that is being hovered over by the mouse pointer, or a checkbox that is currently disabled or checked, or an element that is the first child of its parent in the DOM tree.\n// Pseudo-elements: Match one or more parts of content that are in a certain position in relation to an element, for example the first word of each paragraph, or generated content appearing just before an element.\n\n:active\n:any\n:checked\n:default\n:dir()\n:disabled\n:empty\n:enabled\n:first\n:first-child\n:first-of-type\n:fullscreen\n:focus\n:focus-within\n:hover\n:indeterminate\n:in-range\n:invalid\n:lang()\n:last-child\n:last-of-type\n:left\n:link\n:not()\n:nth-child()\n:nth-last-child()\n:nth-last-of-type()\n:nth-of-type()\n:only-child\n:only-of-type\n:optional\n:out-of-range\n:read-only\n:read-write\n:required\n:right\n:root\n:scope\n:target\n:valid\n:visited\n\n// Combinators: These are not exactly selectors themselves, but ways of combining two or more selectors in useful ways for very specific selections. So for example, you could select only paragraphs that are direct descendants of divs, or paragraphs that come directly after headings.\n\nA, B\t匹配 A 或 B\nA B\t    匹配 A 里面的 B\nA > B\t匹配 A 里面的直属 B\nA + B\t匹配 A 下一个兄弟节点 B\nA ~ B\t匹配 A 的下一群兄弟节点 B\n\n// Multiple selectors: Again, these are not separate selectors; the idea is that you can put multiple selectors on the same CSS rule, separated by commas, to apply a single set of declarations to all the elements selected by those selectors.\n```\n\n### 2.3 属性\n\n#### Position\n\nhttp://cssreference.io/positioning/\n\n#### Display\n\n#### Box Model\n\n块级元素 (Block)\n新开始一行并且尽可能撑满容器，p,form,header,footer,section\n设置块级元素的 width 可以防止它从左到右撑满整个容器\n行内元素 (inline)\n包裹一些文字，而不会打乱段落的布局，a,span\nnone\nscript 默认 display:none,visibility:hidden 是占据空间\n\n盒模型\n\n属性\n\n三，层叠与继承\n\n既然是层叠，就要有层叠的规律\n\n## 0x03 CSS 新语法\n\n### 3.1 Flex Layout\n\n- https://github.com/philipwalton/solved-by-flexbox\n\n### 3.2 Grid Layout\n\n## 0x04 SCSS\n\n这是一种兼容 CSS 语法的新语言。主要用于提升代码的可维护性。\n\n至于其他 less 之类大同小异。只选取了功能最强大的部分进行间接。\n\n### 4.1 OOCSS / BEM / 我的实践\n\n### 4.1 如何组织 SCSS 代码 --- 布局篇\n\n### 4.2 如何组织 SCSS 代码 --- 组件篇\n\n#### 4.2 BEM\n\n## 0x05 CSS 规范\n\n- https://github.com/airbnb/css\n\n- Use soft tabs (2 spaces) for indentation\n- Prefer dashes over camelCasing in class names.\n  - Underscores and PascalCasing are okay if you are using BEM (see OOCSS and BEM below).\n- Do not use ID selectors\n- When using multiple selectors in a rule declaration, give each selector its own line.\n- Put a space before the opening brace { in rule declarations\n- In properties, put a space after, but not before, the : character.\n- Put closing braces } of rule declarations on a new line\n- Put blank lines between rule declarations\n\nOOCSS 与 BEM 混用\n\n> 只要是可维护的好代码，并不需要拘泥于用什么风格\n\n### 5.1 圣杯\n\n## 0xEE 参考链接\n\n- https://github.com/picturepan2/spectre\n\n---\n\nChangeLog:\n\n- **2017-12-20** 初始化本文\n"},{"tags":["VueJS"],"path":"20170915_ReadingVueDocuments.md","title":"VueJS 文档阅读笔记","slug":"VueJS 文档阅读笔记","date":"2017-09-15","category":"前端开发","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x01 Essential\n\n### 1.1 The Vue Instance\n\n当 Vue 实例被创建时，添加所有在 Data 对象中的属性到 Reactivity System 中。\n\n> 而创建之后添加赋值新属性，则不 Reactive\n\n而实例被创建之时，会自带前缀为 $ 的一系列属性和方法\n\n#### 1.1.1 内置方法和属性\n\n##### Instance Properties\n\nvm.$data\nvm.$props\nvm.$el\nvm.$options\nvm.$parent\nvm.$root\nvm.$children\nvm.$slots\nvm.$scopedSlots\nvm.$refs\nvm.$isServer\nvm.$attrs\nvm.$listeners\n\n<!-- more -->\n\n##### Instance Methods / Data\n\nvm.$watch\nvm.$set\nvm.$delete\n\n##### Instance Methods / Events\n\nvm.$on\nvm.$once\nvm.$off\nvm.$emit\n\n##### Instance Methods / Lifecycle\n\nvm.$mount\nvm.$forceUpdate\nvm.$nextTick\nvm.$destroy\n\n#### 1.1.2 生命周期\n\n![生命周期](https://vuejs.org/images/lifecycle.png)\n\n### 1.2 Template Syntax\n\nVueJS 编译 模板为 VirtualDOM render 函数，如果对 VirtualDom 非常熟悉的话，则可以使用\n\n#### 1.2.1 插值\n\n```\n# text\n{{ msg }}\n<span v-once> {{ msg }} <span>\n# raw html\n<div v-html=\"rawHTML\"></div>\n# attributes\n<div v-bind:id=\"dynamicID\"></div>\n# JS Expressions\n{{ number + 1 }}\n{{ ok ? 'YES' : 'NO' }}\n{{ message.split('').reverse().join('') }}\n<div v-bind:id=\"'list-' + id\"></div>\n```\n\n#### 1.2.2 指令\n\n- v-bind -> :\n- v-on -> @\n- v-on:submit.prevent=\"onSubmit\"\n\n### 1.3 Computed Properties and Watchers\n\n- 当使用 Computed 的时候，一旦其依赖的 reactive 的 data 发生变化之后，则其值发生变化。\n- 其实，可以在模板中调用方法，但只能在项目中。\n\n### 1.4 Class and Style Bindings\n\n#### 1.4.1 Object 语法\n\n```\n<div class=\"static\"\n     :class=\"{ active: isActive, 'text-danger': hasError }\">\n</div>\n```\n\n#### 1.4.2 Array 语法\n\n```\n<div v-bind:class=\"[isActive ? activeClass : '', errorClass]\"></div>\n```\n\n#### 1.4.3 组件\n\n```\n<my-component class=\"baz boo\"></my-component>\n\n<p  class=\"origin baz boo\">\n```\n\n### 1.5 Conditional Rendering\n\n```\n<h1 v-if=\"ok\">Yes</h1>\n\n<h1 v-if=\"ok\">Yes</h1>\n<h1 v-else>No</h1>\n\n<div v-if=\"type === 'A'\">\n  A\n</div>\n<div v-else-if=\"type === 'B'\">\n  B\n</div>\n<div v-else-if=\"type === 'C'\">\n  C\n</div>\n<div v-else>\n  Not A/B/C\n</div>\n```\n\n- v-if 是否\n- v-for 优先级高于 v-if\n\n### 1.6 List Rendering\n\n对于数组\n\n```\n<ul id=\"example-2\">\n  <li v-for=\"(item, index) in items\">\n    {{ parentMessage }} - {{ index }} - {{ item.message }}\n  </li>\n</ul>\n```\n\n对于对象\n\n```\n<ul id=\"example-2\">\n  <li v-for=\"(item, index) in items\">\n    {{ parentMessage }} - {{ index }} - {{ item.message }}\n  </li>\n</ul>\n```\n\n#### 1.6.1 ARRAY 修改检测\n\n##### 方法\n\n- push()\n- pop()\n- shift()\n- unshift()\n- splice()\n- sort()\n- reverse()\n\n##### 取代数组\n\nfilter\n\n##### 警告\n\n```html\n直接通过 index 对数组进行修改 不应该 vm.items[indexOfItem] = newValue 应该 //\nVue.set Vue.set(example1.items, indexOfItem, newValue) // Array.prototype.splice\nexample1.items.splice(indexOfItem, 1, newValue) 修改 length 不该 vm.items.length\n= newLength 应该 example1.items.splice(newLength)\n```\n\n> 猜测背后可能是因为这种方式是无法监测设置\n\n#### 1.6.2 Object 修改检测警告\n\n```javascript\njs 无法直接提供对\n\nthis.$set(this.userProfile, 'age', 27)\n```\n\n### 1.7 Event Handling\n\n#### 1.7.1 Listening to Events\n\n```html\n<div id=\"example-1\">\n  <button v-on:click=\"counter += 1\">Add 1</button>\n  <p>The button above has been clicked {{ counter }} times.</p>\n</div>\n```\n\nPS: 注意，前面 v-on v-bind 所有的绑定可以绑在方法上，也可以直接填单行表达式。可以提高可阅读性\n\n#### 1.7.2 Method Event Handlers\n\n可以绑定方法\n\n#### 1.7.3 Methods in Inline Handlers\n\n可以绑定方法加参数，配合 for / if\n\n#### 1.7.4 Event Modifiers\n\n事件修饰符\n\n```javascript\n.stop\n.prevent\n.capture\n.self\n.once\n```\n\n```html\n<!-- the click event's propagation will be stopped -->\n<a v-on:click.stop=\"doThis\"></a>\n<!-- the submit event will no longer reload the page -->\n<form v-on:submit.prevent=\"onSubmit\"></form>\n<!-- modifiers can be chained -->\n<a v-on:click.stop.prevent=\"doThat\"></a>\n<!-- just the modifier -->\n<form v-on:submit.prevent></form>\n<!-- use capture mode when adding the event listener -->\n<!-- i.e. an event targeting an inner element is handled here before being handled by that element -->\n<div v-on:click.capture=\"doThis\">...</div>\n<!-- only trigger handler if event.target is the element itself -->\n<!-- i.e. not from a child element -->\n<div v-on:click.self=\"doThat\">...</div>\n```\n\n#### 1.7.5 Key Modifiers\n\n```javascript\n.enter\n.tab\n.delete (captures both “Delete” and “Backspace” keys)\n.esc\n.space\n.up\n.down\n.left\n.right\n```\n\n```html\n<!-- same as above -->\n<input v-on:keyup.enter=\"submit\" />\n<!-- also works for shorthand -->\n<input @keyup.enter=\"submit\" />\n```\n\n#### 1.7.6 System Modifier Keys\n\n键盘\n\n```\n.ctrl\n.alt\n.shift\n.meta\n```\n\n```\n<!-- Alt + C -->\n<input @keyup.alt.67=\"clear\">\n<!-- Ctrl + Click -->\n<div @click.ctrl=\"doSomething\">Do something</div>\n```\n\n鼠标\n\n```\n.left\n.right\n.middle\n```\n\n#### 1.7.7 Why Listeners in HTML?\n\n在以往的开发中，直接写在 html 的 onclick 是很糟糕的方式，因为这违反了局部变量准则。将 onclick 变量提升为整个页面很容易导致，页面内部组织混乱。\n\n而 v-on 则仅执行 viewmodel 的方法，不会绑定到其他方法里。\n\n### 1.8 Form Input Bindings\n\nhttps://vuejs.org/v2/guide/forms.html\n\n对于每个 Form 空间，可以进行一定的封装。\n\n比如拖拽上传啦，比如 RadioGroup 啦等等。通过封装，可以进行相关的分析。\n\n### 1.9 Components\n\nUsing Components\nGlobal Registration\nLocal Registration\nDOM Template Parsing Caveats\ndata Must Be a Function\nComposing Components\nProps\nPassing Data with Props\ncamelCase vs. kebab-case\nDynamic Props\nLiteral vs. Dynamic\nOne-Way Data Flow\nProp Validation\nNon-Prop Attributes\nReplacing/Merging with Existing Attributes\nCustom Events\nUsing v-on with Custom Events\nBinding Native Events to Components\n.sync Modifier\nForm Input Components using Custom Events\nCustomizing Component v-model\nNon Parent-Child Communication\nContent Distribution with Slots\nCompilation Scope\nSingle Slot\nNamed Slots\nScoped Slots\nDynamic Components\nkeep-alive\nMisc\nAuthoring Reusable Components\nChild Component Refs\nAsync Components\nAdvanced Async Components\nComponent Naming Conventions\nRecursive Components\nCircular References Between Components\nInline Templates\nX-Templates\nCheap Static Components with v-once\n\n### 总结\n\n组件化是 Vue 模块化组织前端网页的方式。\n\nVue 的组件化，将模板，JavaScript 与样式放在一起。出于代码的复用性：\n\n组件化可以给组件子组件们组织起来，起一个阅读性更好的名称，从而使得编写 Vue 组件更加语义化。\n\n- 如果模板是常用的组件，比如手风琴控件，Menu 控件，sidebar 控件\n\nVue 通过组件来组织代码，但糟糕的是并不是一切都可以被组件化\n\n## 0x02 Transitions & Animation\n\n### 2.1 Event Handling\n\n### 2.2 Event Handling\n\n## 0x03 Reusability & Composition\n\n## 0x04 Tooling\n\n## 0x05 Scaling Up\n\n## 0x06 Internals\n\n## 0x07 Vue 番外篇\n\n下面的内容从 Vue 作者的知乎 Live 上取来。\n\n### 阅读源码的建议\n\nhttp://hcysun.me/2017/03/03/Vue 源码学习 /\n\n### 框架背后的要解决的原理\n\n组件为基本单元\n\n页面 ->应用（模块，组件树（偏展示））\n\n- 接入型 container\n- 展示型\n- 交互型 比如各类加强版的表单组件，通常强调复用\n- 功能型 比如 `<router-view>`，`<transition>`，作为一种扩展、抽象机制存在。\n\nview = render(state)\n\n- 命令式 (jquery)\n- 声明式\n\n### Virtual Dom\n\n### 变化侦测和渲染机制\n\npush pull\n\nvue 混合式\n\n### 状态管理\n\n## 0xEE TODO TO LIST\n\n---\n\nChangeLog:\n\n- **2017-09-15** 初始化本文\n"},{"tags":["React"],"path":"20170726_ReactCheatSheet.md","title":"React CheatSheet","slug":"React CheatSheet","date":"2017-07-26","category":"前端开发","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00. 前言\n\n> 备注：由于目前没有上 React 的打算，本文暂时太监\n\n之前一直使用 VueJS 进行开发，心血来潮想换换口味，于是就借着自己的一个开源的项目尝试一下 ReactJS , 代码分为两部分，如下：\n\n- 前台系统（支持 SSR) [YaReactBlog](https://github.com/twocucao/YaReactBlog)\n- 后台系统 [YaReactAdmin](https://github.com/twocucao/YaReactAdmin)\n\n```bash\n\nTODO:\n\n```\n\n<!-- more -->\n\n本文目录\n\n- 前端、单页与 React 开发\n- 官网的 Tutorial / Guide 要点\n- Dva 下使用 React JS 的要点\n\n## 0x00. 前端、单页与 React 开发\n\n### 0.1. 前端\n\n前端开发，是最近几年才出现的独立工种。\n\n在我的印象中，以前的人很少会区分前端和后端，现在的前端的职责往往是由后端的人顺手做掉的。当然，这种界面一般情况下都比较丑。\n\n后来，随着浏览器的功能越来越强大，性能越来越好，用户对于界面要求也就越来越高。甚至到后来，对于用户界面的操作的复杂程度要求也越来越高。 传统的后端渲染 Template + 简单的 Ajax 不能满足要求了。\n\n> 要界面，要交互，要复杂\n\n于是便出现了单页应用。\n\n### 0.2. 单页\n\n单页完全可以当做一个性能不是很强的，运行在浏览器中的，使用 HTML CSS JS 来编写的小型客户端。\n\n写单页和写客户端基本一致的情况下，于是在这种情况下，前端开发在使用单页后，直接可以 Mock 数据，接着编写界面，接着调通页面的状态和操作，最后发布。\n\n### 0.3. ReactJS\n\n为什么选用 ReactJS 呢？\n\n个人认为，框架是用于改善代码组织的一种约束。\n\n不管是 Web 应用开发的早期的 HTML in PHP OR PHP in HTML, 还是中期的 MVC MTV, 还是后来的 富 AJAX 操作，还是现在的 SPA, 出现的各种框架无非就是为了解决代码组织的问题。\n\n对后端而言，后端 WEB 框架的设计，都是为了单个模块职责过重而出现的一种解决方案：\n\n- HTML IN PHP 拼接代码简单暴力，可是如果拼接太多，每个文件就很职责重，代码阅读性差，不方便调试，就显得很杂乱。\n- PHP in HTML 相比上一个解决方案好很多。可是，嵌入过多 PHP 代码，代码阅读性差，不方便调试，则会显得比较混乱。\n- MVC 与 MTV 把渲染的变量独立出来放到 Controller 中，然后把需要渲染的 HTML 模板放到 Template 中，并且在 Template 中来完成模板的拼接。最后调用 Render 进行渲染。是不是这样问题就解决了呢？不是，如果把业务逻辑放在 Model 层，则 Model 职责过重。那就必须要添加一个 Serivce 层来封装业务逻辑。是不是封装了一个\n\n如果业务逻辑简单到令人发指，HTML IN PHP 可以给人最大的灵活性。\n\n1. 尝试一下新技术。保持对技术的敏感性。\n2. React 是 FB 出的一套前端框架。大厂支持，不会轻易太监掉。\n3. 写了一段时间 VueJS 换换口味。\n\n当我们讨论一个框架的时候，除了基本的框架之外还必须要有大量的社区资源，那么对 React 而言，除了 ReactJS 之外，还有什么？\n\n```bash\n\n后台系统\n\n - ant.design\n\n打包构建\n\n - webpack\n\n路由和状态管理\n\n - react-router\n - react-router-redux\n - redux\n - redux-saga\n\n为了更好的管理路由和状态，还是使用 dva 来管理比较好。\n\n - [dva](https://github.com/dvajs/dva)\n - [dva-cli](https://github.com/dvajs/dva-cli)\n\n开发构建工具\n\n - [roadhog](https://github.com/sorrycc/roadhog)\n\n```\n\n## 0x01. 官网的 Tutorial / Guide\n\n官网的要点\n\n## 0x02. 在 dva 下，编写 React 组件的正确姿势\n\n编写 React 的时候，我选用了 dva 框架配合 ReactJS 来编写单页。\n\n参考 FB 的这篇教程后，梳理了我编写组件的步骤 https://facebook.github.io/react/docs/thinking-in-react.html :\n\n1. 先构思出原型 （或者拿到 UI 图）\n2. Mock 出假数据\n3. 分解页面 OR 组件为 组件树\n4. 编写静态组件树\n5. 确定最小表达 UI （加上满足要求的样式）\n6. 确定什么时候需要什么状态（网络请求，键盘输入，位置变化等等）\n7. 收尾美化\n8. 在发现问题的时候进行优化\n\n## 0x03. 在 dva 下，编写 React 组件的正确姿势\n\n---\n\nChangeLog:\n\n- **2017-07-17** 重修文字\n"},{"tags":["JavaScript"],"path":"20170704_RethinkingInJavaScript.md","title":"Rethinking In JavaScript","slug":"Rethinking In JavaScript","date":"2017-07-04","category":"前端开发","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00. 前言\n\nJavaScript 这门语言已经不容小觑了，在项目中的前端部分基于 VueJS 和 ElementUI 之后，我也就顺应历史潮流深入了解了一下这门不容小觑的语言。\n\n<!-- more -->\n\n### 1. 为什么是 JavaScript\n\n为什么是 JavaScript 呢？\n\n因为太火，不得不认真学习一下。\n\n我本人对 JavaScript 这种语言是有偏见的，这点我不会掩饰，我始终记得在正常的语言 Python / Java / C# 中实现一个休眠的简单功能和在 JS 中实现一个休眠功能的差别。\n\n在 Python 中有很多语法糖，内置数据结构丰富，而 JS 则并不是如此，数据类型相对少，Bool 判断混乱，而今天，这门混乱的语言在流行程度上几乎接近于 Java 这门语言，即便是存在这样或者那样的问题，JavaScript 依然是一种奇葩的王者。\n\n在服务端，有多少功能是 Python 完不成而 JavaScript（即 NodeJS) 可以胜任的呢？而且，NodeJS 写起来的感觉比起 Python 来说，还是差了很多，所以，我比较倾向于把计算类和 IO 类的操作用 Python 来写，至于浏览器端就交给 JavaScript 好了。\n\n那么，对 JS 的这种定位，也使得我对 JS 生态圈的掌握程度不会超过 Vue/React 系。\n\n### 2. 工具链\n\n#### 2.1. 浏览器端\n\n#### 2.2. 桌面端\n\n#### 2.3. 客户端\n\n### 4. 文档\n\n### 5. 社区\n\n### 6. 书籍\n\n## 0x01 基本概念\n\n### 1. 数据类型\n\n- Number （没有 INT 值，只有 double-precision 64-bit format IEEE 754 ）\n- String\n- Boolean\n- Symbol (new in ES2015)\n- Object\n  - Function\n  - Array\n  - Date\n  - RegExp\n- null\n- undefined\n\n### 2. 操作\n\n#### 操作\n\n#### 操作\n\n### 3. 语句\n\n## 0x02 中级概念\n\n### 函数\n\n#### 作用域\n\n### 模块\n\n### 面向对象\n\n### 错误 / 调试测试\n\n### IO 编程\n\n### 进程和线程\n\n#### 多线程\n\n#### 多进程\n\n#### GIL\n\n##### 协同式多任务处理\n\n##### 抢占式多任务处理\n\n##### 线程安全\n\n### 正则表达式\n\n## 0x03 高级技巧\n\n## 0x04 标准库\n\n### 常用内建模块\n\n### 系统化模块\n\n### 安全性\n\n### 性能\n\n## 0x05 NPM && Yarn\n\n## 0xEE 文章更新\n\n- **2017-07-05 19:43:00** : 初始化本文\n"}],"total":6}},"__N_SSG":true}