{"pageProps":{"category":{"name":"系统设计","posts":[{"tags":["业务系统"],"path":"20210607_SD01_Back_Pressure.md","title":"系统设计 01 - 背压 backpressure","slug":"系统设计 01 - 背压 backpressure","date":"2021-06-20","category":"系统设计","lastMod":"2021-06-20","description":"系统设计","thumbnail":"","content":"\n# 系统设计 01 - 背压 backpressure\n\n## 0x00 前言\n\n最近看到一篇讲 backpressure 的文章，今天来聊一聊背压问题。\n\n## 0x01 什么是背压\n\n按照百度的说法\n\n> 指运动流体在密闭容器中沿其路径（譬如管路或风通路）流动时，由于受到障碍物或急转弯道的阻碍而被施加的与运动方向相反的压力\n\n简单来说，水箱入水多，出水少\n\n![Image](https://pic4.zhimg.com/80/v2-7dbaf693275f72d08e672d026f79eef3.jpg)\n\n在正式进入文章之前，务必要注意，\n\n1. 「背压现象」指的是一种生产者速率大于消费者速率的现象。\n2. 「背压机制」指的是一种预防背压现象出现的机制。\n\n## 0x02 常见的背压场景\n\nProducer 产出多 Consumer 来不及消费完\n\n小到文件的 IO, 在请求到响应的整个生命周期，大到成白上千的数据计算任务，都会存在背压问题。\n\n1. 读写文件 - 读快写慢 假设读速度 150MB/s 写速度 100MB/s, 那么每一秒就必须缓冲 50MB, 也就是 20 多秒就接近 1GB, 可想而知，如果不注意策略的话，内存很快就撑爆。\n2. 服务间通讯 - 客户端对服务 A qps 为 100, 服务 A 需要请求内部服务 B, B 的 QPS 为 75, 如果不做额外的处理，服务 A 每秒钟就会积压 25 个请求。\n3. 消息队列中瞬时消息过多 - kafka 内瞬间累积了海量的消息。\n4. 爬虫速度过快，解析 worker 无法在相同时间内完成解析入库。\n5. UI 渲染，在比较热闹的直播页面，海量的用户发送弹幕，而用户界面很容易收到并且渲染海量消息而崩溃。\n6. 用户支付完成后跳转到支付成功页面。\n7. 今天花三十分钟写了 300 个 BUG, 导致测试妹纸直接崩溃。\n\n## 0x03 背压解决策略\n\n1. 减少数据产出速率\n2. 增加数据消费速率\n3. 缓冲数据 use buffer\n4. 丢弃数据\n\n### 场景 1: 读写文件\n\nhttps://nodejs.org/en/docs/guides/backpressuring-in-streams/\n\nNodeJS 团队分别测试了禁用和启用 backpressure 特性的情况下运行了这段脚本\n\n```javascript\nconst gzip = require(\"zlib\").createGzip()\nconst fs = require(\"fs\")\n\nconst inp = fs.createReadStream(\"The.Matrix.1080p.mkv\")\nconst out = fs.createWriteStream(\"The.Matrix.1080p.mkv.gz\")\n\ninp.pipe(gzip).pipe(out)\n```\n\n不支持 backpressure 的情况首先带来的是内存的激增，其次是\n\n1. 影响其他速度\n2. GC 频率变高\n3. 内存耗尽\n\n对于 NodeJS 来说，选择了 Buffer 的手段\n\n### 场景 2: 服务间通讯\n\n对于 客户端 -> 服务 A -> 服务 B\n\n往往是在客户端与服务 A 之前加负载均衡，A 与 B 之间也加负载均衡\n\n负载均衡也分为两种，服务端负载均衡以及客户端负载均衡。\n\n- 负载均衡此时也承担了 Buffer 的作用。\n- 而多个服务 A 和多个服务 B 承担了增加消费速率的作用。\n\n### 场景 3: 爬虫 / 消息队列瞬时消息过多\n\n大多是扩 buffer, 扩消费者。\n\n### 场景 4: UI 渲染\n\n之前写过弹幕类服务。其中对前后端的部分考虑点还是很有趣的。\n\n在弹幕激增的情况下，弹幕列表不能瞬间挂掉。\n\n对于用户发送的弹幕消息，后端做好用户的分组，然后针对每个用户做好弹幕限流。这样确保后端传给前端的弹幕事件是可接受范围内的。\n\n然而，随着弹幕瞬时消息的激增，前端那边还是有点控不住了。\n\n几轮讨论下来，判断出 UI 渲染是瓶颈。后端已经做好用户的分组和弹幕的限流。再做消息的合并必要性不是很大。\n\n比如，瞬间接收 100 次弹幕事件。应该按照每秒进行合并弹幕批量前面 95 条弹幕接着渲染最后 5 条弹幕。\n\n整个界面就看起来顺滑多了。\n\n参考 https://steveholgado.com/rxjs-chat-app/\n\n## 0xEE 参考链接\n\n- https://lucumr.pocoo.org/2020/1/1/async-pressure/\n- https://nodejs.org/en/docs/guides/backpressuring-in-streams/\n"},{"tags":["业务系统"],"path":"20210627_RESTful_vs_GraphQL.md","title":"也聊聊 RESTful vs GraphQL","slug":"也聊聊 RESTful vs GraphQL","date":"2021-06-20","category":"系统设计","lastMod":"2021-06-20","description":"系统设计","thumbnail":"","content":"\n# 也聊聊 RESTful vs GraphQL\n\n## 0x00 前言\n\n本文最早行文于 2018 年中，那时 GraphQL 的生态尚未成熟，也缺乏社区总结的一些经验。\n\n> 较早入了坑，回首百年身\n\n2021 年中，复盘一下 GraphQL 的一些使用经验。\n\n名词约定\n\n- **接口生产端 / 服务端 下面统一称「生产端」**\n- **接口消费端 / 客户端 下面统一称「消费端」**\n\n## 0x01 流水的技术方案，铁打的需求。\n\n年幼时看笑傲江湖，华山派两派居然为了剑宗和气宗争个你死我活。\n\n觉得甚是幼稚。\n\n年纪渐大之后发现社会处处充满着这种「谁好」的争论。\n\n- 剑宗 or 气宗\n- 自然美 or 人造美\n- Java or Python or Golang\n- Editor or IDE\n- Rest or GraphQL\n- 单体应用 or 微服务\n\n剑招是死的，人是活的。\n\n当讨论问题的时候，下面两个问题意义可能并不是很大。\n\n- 用剑宗初学者和气宗高手比，或者相反，这个完全没有多大意义？\n- 用剑宗初学者和气宗初学者比孰强孰弱，这个有一点意义，但意义也不是很大。菜鸡互啄。\n\nGraphQL 作为挑战者，下面几个问题是很有意义的。\n\n- 现有方案存在哪些问题？\n- GraphQL 相比于原先成熟稳定的方案\n- 新方案解决了哪些原先没有解决的问题。\n- 新方案更低成本解决了哪些问题。\n- 现有的痛点是否存在一些新老方案都无法解决的问题。\n- 有无前车之鉴，有无社区最佳实践。\n- 迁移成本和学习成本是多少。\n- 回滚成本多少。\n\n## 0x02 RESTful 的缺点\n\nRESTful 有很多接口上最佳实践，但生搬硬套就会使得接口比较诡异。\n\n这里只说生搬硬套 RESTFul 的带来的缺点，对于大部分公司来说，这些缺点远远抵不上带来的优点。\n\n### 语义不明确\n\n比如，业务具备一定复杂性的时候，语义容易不明确。\n\n预览订单和下单两个接口，如果遵循如下的标准\n\n- 接口路径使用名词而非动词\n- GET 不修改，POST/PUT/DELETE 修改状态\n- 使用子字段来表述关系，查询订单 GET /shop/711/orders/\n\n严格遵循 RESTful 的话，接口就会成这个样子\n\n```bash\nGET /shops/1/order  {   \"products\": [...] }\nPUT /shops/1/order  {   \"products\": [...] }\n```\n\n反正我是看不出来这是一坨啥玩意的，至于如果你硬性规范 PUT order 就是创建订单，就会出现接下来两个接口完全不知道该怎么写\n\n```\n    支付订单 （用 patch /shop/1/order)\n    取消订单 （用 delete 方法，也没有 delete 呀）\n    退款订单\n    部分退款订单\n```\n\n- 产品上，用户删除了一台机器，那就是删除了一台机器？这里是软删。\n- 产品上，管理员删除了一台机器，那就是删除了一台机器？机器记录还在的。\n\n所以，采用的是 DELETE /machine/1\n\n> 剑招是死的，人是活的。\n\n不严格遵循 RESTful 的时候可以这么写。\n\n```bash\nPOST /preview_order\n{\n  \"shop_id\": 123,\n  \"products\": [...]\n}\n\nPOST /make_order\n{\n  \"shop_id\": 123,\n  \"products\": [...]\n}\n\nPOST /pay_order\n{\n  \"order_id\": \"202012001231237\",\n  \"balance\": \"20.20\",\n}\nPOST /cancel_order\n{\n  \"order_id\": \"202012001231237\"\n}\n```\n\n至于第三点的子字段表述关系，是一个典型的反面教材\n\n引用 Python 之禅来表达\n\n```\nFlat is better than nested. 扁平优于嵌套\n```\n\n### 得到即是失去 - Get's loss\n\nGET 让问题变得复杂\n\nRest 时代一个有代表性的问题就是如何在 GET 方法里处理以下四个问题\n\n- 过滤 filter\n- 排序 sort\n- 字段裁剪 field selections\n- 分页 pagination\n\n为了解决这个问题，一个稍微复杂的查询接口就成了如下的样子\n\n```bash\nGET /cars?seats<=2&sort=-manufactorer,+model&fields=manufacturer,model,id,color&page=1&per_page=10\n```\n\n> **可阅读性较差**\n\n而如果这么写，则前端无需把原先的 queryparams 转化成逗号结尾的字符串，后端也需要跟着解析并且转成自己想要的格式\n\n如果按照如下的写法，后端则可以直接使用 json 标准库里的数据类型。\n\n```bash\nPOST /cars\n{\n  \"filters\": [\n      {\n        \"seat__lt\": 2,\n    }\n  ]\n  \"sort\": [\n    \"-manufactorer\",\n    \"+model\"\n  ],\n  \"fields\": [\n    \"manufacturer\",\n    \"model\",\n    \"id\",\n    \"color\"\n  ],\n  \"pagination\": {\n    \"page\": 1,\n    \"per_page\": 10\n  }}\n\n```\n\n### 未很好解决的问题\n\nRESTFul 接口提倡的是细粒度、正交性。\n\n这样的接口是为了更加方便的复用多个接口来组成页面，但是并非没有问题。\n\n细粒度和正交性意味着接口是 building block, 而 building block 组合起来是交给前端来做的。 这意味着前端为了组合多个资源，则需要发起多次请求。\n\n这首先是带来了的网络开销成本 (HTTP 2 解决了首部开销、多路复用等 HTTP 1.1 面临的问题，还做到了完全向后兼容。) 和响应内容拼装成本\n\n其次，前端往往会抱怨\n\n1.  服务端这个接口字段少了，后端往往会复用序列器，直接把太多前端用不到的数据一并返回。\n2.  服务端这个接口字段太多，需要慢慢找 diff, 于是会开始抱怨文档问题。\n\n于是大家采用了 swagger/openapi 的配套解决方案。同时带来了，文档的缺失和滞后\n\n## 0x03 GraphQL 是新的颠覆者么？\n\nGraphQL 也不是什么革命性的产品，不过是一种新的开 Web 接口的方式罢了。\n\n而请求接口提交的参数也变成了包含参数的一种查询语言。\n\n官方宣传的 GraphQL 搞好了，只需如此：\n\n```graphql\n# Step1\\. 描述你的数据\ntype Project {\n  name: String\n  tagline: String\n  contributors: [User]\n}\n# Step2\\. 请求所需数据。\n{\n  project(name: \"GraphQL\") {\n    tagline\n  }\n}\n# Step3\\. 拿到所需数据。\n{\n  \"project\": {\n      \"tagline\": \"A query language for APIs\"\n  }\n}\n```\n\n嗯，是不是和 SQL 看起来有点像？当然咯，都是查询语言 (QL) 嘛。\n\n## 0x04 GraphQL 给消费端带来的好处\n\nGraphQL 的好处，自然是接口消费端写起来就是一个字，爽。\n\n比如我们使用 Github 的 API 做一个简单的查询  \n地址如下 https://link.zhihu.com/?target=https%3A//developer.github.com/v4/explorer/\n查询如下\n\n```graphql\nquery {\n  viewer {\n    login\n    bio\n    repositories(first: 10, orderBy: { field: STARGAZERS, direction: DESC }) {\n      nodes {\n        nameWithOwner\n        viewerHasStarred\n        watchers {\n          totalCount\n        }\n        stargazers {\n          totalCount\n        }\n      }\n      totalCount\n    }\n  }\n}\n```\n\n结果如下\n\n```json\n{\n  \"data\": {\n    \"viewer\": {\n      \"login\": \"twocucao\",\n      \"bio\": \"FullStack Pythonist In Shanghai\",\n      \"repositories\": {\n        \"nodes\": [\n          {\n            \"nameWithOwner\": \"twocucao/YaDjangoBlog\",\n            \"viewerHasStarred\": true,\n            \"watchers\": {\n              \"totalCount\": 12\n            },\n            \"stargazers\": {\n              \"totalCount\": 326\n            }\n          },\n          {\n            \"nameWithOwner\": \"twocucao/danmu.fm\",\n            \"viewerHasStarred\": true,\n            \"watchers\": {\n              \"totalCount\": 23\n            },\n            \"stargazers\": {\n              \"totalCount\": 316\n            }\n          },\n          {\n            \"nameWithOwner\": \"twocucao/YaVueBlog\",\n            \"viewerHasStarred\": true,\n            \"watchers\": {\n              \"totalCount\": 8\n            },\n            \"stargazers\": {\n              \"totalCount\": 141\n            }\n          },\n          {\n            \"nameWithOwner\": \"twocucao/danmu\",\n            \"viewerHasStarred\": true,\n            \"watchers\": {\n              \"totalCount\": 5\n            },\n            \"stargazers\": {\n              \"totalCount\": 69\n            }\n          },\n          {\n            \"nameWithOwner\": \"twocucao/silverhand\",\n            \"viewerHasStarred\": true,\n            \"watchers\": {\n              \"totalCount\": 7\n            },\n            \"stargazers\": {\n              \"totalCount\": 60\n            }\n          },\n          {\n            \"nameWithOwner\": \"twocucao/ChortHotKey\",\n            \"viewerHasStarred\": true,\n            \"watchers\": {\n              \"totalCount\": 7\n            },\n            \"stargazers\": {\n              \"totalCount\": 32\n            }\n          }\n          // ......\n        ],\n        \"totalCount\": 155\n      }\n    }\n  }\n}\n```\n\n如果你说，我还要看看这个 repo 的主要语言，那么增加一行查询即可。如图。\n\n![](https://pic2.zhimg.com/v2-997f49fd55e972c37d458a2aef6fb4dd_b.jpg)\n\n![](https://pic2.zhimg.com/80/v2-997f49fd55e972c37d458a2aef6fb4dd_1440w.jpg)\n\n是不是很方便？前端基本对着 Schemas 里面的 query 查询完毕就完毕了。\n\n查询这么搞可以，增删改查之类的操作呢？\n\nGraphQL 里面还有 Mutation 可以帮你解决这个问题，在后端定义完 Mutation , 前端在 Mutation 里面可以直接传参。\n\n甚至，**后端开出接口时，可以依据请求和响应生成对应的 typescript 代码，然后享受代码补全的快感。**\n\n> **极大利好前端**\n\n有人说, graphql 不就最后生成了 schema 嘛\n\n可不要小瞧了生成全接口的 schema, 用它可以做很多东西\n\n1.  **便捷的文档功能,** 接口列表以及入参的初步生成。便于快速调接口，比如我写了一个接口，发布到测试环境，接着点击一个按扭直接同步到 insomnia 里。点击运行即可调试。**「甚至可以做简单的接口自动化测试」**\n2.  **可以生成 typescript/javascript 代码,** 让前端享受到直接在代码里补全的快感。\n3.  比对两个版本之间的 schema 可以直接得出接口 schema 上，后端有没有做好兼容。如果不行, 则 CI 无法跑过\n\n![](https://pic1.zhimg.com/v2-c7a593ada4bc7fc78b20c3d18b5e1850_b.jpg)\n\n## 0x05 GraphQL 给生产端带来的挑战\n\n消费端（前端）爽了，是否意味着生产端（服务端）会爽呢？\n\n> **并不是**\n\n- 对于前端来说，如果要消费 graphql api, 相对容易一些。 只需将原先的 api 层改为 graphqlfetch 即可\n- 对于后端来说，如果要生产 graphql api, 则麻烦了不少。\n\n下文我会以 graphene 这个 graphql python 库来说明带来的一些挑战\n\nhttps://link.zhihu.com/?target=https%3A//github.com/graphql-python/graphene\n\n有的挑战是和 graphql 相关的，有的挑战则是来自 graphene 库，或许其他库有更好的解决方案。\n\n> 注意！痛点背后的原因，大多是 graphql 以及配套库玩的不熟。**而不一定是 RESTFUL 不存在这些问题**\n\n大致有如下挑战\n\n- View 层代码组织剧变\n- 权限问题\n- 版本更迭\n- required vs nullable vs blank\n- 服务端缓存\n- 嵌套式 API\n- N+1 问题\n- 为名所困\n\n### View 层代码组织剧变\n\n以简单的查询和创建两个接口为例。\n\n```python\n\nimport graphene\n\nclass PersonInput(graphene.InputObjectType):\n  name = graphene.String(required=True)\n  age = graphene.Int(required=True)\n\nclass CreatePerson(graphene.Mutation):\n\n  class Arguments:\n    person_data = PersonInput(required=True)\n    person = graphene.Field(Person)\n\n  def mutate(root, info, person_data=None):\n    person = Person(name=person_data.name,age=person_data.age)\n    return CreatePerson(person=person)\n\nclass Person(graphene.ObjectType):\n  name = graphene.String()\n  age = graphene.Int()\n\nclass MyMutations(graphene.ObjectType):\n  create_person = CreatePerson.Field()\n\n# We must define a query for our schema\nclass Query(graphene.ObjectType):\n  person = graphene.Field(Person)\n  schema = graphene.Schema(query=Query, mutation=MyMutations)\n\n```\n\n同样的逻辑用原先的方法只需如此即可。\n\n```python\n@bp.get(\"/person\")\ndef get_person():\n  # do get person\n  return data\n\nclass DataValidator(validator):\n  name: constr(min_length=2, max_length=10)\n  age: conint(gte=1, lte=200)\n\n@bp.post(\"/person_create\")\ndef person_create(data: DataValidator):\n  # do create person\n  return data\n```\n\n- 第一个痛点**原先简单清晰的代码变成了非常冗长的代码。**\n\n为了提升输入速度，分别尝试了 code generator / snippet 。大量的输入的代价是代码阅读带来较多无效阅读，反而造成了更多的调试困难。\n\n- 第二个痛点**校验层没了。而增加校验层变得比较麻烦。**\n\n随着代码量上升，相同业务逻辑的物理距离变得比较长，query 和 mutation 需要拆分到两个文件或者一个文件的上部分和下部分。\n\n- 假设你写的是一个商城，从上到下阅读代码会发现一会儿是商品基本信息，一会儿是分类，一会儿是订单，一会儿又是分类，order 的逻辑查看在一个文件的犄角旮旯，修改在另一个文件的犄角旮旯。代码复杂度 +1\n- 假设查询订单和修改订单两个接口查询，查看与修改所查询的业务逻辑是一样的。由于物理距离过于远，则大概率会写两遍这个代码。Same Logic, Write Everywhere\n\n我在 tifa 这个 fastapi 项目里尝试了使用这种组织 view 层代码的姿势\n\n这种组织代码的方式可以用 restful 的开发体验，获得 graphql 的效果\n\nhttps://link.zhihu.com/?target=https%3A//github.com/twocucao/tifa/blob/master/tifa/apps/admin/graphql.py\n\n```python\nrouter = GQLRouter()\n\nclass TPost(gr.ObjectType):\n    id = gr.Int(description=\"博客 ID\")\n    name = gr.String(required=True, description=\"博客标题\")\n\n@router.item(\"ok\", output=gr.Boolean)\ndef test_ok():\n    \"\"\"\n    做一个简单的 healthcheck\n    \"\"\"\n    return True\n\n@router.item(\"test_exception\", output=gr.Boolean)\ndef test_exception():\n    raise ApiException(\"raise an api exception\")\n\n@router.item(\"post\", output=TPost)\nasync def post_by_id(id: gr.Int):\n    \"\"\"\n    文章详情\n    \"\"\"\n    return await Post.get(id)\n\n@router.list(\"posts\", output=TPost)\nasync def posts():\n    \"\"\"\n    文章列表\n    \"\"\"\n    return await Post.all()\n\nclass PPostPagination(gr.InputObjectType):\n    q = gr.String(description=\"标题，等等\")\n\n@router.pagination(\"posts2\", output=TPost)\ndef posts_pagination(params: PPostPagination):\n    return {\n        \"items\": [\n            {\n                \"id\": i,\n                \"name\": \"testName\",\n            }\n            for i in range(10)\n        ],\n        \"per_page\": 10,\n        \"page\": 1,\n    }\n\nclass ParamsCreatePost(gr.InputObjectType):\n    name = gr.String(required=True)\n\n@router.mutation(\"create_post\", output=TPost)\nasync def create_post(params: ParamsCreatePost):\n    post = await Post.add(\n        name=params.name\n    )\n    await db.session.commit()\n    return post\n```\n\n可以看出，这种组织方式有如下的优点\n\n1.  depth 为 1 的 query / mutation 字段为一个 route\n2.  简单粗暴的权限可以做在 route 上\n3.  与 restful 完全一致的代码组织方式。RESTFul 代码几乎无缝迁移。\n\n### 权限问题\n\n接口的正交性带来的是细粒度的控制，而聚合起来之后，权限则不是很好管控。\n\n一个请求打过来包含了越权和非越权的请求。服务端需要如何判断？\n\n> **保大保小？**\n\n在 Restful 里依据路由可以做简单粗暴的首次鉴权。并且程序设计之初就会考虑到权限问题。\n\n在我 18 年研究 graphql 的时候，几乎就没有关于权限的最佳实践..\n\n当然，graphql 已经流行了好久了，现在也有一些成熟的解决方案了。\n\n### 版本更迭\n\n随着业务的变更，往往需要新增 / 废弃一些接口。\n\n在原先 RESTFul 的实践下\n\n1.  接口新增只需要考虑 v2 版本\n2.  接口移除通过监控接口的请求次数来解决这个问题。\n\ngraphql 社区推荐的是不废弃接口，只做兼容。尝试遵循了 graphql 社区的意见。最后还是改回和 restful 类似的方案了。\n\n还有另外一些痛点，以往想把一些性能敏感的接口拆出来的时候，一般可以\n\n1.  运维手段：直接起另一个服务，然后在网关那边直接转发请求即可。\n2.  非运维手段：请求依旧由现在的服务接收，然后由再次发起请求到新服务上。\n\n如果采用 graphql 之后，就只能用第二种方案了。\n\n### required vs nullable vs blank\n\n```\n  not required 表示这个字段不是必须的，可传可不传。\n  required 表示这个字段是必须的，但可为 null/none, 也可不为。\n  not nullable 表示这个字段是必须的，但是不能为 null/none\n  nullable 表示这个字段是必须的，但可为 null/none, 也可不为。\n  not blank 表示这个字段是可为空的\n  对于字符串，则必须要不为 \"\"\n  对于列表，则必须要存在至少一个 item\n```\n\n举个例子来说明，如果要表示如下的响应内容\n\n订单没有支付状态，就没有支付方式，即不应该有支付方式这个字段。\n\n```\n\n# 未支付订单\n{\n  \"status\": \"NOT_PAID\"\n}\n# 已支付订单\n{\n  \"status\": \"PAID\",\n  \"pay_method\": \"WECHAT\"\n}\n```\n\n> 这样的接口是**无法表示**, 如果有这个字段，就展示在界面上，没有这个字段就不展示在界面上的\n\ngraphql 没法做到未支付订单无 pay_method 这种情况，在响应体里 pay_method 总是为 null\n\n```\n# 未支付订单\n{\n  \"status\": \"NOT_PAID\"\n  \"pay_method\": null\n}\n```\n\n当然，如果硬是要做的话，只能借助 UNION[PaidOrder,NotPaidOrder] 来实现。使用 Union 本身就造成了序列化的成本急剧上升。\n\n### 服务端缓存\n\n要查什么，往往不可知（无法预知查询语句），随前端来定。不知道该怎么缓存响应内容。\n\n以往通过 URI 定位资源，Http 协议无状态，非常容易实现对应用层透明的缓存。\n\n而 GraphQL 重新定义了资源的定位方式，设计缓存的时候往往不知道该怎么设计。\n\n### 嵌套式 API\n\n在 graphql 的场景下，重写 resolver 是一个非常的影响是未知的。\n\n因为，你不知道有多少个 query 用了这个 field, 为了知道这个问题，你还得打点知道有多少个场景的 query 用到了这个字段。\n\n现实生活中情况可能复杂一些。\n\n这个例子旨在说明，存在一些改动的心智负担比较严重。\n\n比如，前端变动，接口层次，所有商家级别的数据落到店铺级别。\n\n这个例子正确的解法是联合前端一起升级到 V2\n\n### N+1 问题\n\n有的时候需要看情况来解决不同的 N+1 问题，也是比较迷惑的....\n\n客户端不见得会按照你的预期来查询。\n\n这就意味着，同一个结构，有的时候要依据情况 A 来重写查询，有的时候要依据情况 B 来重写查询。\n\n### 为名所困\n\n项目写了半年，由于 graphene 玩的不熟，我（后端）一直在各种起名困难症中度过。\n\n明明业务流程都差不多，但最后结果全是在改各种各样 ObjectType 的前缀。\n\n## 0x06 结论\n\n**GraphQL 这一套玩的熟悉的话，效率确实非常高。(前提是团队里面的人能玩的熟悉)**\n\n如果团队里面缺少全栈人才的话，在很多地方的比较难推进的动。graphql 用起来确实爽，特别是前端。\n\n由于是较新的技术，**引入进来算上折腾出最佳实践的成本和折腾过程中诞生的技术债，收益可能并没有想象的那么大。**\n\nrestful 其实也并不是做不到不少 graphql 能做到的东西。schema 生成工具其实蛮多的.\n\n> 不过，搞技术嘛，**折腾不止 生命不息**, 说不一定这次折腾收益就很高了呢？\n\n## 0xEE 参考链接\n\n- Photo by [Sigmund](https://link.zhihu.com/?target=https%3A//unsplash.com/%40sigmund%3Futm_source%3Dunsplash%26utm_medium%3Dreferral%26utm_content%3DcreditCopyText) on [Unsplash](https://link.zhihu.com/?target=https%3A//unsplash.com/s/photos/compute%3Futm_source%3Dunsplash%26utm_medium%3Dreferral%26utm_content%3DcreditCopyText)\n- [「FastAPI 脚手架」](https://link.zhihu.com/?target=https%3A//github.com/twocucao/tifa)\n- https://link.zhihu.com/?target=https%3A//graphene-python.org/\n- https://link.zhihu.com/?target=https%3A//graphql.org/\n- https://link.zhihu.com/?target=https%3A//www.apollographql.com/docs/react/data/operation-best-practices/\n- https://link.zhihu.com/?target=https%3A//graphql-code-generator.com/docs/plugins/typescript\n"},{"tags":["业务系统"],"path":"20210430_FastAPI.md","title":"如何评价最近爆红的FastAPI？","slug":"如何评价最近爆红的FastAPI？","date":"2021-04-27","category":"系统设计","lastMod":"2021-06-20","description":"系统设计","thumbnail":"","content":"\n# 如何评价最近爆红的 FastAPI\n\n用 fastapi 写过两个项目。\n\n两个系统写下来后，对 fastapi 的使用有了比较粗浅的认识。也封装了一个极简脚手架，希望能帮助到有缘人。**（文末有对这个脚手架的介绍）**\n\nhttps://link.zhihu.com/?target=https%3A//github.com/twocucao/tifa\n\n首先抛出结论\n\n> **fastapi 长远看好, 保持关注，但截至目前 (2021 年 4 月）写业务还是比较倾向于 django/flask。**\n\ngevent + flask/django 对比 async fastapi\n\n当然, 本文的比较是不公平的, 因为我比较的是「现有服务迁移到 FastAPI」的一些痛点\n\n综合了『上手成本』 『开发成本』 『迁移成本』后，我得出一个结论『迁移的边际效益不高』\n\n分开说的话，主要有如下几个原因。\n\n1.  「**相对较弱的生态**」 django/flask 相比生态太丰富了, 当我遇到一个问题, 当我想找一个插件, 都能比较轻松的找到。但 fastapi 尽管出来了好几年，但依然不如。async/await 的生态也是不如 sync 的生态。\n\n2.  「**其实 FastAPI 的一些卖点可以很方便的集成到你的项目中**」比如 Pydantic + django/flask 甚至可以做的更加简单清晰。\n\n3.  「**async await 调试成本较高**」async await 对代码的侵入性很强，迁移简单的项目还行，成年老项目，迁移过程不见得很顺畅。对常规的 Web 性能的提升也没有到非要它不可的地步。gevent+django/flask 性能虽然没有那么强，但是依旧是耐打。\n\n## 原因 1\\. 相对较弱的生态\n\n生态粗略分为三种\n\n1.  围绕着框架本身的插件生态，比如 flask-sqlalchemy 很好的集成了 flask 框架本身和 sqlalchemy\n\n2.  一些开放平台的 sdk 生态，比如有的是官方出品 - aliyun-oss-sdk, 有的是社区贡献 - wechatpy 。\n\n3.  io 的生态，由于上了异步，那么原先的请求库，数据库驱动等等 io 相关的库也要拿出来重新踩坑。\n\n在挑选这些插件的时候，则会遇到这种或者那种的问题，比如\n\n1.  django-debug-toolbar / flask-debug-toolbar 的 fastapi 替代品是啥？\n\n2.  celery 的 async 替代品是啥，即使有我为何要抛弃一个成熟的 celery 去踩坑？听说, faust 挺火的, 但用了这个库, 代码组织结构都变太多了. 听说 aiotasks 也不错, 仔细一看, 代码最后更新时间是**3 年前**\n\n3.  为了新开启一个项目，我还得把支付宝 sdk 从同步代码改成异步代码？直接用他们的 sdk+gevent 不改一行代码不香嘛？数据库驱动，redis 库，请求库，支付宝 sdk，微信 sdk，各类开放平台 sdk，只要是涉及到 io 的库基本上都要换一套，但是现有的 codebase 线上已经踩过不少的坑了，为何要换？甚至要重写？\n\n在经过很长时间的调研和一个一个插件的测试之后，我一拍脑袋，下了结论。\n\n> 还是用成熟的东西省心呀，顺畅跑了那么多年的老代码，拷贝在身边，一用好多年。\n>\n> **django/flask + gevent 赛高！**\n\n## 原因 2\\. 其实 FastAPI 的一些卖点可以很方便的集成到你的项目中\n\nfastapi 所说的亮点是什么性能好、编码速度快、减少人为的 BUG 符合直觉等等\n\n但回过头来想想，除了 asyncio 和 自带 openapi/json schema, 其他的框架也有这些特点嘛比如写起来很快，简单、简洁\n\n> 有人说，Pydantic 用来做校验器很好用。所以，我们要用 fastapi\n\n可是，当我写 flask + pydantic 代码的时候，我写的代码是这样的\n\n```python\nclass LoginType(str, enum.Enum):\n  MOBILE_CODE = \"MOBILE_CODE\"\n  USER_PASSWORD = \"USER_PASSWORD\"\n\nclass VLogin(BaseModel):\n  mobile_or_username: str # 这里可以加上更加复杂的校验\n  password: Optional[str]\n  type: LoginType\n\n@bp.post(\"/login\")\n@validator\ndef do_login(data: VLogin):\n  # read data and do login logic\n  return user_dict\n\n```\n\n**这个 validator 装饰器实现连换行加起来才 60 行。**\n\n所以说，在 flask/django 里，你完全不需要懂依赖注入。就可以把校验做的很干净。\n\n啥，你还要文档? pydantic 可以直接导出 jsonschema ，写个简单的解析放到文档里就行了。\n\n啥，你还要更加详细的文档丢给前端，那我觉得 graphql 可能是更加合适的选择。\n\n> **你说 asyncio 并发量高, 但 gevent 并发量相比也不低呀**\n\n## 原因 3\\. async/await 调试成本比较高\n\n为何说，调试成本较高\n\nasync await 对代码的污染性太强。\n\n比如，**风陵渡口初相遇， 一 await 误终身。** 开发者深恶痛绝的「一次 await，处处 async」\n\n底层模块一旦 await/async 了，则依赖于上面的所有模块函数都要 await, 如果不 await 代码就出问题。\n\n> **设想一下，如果你用了别人写的函数，这个函数突然 async 了。万一 ci 跑过了发了版本，是不是感觉今天要先回滚后加班了？**\n>\n> 当然，如果某一天有一种方法可以做到调用的时候，自动 await 的话，调试成本倒是低了不少。\n\n## 那么这是否代表我不看好/不喜欢 FastAPI 呢？\n\n> **恰恰相反，我很喜欢这个让人耳目一新的框架。**\n\n对于 FastAPI 的一些诟病，大多来自于我本人对 async/await 生态不了解(**也可以理解为老了, 懒得踩坑了**)。以及「**我已经用好了这 flask/django, 没有必要再去为了踩坑新 Web 框架而踩坑**」。\n\n**但这可以说成是「我懒」的问题, 也可以说是「新框架挑战老框架」的问题**\n\n毕竟某种角度上，苹果手机贵不一定是「苹果手机的贵」的问题，也可以说是「我穷」的问题。如果不能飞花摘叶, 那便老老实实玄铁重剑.\n\n当我要做一个纯业务的系统，我的目标是快速上线验证市场。在这个阶段其实 gevent+flask/django 的性能是完全足够的。性能不足，扩容来凑。\n\n在 gevent + flask/django 这种既有成熟解决方案的面前，FastAPI 的一些优点并没有解决我的痛点。\n\nfastapi 实实在在解决了我的痛点的，是对 websocket 良好的支持。 如果我要写系统是聊天室系统，比如弹幕系统，比如实时协作。fastapi 应该是目前为止最好的解决方案了(相比 django channel/gevent)\n\n> **总而言之 如果我的下一个系统没有历史负担, 需要的是并发数+Python, 而不是狂怼业务, 接各种 SDK, 那么 FastAPI 就是我的首选.**\n\n## 关于脚手架\n\n我在踩坑 fastapi 的过程中封装了一套极简脚手架。\n\n1.  FastAPI + Python 3.9 + poetry + Makefile\n2.  tortoise-orm + tortoise-migration\n3.  自带 shell plus (如下图)\n\nhttps://link.zhihu.com/?target=https%3A//github.com/twocucao/tifa\n"},{"tags":["业务系统"],"path":"20201222_BusinessLogic.md","title":"业务系统的一些碎碎念","slug":"业务系统的一些碎碎念","date":"2020-12-22","category":"系统设计","lastMod":"2020-01-01","description":"Odoo","thumbnail":"","content":"\n# 业务系统的一些碎碎念\n\n## 0x00 前言\n\n## 0x01 业务逻辑从不讲逻辑\n\n## 0x02 基于字段开发 or 基于业务开发\n\n加字段本质是加业务 加表来加字段\n\n## 0x04 扩展内容\n\n这个时候需要来了一个需求，要统计上报接口错误率和延迟。所有协议的所有实现，都要修改一遍，添加上统计上报的代码。这里包括遍历所有的业务方法，找到 HTTP 调用的地方。\n\n然后又来了一个需求，要对接口进行容错，对故障节点进行自动摘除。然后又要全文遍历一遍。\n\n然后又来了一个需求，因为下游接入了弹性的云服务，不能使用域名进行服务发现，因为端口号会变化。于是又要改一遍所有的地方加上服务发现的代码。\n\n然后又来了一个需求，需要对 RPC 调用进行染色，支持流量镜像等。需要在 RPC 协议中都加入一个 trace id 以及透传的字段，于是所有的 RPC 调用都要改一遍。\n\n我们可以总结出以下规律：\n\n非功能性需求有很强的复用性，不仅是可以独立出来，而且是必须独立出来。 破坏了 consistency，导致的就是重复实现，重复修改 本质上仍然是分工问题，破坏了 autonomy。如果所有的 RPC\n框架都由基础架构负责，稳定性也有基础架构负责。那么可以由基础架构团队一方自主完成所有的工作。\n\n## 0xEE 扩展阅读\n\n- https://github.com/taowen/modularization-examples\n\n---\n\nChangeLog:\n\n- **2020-12-15** 重修文字\n"},{"tags":["开源项目"],"path":"20201215_Odoo.md","title":"Odoo 对于 B 端业务开发的一些启示","slug":"Odoo 对于 B 端业务开发的一些启示","date":"2020-12-15","category":"系统设计","lastMod":"2020-01-01","description":"Odoo","thumbnail":"","content":"\n## 0x00 前言\n\n最近几个月一直在做 B 端的业务开发。\n\n写着写着便想从 Odoo 里面借鉴一些特性。\n\n于是便诞生了本文。\n\n## 0x01 业务逻辑从不讲逻辑开始\n\n众所周知，B 端\n\n> Odoo 如何应对不确定性\n\n## 0x02 基于字段开发 or 基于业务开发\n\n## 0x03 Use Addon to Build App\n\nHotel Management = BizLogic + Pos + Inventory + Invoicing\n\nAppointment = BizLogic + Pos + Inventory + Invoicing\n\n## 0x04 需求理解\n\n- Accounting\n- Marketing\n- Product\n- https://apps.odoo.com/apps/modules/14.0/product_advanced_attribute/\n- Inventory\n- Appointment\n- https://apps.odoo.com/apps/modules/13.0/itlibertas_timesheet/\n- https://apps.odoo.com/apps/modules/13.0/business_appointment/\n- https://apps.odoo.com/apps/modules/12.0/odoo_jewellery_management/\n- CRM\n- 销售追踪\n\n- 网站设计\n  - 小程序设计？\n- 电子商务\n- 调研\n- 预约和排期\n\n## 0x04 扩展内容\n\n## 0xEE 扩展阅读\n\n---\n\nChangeLog:\n\n- **2020-12-15** 重修文字\n"},{"tags":["秒杀"],"path":"20190210_秒杀系统的一些注意点.md","title":"秒杀系统的一些注意点","slug":"秒杀系统的一些注意点","date":"2019-02-10","category":"系统设计","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n## 秒杀常见问题\n\n### 01 卖超问题\n\n假设有 20 个商品要卖，1W 个请求打过来。\n\n1. SQL 加上数量判断，防止数量超掉\n\n应用层的检查，并发量上来，肯定要加行级锁，开销比较大。\n\n2. redis 集合预先缓存好相关的数量，然后从 redis 上进行应用层的数量检查。\n\n然后走异步队列。\n\n因为对于数据库来说，我只要 20 个请求即可，redis 起到了一个阻挡多余的请求穿透到 DB 中的作用。\n\n即便如此，redis 依然可能会出现一些意外的情况，比如为负数，这个时候多打进去几个请求，变成 24 个，这个时候 MQ 的作用就出来了。排好队伍。\n\n3. 唯一索引\n\n数据库层的检查，可以从根本上防止问题\n\n### 02 缓存问题\n\n1. page 级别的缓存，由于 wsgi 协议本身在 flask 中返回的就是文本，所以，当作文本处理即可\n2. obj 级别的缓存\n\n能走内存的走内存，能走 redis 就走 redis, 能通过 mq 削减峰值的就走 mq, 能走 mongodb 的走 mongodb, 最后是数据库。\n\n### 03 安全\n\n1. 验证码\n2. 接口防刷限流\n3. 秒杀接口隐藏\n\n### 04 分布式锁\n\n1. 不加锁，并发起来资源浪费\n2. 加锁，然而，线路抖动会导致不能及时释放锁\n3. 加过期锁，或者加带有时间的锁，然后重新获取锁。\n4. redisson 封装好的方法\n\n### 06 减少数据库访问时间\n\n1. 首先考虑在 where 和 order by 设计的列上建立索引\n2. 索引越多，插入越慢，这个要做好平衡\n3. 避免过长的事务级操作，提高并发能力\n\n其他的可以参考 MySQL 的一些优化原则，油管上很多。\n\n### 07 分布式事务\n\n分布式事务，准确来说，是分布式\n\n## 0xEE 参考\n\n### PEP\n\n- PEP 3107\n- PEP 483\n- PEP 3107\n- PEP 3107\n\n- [关于 gradual typing](http://wphomes.soic.indiana.edu/jsiek/what-is-gradual-typing/)\n\nhttps://mypy.readthedocs.io/en/latest/cheat_sheet_py3.html\n\nhttps://blog.zulip.org/2016/10/13/static-types-in-python-oh-mypy/\n\n---\n\nChangeLog:\n\n- **2018-11-25** 初始化本文\n"},{"tags":["Web Develop"],"path":"20180904_系统设计入门笔记.md","title":"Thinking In Web Developing","slug":"Thinking In Web Developing","date":"2018-09-04","category":"系统设计","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n## 0x02 前端\n\n### CDN\n\n代理服务器分布式网络，它从靠近用户的位置提供内容\n\n#### 更新方式\n\n推送 PUSH\n\n当服务器内容发生变动，推送 CDN 接受新的内容。\n\n- 更新最快\n- 流量最小化\n- 存储最大化\n\n拉取 PULL\n\n当用户请求该资源的时候，从服务器拉取资源。\n\n- 更新有延迟\n- 存储最小化\n\n#### 缺点\n\n1. CDN 成本可能会很高\n2. TTL 过期之前更新内容，CDN 缓存内容可能会过时\n\n## 0x02 后端组件\n\n### 负载均衡器\n\n负载均衡起到了一个均衡负载的作用\n\n1. 防止请求进入运行情况糟糕的服务器。\n2. 防止资源过载。\n3. 帮助消除单一故障点。\n\n额外的功能：\n\n1. SSL 终结：解密传入的请求，并加密服务器响应。\n\n工作-备用 / 双工作\n\n#### 选 Worker\n\n- Random\n- Round Robin\n- Least Busy\n- Sticky session / Cookie\n- By request paramters\n\n#### 路由流量\n\n- 随机\n- 最少负载\n- Session/Cookie\n- 轮询调度或加权轮询调度\n- 四层负载均衡\n- 七层负载均衡\n\n### 反向代理\n\n- 安全性：隐藏后端服务器信息\n- 可扩展性和灵活性：客户端只能看到服务器，服务端\n- 本地终结 SSL 会话：\n- 压缩：\n- 缓存：\n- 静态内容：\n\n## 0x08 Http Server Model\n\n### Master\n\n主进程监听不同的进程信号，并且作出反馈。\n\n- TTIN TTOU 告诉 master 升高或者降低运行的 worker\n- CHLD 子进程已结束\n\n### 四种 Worker\n\n#### 同步 Workers\n\n单请求单 worker, 并且不支持 persistent connections\n\n在 CPU 和网络贷款上资源有限。（啥意思，,,,)\n\n即请求时间不定的情况应该是要避免的。\n\n#### 异步 Workers\n\n异步场景\n\n- Applications making long blocking calls (Ie, external web services)\n- Serving requests directly to the internet\n- Streaming requests and responses\n- Long polling\n- Web sockets\n- Comet （其实就是推送）\n\n通过 eventlet / gevent 使用 Greenlets\n\n#### Tornado Workers\n\ntornado\n\n#### AsyncIO Workers\n\n- gthread\n- gaiohttp\n\n### Pre-fork Web Server\n\nhttps://stackoverflow.com/questions/25834333/what-exactly-is-a-pre-fork-web-server-model\n\npre-forking 意味着 一个 master 创建了多个 fork 来处理请求。每一个分叉意味着一个独立的 \\*nix 进程（不一定吧，异步 worker 怎么算？)。\n\nThe pre in pre-fork means that these processes are forked before a request comes in. They can however usually be increased or decreased as the load goes up and down.\n\nlibev / libuv\n\nepoll or kqueue, it is always indispensable to the asynchronous topic.\n\nasyncio\n\nsanic\nlibuv\nuvloop\n\n## 0xEE 结论\n"}],"total":7}},"__N_SSG":true}