{"pageProps":{"category":{"name":"Golang","posts":[{"tags":["Golang","CheatSheat"],"path":"20180829_GoLang.md","title":"写给 Pythonista 的 Golang 入门指北","slug":"写给 Pythonista 的 Golang 入门指北","date":"2018-08-29","category":"Golang","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n原计划是去年 8 月份入 Golang 大法的，然后开一篇帖子进行写个入门指北来着。这一拖就拖到了今年。\n\n同样是快速上手教程，这篇文章和其他的文章的不同点在于，完全假设你是 Pythonista 的入门。\n\n## 0x00 前言\n\n## 0x01 安装\n\nGolang 安装\n\n```\n# 如果你是在 mac 上，建议先安装下面的 SDK 以防不测\nopen /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg\n# 安装 golang\nbrew install golang\n# 配置环境变量\necho $GOPATH # /Users/twocucao/Codes/ReposGo\n\ncd /Users/twocucao/Codes/ReposPublic/\n\nmkcd thanos # mkdir && cd\ngo mod init github.com/twocucao/thanos\ngit remote add origin git@github.com:twocucao/thanos.git\n```\n\n接下来，需要解决卡 golang.org 的网络问题。\n\n```\nexport GOPROXY=https://goproxy.io\ngo get -v -u github.com/hqpko/go-mod-tidy\ngo mod tidy\n```\n\n接下来就是随便找一些带有依赖库的代码。放到该文件夹下面。\n\n你也可以直接从这里 https://github.com/twocucao/thanos.git 拉取代码\n\n## 0x01 基本概念\n\n### 工具链\n\n### 文档\n\n### 社区\n\n### 书籍\n\n### 内置简单类型\n\n对于一些基本的数据类型，操作为 加减乘除取余数位运算等等\n\n- 数字类型\n- 布尔类型\n- 字符串类型\n- 数组 / 列表\n- 字典\n\n### 内置复杂类型\n\n- 集合结构 : 串\n- 线性结构 : 线性表 （单链表，静态链表，循环链表，双向链表，**栈，队列**)\n- 树形结构 : 树（二叉树，B+ 树，红黑树）\n- 图形结构 : 图\n\n### 对象\n\n### 字符串\n\n## 0x02 中级概念\n\n### 函数\n\n#### 作用域\n\n### 模块\n\n模块，这个概念，可大可小，大的时候，把一个程序说成是模块，小的时候，可以把一个文件，甚至你说这一个函数是一个模块，也行。\n\n这里的模块指的是一个包下的函数。\n\n### 面向对象\n\n面向对象有三大概念：\n\n- 封装\n- 继承\n- 多态\n\n### 错误 / 调试测试\n\n异常处理实际上可以考验一个程序员编写代码的健壮性。\n\n事实上来说，代码写的健壮是一个程序员必备的素养。但其实在开发过程中，出于对项目进行赶工上线，需要对程序的健壮性做出一定的取舍。并且，在编写客户端，服务端，网页前端的时候基本上都会遇到这个问题。什么时候选择健壮的程序，什么时候选择是还可以的程序。需要自己的经验。\n\n### IO 编程\n\n### 进程和线程\n\n#### 多线程\n\n> Go 多线程约等于并发。\n\n#### 多进程\n\n##### 协同式多任务处理\n\n如果有两个线程，同时进行 IO 请求，当其中一个线程连接之后，立即会**主动让出 GIL**, 其他线程就可以运行。\n\n> 当 N 个线程在网络 I/O 堵塞，或等待重新获取 GIL，而一个线程运行 Python。\n\n让出之后还要执行代码呀，所以要有个收回 GIL 的动作。\n\n##### 抢占式多任务处理\n\n##### 线程安全\n\n原子操作：sort 之类不需要\n非原子操作：n=n+2 的字节码分为 加载 n , 加载 2 , 相加，存储 n, 四个步骤，由于不是原子性，很可能被由于 15 ms 而被打断。\n\n当然，懒人一向是 : **优先级不决加括号，线程不决加 lock**\n\n对于 Java, 程序员努力在尽可能短的时间内加锁存取共享数据，减轻线程的争夺，实现最大并行。但 Python 中，线程无法并行运行，细粒度的锁就没有了优势。\n\n### 正则表达式\n\n## 0x03 高级技巧\n\n## 0x04 标准库\n\n### 常用内建模块\n\n### 系统化模块\n\n## 0x05 第三方库\n\n- Requests : API 人性化\n\n## 0x06 代码质量\n\n### 正确性\n\n### 可维护性\n\n### 可读性\n\n### 安全性\n\n### 性能\n\n## 0x07 常用命令\n\n```\ngo build\ngo install -v\ngo clean\ngo fmt\ngo get\ngo test\ngo tool fix . # 修复老代码到新版本\ngo tool vet directory|files\ngo tool yacc -o gopher.go -p parser gopher.y\ngodoc -http=:8080\ngo version 查看 go 当前的版本\ngo env 查看当前 go 的环境变量\ngo list 列出当前全部安装的 package\ngo run 编译并运行 Go 程序\n```\n\n## 0xEE 文章更新\n\n```\n# 如果你是在 mac 上，建议先安装下面的 SDK 以防不测\nopen /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg\n\n```\n\n# Golang\n\n## 模块 01：Go 语言实践 - Runtime\n\n### Goroutine 的调度原理\n\n- Goroutine 和线程的区别\n- Goroutine 的实现、GPM 调度模型、调度状态及流转、调度原理、协作式抢占以及和网络库的协作\n\nhttps://www.jianshu.com/p/105719434c29\n\nhttps://zboya.github.io/post/go_scheduler/\n\nhttps://studygolang.com/articles/16407\n\n### 内存模型\n\nGo 的内存分配机制\nGo 内存分配的内部结构和分配机制\n\nhttps://deepu.tech/memory-management-in-golang/\n\nhttps://medium.com/a-journey-with-go/go-memory-management-and-allocation-a7396d430f44\n\n### GC（垃圾回收）的原理\n\nGC 三色标记算法\n\nhttps://blog.golang.org/ismmkeynote\n\nGC 介绍、三色标记的实现原理、GC 的流程以及 GC 的一些优化方案\n\n### channel 的消息通讯原理\n\nchannel 的底层实现\nchannel 的通讯机制、环形队列的结构、调度和唤醒的原理\n\nhttps://stackoverflow.com/questions/19621149/how-are-go-channels-implemented\n\n## 模块 02：Go 语言实践 - 并行编程\n\n### Memory Model\n\nGo 中内存模型和同步语义\n\nhttps://zhuanlan.zhihu.com/p/110032965\nhttps://golang.org/ref/mem\nhttps://golang.org/doc/\n\n内存模型：Happens Before、同步语义、channel 通讯、锁\n\n### 并发特性并发编程模式\n\nhttps://blog.golang.org/pipelines\n\nTimeout、Pipeline、Cancellation、Fanout、errgroup 等模式\n利用 channel 完成并行开发的设计模式，包含超时控制、管道、扇出、errgroup 并发\n无法熟练使用基于 channel 通讯方式的并行编程模式\n\n### Context 的原理并掌握其使用方法\n\nContext 传播式传递有什么意义\n使用 Go 标准库 Context 的原理和最佳实践，包含超时控制、元数据传递、生命周期控制\n\nhttps://blog.golang.org/context\nhttps://levelup.gitconnected.com/context-in-golang-98908f042a57\n\n## 模块 03：Go 语言实践 - 网络编程\n\n### Golang TCP 网络编程\n\nGo 实现高性能的 TCP Server\n\ngoim 项目了解 Go 语言中 TCP Server 的基础库和性能优化方案\n\n### Golang HTTP 网络编程\n\nHTTP 框架选型\n针对业务需求对 HTTP 框架做针对性的扩展\n结合 gin 项目了解 Go 语言中的 HTTP Server 的基础库和框架\n\n## 模块 04：Go 语言实践 - 异常处理\n\n### error 的处理方法\n\n### 业务错误的处理方法\n\nerror 的处理复杂，不会正确使用\n业务错误定义和 error 整合难度较高\n\nGo 语言中的 error 处理实践：检查错误、定义错误、追加上下文\nGo 项目中的业务错误码如何结合 error 的最佳实践\n\n## 模块 05：Go 工程化实践\n\n### 良好的项目目录组织原则和规范\n\n### API 的设计方法和规范\n\n### Package 的管理和设计方法\n\n### 单元测试\n\n1. Go 项目的标准化管理\n2. 设计 API\n3. 包管理\n\n4. 良好的 Go 项目中的分层目录结构组织和代码规范\n5. Go 项目中 API 的设计原则和方法：定义、状态和业务错误码处理\n6. Go 项目中包的设计和最佳实践、go mod 的使用\n7. go test 工具链的使用方法、单元测试的最佳实践以及 Mock 技术\n\n## 模块 06：Go 架构实践 - 分布式架构（前端负载均衡）\n\n### 高可用 DNS 的最佳实践\n\n### CDN 的架构和应用场景\n\n### 深入理解 4/7 层负载均衡的原理\n\n在线服务的全链路视野\n应用服务上层的负载均衡\n\nDNS 的原理、防劫持的方法、HTTPDNS + IP 长连接\nCDN 的系统架构、应用领域以及保证数据一致性的方法\nLVS、Nginx 4/7 层负载均衡的原理和实践\n\n## 模块 07：Go 架构实践 - 分布式架构（数据分片）\n\n### 数据 Sharding 的设计原则\n\n### 了解 Hash 分片的算法和演进历史\n\nSharding 的应用场景，不会合理使用\nHash 算法的使用场景\n\n数据分片设计，如：分库分表、多活的 Shard 设计等等\n分片算法的 Hash 实现和演进：Hash 求余、一致性 Hash、有界负载一致性 Hash、节点映射\n\n## 模块 08：Go 架构实践 - 微服务（微服务概览与治理）\n\n### 微服务的演进历史及优缺点\n\n### 微服务的设计方法\n\n### 微服务中 RPC 的底层原理\n\n微服务的服务角色：API Gateway、BFF 还是 Service？\n微服务拆分\nRPC 的原理，不知道如何进行微服务 RPC 框架的选型\n\n微服务的原理、概念，以及微服务的实现细节\nAPI Gateway、BFF、Service 等概念精讲\n微服务通讯 RPC 框架的细节和选型\n\n## 模块 09：Go 架构实践 - 微服务（可用性设计）\n\n### 可用性设计的最佳实践\n\n### 可用性设计的几大关键点：隔离、超时控制、过载保护、限流、容错 & 重试\n\n如何设计高可用的分布式服务\n何提升服务自愈能力\n\n微服务的隔离实现，以及架构设计中的隔离实现\n进程内超时控制和跨进程超时控制\n程序自保护避免过载，抛弃一定的流量完成自适应限流\n单机限流、多租户场景的分布式限流\n节点故障的容错逻辑、重试容错的策略和设计\n\n## 模块 10：Go 架构实践 - 中间件（日志、指标、链路追踪）\n\n### 日志收集\n\n### 监控指标体系\n\n### 分布式链路追踪\n\n如何解决微服务的可观测性难题\n怎么做微服务的可视化和标准化\n出故障后，难以对微服务进行问题诊断\n\n实现一个可以集中收集所有微服务实例的日志，并能统一查看和检索的日志采集架构\n指标监控、使用 Prometheus 解决监控可视化、指标采集\n微服务中的跨服务性能问题诊断，结合 Jaeger 实现分布式链路追踪\n\n## 模块 11：Go 架构实践 - 中间件（缓存、数据库）\n\n### Redis、Memcache 的原理和实战技巧\n\n### MySQL 的常用设计和优化方法\n\n1. 解决缓存的一致性问题\n2. 怎样合理地设计 MySQL 的表\n\n3. Redis、Memcache 的应用场景、最佳实践，以及缓存的一致性设计\n4. MySQL 的表设计、常用优化手段，以及如何解决分布式事务\n\n## 模块 12：Go 架构实践 - 中间件（消息队列、服务发现）\n\n### 深入理解消息队列的原理，掌握基于消息队列的架构设计方法\n\n### 服务发现原理、选型策略，以及服务发现实现的微服务多租户架构\n\n1. 消息解耦的架构设计\n2. 如何实现服务发现对平滑发布的支持\n3. 怎样利用多租户实现多测试环境\n\n4. Kafka 的实现原理、异步消息系统的架构设计\n5. RPC 服务发现、动态地址的选型和实现原理，以及基于服务发现的平滑重启和多租户架构\n\n---\n\nChangeLog:\n\n- **2018-08-22** 初始化接口\n"}],"total":1}},"__N_SSG":true}