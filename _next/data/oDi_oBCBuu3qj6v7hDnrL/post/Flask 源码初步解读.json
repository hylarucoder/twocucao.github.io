{"pageProps":{"post":{"tags":["Python","Flask"],"path":"20180309_Flask源码解析.md","title":"Flask 源码初步解读","slug":"Flask 源码初步解读","date":"2018-03-09","category":"Flask","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"<h2 id=\"0x00-前言\"><a class=\"v-toc-item\" href=\"#0x00-前言\">#</a> 0x00 前言</h2>\n<p>系列文章先暂时停更一下。今天换换口味。</p>\n<p>久闻 Flask 是众多 Pythonist 喜欢的框架。这次借着换工作的机会熟悉一下 Flask</p>\n<ol>\n<li>本文先分享我阅读代码的一些小经验</li>\n<li>接着通过最简单的一个 WSGI APP 开始，带着<strong>如何设计一个 Web 框架</strong>这个问题，先头脑风暴，从而脑补（而不是实现）出一个 Web 框架的基本要素。</li>\n<li>从源码角度理解，Flask 从启动到接受第一个请求、返回第一个响应期间都发生了什么。</li>\n<li>最后交代一些自己在这个过程中的一些突发的想法。</li>\n</ol>\n<blockquote>\n<p>将解读 Flask 的源码放在一篇文章里，势必会造成广度有余而深度不足。所以本想定位于 Flask 源码初步解读。</p>\n</blockquote>\n<h2 id=\"0x01-阅读-flask-代码的一种较好的姿势\"><a class=\"v-toc-item\" href=\"#0x01-阅读-flask-代码的一种较好的姿势\">#</a> 0x01 阅读 Flask 代码的一种较好的姿势</h2>\n<p>之前在 <a href=\"https://www.zhihu.com/question/28509408/answer/299763091\">https://www.zhihu.com/question/28509408/answer/299763091</a> 分享过自己一点阅读代码的粗浅的经验，是以阅读一个 Django 的应用为案例的。这里借着读 Flask 本身分享一下我的看法。</p>\n<p>读源码，是一个技术活。一是忌讳要想读懂全部，另一个忌讳是以为自己能一下子毫无障碍的读懂全部代码。</p>\n<ol start=\"0\">\n<li>建议 0 : 看源码的时候，<strong>务必务必带着问题去读</strong>。每一次阅读其实都是在尝试回答或小或大的问题（当然，读书看文章莫不如是）。</li>\n<li>建议 1 : 先读现成的文档，不要上来就对着代码一通瞎看。</li>\n<li>建议 2 : 所谓『横看成岭侧成峰，远近高低都不同』 你需要从不同的角度来读源码。</li>\n<li>建议 3 : 抓大放小，该略读就略读（比如知道 Nginx 的大致作用就好，做优化请求响应的时候再翻看文档），该精读则精读（具体一个关键的功能）。</li>\n</ol>\n<blockquote>\n<p>好，坐好，预备，开车。</p>\n</blockquote>\n<h2 id=\"0x02-问题-1-如何设计一个-web-框架\"><a class=\"v-toc-item\" href=\"#0x02-问题-1-如何设计一个-web-框架\">#</a> 0x02 问题 1: 如何设计一个 Web 框架</h2>\n<h3 id=\"头脑风暴\"><a class=\"v-toc-item\" href=\"#头脑风暴\">#</a> 头脑风暴</h3>\n<p>Flask 是一个微 Web 框架，换而言之，代码量少的 Web 框架。当然，其实 Flask 框架是一个微框架，但『常规的 Flask 应用』本身的代码加起来一点都不比『Django 应用』少。这个地方我们后面会讲到。</p>\n<p>在阅读 Flask 相关代码的之前，先头脑风暴一下：</p>\n<blockquote>\n<p>如何设计一个 Web 框架？</p>\n</blockquote>\n<p>当心中对这个问题有一定的了解之后，读 Flask 代码会更好。</p>\n<p>首先，Web 框架是为了提升 Web 开发的。(XX 框架是为了提升 XX 开发的）, 这种提升可能会是 开发体验 / 性能。</p>\n<p>我们来看看那个 Python 世界最基础的 wsgi app 相关代码。</p>\n<pre><code class=\"language-python\">def <span class=\"token function\">application</span><span class=\"token punctuation\">(</span>environ<span class=\"token punctuation\">,</span> start_response<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>\n    <span class=\"token function\">start_response</span><span class=\"token punctuation\">(</span><span class=\"token string\">'200 OK'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Content-Type'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'text/plain'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'Hello World!'</span><span class=\"token punctuation\">]</span>\n</code></pre>\n<p>在之前的文章，我也借 Django 的 DRF 提到过这个极简的代码。</p>\n<p>但这个简单的 webapp，显然是啥玩意都不够用的。比如说：</p>\n<ul>\n<li>没有路由，我访问啥玩意都是 hello world。</li>\n<li>单线程 IO 阻塞模型基本上啥都不能干。你比如说，启动这个 webapp 的时候在 return 数据之前直接 sleep 十秒，然后请求都进不来。</li>\n<li>没有数据存取，连个数据库链接 CURDE 啥玩意都没有</li>\n<li>environ 太过于底层，如果是判断 headers 啥的太麻烦，要是像 django 里面一样能拿到一个 request 对象返回一个 response 对象就好了。</li>\n<li>没有模板语言</li>\n<li>还有其他能够提升开发体验的东西，比如自带 http server 代码热加载之类。</li>\n</ul>\n<pre><code class=\"language-python\">def <span class=\"token function\">application</span><span class=\"token punctuation\">(</span>environ<span class=\"token punctuation\">,</span> start_response<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>\n    # 直接 thread local 支持多个请求。\n    # 依据 environ 判断路由\n    # 依据 路由 执行相关 view 层方法\n    # 在相关 view 层方法内执行相关逻辑\n    <span class=\"token function\">start_response</span><span class=\"token punctuation\">(</span><span class=\"token string\">'200 OK'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Content-Type'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'text/plain'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    # 返回对应响应\n    <span class=\"token keyword\">return</span> response\n</code></pre>\n<p>当然，思路是这么个思路，这个思路也确实非常的命令式，非常的面向过程。</p>\n<p>至于我们如何把这个面向过程的思路变成面向对象的设计与实现，则需要更加细致的思考这些问题。</p>\n<ol>\n<li>能不能把 request 和 response 封装一下？方便在 view 里面处理？</li>\n<li>能不能有个 URLDisparch 之类的东西，帮你解决 url 和 view 的 mapping 问题。或者路由能不能直接搞成 装饰器类型的比如 @router(“/”) 直接放在 view 层的 function 上。</li>\n<li>能不能有个方便对数据库进行 CURDE 的东西？比如 ORM/ODM</li>\n<li>这玩意会不会线程不安全，假如我想每一个请求都有单独的变量集合的话，线程怎么管理？</li>\n<li>…</li>\n</ol>\n<h3 id=\"设计-web-框架\"><a class=\"v-toc-item\" href=\"#设计-web-框架\">#</a> 设计 Web 框架</h3>\n<p>利用 Flask 作者的另一个库 werkzeug 的案例中有这么一个东西。</p>\n<p><a href=\"https://github.com/pallets/werkzeug/blob/master/examples/shortly/shortly.py\">https://github.com/pallets/werkzeug/blob/master/examples/shortly/shortly.py</a></p>\n<p>几百行代码就不贴在这里了。仔细看看还是挺有趣的。 这个可以算作另一个超简的 Webapp 了。</p>\n<p>Flask 算作在这个基础上进行一定的扩展而成。</p>\n<p>看完上面这个就可以出去吹牛逼可以自己写一个极简 Web 框架了。</p>\n<p>那么，你可能有疑问，为何有了 Flask 之后，是否需要看这个更底层的 Werkzeug 的库，当然，有必要咯，Python 世界除了老牌的比较流行的 Django/Flask, 还有一个新星，叫做 APIStar</p>\n<p><a href=\"https://github.com/encode/apistar\">https://github.com/encode/apistar</a></p>\n<h2 id=\"0x02-问题-2-请求流程是怎么样的\"><a class=\"v-toc-item\" href=\"#0x02-问题-2-请求流程是怎么样的\">#</a> 0x02 问题 2: 请求流程是怎么样的</h2>\n<p>我们就拿这个 flask 的极简案例，进行<strong>首次</strong>阅读 Flask 代码。</p>\n<pre><code class=\"language-python\"># hello<span class=\"token punctuation\">.</span>py\nfrom flask <span class=\"token keyword\">import</span> Flask\n\napp <span class=\"token operator\">=</span> <span class=\"token function\">Flask</span><span class=\"token punctuation\">(</span>__name__<span class=\"token punctuation\">)</span>\n\n@app<span class=\"token punctuation\">.</span><span class=\"token function\">route</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/'</span><span class=\"token punctuation\">)</span>\ndef <span class=\"token function\">hello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>\n    <span class=\"token keyword\">return</span> <span class=\"token string\">'Hello, World!'</span>\n\n$ <span class=\"token constant\">FLASK_APP</span><span class=\"token operator\">=</span>hello<span class=\"token punctuation\">.</span>py flask run\n</code></pre>\n<blockquote>\n<p>从请求到响应的整个流程，Flask 的是怎么处理请求的？</p>\n</blockquote>\n<h3 id=\"21-服务器是怎么起来的\"><a class=\"v-toc-item\" href=\"#21-服务器是怎么起来的\">#</a> 2.1 服务器是怎么起来的</h3>\n<p>首先 flask run 之后，发生了什么？</p>\n<p>先初始化环境变量，然后导入 dotenv 文件，然后执行 run_command 方法，找到 <a href=\"http://hello.py\">hello.py</a> 然后导入</p>\n<pre><code class=\"language-python\">#cli<span class=\"token punctuation\">.</span>py#run_command 方法\napp <span class=\"token operator\">=</span> <span class=\"token function\">DispatchingApp</span><span class=\"token punctuation\">(</span>info<span class=\"token punctuation\">.</span>load_app<span class=\"token punctuation\">,</span> use_eager_loading<span class=\"token operator\">=</span>eager_loading<span class=\"token punctuation\">)</span>\n# 上一行代表着其实我们每次在本地 flask run 的时候，起的服务并不是 flask_app<span class=\"token punctuation\">,</span> 而是被 DispatchingApp 包装了一层的 flask app\n\nfrom werkzeug<span class=\"token punctuation\">.</span>serving <span class=\"token keyword\">import</span> run_simple\n<span class=\"token function\">run_simple</span><span class=\"token punctuation\">(</span>host<span class=\"token punctuation\">,</span> port<span class=\"token punctuation\">,</span> app<span class=\"token punctuation\">,</span> use_reloader<span class=\"token operator\">=</span>reload<span class=\"token punctuation\">,</span> use_debugger<span class=\"token operator\">=</span><span class=\"token keyword\">debugger</span><span class=\"token punctuation\">,</span>\n            threaded<span class=\"token operator\">=</span>with_threads<span class=\"token punctuation\">,</span> ssl_context<span class=\"token operator\">=</span>cert<span class=\"token punctuation\">)</span>\n</code></pre>\n<p>进行这层包装之后，就可以显示 WERKZEUG 的所谓在浏览器中的 报错信息了。</p>\n<p>通常开发时这里的 run_simple 最后会调用 run_with_reloader , 每当程序退出的时候，reloader 就依照策略重新跑一次 reload 一次。</p>\n<pre><code class=\"language-python\">def <span class=\"token function\">run_with_reloader</span><span class=\"token punctuation\">(</span>main_func<span class=\"token punctuation\">,</span> extra_files<span class=\"token operator\">=</span>None<span class=\"token punctuation\">,</span> interval<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n                      reloader_type<span class=\"token operator\">=</span><span class=\"token string\">'auto'</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>\n    <span class=\"token string\">\"\"</span><span class=\"token string\">\"Run the given function in an independent python interpreter.\"</span><span class=\"token string\">\"\"</span>\n    <span class=\"token keyword\">import</span> signal\n    reloader <span class=\"token operator\">=</span> reloader_loops<span class=\"token punctuation\">[</span>reloader_type<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>extra_files<span class=\"token punctuation\">,</span> interval<span class=\"token punctuation\">)</span>\n    signal<span class=\"token punctuation\">.</span><span class=\"token function\">signal</span><span class=\"token punctuation\">(</span>signal<span class=\"token punctuation\">.</span><span class=\"token constant\">SIGTERM</span><span class=\"token punctuation\">,</span> lambda <span class=\"token operator\">*</span>args<span class=\"token operator\">:</span> sys<span class=\"token punctuation\">.</span><span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">try</span><span class=\"token operator\">:</span>\n        <span class=\"token keyword\">if</span> os<span class=\"token punctuation\">.</span>environ<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">'WERKZEUG_RUN_MAIN'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token string\">'true'</span><span class=\"token operator\">:</span>\n            t <span class=\"token operator\">=</span> threading<span class=\"token punctuation\">.</span><span class=\"token function\">Thread</span><span class=\"token punctuation\">(</span>target<span class=\"token operator\">=</span>main_func<span class=\"token punctuation\">,</span> args<span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            t<span class=\"token punctuation\">.</span><span class=\"token function\">setDaemon</span><span class=\"token punctuation\">(</span>True<span class=\"token punctuation\">)</span>\n            t<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n            reloader<span class=\"token punctuation\">.</span><span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">else</span><span class=\"token operator\">:</span>\n            sys<span class=\"token punctuation\">.</span><span class=\"token function\">exit</span><span class=\"token punctuation\">(</span>reloader<span class=\"token punctuation\">.</span><span class=\"token function\">restart_with_reloader</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    except KeyboardInterrupt<span class=\"token operator\">:</span>\n        pass\n</code></pre>\n<p>好，服务起来了。</p>\n<h3 id=\"22-请求-响应的流程\"><a class=\"v-toc-item\" href=\"#22-请求-响应的流程\">#</a> 2.2 请求-响应的流程</h3>\n<p>我们先看 Flask 类里面的比较关键的两个方法：</p>\n<pre><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Flask</span><span class=\"token punctuation\">(</span>_PackageBoundObject<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>\n    # 一些方法 <span class=\"token operator\">...</span><span class=\"token operator\">...</span>\n    def <span class=\"token function\">full_dispatch_request</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>\n        # 主要是执行一些方法，最后返回响应\n        self<span class=\"token punctuation\">.</span><span class=\"token function\">try_trigger_before_first_request_functions</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">try</span><span class=\"token operator\">:</span>\n            request_started<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span>\n            rv <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span><span class=\"token function\">preprocess_request</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">if</span> rv is None<span class=\"token operator\">:</span>\n                rv <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span><span class=\"token function\">dispatch_request</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        except Exception <span class=\"token keyword\">as</span> e<span class=\"token operator\">:</span>\n            rv <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span><span class=\"token function\">handle_user_exception</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span>\n        # <span class=\"token operator\">??</span><span class=\"token operator\">?</span> <span class=\"token constant\">TODO</span>\n        <span class=\"token keyword\">return</span> self<span class=\"token punctuation\">.</span><span class=\"token function\">finalize_request</span><span class=\"token punctuation\">(</span>rv<span class=\"token punctuation\">)</span>\n\n    # 这里是我们熟悉的 environ<span class=\"token punctuation\">,</span> 和 start_response\n    def <span class=\"token function\">wsgi_app</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> environ<span class=\"token punctuation\">,</span> start_response<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>\n        <span class=\"token string\">\"\"</span>\"\n        <span class=\"token operator\">:</span>param environ<span class=\"token operator\">:</span> a <span class=\"token constant\">WSGI</span> environment\n        <span class=\"token operator\">:</span>param start_response<span class=\"token operator\">:</span> a callable accepting a status code<span class=\"token punctuation\">,</span>\n                               a list <span class=\"token keyword\">of</span> headers and an optional\n                               exception context to start the response\n        <span class=\"token string\">\"\"</span>\"\n        # 在这里对 environ 进行封装，创建请求上下文\n        ctx <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span><span class=\"token function\">request_context</span><span class=\"token punctuation\">(</span>environ<span class=\"token punctuation\">)</span>\n        error <span class=\"token operator\">=</span> None\n        <span class=\"token keyword\">try</span><span class=\"token operator\">:</span>\n            <span class=\"token keyword\">try</span><span class=\"token operator\">:</span>\n                # 这里将请求上下文压入 _request_ctx_stack\n                ctx<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n                response <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span><span class=\"token function\">full_dispatch_request</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n            except Exception <span class=\"token keyword\">as</span> e<span class=\"token operator\">:</span>\n                error <span class=\"token operator\">=</span> e\n                response <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span><span class=\"token function\">handle_exception</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span>\n            except<span class=\"token operator\">:</span>\n                error <span class=\"token operator\">=</span> sys<span class=\"token punctuation\">.</span><span class=\"token function\">exc_info</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n                raise\n            <span class=\"token keyword\">return</span> <span class=\"token function\">response</span><span class=\"token punctuation\">(</span>environ<span class=\"token punctuation\">,</span> start_response<span class=\"token punctuation\">)</span>\n        finally<span class=\"token operator\">:</span>\n            <span class=\"token keyword\">if</span> self<span class=\"token punctuation\">.</span><span class=\"token function\">should_ignore_error</span><span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>\n                error <span class=\"token operator\">=</span> None\n            # 这里将创建的请求上下文从中 _request_ctx_stack pop 出来\n            ctx<span class=\"token punctuation\">.</span><span class=\"token function\">auto_pop</span><span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">)</span>\n</code></pre>\n<p>从 wsgi_app 泪看，就可以看到我们之前在当时在开脑洞时候看到的。</p>\n<ol>\n<li>把 request 和 response 封装一下？方便在 view 里面处理？</li>\n<li>有个 URLDisparch 之类的东西，帮你解决 url 和 view 的 mapping 问题。</li>\n</ol>\n<p>话说回来？</p>\n<blockquote>\n<p>这个 ctx 是啥？<br>\n当然，flask 不带 ORM, 这我们也就不研究了。</p>\n</blockquote>\n<p>– TODO: 在这里需要重构一下</p>\n<p>不过话说回来 请求上下文的容器 request_ctx_stack 到底是啥？</p>\n<blockquote>\n<p>另一种本地数据存储方式。</p>\n</blockquote>\n<p>在多线程的情况下，每一个请求都会创建一个线程，从这个请求被发起到销毁，我想拥有单独的变量（修改这个变量不会影响到其他变量），比如 sessions 之类。</p>\n<p>显然，在多线程的情况下，以上的需求完全可以通过 threadlocal 来实现。</p>\n<p>翻了 werkzeug 的文档，找到了原因：</p>\n<blockquote>\n<p>因为 python 里面的并发模型并不只有多线程一种。比如 greenlets, 每一个请求，都在一个线程里面。</p>\n</blockquote>\n<h2 id=\"0x02-问题-2-flask-中-context-机制\"><a class=\"v-toc-item\" href=\"#0x02-问题-2-flask-中-context-机制\">#</a> 0x02 问题 2: Flask 中 Context 机制</h2>\n<p>在 Django 完成一个 View 层的逻辑是这样的，Django 封装好了请求，请求经过 middleware 的处理，最后调用 login 函数，并且传入 request 方便 view 函数进行处理。</p>\n<pre><code class=\"language-python\">def <span class=\"token function\">login</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>\n    <span class=\"token keyword\">if</span> request<span class=\"token punctuation\">.</span>method <span class=\"token operator\">==</span> <span class=\"token string\">'POST'</span><span class=\"token operator\">:</span>\n        error <span class=\"token operator\">=</span> someerror\n    <span class=\"token keyword\">return</span> <span class=\"token function\">render_template</span><span class=\"token punctuation\">(</span><span class=\"token string\">'login.html'</span><span class=\"token punctuation\">,</span> error<span class=\"token operator\">=</span>error<span class=\"token punctuation\">)</span>\n</code></pre>\n<p>在 Flask 完成一个 View 层的逻辑是这样的</p>\n<pre><code class=\"language-python\">from flask <span class=\"token keyword\">import</span> request\n@app<span class=\"token punctuation\">.</span><span class=\"token function\">route</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/login'</span><span class=\"token punctuation\">,</span> methods<span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token string\">'POST'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'GET'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\ndef <span class=\"token function\">login</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>\n    <span class=\"token keyword\">if</span> request<span class=\"token punctuation\">.</span>method <span class=\"token operator\">==</span> <span class=\"token string\">'POST'</span><span class=\"token operator\">:</span>\n        error <span class=\"token operator\">=</span> someerror\n    <span class=\"token keyword\">return</span> <span class=\"token function\">render_template</span><span class=\"token punctuation\">(</span><span class=\"token string\">'login.html'</span><span class=\"token punctuation\">,</span> error<span class=\"token operator\">=</span>error<span class=\"token punctuation\">)</span>\n</code></pre>\n<p>假如我是一个爱问问题的年轻人，这里肯定会有疑惑：</p>\n<blockquote>\n<p>从外部 import 过来，那就是利用了 python 自带的 import 单例模式。 那么线程和线程之间拿到的肯定是同一个 request 呀。但 Django 里面每个 request 都是不一样的，否则一些很基础功能的比如已经认证的用户就无法拿到了。</p>\n</blockquote>\n<p>我已经不是那个爱问问题的年轻人，因为年纪已经不小了。逃…</p>\n<p>显然，每一次在 view 层引用的 request 肯定不是同一个 request , 那么，这是如何做到的呢？比如用 ThreadLocal , ThreadLocal 通过每个线程不同的 ID 拿到的本地变量，于是我们查看一下对应的实现。 这个 request 来自于 <a href=\"http://global.py\">global.py</a> , 使用了一个 werkzeug.local 里面的 LocalProxy</p>\n<pre><code class=\"language-python\">from functools <span class=\"token keyword\">import</span> partial\nfrom werkzeug<span class=\"token punctuation\">.</span>local <span class=\"token keyword\">import</span> LocalStack<span class=\"token punctuation\">,</span> LocalProxy\n\ndef <span class=\"token function\">_lookup_req_object</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>\n    top <span class=\"token operator\">=</span> _request_ctx_stack<span class=\"token punctuation\">.</span>top\n    <span class=\"token keyword\">if</span> top is None<span class=\"token operator\">:</span>\n        raise <span class=\"token function\">RuntimeError</span><span class=\"token punctuation\">(</span>_request_ctx_err_msg<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">getattr</span><span class=\"token punctuation\">(</span>top<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span>\n\ndef <span class=\"token function\">_lookup_app_object</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>\n    top <span class=\"token operator\">=</span> _app_ctx_stack<span class=\"token punctuation\">.</span>top\n    <span class=\"token keyword\">if</span> top is None<span class=\"token operator\">:</span>\n        raise <span class=\"token function\">RuntimeError</span><span class=\"token punctuation\">(</span>_app_ctx_err_msg<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">getattr</span><span class=\"token punctuation\">(</span>top<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span>\n\ndef <span class=\"token function\">_find_app</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>\n    top <span class=\"token operator\">=</span> _app_ctx_stack<span class=\"token punctuation\">.</span>top\n    <span class=\"token keyword\">if</span> top is None<span class=\"token operator\">:</span>\n        raise <span class=\"token function\">RuntimeError</span><span class=\"token punctuation\">(</span>_app_ctx_err_msg<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> top<span class=\"token punctuation\">.</span>app\n\n# context locals\n_request_ctx_stack <span class=\"token operator\">=</span> <span class=\"token function\">LocalStack</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n_app_ctx_stack <span class=\"token operator\">=</span> <span class=\"token function\">LocalStack</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\ncurrent_app <span class=\"token operator\">=</span> <span class=\"token function\">LocalProxy</span><span class=\"token punctuation\">(</span>_find_app<span class=\"token punctuation\">)</span>\n# 这就是我们需要的注意的地方，LocalProxy\nrequest <span class=\"token operator\">=</span> <span class=\"token function\">LocalProxy</span><span class=\"token punctuation\">(</span><span class=\"token function\">partial</span><span class=\"token punctuation\">(</span>_lookup_req_object<span class=\"token punctuation\">,</span> <span class=\"token string\">'request'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nsession <span class=\"token operator\">=</span> <span class=\"token function\">LocalProxy</span><span class=\"token punctuation\">(</span><span class=\"token function\">partial</span><span class=\"token punctuation\">(</span>_lookup_req_object<span class=\"token punctuation\">,</span> <span class=\"token string\">'session'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\ng <span class=\"token operator\">=</span> <span class=\"token function\">LocalProxy</span><span class=\"token punctuation\">(</span><span class=\"token function\">partial</span><span class=\"token punctuation\">(</span>_lookup_app_object<span class=\"token punctuation\">,</span> <span class=\"token string\">'g'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p>看到这里一阵蛋疼，貌似没有 threadlocal ？再次查看相关实现最后还是定位到了如何区分不同的 request 的核心代码。</p>\n<pre><code class=\"language-python\"># since each thread has its own greenlet we can just use those <span class=\"token keyword\">as</span> identifiers\n# <span class=\"token keyword\">for</span> the context<span class=\"token punctuation\">.</span>  If greenlets are not available we fall back to the\n# current thread ident depending on where it is<span class=\"token punctuation\">.</span>\n<span class=\"token keyword\">try</span><span class=\"token operator\">:</span>\n    from greenlet <span class=\"token keyword\">import</span> getcurrent <span class=\"token keyword\">as</span> get_ident\n    # greenlet 的代码是 <span class=\"token constant\">C</span><span class=\"token punctuation\">,</span> 时间长没看 <span class=\"token constant\">C</span> 代码了，看了半天没看明白\n    # 翻了文档返回当前的 greenlet<span class=\"token punctuation\">,</span> 也就是返回调用此函数的 greenlet\nexcept ImportError<span class=\"token operator\">:</span>\n    <span class=\"token keyword\">try</span><span class=\"token operator\">:</span>\n        from thread <span class=\"token keyword\">import</span> get_ident\n    except ImportError<span class=\"token operator\">:</span>\n        from _thread <span class=\"token keyword\">import</span> get_ident\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Local</span><span class=\"token punctuation\">(</span>object<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>\n    __slots__ <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token string\">'__storage__'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'__ident_func__'</span><span class=\"token punctuation\">)</span>\n\n    def <span class=\"token function\">__init__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>\n        object<span class=\"token punctuation\">.</span><span class=\"token function\">__setattr__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> <span class=\"token string\">'__storage__'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n        # 这里传递的 ident 就可以直接\n        object<span class=\"token punctuation\">.</span><span class=\"token function\">__setattr__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> <span class=\"token string\">'__ident_func__'</span><span class=\"token punctuation\">,</span> get_ident<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">LocalStack</span><span class=\"token operator\">:</span>\n    # 用 local 实现的栈\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">LocalProxy</span><span class=\"token operator\">:</span>\n    # 一个 local 的代理器\n    def <span class=\"token function\">__getattr__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>\n    <span class=\"token keyword\">if</span> name <span class=\"token operator\">==</span> <span class=\"token string\">'__members__'</span><span class=\"token operator\">:</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">dir</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">.</span><span class=\"token function\">_get_current_object</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">getattr</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">.</span><span class=\"token function\">_get_current_object</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span>\n</code></pre>\n<p>即：</p>\n<ol>\n<li>当 Flask 以多线程模型运行的时候，则使用的是 threadlocal 方式</li>\n<li>当 Flask 以 greenlet 的模型运行的时候，则使用的是 greenlet 区分不同</li>\n</ol>\n<p>接下来回头看一下处理 request 的逻辑</p>\n<pre><code class=\"language-python\">from flask <span class=\"token keyword\">import</span> request\n@app<span class=\"token punctuation\">.</span><span class=\"token function\">route</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/login'</span><span class=\"token punctuation\">,</span> methods<span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token string\">'POST'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'GET'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\ndef <span class=\"token function\">login</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>\n    # 这个 request 哪里来？\n    <span class=\"token keyword\">if</span> request<span class=\"token punctuation\">.</span>method <span class=\"token operator\">==</span> <span class=\"token string\">'POST'</span><span class=\"token operator\">:</span>\n        error <span class=\"token operator\">=</span> someerror\n    <span class=\"token keyword\">return</span> <span class=\"token function\">render_template</span><span class=\"token punctuation\">(</span><span class=\"token string\">'login.html'</span><span class=\"token punctuation\">,</span> error<span class=\"token operator\">=</span>error<span class=\"token punctuation\">)</span>\n</code></pre>\n<p>于是，我们就知道了，当引用 request 这个 LocalProxy 的时候，引用的确实是同一个名称为 request 变量，并且这个变量也确实是 LocalProxy 的实例</p>\n<blockquote>\n<p>但是当使用 request.method 的时候，LocalProxy 重载了 取到的则是另一个『请求对象』的 method.</p>\n</blockquote>\n<p>于是拿到当前请求的信息。</p>\n<p>当然，其实我们也可以依据利用这个技巧写一个 currentuser 的 ProxyLocal, 然后在每个 view 层里面使用 user.has_something 进行操作。</p>\n<h2 id=\"0x03-问题-3-flask-中官方的机制\"><a class=\"v-toc-item\" href=\"#0x03-问题-3-flask-中官方的机制\">#</a> 0x03 问题 3: Flask 中官方的机制</h2>\n<h2 id=\"0x04-问题-3-flask-中是如何做到优雅扩展的\"><a class=\"v-toc-item\" href=\"#0x04-问题-3-flask-中是如何做到优雅扩展的\">#</a> 0x04 问题 3: Flask 中是如何做到优雅扩展的</h2>\n<h2 id=\"0x05-其他问题\"><a class=\"v-toc-item\" href=\"#0x05-其他问题\">#</a> 0x05 其他问题</h2>\n<h3 id=\"flask-应用\"><a class=\"v-toc-item\" href=\"#flask-应用\">#</a> Flask 应用</h3>\n<hr>\n<p>ChangeLog:</p>\n<ul>\n<li><strong>2018-03-09</strong> 重修文字</li>\n</ul>\n","toc":"<ul class=\"v-article-toc\">\n<li>\n<ul>\n<li><a href=\"#0x00-%E5%89%8D%E8%A8%80\">0x00 前言</a></li>\n<li><a href=\"#0x01-%E9%98%85%E8%AF%BB-flask-%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B8%80%E7%A7%8D%E8%BE%83%E5%A5%BD%E7%9A%84%E5%A7%BF%E5%8A%BF\">0x01 阅读 Flask 代码的一种较好的姿势</a></li>\n<li><a href=\"#0x02-%E9%97%AE%E9%A2%98-1-%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA-web-%E6%A1%86%E6%9E%B6\">0x02 问题 1: 如何设计一个 Web 框架</a>\n<ul>\n<li><a href=\"#%E5%A4%B4%E8%84%91%E9%A3%8E%E6%9A%B4\">头脑风暴</a></li>\n<li><a href=\"#%E8%AE%BE%E8%AE%A1-web-%E6%A1%86%E6%9E%B6\">设计 Web 框架</a></li>\n</ul>\n</li>\n<li><a href=\"#0x02-%E9%97%AE%E9%A2%98-2-%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84\">0x02 问题 2: 请求流程是怎么样的</a>\n<ul>\n<li><a href=\"#21-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%98%AF%E6%80%8E%E4%B9%88%E8%B5%B7%E6%9D%A5%E7%9A%84\">2.1 服务器是怎么起来的</a></li>\n<li><a href=\"#22-%E8%AF%B7%E6%B1%82-%E5%93%8D%E5%BA%94%E7%9A%84%E6%B5%81%E7%A8%8B\">2.2 请求-响应的流程</a></li>\n</ul>\n</li>\n<li><a href=\"#0x02-%E9%97%AE%E9%A2%98-2-flask-%E4%B8%AD-context-%E6%9C%BA%E5%88%B6\">0x02 问题 2: Flask 中 Context 机制</a></li>\n<li><a href=\"#0x03-%E9%97%AE%E9%A2%98-3-flask-%E4%B8%AD%E5%AE%98%E6%96%B9%E7%9A%84%E6%9C%BA%E5%88%B6\">0x03 问题 3: Flask 中官方的机制</a></li>\n<li><a href=\"#0x04-%E9%97%AE%E9%A2%98-3-flask-%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E4%BC%98%E9%9B%85%E6%89%A9%E5%B1%95%E7%9A%84\">0x04 问题 3: Flask 中是如何做到优雅扩展的</a></li>\n<li><a href=\"#0x05-%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98\">0x05 其他问题</a>\n<ul>\n<li><a href=\"#flask-%E5%BA%94%E7%94%A8\">Flask 应用</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n"}},"__N_SSG":true}