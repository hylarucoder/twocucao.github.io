{"pageProps":{"post":{"tags":["Django"],"path":"20180516_PyConDjango.md","title":"PyCon 2018 之 Django 专题","slug":"PyCon 2018 之 Django 专题","date":"2018-05-16","category":"Django","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"<h2 id=\"0x00-前言\"><a class=\"v-toc-item\" href=\"#0x00-前言\">#</a> 0x00 前言</h2>\n<p>PyCon 2018 有很多精彩的演讲，今天的文章里，挑出 Django 的几篇演讲大致讲讲。</p>\n<blockquote>\n<p>注意：为什么是大致讲讲呢？因为即便是你看了我的这篇文章，依然需要多下点功夫自己去看演讲，自己去查资料，自己去消化。我的这篇文章只不过是我看演讲查资料慢慢消化过程中的产物而已。</p>\n</blockquote>\n<h2 id=\"0x01-演讲-1-taking-django-async\"><a class=\"v-toc-item\" href=\"#0x01-演讲-1-taking-django-async\">#</a> 0x01 演讲 1 - Taking Django Async</h2>\n<p>本演讲其实就是为了推广 Django 的新库。django-channels</p>\n<p>这个库从 2015 年首发，现在已经经过了三年的进程。应该算是相对成熟了。</p>\n<p>这个库有什么不走寻常路的地方吗？答案是有的：</p>\n<ol>\n<li>使得 Django 增加了异步协议，比如说 WebSocket 协议</li>\n<li>使得 Django 可运行后台任务。</li>\n</ol>\n<p>作为 v2 版本的核心开发，作者必然是要吐槽一下 v1 版本，然后推荐一下 v2 版本。</p>\n<p>v1 版本的架构设计是这样的。</p>\n<p>核心开发给出了这样的评价：</p>\n<ol>\n<li>在 Python2.7 的时候，就只能这么搞了。</li>\n<li>需要维护的东西太多</li>\n<li>没有 asyncio support</li>\n<li>搬砖时候一不小心容易砸到脚</li>\n</ol>\n<blockquote>\n<p>TODO : 补充一些其他的缺点</p>\n</blockquote>\n<p>异步与同步接口耦合</p>\n<p>作者认为此并非长久之计。</p>\n<p>v2 时候，</p>\n<p>重写 75% 的代码</p>\n<p>异步与同步接口分离</p>\n<p>这么设计的话，需要解决接下来的一个问题，同步转异步，异步转同步。</p>\n<p>比如，我访问 view, 实际上是 async 转 sync, 然后才能调用 django 相关的方法，接着返回响应内容的时候，我还需要 sync 转 async.<br>\n再比如，我使用 websocket, 访问一条数据，但 ORM 是 sync 的方法，我还是要 async 转 sync 再转 async</p>\n<p>这个 async 和 sync 的相互转换应该怎么做呢？</p>\n<p>于是，两个适配方法就诞生了：</p>\n<ul>\n<li>sync_to_async : 接收一个 async 的 function, 使之 awaitable, 然后使之在后台线程里运行。</li>\n<li>async_to_sync : 接收一个 awaitable 的 coroutine , 使之转化成一个同步的 function, 该 function 暂停你调用的当前的线程，跳转到包含 eventloop 的主线程执行完毕，然后跳转回来。</li>\n</ul>\n<p><a href=\"https://www.aeracode.org/2018/02/19/python-async-simplified/\">https://www.aeracode.org/2018/02/19/python-async-simplified/</a></p>\n<h3 id=\"wsgi-如何运行-async\"><a class=\"v-toc-item\" href=\"#wsgi-如何运行-async\">#</a> WSGI 如何运行 async</h3>\n<h3 id=\"asgi-如何运行-a\"><a class=\"v-toc-item\" href=\"#asgi-如何运行-a\">#</a> ASGI 如何运行 A</h3>\n<h3 id=\"这对-django-意味着什么\"><a class=\"v-toc-item\" href=\"#这对-django-意味着什么\">#</a> 这对 Django 意味着什么？</h3>\n<h3 id=\"如何保持兼容性\"><a class=\"v-toc-item\" href=\"#如何保持兼容性\">#</a> 如何保持兼容性</h3>\n<h2 id=\"0x02-演讲-2-beyond-django-basic\"><a class=\"v-toc-item\" href=\"#0x02-演讲-2-beyond-django-basic\">#</a> 0x02 演讲 2 - Beyond Django Basic</h2>\n<p>作为一名有一定经验的 Django 开发者，用快进的方式看完了这个演讲。毕竟，我已经不是 Django 新手了。</p>\n<blockquote>\n<p>毕竟这篇演讲只是给那些学完 tutorial 的人</p>\n</blockquote>\n<p>想深入了解 Django, 多刷几遍文档比什么都好。</p>\n<p>嗯，就不介绍了。</p>\n<h2 id=\"0x03-演讲-3-introduction-to-tdd-with-django-intermediate-testing-with-django\"><a class=\"v-toc-item\" href=\"#0x03-演讲-3-introduction-to-tdd-with-django-intermediate-testing-with-django\">#</a> 0x03 演讲 3 - Introduction to TDD with Django &amp;&amp; Intermediate testing with Django</h2>\n<p>本演讲主要内容是 TDD 测试和 Mock 的技巧。</p>\n<p>建议熟手直接看演讲者的书吧，本视频本人仅仅匆匆倍速看了一遍，估计并没有超出他的书的范围。</p>\n<p>简单介绍了以下内容</p>\n<ul>\n<li>单元测试和功能性测试</li>\n<li>通过 Selenium browser 进行自动化测试</li>\n<li>unittest 标准库</li>\n<li>Django models, views and templates</li>\n<li>测试前后端代码</li>\n<li>基于测试的重构</li>\n<li>TDD workflow</li>\n</ul>\n<p>地址如下</p>\n<p><a href=\"https://www.obeythetestinggoat.com/book/praise.harry.html\">https://www.obeythetestinggoat.com/book/praise.harry.html</a></p>\n<p>说说个人对测试和 TDD 测试的基本态度，我觉得测试是好事，适当的测试是可以提升代码质量和程序稳定性的。</p>\n<p>说测试会降低开发速度的，八成是没有善用测试。如果测试拖慢了你的开发速度，只能说明没有进行合适的测试，比如对一些无关紧要的功能进行测试。</p>\n<p>但，这篇演讲和配套资料很好，不过有些美中不足。 这里基本上都还在用 Django 的 MTV 这一套。</p>\n<blockquote>\n<p>我反正是不用这一套了。这个年头流行 SPA 呀。</p>\n</blockquote>\n<p>所以，我们这篇演讲指的关注的内容就变成如下内容了。</p>\n<ul>\n<li>单元测试和功能性测试</li>\n<li>unittest 标准库</li>\n<li>Django models</li>\n<li>基于测试的重构</li>\n<li>TDD workflow</li>\n</ul>\n<p>而且，对于 API 的测试，现在基本上流行 POSTMAN</p>\n<p>用 POSTMAN 的优点就在于可以把参数缓存下来下次接着用。有个小技巧就是从 chrome 拷贝一下 curl 到 postman 中。非常好用。</p>\n<p>既然流行 SPA, 那么本次有没有介绍开 API 的利器呢？</p>\n<h2 id=\"0x04-演讲-4-api-driven-django\"><a class=\"v-toc-item\" href=\"#0x04-演讲-4-api-driven-django\">#</a> 0x04 演讲 4 - API-Driven Django</h2>\n<p>嗯，Django + django-rest-framework 实在是开 WebAPI 的神器。</p>\n<p>这篇演讲，算是普及了一下常识。并没有想象当中的深入。</p>\n<p>想用 Django 和 DjangoRestFramework 搞事情的，可以过来看我这篇文章。</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/33903527\">https://zhuanlan.zhihu.com/p/33903527</a></p>\n<blockquote>\n<p>需要注意的是，本次 PyCon 中有很多人已经用上了 pipenv 了。</p>\n</blockquote>\n<h2 id=\"0x05-演讲-5-pipenv-未来的-python-包管理工具\"><a class=\"v-toc-item\" href=\"#0x05-演讲-5-pipenv-未来的-python-包管理工具\">#</a> 0x05 演讲 5 - pipenv 未来的 Python 包管理工具</h2>\n<p>Kenneth Reitz 出品，必属精品。</p>\n<h3 id=\"python-打包历史\"><a class=\"v-toc-item\" href=\"#python-打包历史\">#</a> Python 打包历史</h3>\n<p>刚开始，我们是这样安装包的。</p>\n<pre><code>curl http://pypi.python.org/packages/alsdasdl/requests.tar.gz | tar zxf\ncd requests/\npython setup.py install\n</code></pre>\n<p>这个问题初看起来不是问题，但是随着你安装程序的增多就知道有多么痛苦了。</p>\n<ol>\n<li>有的依赖库依赖别的库你怎么解决？比如 pandas 需要安装 numpy</li>\n<li>有的依赖库依赖 c 库怎么办？比如 LXML</li>\n<li>在 python2.6.5 下，如果我需要安装两个不同版本的 Django 开发不同的软件怎么办？难道只能动态复制文件到 site-packages 里面？</li>\n</ol>\n<p>后来，我们是这样安装包的。</p>\n<pre><code>easy_install requests\n</code></pre>\n<p>我们可以直接从 pypi 进行安装了。但尼玛，为什么 easy_install 安装很 easy, 但是没有 easy_uninstall?</p>\n<p>好，2010 年后，我们继续前进：</p>\n<ul>\n<li>可以通过 pip 替代 easy_install 了。</li>\n<li>可以通过 virtualenv 管理项目的依赖库了。虽然说，还是不能像 ruby gem 一样同时把多个版本的的软件装在同一个系统里。</li>\n<li>可以通过 requirements 锁依赖了。</li>\n</ul>\n<p>但，其他编程语言社区分别出现了如下的包管理工具：</p>\n<ul>\n<li>node -&gt; yarn &amp;&amp; npm , 有 lockfile</li>\n<li>php -&gt; composer , 有 lockfile</li>\n<li>rust -&gt; cargo , 有 lockfile</li>\n<li>ruby -&gt; bundler , 有 lockfile</li>\n</ul>\n<p>而生命苦短一方居然</p>\n<ul>\n<li>python -&gt; pip &amp;&amp; virtualenv/venv , 无 lockfile</li>\n</ul>\n<blockquote>\n<p>PS: Python3.3 之后，默认可以直接使用 venv 模块，不需要再安装 virtualenv 了。但还是需要手动，并且用起来比较反直觉。</p>\n</blockquote>\n<p>关于 requirements.txt</p>\n<ul>\n<li>如果你使用 pip freeze 来形成这个文件，则不直观，完全看不出来哪个依赖库依赖哪个依赖。</li>\n<li>如果你直接手动指定你所需要的库，比如 flask 的话，似乎又有些太直观了。</li>\n</ul>\n<p>如果能有一个东西，既可以表示 freeze 的结果 (what you want)，又可以表示你需要的库 (what you need). 就好了。</p>\n<blockquote>\n<p>这当然可以考虑用两份 requirements 来解决。先安装 what you need 用来开发，然后 freeze 为 what you want 去部署。</p>\n</blockquote>\n<p>当然，铺垫了这么多 K 神肯定是来介绍他的 pipenv 的。</p>\n<p>比如说，我想查看，本项目的依赖库，直接 pipenv graph</p>\n<pre><code>coverage==4.5.1\nfabric==2.0.1\n  - cryptography [required: &gt;=1.1, installed: 2.2.2]\n    - asn1crypto [required: &gt;=0.21.0, installed: 0.24.0]\n    - cffi [required: &gt;=1.7, installed: 1.11.5]\n      - pycparser [required: Any, installed: 2.18]\n    - idna [required: &gt;=2.1, installed: 2.6]\n    - six [required: &gt;=1.4.1, installed: 1.11.0]\n  - invoke [required: &lt;2.0,&gt;=1.0, installed: 1.0.0]\n  - paramiko [required: &gt;=2.4, installed: 2.4.1]\n    - bcrypt [required: &gt;=3.1.3, installed: 3.1.4]\n      - cffi [required: &gt;=1.1, installed: 1.11.5]\n        - pycparser [required: Any, installed: 2.18]\n      - six [required: &gt;=1.4.1, installed: 1.11.0]\n    - cryptography [required: &gt;=1.5, installed: 2.2.2]\n      - asn1crypto [required: &gt;=0.21.0, installed: 0.24.0]\n      - cffi [required: &gt;=1.7, installed: 1.11.5]\n        - pycparser [required: Any, installed: 2.18]\n      - idna [required: &gt;=2.1, installed: 2.6]\n      - six [required: &gt;=1.4.1, installed: 1.11.0]\n    - pyasn1 [required: &gt;=0.1.7, installed: 0.4.2]\n    - pynacl [required: &gt;=1.0.1, installed: 1.2.1]\n      - cffi [required: &gt;=1.4.1, installed: 1.11.5]\n        - pycparser [required: Any, installed: 2.18]\n      - six [required: Any, installed: 1.11.0]\nflake8==3.5.0\n  - mccabe [required: &gt;=0.6.0,&lt;0.7.0, installed: 0.6.1]\n  - pycodestyle [required: &lt;2.4.0,&gt;=2.0.0, installed: 2.3.1]\n  - pyflakes [required: &gt;=1.5.0,&lt;1.7.0, installed: 1.6.0]\n# 其他省略\n</code></pre>\n<p>如何尝鲜？我最近更新到了之前写的一个库（代码写的惨不忍赌，最近准备重构）</p>\n<pre><code>git clone git@github.com:twocucao/YaPyLib.git\ncd YaPyLib/\nbrew install pipenv\npipenv --three\npipenv install --dev\npipenv shell\n</code></pre>\n<p>至于其他的功能，参考官网自己摸索吧。</p>\n<blockquote>\n<p>在用 npm 和 yarn 的时候，我有这么一个想法，希望 python 圈子里面能出一个类似于包管理工具。今年 2 月份的时候把自己的项目迁移过来，发现 pipenv 用起来很挺舒服的。</p>\n</blockquote>\n<blockquote>\n<p>pipenv 是未来。火速用上吧。</p>\n</blockquote>\n<h2 id=\"0xee-参考链接\"><a class=\"v-toc-item\" href=\"#0xee-参考链接\">#</a> 0xEE 参考链接</h2>\n<hr>\n<p>ChangeLog:</p>\n<ul>\n<li><strong>2018-03-09</strong> 重修文字</li>\n</ul>\n","toc":"<ul class=\"v-article-toc\">\n<li>\n<ul>\n<li><a href=\"#0x00-%E5%89%8D%E8%A8%80\">0x00 前言</a></li>\n<li><a href=\"#0x01-%E6%BC%94%E8%AE%B2-1-taking-django-async\">0x01 演讲 1 - Taking Django Async</a>\n<ul>\n<li><a href=\"#wsgi-%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C-async\">WSGI 如何运行 async</a></li>\n<li><a href=\"#asgi-%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C-a\">ASGI 如何运行 A</a></li>\n<li><a href=\"#%E8%BF%99%E5%AF%B9-django-%E6%84%8F%E5%91%B3%E7%9D%80%E4%BB%80%E4%B9%88\">这对 Django 意味着什么？</a></li>\n<li><a href=\"#%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8C%81%E5%85%BC%E5%AE%B9%E6%80%A7\">如何保持兼容性</a></li>\n</ul>\n</li>\n<li><a href=\"#0x02-%E6%BC%94%E8%AE%B2-2-beyond-django-basic\">0x02 演讲 2 - Beyond Django Basic</a></li>\n<li><a href=\"#0x03-%E6%BC%94%E8%AE%B2-3-introduction-to-tdd-with-django-intermediate-testing-with-django\">0x03 演讲 3 - Introduction to TDD with Django &amp;&amp; Intermediate testing with Django</a></li>\n<li><a href=\"#0x04-%E6%BC%94%E8%AE%B2-4-api-driven-django\">0x04 演讲 4 - API-Driven Django</a></li>\n<li><a href=\"#0x05-%E6%BC%94%E8%AE%B2-5-pipenv-%E6%9C%AA%E6%9D%A5%E7%9A%84-python-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7\">0x05 演讲 5 - pipenv 未来的 Python 包管理工具</a>\n<ul>\n<li><a href=\"#python-%E6%89%93%E5%8C%85%E5%8E%86%E5%8F%B2\">Python 打包历史</a></li>\n</ul>\n</li>\n<li><a href=\"#0xee-%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\">0xEE 参考链接</a></li>\n</ul>\n</li>\n</ul>\n"}},"__N_SSG":true}