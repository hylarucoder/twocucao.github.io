{"pageProps":{"post":{"tags":["Pandas","Numpy","CheatSheet"],"path":"20180210_ElasticSearchCheatSheet.md","title":"ElasticSearch CheatSheet","slug":"ElasticSearch CheatSheet","date":"2018-02-10","category":"DevOps","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"<h2 id=\"0x00-前言\"><a class=\"v-toc-item\" href=\"#0x00-前言\">#</a> 0x00 前言</h2>\n<p>本文为 Cheatsheet 类型文章，用于记录我在日常编程中经常使用的 ElasticSearch 相关和命令。</p>\n<blockquote>\n<p>最早使用 ElasticSearch 是两年前了。最近准备用 Django 写一个全栈式的应用，借用强大的 ES 来做搜索。</p>\n</blockquote>\n<p>这是我在写程序之余写这篇笔记的原因。最近因为换工作的事情耽误了教程更新，就把这篇笔记放出来吧。不定期更新。</p>\n<p>官网介绍 ElasticSearch 不仅仅是全文搜索，也可以结构化搜索（这里用结构化查询会更准确一些），处理人类语言，地理位置，以及关系。</p>\n<p>然而，我在项目使用过程中还是主要用到了全文搜索以及推荐。</p>\n<p>不用其他的主要原因是因为 ES 尺有所短寸有所长：</p>\n<ol>\n<li>geo 处理方面 postgis 完全就是神一般的存在。为什么还要用 ES 呢？</li>\n<li>关系型数据库的核心不就是处理关系？复杂的关系肯定还是放在关系数据库里面。</li>\n</ol>\n<ul>\n<li>highlighted search</li>\n<li>search-as-you-type</li>\n<li>did-you-mean suggestions</li>\n</ul>\n<p>我对 ElasticSearch 在后台组件里的作用在于搜索与推荐：</p>\n<ol>\n<li>整站的搜索功能</li>\n</ol>\n<ul>\n<li>全文搜索</li>\n</ul>\n<ol start=\"2\">\n<li>推荐</li>\n</ol>\n<ul>\n<li>依据某几个维度的数据进行排序</li>\n</ul>\n<p>知乎的文章居然不支持 toc, 实在是太蛋疼了。</p>\n<p>文章目录如下</p>\n<pre><code>  ▼ 0x00 前言 : section\n  ▼ 0x01 安装，配置，基本 shell 命令 : section\n      1. 安装 : section\n      2. 配置 : section\n      3. 插件 : section\n    0x02 ElasticSearch 配套工具 : section\n  ▼ 0x03 ElasticSearch 基础概念 : section\n    ▼ 3.1 Elasticsearch CRUDE 以及基本操作 : section\n        CURDE : section\n        普通搜索 : section\n        聚集搜索 : section\n  ▼ 0x04 全文搜索的基本概念 : section\n      4.1 全文搜索遇到的挑战 : section\n    ▼ 4.2 全文搜索的索引时与查询时 : section\n        1. 索引时 ES 做了什么？ : section\n        2. 查询时 ES 做了什么？ : section\n        3. 全文搜索调优之中文分词 : section\n        4. 全文搜索调优之停止词 : section\n        5. 全文搜索调优之同义词 : section\n        6. 全文搜索调优之拼写错误 : section\n      ▼ 7. 全文搜索调优之相关性 : section\n          索引时三因素 : section\n          查询时 : section\n          计算公式 : section\n    0x05 搜索语法 : section\n    0x06 Python SDK : section\n    0x07 踩坑集 : section\n    0xEE 参考链接 : section\n</code></pre>\n<!-- more -->\n<h2 id=\"0x01-安装配置基本-shell-命令\"><a class=\"v-toc-item\" href=\"#0x01-安装配置基本-shell-命令\">#</a> 0x01 安装，配置，基本 shell 命令</h2>\n<h3 id=\"1-安装\"><a class=\"v-toc-item\" href=\"#1-安装\">#</a> 1. 安装</h3>\n<p>具体在项目中的配置建议看一下我写的配置文章 <a href=\"https://zhuanlan.zhihu.com/p/33920401\">https://zhuanlan.zhihu.com/p/33920401</a> 和并且参考现有代码 <a href=\"https://github.com/twocucao/YaDjangoBlog\">https://github.com/twocucao/YaDjangoBlog</a></p>\n<pre><code># 执行如下的命令\ncurl 'http://localhost:9200/?pretty'\n# 输出结果\n{\n  &quot;name&quot; : &quot;XOGvo8a&quot;,\n  &quot;cluster_name&quot; : &quot;docker-cluster&quot;,\n  &quot;cluster_uuid&quot; : &quot;fAwp341bQzalzBxRFyD1YA&quot;,\n  &quot;version&quot; : {\n    &quot;number&quot; : &quot;6.2.1&quot;,\n    &quot;build_hash&quot; : &quot;7299dc3&quot;,\n    &quot;build_date&quot; : &quot;2018-02-07T19:34:26.990113Z&quot;,\n    &quot;build_snapshot&quot; : false,\n    &quot;lucene_version&quot; : &quot;7.2.1&quot;,\n    &quot;minimum_wire_compatibility_version&quot; : &quot;5.6.0&quot;,\n    &quot;minimum_index_compatibility_version&quot; : &quot;5.0.0&quot;\n  },\n  &quot;tagline&quot; : &quot;You Know, for Search&quot;\n}\n</code></pre>\n<h3 id=\"2-配置\"><a class=\"v-toc-item\" href=\"#2-配置\">#</a> 2. 配置</h3>\n<p>配置略</p>\n<h3 id=\"3-插件\"><a class=\"v-toc-item\" href=\"#3-插件\">#</a> 3. 插件</h3>\n<p>ES 的插件有很多，截止笔者写这篇文章的时候，ES 最新的版本是 6.2.1 版本。</p>\n<blockquote>\n<p>PS: 两年前我用的还是 2.3.3 版本。新版本有很多插件配置起来已经有所不同了。比如说 head 现在已经被独立出来作为一个单纯的网页，chrome 商店可以直接下载。</p>\n</blockquote>\n<p>需要配 ik-analyser. 如果你在 YaDjangoBlog 中起了这个命令，则已经配置完毕。</p>\n<h2 id=\"0x02-elasticsearch-配套工具\"><a class=\"v-toc-item\" href=\"#0x02-elasticsearch-配套工具\">#</a> 0x02 ElasticSearch 配套工具</h2>\n<p>建议使用 Head 插件来进行简单的查询与调试。</p>\n<h2 id=\"0x03-elasticsearch-基础概念\"><a class=\"v-toc-item\" href=\"#0x03-elasticsearch-基础概念\">#</a> 0x03 ElasticSearch 基础概念</h2>\n<h3 id=\"31-elasticsearch-crude-以及基本操作\"><a class=\"v-toc-item\" href=\"#31-elasticsearch-crude-以及基本操作\">#</a> 3.1 Elasticsearch CRUDE 以及基本操作</h3>\n<p>详细的搜索见 Python SDK</p>\n<h4 id=\"curde\"><a class=\"v-toc-item\" href=\"#curde\">#</a> CURDE</h4>\n<p>ES 使用的是 RESTFUL API 接口</p>\n<p>这也就意味着：</p>\n<ul>\n<li>PUT 创建记录</li>\n<li>GET 获取记录</li>\n<li>POST 更新记录</li>\n<li>DELETE 删除记录</li>\n<li>HEAD 是否存在</li>\n</ul>\n<h4 id=\"结构化搜索\"><a class=\"v-toc-item\" href=\"#结构化搜索\">#</a> 结构化搜索</h4>\n<p>ES 写复杂查询的时候，语法乱，这个过程需要多翻看 guide 和手册。</p>\n<p><a href=\"https://www.elastic.co/guide/en/elasticsearch/guide/current/structured-search.html\">https://www.elastic.co/guide/en/elasticsearch/guide/current/structured-search.html</a></p>\n<h4 id=\"全文搜索\"><a class=\"v-toc-item\" href=\"#全文搜索\">#</a> 全文搜索</h4>\n<p>全文搜索包含两个重要方面：</p>\n<ul>\n<li>相关性：通过 TF/IDF , 距离 , 模糊相似度，以及其他算法</li>\n<li>分析：大文本 token 化，用于形成倒排索引。这个过程见 4.2</li>\n</ul>\n<p><a href=\"https://www.elastic.co/guide/en/elasticsearch/guide/current/full-text-search.html\">https://www.elastic.co/guide/en/elasticsearch/guide/current/full-text-search.html</a></p>\n<h4 id=\"聚集搜索\"><a class=\"v-toc-item\" href=\"#聚集搜索\">#</a> 聚集搜索</h4>\n<p><a href=\"https://www.elastic.co/guide/en/elasticsearch/guide/current/aggregations.html\">https://www.elastic.co/guide/en/elasticsearch/guide/current/aggregations.html</a></p>\n<h2 id=\"0x04-全文搜索的基本概念\"><a class=\"v-toc-item\" href=\"#0x04-全文搜索的基本概念\">#</a> 0x04 全文搜索的基本概念</h2>\n<h3 id=\"41-全文搜索遇到的挑战\"><a class=\"v-toc-item\" href=\"#41-全文搜索遇到的挑战\">#</a> 4.1 全文搜索遇到的挑战</h3>\n<p>在最初开源搜索引擎技术还不是很成熟的时候，我们一般都会使用 RDBMS 进行简单搜索。</p>\n<p>简单搜索，也就是我们常常使用的 like 查询（当然，有的数据库可以使用正则表达式）</p>\n<p>这种方式是简单暴力的查询方式，优点是实现起来简单暴力。缺点是在这个场景下性能和准确度很差。</p>\n<p>举例：</p>\n<ul>\n<li>假如站点里文章数量比较大，并且文章内容比较长，则进行一次全表查询，效率可想而知。当然，做好分库分表读写分离也是能用的。</li>\n<li>如果我要对搜索到的词语进行高亮，则实现方式就只能是把查询到的文章放在应用层里面进行批量替换。</li>\n<li>RDBMS 似乎完全不懂语言与语言之间的区别。比如说：\n<ul>\n<li>『停止词 / 常用词』有的字我是不需要的，比如南京的狗，其实我想搜的是南京狗，这里的『的』就不是我需要的。</li>\n<li>『同义词』有的字我需要的是他的同义词，比如日本黄狗，其实我想搜的是柴犬。</li>\n<li>『附加符号』假如说我们搜索一个声调 [nǐ], 总不能让用户打出 [nǐ] 进行搜索吧？总归要转为 ni 才能方便搜索</li>\n<li>『词根形式』对于一个单词，假如是动词可能有时态上的区分，如果是名词，可能有单复数的区分。假如我搜 mice, 其实同样的 mouse 也应该被搜索出来。但有事用这种方式也会矫枉过正，比如 organizations 的 原型其实并不是 organization 而是，organ. （当然，overstemming 和 understemming 也是两个不可忽视的问题）\n<ul>\n<li>Number: fox, foxes</li>\n<li>Tense: pay, paid, paying</li>\n<li>Gender: waiter, waitress</li>\n<li>Person: hear, hears</li>\n<li>Case: I, me, my</li>\n<li>Aspect: ate, eaten</li>\n<li>Mood: so be it, were it so</li>\n<li>PS: 万幸的是，中文处理中木词根这个概念。我也就不深入这块了。</li>\n</ul>\n</li>\n<li>『拼写问题』 周杰棍与周杰伦</li>\n<li>『分词 / 识别词』中文不像英文，词和词之间是完全没有空格的，也就是说，中文天然要比英文多一个关于分词的步骤。</li>\n</ul>\n</li>\n</ul>\n<p>是的，我们需要一种新的姿势，来进行搜索。也就是本文所说的全文搜索。</p>\n<h3 id=\"42-全文搜索的索引时与查询时\"><a class=\"v-toc-item\" href=\"#42-全文搜索的索引时与查询时\">#</a> 4.2 全文搜索的索引时与查询时</h3>\n<p>本小节先搞清楚两个点，</p>\n<ol>\n<li>索引时 ES 做了什么？</li>\n<li>查询时 ES 做了什么？</li>\n</ol>\n<ul>\n<li>索引时，指的是 ElasticSearch 在存储文档的阶段。</li>\n<li>查询时，指的是 ElasticSearch 在查询文档的阶段。</li>\n</ul>\n<h4 id=\"1-索引时-es-做了什么\"><a class=\"v-toc-item\" href=\"#1-索引时-es-做了什么\">#</a> 1. 索引时 ES 做了什么？</h4>\n<blockquote>\n<p>这里我们略过定义 index,type,document 仅仅指某个 field 被赋值 document 被保存的时候针对这个被赋值的 text 类型 field 的处理。</p>\n</blockquote>\n<ul>\n<li>第一步：<strong>文本经过 analyzer 处理</strong></li>\n<li>第二步：<strong>形成倒排索引</strong></li>\n</ul>\n<p>先看第一步：</p>\n<p>通常在定义 field 的时候显式指定 analyzer（分析器）.</p>\n<p>这个 analyzer 一般的作用如下：</p>\n<ul>\n<li>STEP 1: 令牌化文本为独立的词</li>\n<li>STEP 2: 词语转小写</li>\n<li>STEP 3: 去除常见的停止词</li>\n<li>STEP 4: 获取词的词根的原型</li>\n</ul>\n<p>不同的 analyzer 作用大同小异，拿我们常用的 <a href=\"https://github.com/medcl/elasticsearch-analysis-ik\">https://github.com/medcl/elasticsearch-analysis-ik</a> 的话，则也是类似的步骤（下面步骤是我猜测的，没看源码）</p>\n<ol>\n<li>令牌化文本为独立的词语 - 分词，并且令牌化文本为独立的词汇</li>\n<li>除去常见的停止词</li>\n<li>匹配同义词</li>\n<li>…</li>\n</ol>\n<p>可以定义字段的时候可以指定 analyzer（索引时） 与 search_analyzer（查询时）</p>\n<p>先看经过第一步之后，就可以进入第二步形成倒排索引了，此时，倒排索引之于 ElasticSearch 可以类比于 btree 之于 MySQL 或者 Gist 之于 PostgreSQL.</p>\n<p>那么，倒排索引包含哪些东西呢？</p>\n<ul>\n<li><strong>Terms dictionary</strong>\n<ul>\n<li>已排序完毕的 terms, 以及包含这些 terms 的 documents 的数量。</li>\n</ul>\n</li>\n<li><strong>Postings List</strong>\n<ul>\n<li>哪些 document 包含这些词</li>\n</ul>\n</li>\n<li><strong>Terms frequency</strong>\n<ul>\n<li>每个 term 在这些文章的频率</li>\n</ul>\n</li>\n<li><strong>Position</strong>\n<ul>\n<li>每个 term 在每个 document 的位置，这是为了便于 phrase query 和 proximity query</li>\n<li>高频词的 phrase query 可能导致 上 G 的数据被读取。虽然有 cache, 但是远远不够。</li>\n</ul>\n</li>\n<li><strong>Offsets</strong>\n<ul>\n<li>每个 term 在每个 document 的开始和结束，便于高亮</li>\n</ul>\n</li>\n<li><strong>Norms</strong>\n<ul>\n<li>用于给短 field 更多权重的因素.(TODO: 啥玩意）</li>\n</ul>\n</li>\n</ul>\n<p>减少停止词仅仅可以减少少部分 terms dictionary 和 postings list , 但是 positions 和 offsets data 对 index 的影响则是非常大的。</p>\n<h4 id=\"2-查询时-es-做了什么\"><a class=\"v-toc-item\" href=\"#2-查询时-es-做了什么\">#</a> 2. 查询时 ES 做了什么？</h4>\n<ul>\n<li>第一步：<strong>文本经过 analyzer 处理</strong></li>\n<li>第二步：<strong>查询倒排索引</strong></li>\n</ul>\n<p>其实搜索的就是这个玩意。</p>\n<ul>\n<li><strong>Terms dictionary</strong></li>\n<li><strong>Postings List</strong></li>\n<li><strong>Terms frequency</strong></li>\n<li><strong>Position</strong></li>\n<li><strong>Offsets</strong></li>\n<li><strong>Norms</strong></li>\n</ul>\n<p>于是，我们就必须关注如何更好的查询文档了。下面几个小节，你就知道全文搜索是比较难调优的了。好，一个一个来。</p>\n<h4 id=\"3-全文搜索调优之中文分词\"><a class=\"v-toc-item\" href=\"#3-全文搜索调优之中文分词\">#</a> 3. 全文搜索调优之中文分词</h4>\n<p>中文分词以前是个难点，现在基本有成熟的解决方案，在没有更加牛逼的分词技术解决方案之前，现在分词效果主要是拼词典。</p>\n<blockquote>\n<p>TODO: 这个话题可能比较大，先挖坑，以后填</p>\n</blockquote>\n<h4 id=\"4-全文搜索调优之停止词\"><a class=\"v-toc-item\" href=\"#4-全文搜索调优之停止词\">#</a> 4. 全文搜索调优之停止词</h4>\n<p>使用停止词是减少索引大小的一种方式（减小索引效果不明显），那么，哪些词语可以呗当做停止词呢？</p>\n<ul>\n<li>低频词语：低频词语具备高权重</li>\n<li>高频词语：高频词语具备低权重</li>\n</ul>\n<p>当然，是否是高频词语依据个人经验主要依据两点来判断：</p>\n<ul>\n<li>具体场景：比如在英文中，and/the 之类的会比较多，但是中文会比较少。同样的，中文里面其他语言的东西会少一些。正文八经的文章出现不正经的词汇的概率会低。在技术问里面，『数据库』属于高频词汇，但是在比如简书之类的，可能梦想 / 鸡汤 / 超级 / 震惊会多一些。掘金的『前端』两个字绝壁是高频词。</li>\n<li>抽样跑新词发现的程序。社区里多的是新词发现的脚本。对文章内容或者从搜索框记录下来的搜索词跑一下新词发现的程序，然后人工筛选，应该可以发现更多的高频和低频的词汇。</li>\n</ul>\n<p>是不是用上停止词就好了呢？并不是。</p>\n<p>比如：</p>\n<ul>\n<li>假如停止词里面包含了 not , 那么 happy 和 not happy 搜索出来的结果则一致。</li>\n<li>假如停止词里面包含了或，那么，如果有个乐队名字叫做『或或』, 则搜索不出来。</li>\n<li>假如停止词里面包含了 to / be / not / or , 则莎士比亚的名言 『To be, or not to be』 则搜索不出来。</li>\n</ul>\n<h4 id=\"5-全文搜索调优之同义词\"><a class=\"v-toc-item\" href=\"#5-全文搜索调优之同义词\">#</a> 5. 全文搜索调优之同义词</h4>\n<p>同义词也有很多种：</p>\n<ol>\n<li>平级关系：插、戳、刺、扎</li>\n<li>包含关系：成人包含男人和女人</li>\n<li>不容易分清楚关系：</li>\n</ol>\n<ul>\n<li>炒，煎，贴，烹，炸，溜<br>\n　- 汆，涮，煮，炖，煨，焐<br>\n　- 蒸，鲊<br>\n　- 卤，酱，熏，烤，炝，腌，拌，焗</li>\n</ul>\n<p>随着场景的不同，上面有些同义词也是不能轻而易举同义的。</p>\n<table>\n<thead>\n<tr>\n<th>-</th>\n<th>索引时</th>\n<th>查询时</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>索引大小</td>\n<td>耗时变多，同义词被索引，大小更大</td>\n<td>耗时几乎不变</td>\n</tr>\n<tr>\n<td>相关性</td>\n<td>准确度下降，所有同义词相同 IDF, 则在所有文档的索引记录中，常用词和冷门词权重相同</td>\n<td>准确度提升，每个同义词的 IDF 将被校正</td>\n</tr>\n<tr>\n<td>性能</td>\n<td>性能下降，查询需要涨到</td>\n<td>性能下降，查询被重写，用于查找同义词</td>\n</tr>\n<tr>\n<td>灵活性</td>\n<td>变差，同义词法则不改变已存在记录，需重新索引</td>\n<td>不变，同义词法则可被更新，无需重新索引</td>\n</tr>\n</tbody>\n</table>\n<p>由此可见，大部分场景下的索引时如果没有特别的需求，<strong>谨慎使用同义词</strong>。</p>\n<blockquote>\n<p>同义词使用自定义 filter , 并且在新建 analyzer 并指定 filter 即可。</p>\n</blockquote>\n<h4 id=\"6-全文搜索调优之拼写错误\"><a class=\"v-toc-item\" href=\"#6-全文搜索调优之拼写错误\">#</a> 6. 全文搜索调优之拼写错误</h4>\n<p>有的时候，用户也会输入错误：</p>\n<ul>\n<li>手误，把『周杰伦』拼成『周杰棍』</li>\n</ul>\n<p>这个时候，搜索引擎应该提示一下，您搜索的是不是『周杰伦』呢？</p>\n<p>这里面就遇到了一个问题，我们显然知道周杰棍和周杰伦是是相似的，为什么呢？或者说，直观上感知的详细，能用数学方式表达出来吗？</p>\n<p>有人说，正则匹配 / 通配符匹配呗。这是一个思路。</p>\n<p>Vladimir Levenshtein 和 frederic damerau 给出了一种相似度算法 <a href=\"https://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance\">https://en.wikipedia.org/wiki/Damerau–Levenshtein_distance</a></p>\n<p>一个词组通过转换到另一个词的步数就是其距离：</p>\n<ul>\n<li>替换：『周杰伦』到『周杰棍』</li>\n<li>插入：『周杰』到『周杰棍』</li>\n<li>删除：『周杰伦』到『周杰』</li>\n<li>相邻字符转换：『周伦杰』和『周杰伦』 , 但是『周杰棍的双节伦』到『周杰伦的双节棍』 并不是相邻字符转换</li>\n</ul>\n<p>用法：</p>\n<blockquote>\n<p>指定 “fuzziness”: step 即可</p>\n</blockquote>\n<p>当 step &gt;=2 的时候，ES 进行查询的时候，每次查询都会遍历 terms 字典，所以，如果 fuzziness 大于 2 的时候遍历 terms 的数量则非常惊人了。</p>\n<ul>\n<li>方法一：设置 prefix_length, 单词的前面一定长度不进行 fuzzy 匹配。一般设置为 3 （估计这是属于英文的匹配，中文环境做不了参考）;</li>\n<li>方法二：设置 max_expansins, 类似于 RDBMS 的 limit, 查询到一定记录之后停止查询。</li>\n</ul>\n<p>fuzzy match query 也是支持的，比如说，假如你指定 “fuzziness” 为 1, 搜索周杰棍，则将周杰伦，周杰全搜索出来了。似乎搜索的很全面呀，但是问题来了：</p>\n<blockquote>\n<p>依据 TF/IDF 的高频低权重，低频高权重的计算方式，<strong>周杰棍由于出现次数极少，反而获得了极高的权重。</strong></p>\n</blockquote>\n<p>跑个题，这种因为『出现次数少，查询的时候反而显得权重较高』的情况。并不仅仅出现在 TF/IDF 算法上。</p>\n<p>这方面搜索引擎和人是一样一样的</p>\n<ul>\n<li>小孩子听腻了家长们所说的『带着脑子去学习』, 反而觉得以前没出现的新词叫『刻意学习』牛逼到爆。</li>\n<li>美女听腻了直男癌说的『漂亮』, 反而觉得夸她『品质 / 品味』的话语词词入心。</li>\n</ul>\n<p>回到正题</p>\n<p>所以，一般情况下还是建议拼写错误主要还是用于：</p>\n<ul>\n<li>Search as you type : completion suggester</li>\n<li>Did you mean : phrase suggester</li>\n</ul>\n<h4 id=\"7-全文搜索调优之相关性\"><a class=\"v-toc-item\" href=\"#7-全文搜索调优之相关性\">#</a> 7. 全文搜索调优之相关性</h4>\n<p>我们在接触 RDBMS 的时候系统是没有相关性的说法的，比如说，2017 年 12 月份 xxx 用户的订单，就是直接 select 出来这些订单。因为 where 语句后面包含了界限明确的条件，而全文搜索则不然。</p>\n<p>这个时候一个人拍着桌子站起来，说：不对呀，我要搜索包含周杰伦的所有文章。这咋没有条件边界。</p>\n<p>嗯，稍等，『选出所有包含周杰伦的文章』条件很清晰。但问题是，排序怎么做？按照日期排？按照点击率排？这篇文章上周已经在在搜索靠前了，已经『长江后浪推前浪了』上了，这周是不是该差不多『前浪死在沙滩上』了？</p>\n<p>Elasticsearch 中使用的计算 score 的公式叫做 practical scoring function, 这个公式借鉴于 TF/TDF 以及 矢量空间模型，但有更多的特征比如，条件因素，字段长度正态化，term / query clause boosting</p>\n<p>全文搜索不仅仅找到匹配的 documents, 并且按照相关性进行排序（其实就是打分 score)。</p>\n<p>为什么需要打分呢？从相亲角度来说，上海内环有房肯定是个超级大加分项。同样是录入信息，在上海内环有房的权重值可是设置的高一些。</p>\n<p>嗯，其实相关性的调优是最难的部分。</p>\n<h5 id=\"索引时三因素\"><a class=\"v-toc-item\" href=\"#索引时三因素\">#</a> 索引时三因素</h5>\n<p>先看前两个因素 TF/IDF</p>\n<ul>\n<li>tf(t in d) = sqrt(frequency)</li>\n<li>idf(t) = 1 + log (numDocs / (docFreq + 1))</li>\n</ul>\n<p>再看后一个因素 Field-Length norm</p>\n<p>标题越短，这个词对这个 field 的代表性越强</p>\n<ul>\n<li>norm(d) = 1 / sqrt(numTerms)</li>\n</ul>\n<h5 id=\"查询时\"><a class=\"v-toc-item\" href=\"#查询时\">#</a> 查询时</h5>\n<p>几个词 -&gt; 几维度 -&gt; 寻求最佳匹配以及近似匹配</p>\n<ul>\n<li>最佳匹配应该是通过计算长度（应该是，但不确定）</li>\n<li>近似匹配，计算距离最近的 cos 值。</li>\n</ul>\n<h5 id=\"计算公式\"><a class=\"v-toc-item\" href=\"#计算公式\">#</a> 计算公式</h5>\n<p>这个公式调优的时候需要用到</p>\n<pre><code class=\"language-bash\"><span class=\"token function\">score</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">,</span>d<span class=\"token punctuation\">)</span>  <span class=\"token operator\">=</span> <span class=\"token function\">queryNorm</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">)</span>\n                <span class=\"token function\">·coord</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">,</span>d<span class=\"token punctuation\">)</span>\n                <span class=\"token function\">·∑</span><span class=\"token punctuation\">(</span><span class=\"token function\">tf</span><span class=\"token punctuation\">(</span>t <span class=\"token keyword\">in</span> d<span class=\"token punctuation\">)</span><span class=\"token function\">·idf</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span>²·t<span class=\"token punctuation\">.</span><span class=\"token function\">getBoost</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token function\">·norm</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">,</span>d<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>t <span class=\"token keyword\">in</span> q<span class=\"token punctuation\">)</span>\n</code></pre>\n<h2 id=\"0x05-搜索语法\"><a class=\"v-toc-item\" href=\"#0x05-搜索语法\">#</a> 0x05 搜索语法</h2>\n<p>Single document APIs</p>\n<ul>\n<li>Index API</li>\n<li>Get API</li>\n<li>Delete API</li>\n<li>Update API</li>\n<li>Multi-document APIs</li>\n</ul>\n<p>Multi Get API</p>\n<ul>\n<li>Bulk API</li>\n<li>Delete By Query API</li>\n<li>Update By Query API</li>\n<li>Reindex API</li>\n</ul>\n<h2 id=\"0x06-python-sdk\"><a class=\"v-toc-item\" href=\"#0x06-python-sdk\">#</a> 0x06 Python SDK</h2>\n<p>官方提供了两个 SDK 方便我们进行日常的开发：</p>\n<ul>\n<li>elasticsearch</li>\n<li>elasticsearch_dsl</li>\n</ul>\n<p>我更喜欢 elasticsearch , 而不是 elasticsearch_dsl, 因为写起来更容易结合 elasticsearch-head 进行 profile</p>\n<p>前者偏底层一些，后者偏高层一些，高底层关系的有点类似于 sql 和 sqlalchemy core 之间的关系。</p>\n<h2 id=\"0x07-踩坑集\"><a class=\"v-toc-item\" href=\"#0x07-踩坑集\">#</a> 0x07 踩坑集</h2>\n<h2 id=\"0xee-参考链接\"><a class=\"v-toc-item\" href=\"#0xee-参考链接\">#</a> 0xEE 参考链接</h2>\n<ul>\n<li><a href=\"https://www.zhihu.com/question/19645541\">https://www.zhihu.com/question/19645541</a></li>\n</ul>\n<hr>\n<p>ChangeLog:</p>\n<ul>\n<li><strong>2018-02-15</strong> 重修文字</li>\n</ul>\n","toc":"<ul class=\"v-article-toc\">\n<li>\n<ul>\n<li><a href=\"#0x00-%E5%89%8D%E8%A8%80\">0x00 前言</a></li>\n<li><a href=\"#0x01-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%9F%BA%E6%9C%AC-shell-%E5%91%BD%E4%BB%A4\">0x01 安装，配置，基本 shell 命令</a>\n<ul>\n<li><a href=\"#1-%E5%AE%89%E8%A3%85\">1. 安装</a></li>\n<li><a href=\"#2-%E9%85%8D%E7%BD%AE\">2. 配置</a></li>\n<li><a href=\"#3-%E6%8F%92%E4%BB%B6\">3. 插件</a></li>\n</ul>\n</li>\n<li><a href=\"#0x02-elasticsearch-%E9%85%8D%E5%A5%97%E5%B7%A5%E5%85%B7\">0x02 ElasticSearch 配套工具</a></li>\n<li><a href=\"#0x03-elasticsearch-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5\">0x03 ElasticSearch 基础概念</a>\n<ul>\n<li><a href=\"#31-elasticsearch-crude-%E4%BB%A5%E5%8F%8A%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C\">3.1 Elasticsearch CRUDE 以及基本操作</a>\n<ul>\n<li><a href=\"#curde\">CURDE</a></li>\n<li><a href=\"#%E7%BB%93%E6%9E%84%E5%8C%96%E6%90%9C%E7%B4%A2\">结构化搜索</a></li>\n<li><a href=\"#%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2\">全文搜索</a></li>\n<li><a href=\"#%E8%81%9A%E9%9B%86%E6%90%9C%E7%B4%A2\">聚集搜索</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#0x04-%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\">0x04 全文搜索的基本概念</a>\n<ul>\n<li><a href=\"#41-%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E9%81%87%E5%88%B0%E7%9A%84%E6%8C%91%E6%88%98\">4.1 全文搜索遇到的挑战</a></li>\n<li><a href=\"#42-%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E7%9A%84%E7%B4%A2%E5%BC%95%E6%97%B6%E4%B8%8E%E6%9F%A5%E8%AF%A2%E6%97%B6\">4.2 全文搜索的索引时与查询时</a>\n<ul>\n<li><a href=\"#1-%E7%B4%A2%E5%BC%95%E6%97%B6-es-%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88\">1. 索引时 ES 做了什么？</a></li>\n<li><a href=\"#2-%E6%9F%A5%E8%AF%A2%E6%97%B6-es-%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88\">2. 查询时 ES 做了什么？</a></li>\n<li><a href=\"#3-%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E8%B0%83%E4%BC%98%E4%B9%8B%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D\">3. 全文搜索调优之中文分词</a></li>\n<li><a href=\"#4-%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E8%B0%83%E4%BC%98%E4%B9%8B%E5%81%9C%E6%AD%A2%E8%AF%8D\">4. 全文搜索调优之停止词</a></li>\n<li><a href=\"#5-%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E8%B0%83%E4%BC%98%E4%B9%8B%E5%90%8C%E4%B9%89%E8%AF%8D\">5. 全文搜索调优之同义词</a></li>\n<li><a href=\"#6-%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E8%B0%83%E4%BC%98%E4%B9%8B%E6%8B%BC%E5%86%99%E9%94%99%E8%AF%AF\">6. 全文搜索调优之拼写错误</a></li>\n<li><a href=\"#7-%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E8%B0%83%E4%BC%98%E4%B9%8B%E7%9B%B8%E5%85%B3%E6%80%A7\">7. 全文搜索调优之相关性</a>\n<ul>\n<li><a href=\"#%E7%B4%A2%E5%BC%95%E6%97%B6%E4%B8%89%E5%9B%A0%E7%B4%A0\">索引时三因素</a></li>\n<li><a href=\"#%E6%9F%A5%E8%AF%A2%E6%97%B6\">查询时</a></li>\n<li><a href=\"#%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F\">计算公式</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#0x05-%E6%90%9C%E7%B4%A2%E8%AF%AD%E6%B3%95\">0x05 搜索语法</a></li>\n<li><a href=\"#0x06-python-sdk\">0x06 Python SDK</a></li>\n<li><a href=\"#0x07-%E8%B8%A9%E5%9D%91%E9%9B%86\">0x07 踩坑集</a></li>\n<li><a href=\"#0xee-%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\">0xEE 参考链接</a></li>\n</ul>\n</li>\n</ul>\n"}},"__N_SSG":true}