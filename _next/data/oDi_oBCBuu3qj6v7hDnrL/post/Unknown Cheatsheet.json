{"pageProps":{"post":{"tags":["Python","Django","YaDjangoBlog"],"path":"20180220_UnKnownCheatSheet.md","title":"Unknown Cheatsheet","slug":"Unknown Cheatsheet","date":"2018-02-20","category":"Django","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"<h2 id=\"0x00-前言\"><a class=\"v-toc-item\" href=\"#0x00-前言\">#</a> 0x00 前言</h2>\n<blockquote>\n<p>写在前面的话：不好意思，标题难以免俗，起了个很俗气的名字。</p>\n</blockquote>\n<p>这是我的一个全栈类型 Django 开源项目的系列讲解教程的目录。目的总的来说有两个：</p>\n<ol>\n<li>一是希望更多的人通过本系列的教程更好的认识 Django 开发技术栈或者说是 Web 开发技术栈，让更多的 Pythonist 更顺畅的进入 Django 开发的世界。</li>\n<li>二是希望借由这个持续更新的过程让自己更加深入理解 Django 技术栈 Django / DjangoRestFramework / Docker / Vue.JS / Celery / PostgreSQL / Redis / RabbitMQ</li>\n</ol>\n<blockquote>\n<p>生命苦短，我用 Python</p>\n</blockquote>\n<p>为什么说这个项目你不容错过？</p>\n<ul>\n<li>新！新！新！保持最新的软件开发版本，E.G: Django 2.0 + Vue.JS 2.5 + PostgreSQL 10 + Celery 4.1.0</li>\n<li>Django 框架：Django 及其 强大的生态圈</li>\n<li>后端组件：PostgreSQL RabbitMQ Redis Ngnix</li>\n<li>前端技术：单页应用 前后端分离 (VueJS+Webpack+DjangoRestFramework), 自动化部署</li>\n<li>Django 社区最佳实践：从配置 / 开发 / 测试 / 部署 <strong>全干</strong>工程师 (Full Stuff Engineer) 的最新的 DevOps 思考成果。</li>\n<li>基本覆盖了进阶 Django 开发所需要的各种组件与操作。</li>\n<li>只需要适当的调整，本项目就可以成为你新开项目的最佳脚手架。</li>\n</ul>\n<p>本系列文章的面向读者：</p>\n<ul>\n<li>目标是 DevOps 的 Pythonist</li>\n<li>爱瞎几把折腾的 Pythonist</li>\n<li>前后端分离的实践者</li>\n</ul>\n<blockquote>\n<p>生命苦短，赶快上车</p>\n</blockquote>\n<h2 id=\"0x01-项目介绍\"><a class=\"v-toc-item\" href=\"#0x01-项目介绍\">#</a> 0x01 项目介绍</h2>\n<p>YaDjangoBlog 是另一个关于博客的轮子，但是其野心并不在于仅仅多造一个博客系统，还有通过本项目做 Django 全栈开发的最佳实践。</p>\n<h3 id=\"11-项目地址\"><a class=\"v-toc-item\" href=\"#11-项目地址\">#</a> 1.1 项目地址</h3>\n<ul>\n<li>前端代码 <a href=\"https://github.com/twocucao/YaVueBlog\">https://github.com/twocucao/YaVueBlog</a></li>\n<li>后端代码 <a href=\"https://github.com/twocucao/YaDjangoBlog\">https://github.com/twocucao/YaDjangoBlog</a></li>\n</ul>\n<h3 id=\"12-项目技术栈\"><a class=\"v-toc-item\" href=\"#12-项目技术栈\">#</a> 1.2 项目技术栈</h3>\n<ul>\n<li>开发与部署环境为 Docker</li>\n<li>Python 3.5.2</li>\n<li>前端 Vue + Webpack + ES2015 + axios</li>\n<li>后端 <a href=\"https://github.com/django/django\">Django 2.0</a> + <a href=\"https://github.com/tomchristie/django-rest-framework/\">DjangoRestFramework</a> + Celery</li>\n<li>自动化部署选用工具 Ansible 以及 Docker</li>\n<li>后端组件\n<ul>\n<li>ElasticSearch 用于搜索和推荐</li>\n<li>PostgreSQL 用于数据持久化</li>\n<li>Redis 用于 Session / 和缓存</li>\n<li>RabbitMQ 分布式队列 / 定时任务</li>\n<li>Nginx 用于反向代理</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"13-特别感谢\"><a class=\"v-toc-item\" href=\"#13-特别感谢\">#</a> 1.3 特别感谢</h3>\n<ul>\n<li>ansible django stack: <a href=\"https://github.com/jcalazan/ansible-django-stack\">https://github.com/jcalazan/ansible-django-stack</a></li>\n<li>cookiecutter-django: <a href=\"https://github.com/pydanny/cookiecutter-django\">https://github.com/pydanny/cookiecutter-django</a></li>\n<li>djangopackages: <a href=\"https://github.com/djangopackages/djangopackages\">https://github.com/djangopackages/djangopackages</a></li>\n<li>董伟明 关于 ElasticSearch 的几篇文章 <a href=\"http://www.dongwm.com/archives/%E7%9F%A5%E4%B9%8ELive%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E4%B9%8B%E4%BD%BF%E7%94%A8Elasticsearch%E6%90%9C%E7%B4%A2/\">http://www.dongwm.com/archives/知乎Live全文搜索之使用Elasticsearch搜索/</a></li>\n<li>各个组件的开发者们\n<ul>\n<li>ElasticSearch</li>\n<li>PostgreSQL</li>\n<li>Redis</li>\n<li>RabbitMQ</li>\n<li>Nginx</li>\n<li>Docker</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"0x02-系列教程目录\"><a class=\"v-toc-item\" href=\"#0x02-系列教程目录\">#</a> 0x02 系列教程目录</h2>\n<h3 id=\"21-教程注意项\"><a class=\"v-toc-item\" href=\"#21-教程注意项\">#</a> 2.1 教程注意项</h3>\n<ol>\n<li>本文的开发环境配置仅仅限于 macOS 上，如果读者使用的是 Windows / 可能需要自己搞定环境的配置。不过笔者使用了 Docker 进行环境配置，应该配置环境会省事很多。</li>\n<li>在阅读本教程，请读者至少跟着 Django 官方的教程跟着走一遍。不要零基础一通瞎搞。</li>\n<li>如果在使用过程中出现问题，请在 ISSUE 提供尽可能多的信息，将问题描述清楚。</li>\n</ol>\n<blockquote>\n<p>本系列教程并不按照一步一步增加代码的方式写教程。我先带着大家搭建好整个项目框架，然后从不同的视角开介绍这个项目，比如：</p>\n</blockquote>\n<ol>\n<li>某个模块的 models 是如何设计的？有哪些卧槽居然可以这么用的方式。</li>\n<li>Django User 如何做扩展？同样在 Django 的生态圈里面，哪些场景有哪些值得围观的包，比如 guardian</li>\n<li>Rest API 应该如何写，Django 里面的 Rest API 应该如何写？会有哪些生产效率 guangguangguang 提升上去的使用方法？权限怎么做？限流怎么搞？</li>\n<li>Py.test TDD 测试驱动开发了解一下？</li>\n</ol>\n<h3 id=\"22-教程目录\"><a class=\"v-toc-item\" href=\"#22-教程目录\">#</a> 2.2 教程目录</h3>\n<ul>\n<li>Django 全栈开发教程 - Python 和 Docker 环境配置</li>\n<li>Django 全栈开发教程 - YaDjangoBlog 博客的后端组件配置</li>\n<li>Django 全栈开发教程 - YaDjangoBlog 博客的前后端初步设计</li>\n<li>Django 全栈开发教程 - YaDjangoBlog 博客的后端初步实现</li>\n<li>Django 全栈开发教程 - YaDjangoBlog 博客的前端实现 YaVueBlog</li>\n<li>Django 全栈开发教程 - YaDjangoBlog 博客的后端组件之 Redis</li>\n<li>Django 全栈开发教程 - YaDjangoBlog 博客的后端组件之 PostgreSQL</li>\n<li>Django 全栈开发教程 - YaDjangoBlog 博客的后端组件之 Elasticsearch</li>\n<li>Django 全栈开发教程 - YaDjangoBlog 博客的后端组件之 RabbitMQ</li>\n<li>Django 全栈开发教程 - YaDjangoBlog 博客的部署</li>\n</ul>\n<p>于是，本文的内容就如下：</p>\n<ul>\n<li>前后端分离</li>\n<li>自动化部署</li>\n<li>数据库相关</li>\n<li>其他踩坑经历</li>\n</ul>\n<!-- more -->\n<h2 id=\"0x01-前后端分离\"><a class=\"v-toc-item\" href=\"#0x01-前后端分离\">#</a> 0x01 前后端分离</h2>\n<p>前后端分离是提高团队开发的一个重要的开发策略，前后端分离之后，后端和前端交流好 JSON 格式，并行开发，局域网中放置一台服务器，后端写好一个功能，推送代码，由 gitlab 触发 Runner 自动交付到局域网的服务器上。这样的话，前后端可以并行开发，从而摆脱每一次开发过程不可避免，前端编写模板，然后由后端套用模板，出了问题，前端修改模板，后端接着修改模板… 循环往复，不曾更改的问题，在这种职责分明的情况下也不会出现背锅侠的问题。</p>\n<p>在往常的开发过程中，而如果 Ajax 比较多或者前端写的代码质量稍微低一些，那么倒霉的事情就发生了，后端和前端的沟通成本那是相当的高。推锅的事情也会发生。</p>\n<p>而新的开发过程中，如果上级有界面上的需求，基本上只需要前端更新一下代码，推送，就可以立即看到效果。<br>\n同样的，后端也是如此。</p>\n<blockquote>\n<p>这就是我选择前后端分离的初衷 – 将主要的精力放在开发上面。而不是套用模板和编辑 Ajax 过程中带来的沟通问题。</p>\n</blockquote>\n<p>在前后端配合上：</p>\n<ul>\n<li>后端选择 Django,Restful 框架选择了 DjangoRestFramework, DRF 的优点在于可以自动生成 API 界面，让前端对照着表单进行请求接口的测试。于是局域网的那一台可以配置为 Debug 模式，生产机器就可以关闭 DEBUG 模式。</li>\n<li>前端选择 VueJS, 选择这个小而精美的框架一方面是基于团队的开发水平考虑，如果使用太激进的框架 React, 可能遇到问题无法在短时间内解决。由于选用了 VueJS, 也就选用了 Vue 全家桶，通过 Webpack2 进行配置完成基本的打包任务，通过 config 读取环境变量进行生产环境和发布环境的 apiurl 的分离</li>\n<li>代码提交选择 <a href=\"http://Coding.NET\">Coding.NET</a> 用于提交代码，在局域网中选择 Gitlab 用于提交代码，配上 Gitlab CI 进行持续集成，每次提交代码直接直接构建本地发布。前后端合作亲密无间。</li>\n</ul>\n<p>前后端分离有什么缺点呢？</p>\n<ol>\n<li>必须强行升级 Https</li>\n<li>开发时候需要关掉 Django 的同源策略</li>\n<li>IE8-- 不兼容</li>\n</ol>\n<h3 id=\"11-django-和-他的小伙伴们\"><a class=\"v-toc-item\" href=\"#11-django-和-他的小伙伴们\">#</a> 1.1 Django 和 他的小伙伴们</h3>\n<p>Django 适用于快速开发，对于创业公司来说，是不错的快速开发语言。</p>\n<p>不仅仅是因为 Python 表达力比较强，更重要的是 Django 有很多高质量的包可以使用。</p>\n<ul>\n<li>Django Debug Toolbar</li>\n<li>DjangoRestFramework</li>\n<li>Django Extensions</li>\n</ul>\n<h3 id=\"14-django-的奇技淫巧\"><a class=\"v-toc-item\" href=\"#14-django-的奇技淫巧\">#</a> 1.4 Django 的奇技淫巧</h3>\n<h4 id=\"django-model\"><a class=\"v-toc-item\" href=\"#django-model\">#</a> Django Model</h4>\n<ul>\n<li><a href=\"http://stackoverflow.com/questions/1355150/django-when-saving-how-can-you-check-if-a-field-has-changed\">Save If Changed</a></li>\n</ul>\n<h2 id=\"0x02-自动化部署\"><a class=\"v-toc-item\" href=\"#0x02-自动化部署\">#</a> 0x02 自动化部署</h2>\n<p>写程序 一般就是开发测试部署。</p>\n<p>话虽然这么时候，但是在具体的实践过程中，还是有很多很多坑需要注意的。</p>\n<p>比如，仅仅就开发环节来说，团队协作怎么搞？你说可以用 GIT 作为版本管理工具，代码托管。那我问你，这个 Web 开发过程中前端开发模板，后端套用模板怎么搞？你说，前后端分离，那前后端分离后 Http 请求被劫持怎么办，跨站攻击怎么搞…<br>\n甚至如果是一个人开发的话，直接拉一台服务器做做部署，定期更新到网站上就行了。但如果是团队协作呢？前端提交了代码，产品经理过来说，你更新一下服务器，后端提交了代码，前端过来说，你更新一下服务器，过程琐碎而耗时。大量的时间就浪费在了这种枯燥的事情上了。两个后端，一个前端的情况下，每天本地发布（交付）的次数就已经是相当惊人（大概是前后端每天提交 5 次左右），如果以后是 3 个后端，三个前端，那我作为主程，每天就写不了代码了，这种情况是断不能忍的。</p>\n<p>这个时候，就需要想着把团队协作开发流程优化好：</p>\n<p>在我刚开始进行开发的时候，使用 bash 配合 Ansible 在本地和上线的 Ubuntu 16.04 上面自动化能够自动化的大部分工作，程序员在本地开发的时候，只需要进行开发，然后推送代码到 repo, 剩下的诸如自动化测试集成到系统中，则全部自动化。</p>\n<h3 id=\"21-使用场景\"><a class=\"v-toc-item\" href=\"#21-使用场景\">#</a> 2.1 使用场景</h3>\n<p>经过研究，我确定了理想中的使用场景：</p>\n<blockquote>\n<p>前端与后端提交代码到代码托管上面的时候，直接集成，构建，Stage 到服务器。</p>\n</blockquote>\n<blockquote>\n<p>到上线的时候，由我执行 Ansible 进行上线。</p>\n</blockquote>\n<h3 id=\"22-实施方案\"><a class=\"v-toc-item\" href=\"#22-实施方案\">#</a> 2.2 实施方案</h3>\n<p>在这个流程中，我需要安装如下的软件：</p>\n<ul>\n<li>Gitlab Gitlab-CI-Runner : 用于解决代码托管，项目的基本成长，以及持续化集成</li>\n<li>PostgreSQL</li>\n<li>MongoDB</li>\n<li>Redis</li>\n<li>RabbitMQ</li>\n<li>Nginx</li>\n<li>Python 以及 Python 扩展的依赖包</li>\n<li>其他</li>\n</ul>\n<p>配置文件为 3 类：</p>\n<ul>\n<li>test</li>\n<li>stage</li>\n<li>production</li>\n</ul>\n<p>硬件设备 3 台：</p>\n<ol>\n<li>第一台为 Gitlab 部署的软件</li>\n<li>第二台为 Stage 环境 （本地局域网持续交付）的机器</li>\n<li>第三台为 Server （阿里云） 机器</li>\n</ol>\n<blockquote>\n<p>注：最初使用 Ubuntu 机器，最终确定使用 Docker 镜像进行构建</p>\n</blockquote>\n<h3 id=\"23-持续交付\"><a class=\"v-toc-item\" href=\"#23-持续交付\">#</a> 2.3. 持续交付</h3>\n<p>当前端工程师 Push Master 分支到 Repo 上的时候，执行 Job 更新网站<br>\n当后端工程师 Push Master 分支到 Repo 上的时候，执行 Job 更新网站</p>\n<p>Push Master 分支，这个自然无需多说，问题是怎么执行 Job 呢？</p>\n<blockquote>\n<p><strong>Gitlab CI Multi Runner</strong></p>\n</blockquote>\n<p>在一台 stage 的机器上安装 gitlab ci multi runner , 并且在该机器上注册 runner 为 shell , 这意味着 runner 会以 gitlab-runner 用户的权限进行测试 , 你需要 uninstall<br>\n然后 install --user=root 一下，然后重启，即可在 gitlab-ci.yml 上。</p>\n<p>修改文件</p>\n<pre><code class=\"language-bash\">\ngitlab<span class=\"token operator\">-</span>runner register # 然后填入相关信息\nvim <span class=\"token operator\">/</span>etc<span class=\"token operator\">/</span>gitlab<span class=\"token operator\">-</span>runner<span class=\"token operator\">/</span>config<span class=\"token punctuation\">.</span>toml # 接着进行修改\n</code></pre>\n<pre><code class=\"language-bash\">concurrent <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\ncheck_interval <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n\n<span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>runners<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span>\n  name <span class=\"token operator\">=</span> <span class=\"token string\">\"yadjangoweb\"</span>\n  url <span class=\"token operator\">=</span> <span class=\"token string\">\"http://192.168.1.139/ci\"</span>\n  token <span class=\"token operator\">=</span> <span class=\"token string\">\"325asd65f4e7xa9faasda8da\"</span>\n  executor <span class=\"token operator\">=</span> <span class=\"token string\">\"shell\"</span>\n  <span class=\"token punctuation\">[</span>runners<span class=\"token punctuation\">.</span>cache<span class=\"token punctuation\">]</span>\n</code></pre>\n<h3 id=\"24-dockerize-application\"><a class=\"v-toc-item\" href=\"#24-dockerize-application\">#</a> 2.4. Dockerize Application</h3>\n<p>Docker 以其轻量级和类似于版本管理的软件方式吸引了我。于是，准备将所有的 Service 都 Docker 化。</p>\n<p>拿 Django 程序来说，首先 Django 程序依赖三个组件 redis / postgresql / rabbitmq , 完成这些组件的安装之后才能进行下一步的操作。</p>\n<h2 id=\"0x03-数据库相关\"><a class=\"v-toc-item\" href=\"#0x03-数据库相关\">#</a> 0x03 数据库相关</h2>\n<h3 id=\"1-数据库设计\"><a class=\"v-toc-item\" href=\"#1-数据库设计\">#</a> 1. 数据库设计</h3>\n<p>PostgreSQL Array 在爬虫方面可以用来标记一个 Record 的处理状态<br>\nPostgreSQL Range 用来判断范围也是一个比较高效的选择（用空间 gist 索引取代两个索引）</p>\n<p>GeoDjango 和 PostGIS 非常配</p>\n<h3 id=\"2-数据迁移\"><a class=\"v-toc-item\" href=\"#2-数据迁移\">#</a> 2. 数据迁移</h3>\n<h4 id=\"11-第一次数据迁移之-mysql-转-postgresql\"><a class=\"v-toc-item\" href=\"#11-第一次数据迁移之-mysql-转-postgresql\">#</a> 1.1. 第一次数据迁移之 MySQL 转 PostgreSQL</h4>\n<p>第一次数据迁移的时候基于 PostgreSQL 社区里面有个大杀器，叫做 PostGIS, 通过 PostGIS, 可以很方便的拥有和国内一些地图公司匹敌的算法。抛开算法实现的效率问题，基本上可以满足日常的开发需求，当时数据量不算大，使用 mysqldump 下来也就 500M 左右，而且行数大约 700W 条，于是使用了一个很笨的方法，就是将数据库使用 Django 命令 dump 成 json, 接着修改配置重新导入新数据库。</p>\n<p>这种方式的缺点就是效率低而且太吃内存了，当时 16G 的服务器满内存，满交换内存地搞了一个上午。</p>\n<h4 id=\"12-第二次数据迁移之重新-makemigrations\"><a class=\"v-toc-item\" href=\"#12-第二次数据迁移之重新-makemigrations\">#</a> 1.2. 第二次数据迁移之重新 makemigrations</h4>\n<p>为什么要重新 makemigrations 呢，因为糟糕的事情发生了。</p>\n<p>有个需求，需要重新定制用户登录认证系统。用户登录认证系统是最最应该在项目开始的时候编写的，这就是项目的基石，这个需求就恰似在房子盖到第三层的时候突然要把地基给加固。</p>\n<p>Django 中如果使用了 auth 模块，则 auth.user 是最先被迁移到数据库中的，而如果你经过权衡继承 AbstractUser 并且 makemigrations 生成个迁移文件 0001_initial.py 后，在正常的情况下不容易将 migration 修改应用到数据库中。</p>\n<blockquote>\n<p>如果我偏要勉强呢？</p>\n</blockquote>\n<p>当然是可以勉强的，删掉数据库中已经记录下来的 auth.user migration 的相关记录即可。</p>\n<p>那我为什么还是需要重新编写 migration 呢？</p>\n<ol>\n<li>因为之前对数据库的结构调整比较频繁，多达 138 次，而在 138 次调整数据结构之后，再去撤销第一次数据表的迁移操作的时候，则无异于厨子做菜要把牛排做 8 分熟，但是厨子做到 7 分熟的时候，突然顾客说，我要 5 分熟的牛排。那只能重新来了。</li>\n<li>顺手精简掉 138 个文件。</li>\n</ol>\n<p>如何做呢？</p>\n<ol>\n<li>数据的迁移在没有表与表之间的关联的时候是很好办的，CSV, 标准 SQL 文件。</li>\n<li>有表关联的情况下则需要权衡数据量来进行迁移，假如数据量在 10 来个 G 的时候，读到内存中，按照数据表的依赖关系，自下而上逐层迁移即可。</li>\n<li>数据量大的时候，则需要去约束，去索引，然后转 CSV/SQL, 迁移到数据表中。如果表依赖不复杂的话，直接 psql 命令重定向数据也可以。</li>\n</ol>\n<p>但是呢，由于使用了 Django, 在数据量不大的时候，完全可以使用 Django 的 ORM 来做迁移。</p>\n<p>我在 Google 了一下，发现下面一个脚本，于是设置数据库为新数据库 default 和 depressed</p>\n<pre><code class=\"language-python\">def <span class=\"token function\">batch_migrate</span><span class=\"token punctuation\">(</span>model<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>\n    # remove data from destination db before copying\n    # to avoid primary key conflicts or mismatches\n    <span class=\"token keyword\">if</span> model<span class=\"token punctuation\">.</span>objects<span class=\"token punctuation\">.</span><span class=\"token function\">using</span><span class=\"token punctuation\">(</span><span class=\"token string\">'default'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">exists</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>\n        model<span class=\"token punctuation\">.</span>objects<span class=\"token punctuation\">.</span><span class=\"token function\">using</span><span class=\"token punctuation\">(</span><span class=\"token string\">'default'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">all</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">delete</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    # <span class=\"token keyword\">get</span> data form the source database\n    items <span class=\"token operator\">=</span> model<span class=\"token punctuation\">.</span>objects<span class=\"token punctuation\">.</span><span class=\"token function\">using</span><span class=\"token punctuation\">(</span><span class=\"token string\">'depressed'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">order_by</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"pk\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">all</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    count <span class=\"token operator\">=</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>items<span class=\"token punctuation\">)</span>\n    # process <span class=\"token keyword\">in</span> chunks<span class=\"token punctuation\">,</span> to handle models <span class=\"token keyword\">with</span> lots <span class=\"token keyword\">of</span> data\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token function\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> count<span class=\"token punctuation\">,</span> <span class=\"token number\">10000</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>\n        chunk_items <span class=\"token operator\">=</span> items<span class=\"token punctuation\">[</span>i<span class=\"token operator\">:</span>i <span class=\"token operator\">+</span> <span class=\"token number\">10000</span><span class=\"token punctuation\">]</span>\n        <span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"已经迁移数据\"</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span>\n        model<span class=\"token punctuation\">.</span>objects<span class=\"token punctuation\">.</span><span class=\"token function\">using</span><span class=\"token punctuation\">(</span><span class=\"token string\">'default'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">bulk_create</span><span class=\"token punctuation\">(</span>chunk_items<span class=\"token punctuation\">)</span>\n\n    # many<span class=\"token operator\">-</span>to<span class=\"token operator\">-</span>many fields are <span class=\"token constant\">NOT</span> handled by bulk create<span class=\"token punctuation\">;</span> check <span class=\"token keyword\">for</span>\n    # them and use the existing implicit through models to copy them\n    <span class=\"token keyword\">for</span> m2mfield <span class=\"token keyword\">in</span> model<span class=\"token punctuation\">.</span>_meta<span class=\"token punctuation\">.</span>many_to_many<span class=\"token operator\">:</span>\n        m2m_model <span class=\"token operator\">=</span> <span class=\"token function\">getattr</span><span class=\"token punctuation\">(</span>model<span class=\"token punctuation\">,</span> m2mfield<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>through\n        <span class=\"token function\">batch_migrate</span><span class=\"token punctuation\">(</span>m2m_model<span class=\"token punctuation\">)</span>\n</code></pre>\n<p>按照表与表之间的依赖关系，逐个迁移到数据库中搞定。</p>\n<h3 id=\"13-sequence-问题\"><a class=\"v-toc-item\" href=\"#13-sequence-问题\">#</a> 1.3 sequence 问题</h3>\n<p>在写 Django 的时候发现的时候无论如何都无法保存新的 item.</p>\n<p>原来的代码为：</p>\n<pre><code class=\"language-python\">item <span class=\"token operator\">=</span> Item<span class=\"token punctuation\">.</span>objects<span class=\"token punctuation\">.</span><span class=\"token function\">get_or_create</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nitem<span class=\"token punctuation\">.</span>foo <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\nitem<span class=\"token punctuation\">.</span><span class=\"token function\">save</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p>报错信息是 Integrety, 报 duplicated 错误（下面的代码当然是打了马赛克了）</p>\n<pre><code class=\"language-python\">django<span class=\"token punctuation\">.</span>db<span class=\"token punctuation\">.</span>utils<span class=\"token punctuation\">.</span>IntegrityError<span class=\"token operator\">:</span> duplicate key value violates unique constraint <span class=\"token string\">\"foo_item_pkey\"</span>\n<span class=\"token constant\">DETAIL</span><span class=\"token operator\">:</span>  <span class=\"token function\">Key</span> <span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token number\">111111</span><span class=\"token punctuation\">)</span> already exists<span class=\"token punctuation\">.</span>\n</code></pre>\n<p>那么，问题来了：</p>\n<blockquote>\n<p><s>挖掘技术哪家强？</s></p>\n</blockquote>\n<p>啊，不是</p>\n<blockquote>\n<p>How To Solve This?</p>\n</blockquote>\n<p>经过猜测，而 get 到已有的 item 设置并且保存的话，并不会出现这个问题。问题主要出在 create 上面。</p>\n<p>于是编写代码验证一下是不是猜想正确</p>\n<pre><code class=\"language-python\"><span class=\"token keyword\">try</span><span class=\"token operator\">:</span>\n    item <span class=\"token operator\">=</span> Item<span class=\"token punctuation\">.</span>objects<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nexcept Exception<span class=\"token operator\">:</span>\n    item <span class=\"token operator\">=</span> Item<span class=\"token punctuation\">.</span>objects<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n# <span class=\"token keyword\">do</span> something\n\nitem<span class=\"token punctuation\">.</span><span class=\"token function\">save</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p>duplicate 的问题肯定是多次存同样的不能重复的字段。</p>\n<p>**但尼玛，我之前做测试的时候考虑过这个逻辑呀？**换而言之，这种问题不应该出现，如果出现了问题，八成是 ORM 用的不对。</p>\n<p>印象中这种问题 Google 一下 Integrety Duplicate Django PostgreSQL 一般就能出来了。</p>\n<p>最后找到解决方案：<a href=\"http://centoshowtos.org/web-services/django-and-postgres-duplicate-key/\">http://centoshowtos.org/web-services/django-and-postgres-duplicate-key/</a></p>\n<p>在终端进入 psql 查询 sequence 最新值</p>\n<pre><code class=\"language-sql\">select start_value<span class=\"token punctuation\">,</span> last_value<span class=\"token punctuation\">,</span> max_value from dt_crawler_item_item_id_seq<span class=\"token punctuation\">;</span>\n\n start_value <span class=\"token operator\">|</span> last_value <span class=\"token operator\">|</span>      max_value\n<span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">|</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">|</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span>\n           <span class=\"token number\">1</span> <span class=\"token operator\">|</span>    <span class=\"token number\">111110</span> <span class=\"token operator\">|</span> <span class=\"token number\">9223372036854775807</span>\n</code></pre>\n<p>而我们查看一下 item_id 的最大值</p>\n<pre><code>select max(item_id) from app_model_item;\n\n   max\n---------\n 111111\n</code></pre>\n<p>重置 sequence last_value 值到最新即可。</p>\n<pre><code>alter sequence app_model_item_item_id_seq restart with 111111;\n</code></pre>\n<blockquote>\n<p>当数据库每次插入一条非指定主键的记录，则获取 last_value(111110), 加 1 得到当前的主键接着插入。但这个过程无异于数据库中已经有了一个 pk 为 111111 的记录，再插入一条。于是报错。</p>\n</blockquote>\n<p>回顾这个问题，该问题是由于 PostGres 的 sequence 造成 pkey 相等，换而言之，postgres 应该在有一个 pk 值为 111111 的时候，插入一个无主键的记录，PostgreSQL 获取 sequence+1(111110 + 1) 得到它认为当前的主键值，接着再一次插入了主键为 111111 的这个值。</p>\n<p>这个过程相当于依次插入两个条 ID 相同的记录。</p>\n<pre><code class=\"language-sql\"><span class=\"token constant\">INSERT</span> <span class=\"token constant\">INTO</span> <span class=\"token function\">table</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">,</span> column2<span class=\"token punctuation\">,</span> …<span class=\"token punctuation\">)</span> <span class=\"token constant\">VALUES</span> <span class=\"token punctuation\">(</span><span class=\"token number\">111111</span><span class=\"token punctuation\">,</span> value2<span class=\"token punctuation\">,</span> …<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token constant\">INSERT</span> <span class=\"token constant\">INTO</span> <span class=\"token function\">table</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">,</span> column2<span class=\"token punctuation\">,</span> …<span class=\"token punctuation\">)</span> <span class=\"token constant\">VALUES</span> <span class=\"token punctuation\">(</span><span class=\"token number\">111111</span><span class=\"token punctuation\">,</span> value2<span class=\"token punctuation\">,</span> …<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<blockquote>\n<p>sequence 避免了每一次 max 查找带来的性能损失，一方面带来了方便，也带来了隐藏的坑。</p>\n</blockquote>\n<p>如果以后这个问题比较多的话，参考下面的源码对文本进行修改。</p>\n<p><a href=\"https://github.com/ASKBOT/django-postgresql-fix-sequences/blob/master/postgresql_sequence_utils/utils.py\">https://github.com/ASKBOT/django-postgresql-fix-sequences/blob/master/postgresql_sequence_utils/utils.py</a></p>\n<h2 id=\"0x04-webserver\"><a class=\"v-toc-item\" href=\"#0x04-webserver\">#</a> 0x04 WebServer</h2>\n<p>目前使用的 WebServer 是用 Nginx 做反向代理，将请求通过 unix socket 转发到 gunicorn，gunicorn 作为 django 实际上的 webserver。</p>\n<h3 id=\"unix-socket-和-gunicorn-的-remote_addr-问题\"><a class=\"v-toc-item\" href=\"#unix-socket-和-gunicorn-的-remote_addr-问题\">#</a> unix socket 和 gunicorn 的 REMOTE_ADDR 问题</h3>\n<p>Django Admin 模块在访问 某个页面的时候特别特别慢，而在我的机器上一切正常，我怀疑的是数据库的问题，于是，那么首先要知道数据库的查询语句，于是想借用 django debug toolbar 来 profiling, 于是问题来了，我在局域网模拟真机环境，结果无论如何都无法呈现 Django Debug Toolbar,</p>\n<p>问题八成出现在 Django 配置环境 或者 Nginx 上面（当然，最后发现是 Gunicorn 的锅）. 在</p>\n<p>经过一段时间的排查，认为是 Nginx 的问题，在相关配置添加下面设置 Header,</p>\n<pre><code class=\"language-python\">proxy_set_header <span class=\"token constant\">X</span><span class=\"token operator\">-</span>Forwarded<span class=\"token operator\">-</span>For $remote_addr<span class=\"token punctuation\">;</span>\n</code></pre>\n<p>结果依旧无法获取 request.Meta[“REMOTE-ADDR”]</p>\n<p>经过搜索发现不止我一个人的问题：<a href=\"https://github.com/benoitc/gunicorn/issues/797\">https://github.com/benoitc/gunicorn/issues/797</a></p>\n<p>最后发现是 Http 请求从 nginx 这儿经过 unix socket 转发到 gunicorn.sock 下默认是没有赋值 REMOTE-ADDR 的，</p>\n<p>那么，这个在 HTTP Header 层次的东西，没有在 gunicorn 层次解决，那就只能在 django 层次解决。</p>\n<p>给 Django 添加中间件如下，放在 djangodebugtools 的前面。</p>\n<pre><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">XForwardedForMiddleware</span><span class=\"token punctuation\">(</span>MiddlewareMixin<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>\n    def <span class=\"token function\">process_request</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> request<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>\n        <span class=\"token keyword\">if</span> request<span class=\"token punctuation\">.</span><span class=\"token constant\">META</span><span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"HTTP_X_FORWARDED_FOR\"</span><span class=\"token punctuation\">,</span> False<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>\n            request<span class=\"token punctuation\">.</span><span class=\"token constant\">META</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"HTTP_X_PROXY_REMOTE_ADDR\"</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> request<span class=\"token punctuation\">.</span><span class=\"token constant\">META</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"REMOTE_ADDR\"</span><span class=\"token punctuation\">]</span>\n            parts <span class=\"token operator\">=</span> request<span class=\"token punctuation\">.</span><span class=\"token constant\">META</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"HTTP_X_FORWARDED_FOR\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">\",\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n            request<span class=\"token punctuation\">.</span><span class=\"token constant\">META</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"REMOTE_ADDR\"</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> parts<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\n</code></pre>\n<p>解决。</p>\n<h3 id=\"nginx-gzip-压缩\"><a class=\"v-toc-item\" href=\"#nginx-gzip-压缩\">#</a> Nginx Gzip 压缩</h3>\n<p>当 json 数据量比较大的时候，则必须要考虑开启压缩。一般情况下，虽然这个可以在 Django 层次完成，但是这么做还不如在 nginx 层次完成。</p>\n<pre><code class=\"language-python\">    gzip on<span class=\"token punctuation\">;</span>\n    gzip_disable <span class=\"token string\">\"msie6\"</span><span class=\"token punctuation\">;</span>\n    gzip_vary on<span class=\"token punctuation\">;</span>\n    gzip_proxied any<span class=\"token punctuation\">;</span>\n    gzip_comp_level <span class=\"token number\">6</span><span class=\"token punctuation\">;</span>\n    gzip_buffers <span class=\"token number\">16</span> <span class=\"token number\">8</span>k<span class=\"token punctuation\">;</span>\n    gzip_http_version <span class=\"token number\">1.1</span><span class=\"token punctuation\">;</span>\n    gzip_types text<span class=\"token operator\">/</span>plain text<span class=\"token operator\">/</span>css application<span class=\"token operator\">/</span>json application<span class=\"token operator\">/</span>x<span class=\"token operator\">-</span>javascript text<span class=\"token operator\">/</span>xml application<span class=\"token operator\">/</span>xml application<span class=\"token operator\">/</span>xml<span class=\"token operator\">+</span>rss text<span class=\"token operator\">/</span>javascript<span class=\"token punctuation\">;</span>\n</code></pre>\n<p>开启之后，我这边的 一个 220k 的数据缩减到 54k</p>\n<h2 id=\"0x04-其他踩坑相关\"><a class=\"v-toc-item\" href=\"#0x04-其他踩坑相关\">#</a> 0x04. 其他踩坑相关</h2>\n<h3 id=\"41-奇怪的文件问题\"><a class=\"v-toc-item\" href=\"#41-奇怪的文件问题\">#</a> 4.1 奇怪的文件问题</h3>\n<p>在某一天遇到了一个问题 往常的时候，当文件上传到 Django 中的时候，都可以正常的解析，但是这两天居然不能用了。</p>\n<pre><code class=\"language-python\"># 问题代码出现在\ndf <span class=\"token operator\">=</span> pd<span class=\"token punctuation\">.</span><span class=\"token function\">read_excel</span><span class=\"token punctuation\">(</span>file_obj<span class=\"token punctuation\">)</span>\n# 报这个问题 google 几乎没有什么解决方案\nInvalid file path or buffer object type\n<span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token string\">'django.core.files.uploadedfile.InMemoryUploadedFile'</span><span class=\"token operator\">></span>\n</code></pre>\n<p>更加糟糕的问题出现了，我本人的开发环境和服务器的开发环境基本一致，但，但，但为什么不能用呢？</p>\n<p>分别回滚代码，Nginx 设置，在线上打 Log, 最终确定了是 Pandas 从 0.19 升级到了 0.20 之后出现的一个小问题。最终还原线上 python 安装环境，搞定。</p>\n<h2 id=\"0xee-参考链接\"><a class=\"v-toc-item\" href=\"#0xee-参考链接\">#</a> 0xEE. 参考链接</h2>\n<hr>\n<p>ChangeLog:</p>\n<ul>\n<li><strong>2018-02-21</strong> 重修文字</li>\n</ul>\n","toc":"<ul class=\"v-article-toc\">\n<li>\n<ul>\n<li><a href=\"#0x00-%E5%89%8D%E8%A8%80\">0x00 前言</a></li>\n<li><a href=\"#0x01-%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D\">0x01 项目介绍</a>\n<ul>\n<li><a href=\"#11-%E9%A1%B9%E7%9B%AE%E5%9C%B0%E5%9D%80\">1.1 项目地址</a></li>\n<li><a href=\"#12-%E9%A1%B9%E7%9B%AE%E6%8A%80%E6%9C%AF%E6%A0%88\">1.2 项目技术栈</a></li>\n<li><a href=\"#13-%E7%89%B9%E5%88%AB%E6%84%9F%E8%B0%A2\">1.3 特别感谢</a></li>\n</ul>\n</li>\n<li><a href=\"#0x02-%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%9B%AE%E5%BD%95\">0x02 系列教程目录</a>\n<ul>\n<li><a href=\"#21-%E6%95%99%E7%A8%8B%E6%B3%A8%E6%84%8F%E9%A1%B9\">2.1 教程注意项</a></li>\n<li><a href=\"#22-%E6%95%99%E7%A8%8B%E7%9B%AE%E5%BD%95\">2.2 教程目录</a></li>\n</ul>\n</li>\n<li><a href=\"#0x01-%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB\">0x01 前后端分离</a>\n<ul>\n<li><a href=\"#11-django-%E5%92%8C-%E4%BB%96%E7%9A%84%E5%B0%8F%E4%BC%99%E4%BC%B4%E4%BB%AC\">1.1 Django 和 他的小伙伴们</a></li>\n<li><a href=\"#14-django-%E7%9A%84%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7\">1.4 Django 的奇技淫巧</a>\n<ul>\n<li><a href=\"#django-model\">Django Model</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#0x02-%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2\">0x02 自动化部署</a>\n<ul>\n<li><a href=\"#21-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\">2.1 使用场景</a></li>\n<li><a href=\"#22-%E5%AE%9E%E6%96%BD%E6%96%B9%E6%A1%88\">2.2 实施方案</a></li>\n<li><a href=\"#23-%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98\">2.3. 持续交付</a></li>\n<li><a href=\"#24-dockerize-application\">2.4. Dockerize Application</a></li>\n</ul>\n</li>\n<li><a href=\"#0x03-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3\">0x03 数据库相关</a>\n<ul>\n<li><a href=\"#1-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1\">1. 数据库设计</a></li>\n<li><a href=\"#2-%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB\">2. 数据迁移</a>\n<ul>\n<li><a href=\"#11-%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%E4%B9%8B-mysql-%E8%BD%AC-postgresql\">1.1. 第一次数据迁移之 MySQL 转 PostgreSQL</a></li>\n<li><a href=\"#12-%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%E4%B9%8B%E9%87%8D%E6%96%B0-makemigrations\">1.2. 第二次数据迁移之重新 makemigrations</a></li>\n</ul>\n</li>\n<li><a href=\"#13-sequence-%E9%97%AE%E9%A2%98\">1.3 sequence 问题</a></li>\n</ul>\n</li>\n<li><a href=\"#0x04-webserver\">0x04 WebServer</a>\n<ul>\n<li><a href=\"#unix-socket-%E5%92%8C-gunicorn-%E7%9A%84-remote_addr-%E9%97%AE%E9%A2%98\">unix socket 和 gunicorn 的 REMOTE_ADDR 问题</a></li>\n<li><a href=\"#nginx-gzip-%E5%8E%8B%E7%BC%A9\">Nginx Gzip 压缩</a></li>\n</ul>\n</li>\n<li><a href=\"#0x04-%E5%85%B6%E4%BB%96%E8%B8%A9%E5%9D%91%E7%9B%B8%E5%85%B3\">0x04. 其他踩坑相关</a>\n<ul>\n<li><a href=\"#41-%E5%A5%87%E6%80%AA%E7%9A%84%E6%96%87%E4%BB%B6%E9%97%AE%E9%A2%98\">4.1 奇怪的文件问题</a></li>\n</ul>\n</li>\n<li><a href=\"#0xee-%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\">0xEE. 参考链接</a></li>\n</ul>\n</li>\n</ul>\n"}},"__N_SSG":true}