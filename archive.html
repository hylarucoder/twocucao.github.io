<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>归档 | 海拉鲁编程客</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/49455a07b6dd33600cdf.css" as="style"/><link rel="stylesheet" href="/_next/static/css/49455a07b6dd33600cdf.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-a54b4f32bdc1ef890ddd.js"></script><script src="/_next/static/chunks/webpack-20d43e08bea62467b090.js" defer=""></script><script src="/_next/static/chunks/framework-0441fae7fd130f37dee1.js" defer=""></script><script src="/_next/static/chunks/main-4777350f2a9ff73ea2b0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-3050679c6e5142ffcaf5.js" defer=""></script><script src="/_next/static/chunks/ea88be26-9bcf6ead520f4ac26973.js" defer=""></script><script src="/_next/static/chunks/421-f2f33a86b546237f0325.js" defer=""></script><script src="/_next/static/chunks/pages/archive-cf7fe59cb774b1899671.js" defer=""></script><script src="/_next/static/uCwe9m-iio9bnoWMgWDqE/_buildManifest.js" defer=""></script><script src="/_next/static/uCwe9m-iio9bnoWMgWDqE/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="v-page"><nav class="shadow"><div class="flex flex-col container mx-auto h-12 px-40 md:flex-row md:items-center md:justify-between"><div class="flex justify-between items-center"><div><a class="text-gray-800 text-xl md:text-xl leading-5" href="/">海拉鲁编程客</a></div><div><button type="button" class="block text-gray-800 hover:text-gray-600 focus:text-gray-600 focus:outline-none md:hidden"><svg viewBox="0 0 24 24" class="h-6 w-6 fill-current"><path d="M4 5h16a1 1 0 0 1 0 2H4a1 1 0 1 1 0-2zm0 6h16a1 1 0 0 1 0 2H4a1 1 0 0 1 0-2zm0 6h16a1 1 0 0 1 0 2H4a1 1 0 0 1 0-2z"></path></svg></button></div></div><div class="md:flex flex-col md:flex-row md:-mx-4 hidden"><a class="my-1 text-gray-800 hover:text-blue-500 md:mx-4 md:my-0" href="/">首页</a><a class="my-1 text-gray-800 hover:text-blue-500 md:mx-4 md:my-0" href="/archive">归档</a><a class="my-1 text-gray-800 hover:text-blue-500 md:mx-4 md:my-0" href="/about">关于我</a><button style="cursor:pointer;overflow:hidden;width:50px;height:23.5px;appearance:none;-moz-appearance:none;-webkit-appearance:none;border:none;background-color:transparent;padding:0" aria-hidden="true"><div style="display:flex;align-items:center;justify-content:center;margin-top:-28.749999999999996px;margin-left:-16px;width:82.5px;height:82.5px"><div></div></div></button></div></div></nav><div class="flex flex-col m-auto mt-10 w-6/12 w-auto"><div><p>这个博客几乎无保留地发布了技术方面的文章、笔记。</p><p>这些技术博客很多是我在探索和学习的时候记下来的，</p><p>如有错误，请斧正。</p></div><div><h2 class="text-xl font-medium text-gray-600 ">2021-06</h2><ol><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%2001%20-%20%E8%83%8C%E5%8E%8B%20backpressure">2021-06-20<!-- --> - <!-- -->系统设计 01 - 背压 backpressure</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/%E4%B9%9F%E8%81%8A%E8%81%8A%20RESTful%20vs%20GraphQL">2021-06-20<!-- --> - <!-- -->也聊聊 RESTful vs GraphQL</a></li></ol></div><div><h2 class="text-xl font-medium text-gray-600 ">2021-04</h2><ol><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/%E5%A6%82%E4%BD%95%E8%AF%84%E4%BB%B7%E6%9C%80%E8%BF%91%E7%88%86%E7%BA%A2%E7%9A%84FastAPI%EF%BC%9F">2021-04-27<!-- --> - <!-- -->如何评价最近爆红的FastAPI？</a></li></ol></div><div><h2 class="text-xl font-medium text-gray-600 ">2020-12</h2><ol><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%80%E4%BA%9B%E7%A2%8E%E7%A2%8E%E5%BF%B5">2020-12-22<!-- --> - <!-- -->业务系统的一些碎碎念</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/Odoo%20%E5%AF%B9%E4%BA%8E%20B%20%E7%AB%AF%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E7%9A%84%E4%B8%80%E4%BA%9B%E5%90%AF%E7%A4%BA">2020-12-15<!-- --> - <!-- -->Odoo 对于 B 端业务开发的一些启示</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/%E6%88%91%E7%9A%84%20React%20%E6%8A%80%E6%9C%AF%E6%A0%88">2020-12-02<!-- --> - <!-- -->我的 React 技术栈</a></li></ol></div><div><h2 class="text-xl font-medium text-gray-600 ">2020-11</h2><ol><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/%E5%BC%80%E6%BA%90%E8%AE%A4%E8%AF%81%E5%9F%BA%E7%A1%80%E6%9C%8D%E5%8A%A1">2020-11-30T18:03:01+08:00<!-- --> - <!-- -->开源认证基础服务</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/Modern%20Shell">2020-11-30<!-- --> - <!-- -->Modern Shell</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/Python%20Profiling/Tracing%20Tools">2020-11-30<!-- --> - <!-- -->Python Profiling/Tracing Tools</a></li></ol></div><div><h2 class="text-xl font-medium text-gray-600 ">2019-09</h2><ol><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E6%95%B4%E6%B4%81%E7%9A%84%20Python%20%E4%BB%A3%E7%A0%81%20%E4%B8%8B">2019-09-24<!-- --> - <!-- -->如何写出整洁的 Python 代码 下</a></li></ol></div><div><h2 class="text-xl font-medium text-gray-600 ">2019-05</h2><ol><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E6%95%B4%E6%B4%81%E7%9A%84%20Python%20%E4%BB%A3%E7%A0%81%20%E4%B8%AD">2019-05-26<!-- --> - <!-- -->如何写出整洁的 Python 代码 中</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E6%95%B4%E6%B4%81%E7%9A%84%20Python%20%E4%BB%A3%E7%A0%81%20%E4%B8%8A">2019-05-25<!-- --> - <!-- -->如何写出整洁的 Python 代码 上</a></li></ol></div><div><h2 class="text-xl font-medium text-gray-600 ">2019-04</h2><ol><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/Python%20ORM">2019-04-12<!-- --> - <!-- -->Python ORM</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E4%BD%BF%E7%94%A8%20Windows%2010">2019-04-03<!-- --> - <!-- -->如何优雅的使用 Windows 10</a></li></ol></div><div><h2 class="text-xl font-medium text-gray-600 ">2019-03</h2><ol><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E6%B5%8B%E8%AF%95%E6%8F%90%E5%8D%87%20Python%20%E4%BB%A3%E7%A0%81%E7%9A%84%E5%81%A5%E5%A3%AE%E6%80%A7">2019-03-23<!-- --> - <!-- -->如何通过测试提升 Python 代码的健壮性</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/%E4%B8%BA%E4%BD%A0%E7%9A%84%E9%A1%B9%E7%9B%AE%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%20ELKFA%20%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F">2019-03-10<!-- --> - <!-- -->为你的项目快速搭建 ELKFA 日志系统</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%20Django%20%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7">2019-03-08<!-- --> - <!-- -->如何保证 Django 项目的数据一致性</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/%E8%BF%99%E5%87%A0%E6%8B%9B%EF%BC%8C%E8%AE%A9%E4%BD%A0%E5%BF%AB%E9%80%9F%E6%8F%90%E5%8D%87%20Python%20%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%80%A7%E8%83%BD">2019-03-05<!-- --> - <!-- -->这几招，让你快速提升 Python 项目的性能</a></li></ol></div><div><h2 class="text-xl font-medium text-gray-600 ">2019-02</h2><ol><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E7%82%B9">2019-02-10<!-- --> - <!-- -->秒杀系统的一些注意点</a></li></ol></div><div><h2 class="text-xl font-medium text-gray-600 ">2018-12</h2><ol><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/%E7%94%A8%20Type%20Annotation%20%E6%8F%90%E5%8D%87%E4%BD%A0%E7%9A%84%20Python%20%E4%BB%A3%E7%A0%81%E5%81%A5%E5%A3%AE%E6%80%A7">2018-12-10<!-- --> - <!-- -->用 Type Annotation 提升你的 Python 代码健壮性</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/%E6%97%85%E6%8B%8D%20Vlog%20CheatSheet">2018-12-10<!-- --> - <!-- -->旅拍 Vlog CheatSheet</a></li></ol></div><div><h2 class="text-xl font-medium text-gray-600 ">2018-11</h2><ol><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/Final%20Cut%20Pro%20X%20CheatSheat">2018-11-25<!-- --> - <!-- -->Final Cut Pro X CheatSheat</a></li></ol></div><div><h2 class="text-xl font-medium text-gray-600 ">2018-09</h2><ol><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/Thinking%20In%20Programming%20Language">2018-09-08<!-- --> - <!-- -->Thinking In Programming Language</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/Thinking%20In%20Web%20Developing">2018-09-04<!-- --> - <!-- -->Thinking In Web Developing</a></li></ol></div><div><h2 class="text-xl font-medium text-gray-600 ">2018-08</h2><ol><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/%E5%86%99%E7%BB%99%20Pythonista%20%E7%9A%84%20Golang%20%E5%85%A5%E9%97%A8%E6%8C%87%E5%8C%97">2018-08-29<!-- --> - <!-- -->写给 Pythonista 的 Golang 入门指北</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/Vue%20%E9%A1%B9%E7%9B%AE%E6%BC%AB%E8%B0%88%202018%20%E7%89%88">2018-08-01<!-- --> - <!-- -->Vue 项目漫谈 2018 版</a></li></ol></div><div><h2 class="text-xl font-medium text-gray-600 ">2018-07</h2><ol><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/Tone%20Color">2018-07-27<!-- --> - <!-- -->Tone Color</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/%E4%BA%BA%E5%83%8F%E6%91%84%E5%BD%B1%E6%8C%87%E5%8C%97">2018-07-18<!-- --> - <!-- -->人像摄影指北</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/%E6%91%84%E5%BD%B1%E5%85%A5%E9%97%A8%E6%8C%87%E5%8C%97">2018-07-10<!-- --> - <!-- -->摄影入门指北</a></li></ol></div><div><h2 class="text-xl font-medium text-gray-600 ">2018-06</h2><ol><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/Synology%20%E7%BE%A4%E6%99%96%20NAS%20%E5%85%A5%E9%97%A8%E6%8C%87%E5%8C%97">2018-06-10<!-- --> - <!-- -->Synology 群晖 NAS 入门指北</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/CPython%20%E6%BA%90%E7%A0%81%E5%88%9D%E6%AD%A5%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0">2018-06-06<!-- --> - <!-- -->CPython 源码初步阅读笔记</a></li></ol></div><div><h2 class="text-xl font-medium text-gray-600 ">2018-05</h2><ol><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/Python%20%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7%20Fabric%20%E6%94%AF%E6%8C%81%20Python3">2018-05-23<!-- --> - <!-- -->Python 自动化工具 Fabric 支持 Python3</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/PyCon%202018%20%E4%B9%8B%20pipenv%20--%20%E6%9C%AA%E6%9D%A5%E7%9A%84%20Python%20%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7">2018-05-23<!-- --> - <!-- -->PyCon 2018 之 pipenv -- 未来的 Python 依赖管理工具</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/PyCon%202018%20%E4%B9%8B%20Django%20%E4%B8%93%E9%A2%98">2018-05-16<!-- --> - <!-- -->PyCon 2018 之 Django 专题</a></li></ol></div><div><h2 class="text-xl font-medium text-gray-600 ">2018-04</h2><ol><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/DjangoORM%20CheatSheet">2018-04-28<!-- --> - <!-- -->DjangoORM CheatSheet</a></li></ol></div><div><h2 class="text-xl font-medium text-gray-600 ">2018-03</h2><ol><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/SQLAlchemy%20CheatSheet">2018-03-31<!-- --> - <!-- -->SQLAlchemy CheatSheet</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/Flask%20%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0">2018-03-09<!-- --> - <!-- -->Flask 文档阅读笔记</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/Flask%20%E6%BA%90%E7%A0%81%E5%88%9D%E6%AD%A5%E8%A7%A3%E8%AF%BB">2018-03-09<!-- --> - <!-- -->Flask 源码初步解读</a></li></ol></div><div><h2 class="text-xl font-medium text-gray-600 ">2018-02</h2><ol><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/YaDjangoBlog%20%E4%B9%8B%20%E5%89%8D%E7%AB%AF%20VueJS%20%E7%AF%87">2018-02-25<!-- --> - <!-- -->YaDjangoBlog 之 前端 VueJS 篇</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/YaDjangoBlog%20%E7%9A%84%E5%89%8D%E5%90%8E%E7%AB%AF%E8%AE%BE%E8%AE%A1">2018-02-24<!-- --> - <!-- -->YaDjangoBlog 的前后端设计</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/YaDjangoBlog%20%E4%B9%8B%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%AF%87">2018-02-23<!-- --> - <!-- -->YaDjangoBlog 之前后端分离篇</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/YaDjangoBlog%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE">2018-02-22<!-- --> - <!-- -->YaDjangoBlog 开发环境配置</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/2018%20%E5%B9%B4%E4%B8%8D%E5%AE%B9%E9%94%99%E8%BF%87%E7%9A%84%20Django%20%E5%85%A8%E6%A0%88%E9%A1%B9%E7%9B%AE">2018-02-21<!-- --> - <!-- -->2018 年不容错过的 Django 全栈项目</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/Unknown%20Cheatsheet">2018-02-20<!-- --> - <!-- -->Unknown Cheatsheet</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/Docker%20CheatSheet">2018-02-10<!-- --> - <!-- -->Docker CheatSheet</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/ElasticSearch%20CheatSheet">2018-02-10<!-- --> - <!-- -->ElasticSearch CheatSheet</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/NumPy%20CheatSheet">2018-02-03<!-- --> - <!-- -->NumPy CheatSheet</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/Celery%20%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%8C%87%E5%8C%97">2018-02-02<!-- --> - <!-- -->Celery 快速入门指北</a></li></ol></div><div><h2 class="text-xl font-medium text-gray-600 ">2018-01</h2><ol><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/%E7%94%A8%20tmux%20%E4%B8%8E%20tmuxinator%20%E6%89%93%E9%80%A0%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E6%B5%81">2018-01-28<!-- --> - <!-- -->用 tmux 与 tmuxinator 打造开发工作流</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/Python%20%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9%E5%92%8C%E5%AD%98%E6%A1%A3">2018-01-23<!-- --> - <!-- -->Python 中的数据压缩和存档</a></li></ol></div><div><h2 class="text-xl font-medium text-gray-600 ">2017-12</h2><ol><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/%E5%85%B3%E4%BA%8E%20CSS%20%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E4%B8%80%E5%88%87">2017-12-28<!-- --> - <!-- -->关于 CSS 你应该知道的一切</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/macOS%20%E7%9A%84%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%BD%AF%E4%BB%B6">2017-12-23<!-- --> - <!-- -->macOS 的系统与软件</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%B0%8F%E6%9C%BA%E5%99%A8%E7%9A%84%20Python%20%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90">2017-12-07<!-- --> - <!-- -->记一次小机器的 Python 大数据分析</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/Python%20%E5%9B%BE%E7%89%87%E7%88%AC%E8%99%AB">2017-12-01<!-- --> - <!-- -->Python 图片爬虫</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/%E8%83%8C%E5%8D%95%E8%AF%8D%E5%B0%8F%E5%8A%A9%E6%89%8B">2017-12-01<!-- --> - <!-- -->背单词小助手</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/Shell%20CheatSheet">2017-12-01<!-- --> - <!-- -->Shell CheatSheet</a></li></ol></div><div><h2 class="text-xl font-medium text-gray-600 ">2017-11</h2><ol><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/Python%20%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%87%86%E5%88%99">2017-11-20<!-- --> - <!-- -->Python 中的作用域准则</a></li></ol></div><div><h2 class="text-xl font-medium text-gray-600 ">2017-10</h2><ol><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8%20macOS">2017-10-07<!-- --> - <!-- -->如何优雅地使用 macOS</a></li></ol></div><div><h2 class="text-xl font-medium text-gray-600 ">2017-09</h2><ol><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/VueJS%20%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0">2017-09-15<!-- --> - <!-- -->VueJS 文档阅读笔记</a></li></ol></div><div><h2 class="text-xl font-medium text-gray-600 ">2017-08</h2><ol><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/ReThinking%20In%20Python">2017-08-04<!-- --> - <!-- -->ReThinking In Python</a></li></ol></div><div><h2 class="text-xl font-medium text-gray-600 ">2017-07</h2><ol><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/React%20CheatSheet">2017-07-26<!-- --> - <!-- -->React CheatSheet</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%9A%84%E5%B8%B8%E8%AF%86%E7%AC%94%E8%AE%B0">2017-07-17<!-- --> - <!-- -->数据科学的常识笔记</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/GeoProcessing%20In%20Python">2017-07-11<!-- --> - <!-- -->GeoProcessing In Python</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/Rethinking%20In%20JavaScript">2017-07-04<!-- --> - <!-- -->Rethinking In JavaScript</a></li></ol></div><div><h2 class="text-xl font-medium text-gray-600 ">2017-06</h2><ol><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/Git%20CheatSheet">2017-06-15<!-- --> - <!-- -->Git CheatSheet</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/Pandas%20CheatSheet">2017-06-03<!-- --> - <!-- -->Pandas CheatSheet</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/CVim">2017-06-03<!-- --> - <!-- -->CVim</a></li></ol></div><div><h2 class="text-xl font-medium text-gray-600 ">2017-05</h2><ol><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8E%20TensorFlow%20%E7%9A%84%E5%9B%BE%E7%89%87%E5%88%86%E7%B1%BB%E5%99%A8">2017-05-29<!-- --> - <!-- -->一个基于 TensorFlow 的图片分类器</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/VSCode%20CheatSheet">2017-05-27<!-- --> - <!-- -->VSCode CheatSheet</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/MacBook%20Pro%2015.4%20Multi-Touch%20Bar">2017-05-01<!-- --> - <!-- -->MacBook Pro 15.4 Multi-Touch Bar</a></li></ol></div><div><h2 class="text-xl font-medium text-gray-600 ">2017-04</h2><ol><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/Thinking%20In%20Python%20Language">2017-04-08<!-- --> - <!-- -->Thinking In Python Language</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/%E3%80%8EFluent%20Python%E3%80%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0">2017-04-07<!-- --> - <!-- -->『Fluent Python』读书笔记</a></li></ol></div><div><h2 class="text-xl font-medium text-gray-600 ">2017-02</h2><ol><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/%E3%80%8E%E5%A5%BD%E5%A5%BD%E8%AF%B4%E8%AF%9D%E3%80%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0">2017-02-01<!-- --> - <!-- -->『好好说话』读书笔记</a></li></ol></div><div><h2 class="text-xl font-medium text-gray-600 ">2017-01</h2><ol><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/%E3%80%8E%E6%8A%8A%E6%97%B6%E9%97%B4%E5%BD%93%E5%81%9A%E6%9C%8B%E5%8F%8B%E3%80%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0">2017-01-27<!-- --> - <!-- -->『把时间当做朋友』读书笔记</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/%E3%80%8E%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%E3%80%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0">2017-01-27<!-- --> - <!-- -->『如何阅读一本书』读书笔记</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/%E5%86%99%E7%BB%99%20Pythoner%20%E7%9A%84%20Spacemacs%20%E5%85%A5%E9%97%A8%E6%8C%87%E5%8C%97">2017-01-15<!-- --> - <!-- -->写给 Pythoner 的 Spacemacs 入门指北</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/%E4%BB%8E%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98%E6%9D%A5%E8%AF%B4%20Python%20%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F">2017-01-14<!-- --> - <!-- -->从一个小问题来说 Python 的作用域</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/PostgreSQL%20CheatSheat">2017-01-05<!-- --> - <!-- -->PostgreSQL CheatSheat</a></li></ol></div><div><h2 class="text-xl font-medium text-gray-600 ">2016-12</h2><ol><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/LeetCode%20Python%20Solution">2016-12-21<!-- --> - <!-- -->LeetCode Python Solution</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/Redis%20Cheatsheet">2016-12-11<!-- --> - <!-- -->Redis Cheatsheet</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/Cheatsheet%20%E9%9B%86%E5%90%88%E7%AF%87">2016-12-10<!-- --> - <!-- -->Cheatsheet 集合篇</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/MongoDB%20Cheatsheet">2016-12-09<!-- --> - <!-- -->MongoDB Cheatsheet</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/Text%20Processing%20In%20Python">2016-12-03<!-- --> - <!-- -->Text Processing In Python</a></li></ol></div><div><h2 class="text-xl font-medium text-gray-600 ">2016-11</h2><ol><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/Awesome-Python">2016-11-26<!-- --> - <!-- -->Awesome-Python</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/%E6%95%B4%E7%90%86%E5%8D%9A%E5%AE%A2">2016-11-23<!-- --> - <!-- -->整理博客</a></li></ol></div><div><h2 class="text-xl font-medium text-gray-600 ">2016-10</h2><ol><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/Ubuntu%20CheatSheet">2016-10-05<!-- --> - <!-- -->Ubuntu CheatSheet</a></li></ol></div><div><h2 class="text-xl font-medium text-gray-600 ">2016-09</h2><ol><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/IPython%20Notebook%20%E5%BC%95%E5%85%A5%20ECharts%20%E5%81%9A%E5%8F%AF%E8%A7%86%E5%8C%96">2016-09-23<!-- --> - <!-- -->IPython Notebook 引入 ECharts 做可视化</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/MySQL%20CheatSheet">2016-09-02<!-- --> - <!-- -->MySQL CheatSheet</a></li></ol></div><div><h2 class="text-xl font-medium text-gray-600 ">2016-07</h2><ol><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/macOS%20Cheatsheet">2016-07-01<!-- --> - <!-- -->macOS Cheatsheet</a></li></ol></div><div><h2 class="text-xl font-medium text-gray-600 ">2016-03</h2><ol><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/%E5%A6%82%E4%BD%95%E5%8F%91%E5%B8%83%E4%B8%80%E4%B8%AA%20Python%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7">2016-03-15<!-- --> - <!-- -->如何发布一个 Python 命令行工具</a></li></ol></div><div><h2 class="text-xl font-medium text-gray-600 ">2016-02</h2><ol><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/%E5%85%B3%E4%BA%8E%E8%83%8C%E5%8D%95%E8%AF%8D%E8%BD%AF%E4%BB%B6%EF%BC%8C%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E6%83%8A%E4%BA%BA%E7%9C%9F%E7%9B%B8">2016-02-24<!-- --> - <!-- -->关于背单词软件，你不知道的惊人真相</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/Python%20%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E7%9C%8B%E6%96%97%E9%B1%BC%20TV">2016-02-15<!-- --> - <!-- -->Python 程序员如何优雅的看斗鱼 TV</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/%E6%96%97%E9%B1%BC%20TV%20%E5%BC%B9%E5%B9%95%E5%8A%A9%E6%89%8B">2016-02-04<!-- --> - <!-- -->斗鱼 TV 弹幕助手</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/Windows%20%E8%BF%81%E7%A7%BB%E5%88%B0%20macOS%20%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%8F%E9%AA%8C">2016-02-01<!-- --> - <!-- -->Windows 迁移到 macOS 的一些经验</a></li></ol></div><div><h2 class="text-xl font-medium text-gray-600 ">2015-12</h2><ol><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/%E4%B9%A6%E5%8D%95">2015-12-31<!-- --> - <!-- -->书单</a></li></ol></div><div><h2 class="text-xl font-medium text-gray-600 ">2015-09</h2><ol><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/%E3%80%8E%E5%8D%9A%E4%BA%BA%E4%BC%A0%E3%80%8F%E5%BD%B1%E8%AF%84">2015-09-19<!-- --> - <!-- -->『博人传』影评</a></li></ol></div><div><h2 class="text-xl font-medium text-gray-600 ">2015-06</h2><ol><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E4%BD%BF%E7%94%A8%20Windows%2010">2015-06-14<!-- --> - <!-- -->如何优雅的使用 Windows 10</a></li></ol></div><div><h2 class="text-xl font-medium text-gray-600 ">2015-05</h2><ol><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8A%80%E5%B7%A7">2015-05-04<!-- --> - <!-- -->搜索引擎的一些技巧</a></li></ol></div><div><h2 class="text-xl font-medium text-gray-600 ">2015-02</h2><ol><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/Chorthotkey%20%E5%8F%91%E5%B8%83">2015-02-22<!-- --> - <!-- -->Chorthotkey 发布</a></li></ol></div><div><h2 class="text-xl font-medium text-gray-600 ">2014-10</h2><ol><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/%E8%87%B3%E5%B0%8A%E5%AE%9D%E5%92%8C%E5%AD%99%E6%82%9F%E7%A9%BA%20-%20%E3%80%8E%E5%A4%A7%E8%AF%9D%E8%A5%BF%E6%B8%B8%E3%80%8F%E5%BD%B1%E8%AF%84">2014-10-25<!-- --> - <!-- -->至尊宝和孙悟空 - 『大话西游』影评</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/Sublime%20Text">2014-10-25<!-- --> - <!-- -->Sublime Text</a></li><li class="ml-5 mt-2 mb-2"><a class="text-indigo focus:text-black font-mono" href="/post/%E5%86%99%E5%9C%A8%E4%BA%BA%E7%94%9F%E7%9A%84%E8%BE%B9%E4%B8%8A">2014-10-16<!-- --> - <!-- -->写在人生的边上</a></li></ol></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"byMonth":[{"name":"2021-06","posts":[{"tags":["业务系统"],"path":"20210607_SD01_Back_Pressure.md","title":"系统设计 01 - 背压 backpressure","slug":"系统设计 01 - 背压 backpressure","date":"2021-06-20","category":"系统设计","lastMod":"2021-06-20","description":"系统设计","thumbnail":"","content":"\n# 系统设计 01 - 背压 backpressure\n\n## 0x00 前言\n\n最近看到一篇讲 backpressure 的文章，今天来聊一聊背压问题。\n\n## 0x01 什么是背压\n\n按照百度的说法\n\n\u003e 指运动流体在密闭容器中沿其路径（譬如管路或风通路）流动时，由于受到障碍物或急转弯道的阻碍而被施加的与运动方向相反的压力\n\n简单来说，水箱入水多，出水少\n\n![Image](https://pic4.zhimg.com/80/v2-7dbaf693275f72d08e672d026f79eef3.jpg)\n\n在正式进入文章之前，务必要注意，\n\n1. 「背压现象」指的是一种生产者速率大于消费者速率的现象。\n2. 「背压机制」指的是一种预防背压现象出现的机制。\n\n## 0x02 常见的背压场景\n\nProducer 产出多 Consumer 来不及消费完\n\n小到文件的 IO, 在请求到响应的整个生命周期，大到成白上千的数据计算任务，都会存在背压问题。\n\n1. 读写文件 - 读快写慢 假设读速度 150MB/s 写速度 100MB/s, 那么每一秒就必须缓冲 50MB, 也就是 20 多秒就接近 1GB, 可想而知，如果不注意策略的话，内存很快就撑爆。\n2. 服务间通讯 - 客户端对服务 A qps 为 100, 服务 A 需要请求内部服务 B, B 的 QPS 为 75, 如果不做额外的处理，服务 A 每秒钟就会积压 25 个请求。\n3. 消息队列中瞬时消息过多 - kafka 内瞬间累积了海量的消息。\n4. 爬虫速度过快，解析 worker 无法在相同时间内完成解析入库。\n5. UI 渲染，在比较热闹的直播页面，海量的用户发送弹幕，而用户界面很容易收到并且渲染海量消息而崩溃。\n6. 用户支付完成后跳转到支付成功页面。\n7. 今天花三十分钟写了 300 个 BUG, 导致测试妹纸直接崩溃。\n\n## 0x03 背压解决策略\n\n1. 减少数据产出速率\n2. 增加数据消费速率\n3. 缓冲数据 use buffer\n4. 丢弃数据\n\n### 场景 1: 读写文件\n\nhttps://nodejs.org/en/docs/guides/backpressuring-in-streams/\n\nNodeJS 团队分别测试了禁用和启用 backpressure 特性的情况下运行了这段脚本\n\n```javascript\nconst gzip = require(\"zlib\").createGzip()\nconst fs = require(\"fs\")\n\nconst inp = fs.createReadStream(\"The.Matrix.1080p.mkv\")\nconst out = fs.createWriteStream(\"The.Matrix.1080p.mkv.gz\")\n\ninp.pipe(gzip).pipe(out)\n```\n\n不支持 backpressure 的情况首先带来的是内存的激增，其次是\n\n1. 影响其他速度\n2. GC 频率变高\n3. 内存耗尽\n\n对于 NodeJS 来说，选择了 Buffer 的手段\n\n### 场景 2: 服务间通讯\n\n对于 客户端 -\u003e 服务 A -\u003e 服务 B\n\n往往是在客户端与服务 A 之前加负载均衡，A 与 B 之间也加负载均衡\n\n负载均衡也分为两种，服务端负载均衡以及客户端负载均衡。\n\n- 负载均衡此时也承担了 Buffer 的作用。\n- 而多个服务 A 和多个服务 B 承担了增加消费速率的作用。\n\n### 场景 3: 爬虫 / 消息队列瞬时消息过多\n\n大多是扩 buffer, 扩消费者。\n\n### 场景 4: UI 渲染\n\n之前写过弹幕类服务。其中对前后端的部分考虑点还是很有趣的。\n\n在弹幕激增的情况下，弹幕列表不能瞬间挂掉。\n\n对于用户发送的弹幕消息，后端做好用户的分组，然后针对每个用户做好弹幕限流。这样确保后端传给前端的弹幕事件是可接受范围内的。\n\n然而，随着弹幕瞬时消息的激增，前端那边还是有点控不住了。\n\n几轮讨论下来，判断出 UI 渲染是瓶颈。后端已经做好用户的分组和弹幕的限流。再做消息的合并必要性不是很大。\n\n比如，瞬间接收 100 次弹幕事件。应该按照每秒进行合并弹幕批量前面 95 条弹幕接着渲染最后 5 条弹幕。\n\n整个界面就看起来顺滑多了。\n\n参考 https://steveholgado.com/rxjs-chat-app/\n\n## 0xEE 参考链接\n\n- https://lucumr.pocoo.org/2020/1/1/async-pressure/\n- https://nodejs.org/en/docs/guides/backpressuring-in-streams/\n"},{"tags":["业务系统"],"path":"20210627_RESTful_vs_GraphQL.md","title":"也聊聊 RESTful vs GraphQL","slug":"也聊聊 RESTful vs GraphQL","date":"2021-06-20","category":"系统设计","lastMod":"2021-06-20","description":"系统设计","thumbnail":"","content":"\n# 也聊聊 RESTful vs GraphQL\n\n## 0x00 前言\n\n本文最早行文于 2018 年中，那时 GraphQL 的生态尚未成熟，也缺乏社区总结的一些经验。\n\n\u003e 较早入了坑，回首百年身\n\n2021 年中，复盘一下 GraphQL 的一些使用经验。\n\n名词约定\n\n- **接口生产端 / 服务端 下面统一称「生产端」**\n- **接口消费端 / 客户端 下面统一称「消费端」**\n\n## 0x01 流水的技术方案，铁打的需求。\n\n年幼时看笑傲江湖，华山派两派居然为了剑宗和气宗争个你死我活。\n\n觉得甚是幼稚。\n\n年纪渐大之后发现社会处处充满着这种「谁好」的争论。\n\n- 剑宗 or 气宗\n- 自然美 or 人造美\n- Java or Python or Golang\n- Editor or IDE\n- Rest or GraphQL\n- 单体应用 or 微服务\n\n剑招是死的，人是活的。\n\n当讨论问题的时候，下面两个问题意义可能并不是很大。\n\n- 用剑宗初学者和气宗高手比，或者相反，这个完全没有多大意义？\n- 用剑宗初学者和气宗初学者比孰强孰弱，这个有一点意义，但意义也不是很大。菜鸡互啄。\n\nGraphQL 作为挑战者，下面几个问题是很有意义的。\n\n- 现有方案存在哪些问题？\n- GraphQL 相比于原先成熟稳定的方案\n- 新方案解决了哪些原先没有解决的问题。\n- 新方案更低成本解决了哪些问题。\n- 现有的痛点是否存在一些新老方案都无法解决的问题。\n- 有无前车之鉴，有无社区最佳实践。\n- 迁移成本和学习成本是多少。\n- 回滚成本多少。\n\n## 0x02 RESTful 的缺点\n\nRESTful 有很多接口上最佳实践，但生搬硬套就会使得接口比较诡异。\n\n这里只说生搬硬套 RESTFul 的带来的缺点，对于大部分公司来说，这些缺点远远抵不上带来的优点。\n\n### 语义不明确\n\n比如，业务具备一定复杂性的时候，语义容易不明确。\n\n预览订单和下单两个接口，如果遵循如下的标准\n\n- 接口路径使用名词而非动词\n- GET 不修改，POST/PUT/DELETE 修改状态\n- 使用子字段来表述关系，查询订单 GET /shop/711/orders/\n\n严格遵循 RESTful 的话，接口就会成这个样子\n\n```bash\nGET /shops/1/order  {   \"products\": [...] }\nPUT /shops/1/order  {   \"products\": [...] }\n```\n\n反正我是看不出来这是一坨啥玩意的，至于如果你硬性规范 PUT order 就是创建订单，就会出现接下来两个接口完全不知道该怎么写\n\n```\n    支付订单 （用 patch /shop/1/order)\n    取消订单 （用 delete 方法，也没有 delete 呀）\n    退款订单\n    部分退款订单\n```\n\n- 产品上，用户删除了一台机器，那就是删除了一台机器？这里是软删。\n- 产品上，管理员删除了一台机器，那就是删除了一台机器？机器记录还在的。\n\n所以，采用的是 DELETE /machine/1\n\n\u003e 剑招是死的，人是活的。\n\n不严格遵循 RESTful 的时候可以这么写。\n\n```bash\nPOST /preview_order\n{\n  \"shop_id\": 123,\n  \"products\": [...]\n}\n\nPOST /make_order\n{\n  \"shop_id\": 123,\n  \"products\": [...]\n}\n\nPOST /pay_order\n{\n  \"order_id\": \"202012001231237\",\n  \"balance\": \"20.20\",\n}\nPOST /cancel_order\n{\n  \"order_id\": \"202012001231237\"\n}\n```\n\n至于第三点的子字段表述关系，是一个典型的反面教材\n\n引用 Python 之禅来表达\n\n```\nFlat is better than nested. 扁平优于嵌套\n```\n\n### 得到即是失去 - Get's loss\n\nGET 让问题变得复杂\n\nRest 时代一个有代表性的问题就是如何在 GET 方法里处理以下四个问题\n\n- 过滤 filter\n- 排序 sort\n- 字段裁剪 field selections\n- 分页 pagination\n\n为了解决这个问题，一个稍微复杂的查询接口就成了如下的样子\n\n```bash\nGET /cars?seats\u003c=2\u0026sort=-manufactorer,+model\u0026fields=manufacturer,model,id,color\u0026page=1\u0026per_page=10\n```\n\n\u003e **可阅读性较差**\n\n而如果这么写，则前端无需把原先的 queryparams 转化成逗号结尾的字符串，后端也需要跟着解析并且转成自己想要的格式\n\n如果按照如下的写法，后端则可以直接使用 json 标准库里的数据类型。\n\n```bash\nPOST /cars\n{\n  \"filters\": [\n      {\n        \"seat__lt\": 2,\n    }\n  ]\n  \"sort\": [\n    \"-manufactorer\",\n    \"+model\"\n  ],\n  \"fields\": [\n    \"manufacturer\",\n    \"model\",\n    \"id\",\n    \"color\"\n  ],\n  \"pagination\": {\n    \"page\": 1,\n    \"per_page\": 10\n  }}\n\n```\n\n### 未很好解决的问题\n\nRESTFul 接口提倡的是细粒度、正交性。\n\n这样的接口是为了更加方便的复用多个接口来组成页面，但是并非没有问题。\n\n细粒度和正交性意味着接口是 building block, 而 building block 组合起来是交给前端来做的。 这意味着前端为了组合多个资源，则需要发起多次请求。\n\n这首先是带来了的网络开销成本 (HTTP 2 解决了首部开销、多路复用等 HTTP 1.1 面临的问题，还做到了完全向后兼容。) 和响应内容拼装成本\n\n其次，前端往往会抱怨\n\n1.  服务端这个接口字段少了，后端往往会复用序列器，直接把太多前端用不到的数据一并返回。\n2.  服务端这个接口字段太多，需要慢慢找 diff, 于是会开始抱怨文档问题。\n\n于是大家采用了 swagger/openapi 的配套解决方案。同时带来了，文档的缺失和滞后\n\n## 0x03 GraphQL 是新的颠覆者么？\n\nGraphQL 也不是什么革命性的产品，不过是一种新的开 Web 接口的方式罢了。\n\n而请求接口提交的参数也变成了包含参数的一种查询语言。\n\n官方宣传的 GraphQL 搞好了，只需如此：\n\n```graphql\n# Step1\\. 描述你的数据\ntype Project {\n  name: String\n  tagline: String\n  contributors: [User]\n}\n# Step2\\. 请求所需数据。\n{\n  project(name: \"GraphQL\") {\n    tagline\n  }\n}\n# Step3\\. 拿到所需数据。\n{\n  \"project\": {\n      \"tagline\": \"A query language for APIs\"\n  }\n}\n```\n\n嗯，是不是和 SQL 看起来有点像？当然咯，都是查询语言 (QL) 嘛。\n\n## 0x04 GraphQL 给消费端带来的好处\n\nGraphQL 的好处，自然是接口消费端写起来就是一个字，爽。\n\n比如我们使用 Github 的 API 做一个简单的查询  \n地址如下 https://link.zhihu.com/?target=https%3A//developer.github.com/v4/explorer/\n查询如下\n\n```graphql\nquery {\n  viewer {\n    login\n    bio\n    repositories(first: 10, orderBy: { field: STARGAZERS, direction: DESC }) {\n      nodes {\n        nameWithOwner\n        viewerHasStarred\n        watchers {\n          totalCount\n        }\n        stargazers {\n          totalCount\n        }\n      }\n      totalCount\n    }\n  }\n}\n```\n\n结果如下\n\n```json\n{\n  \"data\": {\n    \"viewer\": {\n      \"login\": \"twocucao\",\n      \"bio\": \"FullStack Pythonist In Shanghai\",\n      \"repositories\": {\n        \"nodes\": [\n          {\n            \"nameWithOwner\": \"twocucao/YaDjangoBlog\",\n            \"viewerHasStarred\": true,\n            \"watchers\": {\n              \"totalCount\": 12\n            },\n            \"stargazers\": {\n              \"totalCount\": 326\n            }\n          },\n          {\n            \"nameWithOwner\": \"twocucao/danmu.fm\",\n            \"viewerHasStarred\": true,\n            \"watchers\": {\n              \"totalCount\": 23\n            },\n            \"stargazers\": {\n              \"totalCount\": 316\n            }\n          },\n          {\n            \"nameWithOwner\": \"twocucao/YaVueBlog\",\n            \"viewerHasStarred\": true,\n            \"watchers\": {\n              \"totalCount\": 8\n            },\n            \"stargazers\": {\n              \"totalCount\": 141\n            }\n          },\n          {\n            \"nameWithOwner\": \"twocucao/danmu\",\n            \"viewerHasStarred\": true,\n            \"watchers\": {\n              \"totalCount\": 5\n            },\n            \"stargazers\": {\n              \"totalCount\": 69\n            }\n          },\n          {\n            \"nameWithOwner\": \"twocucao/silverhand\",\n            \"viewerHasStarred\": true,\n            \"watchers\": {\n              \"totalCount\": 7\n            },\n            \"stargazers\": {\n              \"totalCount\": 60\n            }\n          },\n          {\n            \"nameWithOwner\": \"twocucao/ChortHotKey\",\n            \"viewerHasStarred\": true,\n            \"watchers\": {\n              \"totalCount\": 7\n            },\n            \"stargazers\": {\n              \"totalCount\": 32\n            }\n          }\n          // ......\n        ],\n        \"totalCount\": 155\n      }\n    }\n  }\n}\n```\n\n如果你说，我还要看看这个 repo 的主要语言，那么增加一行查询即可。如图。\n\n![](https://pic2.zhimg.com/v2-997f49fd55e972c37d458a2aef6fb4dd_b.jpg)\n\n![](https://pic2.zhimg.com/80/v2-997f49fd55e972c37d458a2aef6fb4dd_1440w.jpg)\n\n是不是很方便？前端基本对着 Schemas 里面的 query 查询完毕就完毕了。\n\n查询这么搞可以，增删改查之类的操作呢？\n\nGraphQL 里面还有 Mutation 可以帮你解决这个问题，在后端定义完 Mutation , 前端在 Mutation 里面可以直接传参。\n\n甚至，**后端开出接口时，可以依据请求和响应生成对应的 typescript 代码，然后享受代码补全的快感。**\n\n\u003e **极大利好前端**\n\n有人说, graphql 不就最后生成了 schema 嘛\n\n可不要小瞧了生成全接口的 schema, 用它可以做很多东西\n\n1.  **便捷的文档功能,** 接口列表以及入参的初步生成。便于快速调接口，比如我写了一个接口，发布到测试环境，接着点击一个按扭直接同步到 insomnia 里。点击运行即可调试。**「甚至可以做简单的接口自动化测试」**\n2.  **可以生成 typescript/javascript 代码,** 让前端享受到直接在代码里补全的快感。\n3.  比对两个版本之间的 schema 可以直接得出接口 schema 上，后端有没有做好兼容。如果不行, 则 CI 无法跑过\n\n![](https://pic1.zhimg.com/v2-c7a593ada4bc7fc78b20c3d18b5e1850_b.jpg)\n\n## 0x05 GraphQL 给生产端带来的挑战\n\n消费端（前端）爽了，是否意味着生产端（服务端）会爽呢？\n\n\u003e **并不是**\n\n- 对于前端来说，如果要消费 graphql api, 相对容易一些。 只需将原先的 api 层改为 graphqlfetch 即可\n- 对于后端来说，如果要生产 graphql api, 则麻烦了不少。\n\n下文我会以 graphene 这个 graphql python 库来说明带来的一些挑战\n\nhttps://link.zhihu.com/?target=https%3A//github.com/graphql-python/graphene\n\n有的挑战是和 graphql 相关的，有的挑战则是来自 graphene 库，或许其他库有更好的解决方案。\n\n\u003e 注意！痛点背后的原因，大多是 graphql 以及配套库玩的不熟。**而不一定是 RESTFUL 不存在这些问题**\n\n大致有如下挑战\n\n- View 层代码组织剧变\n- 权限问题\n- 版本更迭\n- required vs nullable vs blank\n- 服务端缓存\n- 嵌套式 API\n- N+1 问题\n- 为名所困\n\n### View 层代码组织剧变\n\n以简单的查询和创建两个接口为例。\n\n```python\n\nimport graphene\n\nclass PersonInput(graphene.InputObjectType):\n  name = graphene.String(required=True)\n  age = graphene.Int(required=True)\n\nclass CreatePerson(graphene.Mutation):\n\n  class Arguments:\n    person_data = PersonInput(required=True)\n    person = graphene.Field(Person)\n\n  def mutate(root, info, person_data=None):\n    person = Person(name=person_data.name,age=person_data.age)\n    return CreatePerson(person=person)\n\nclass Person(graphene.ObjectType):\n  name = graphene.String()\n  age = graphene.Int()\n\nclass MyMutations(graphene.ObjectType):\n  create_person = CreatePerson.Field()\n\n# We must define a query for our schema\nclass Query(graphene.ObjectType):\n  person = graphene.Field(Person)\n  schema = graphene.Schema(query=Query, mutation=MyMutations)\n\n```\n\n同样的逻辑用原先的方法只需如此即可。\n\n```python\n@bp.get(\"/person\")\ndef get_person():\n  # do get person\n  return data\n\nclass DataValidator(validator):\n  name: constr(min_length=2, max_length=10)\n  age: conint(gte=1, lte=200)\n\n@bp.post(\"/person_create\")\ndef person_create(data: DataValidator):\n  # do create person\n  return data\n```\n\n- 第一个痛点**原先简单清晰的代码变成了非常冗长的代码。**\n\n为了提升输入速度，分别尝试了 code generator / snippet 。大量的输入的代价是代码阅读带来较多无效阅读，反而造成了更多的调试困难。\n\n- 第二个痛点**校验层没了。而增加校验层变得比较麻烦。**\n\n随着代码量上升，相同业务逻辑的物理距离变得比较长，query 和 mutation 需要拆分到两个文件或者一个文件的上部分和下部分。\n\n- 假设你写的是一个商城，从上到下阅读代码会发现一会儿是商品基本信息，一会儿是分类，一会儿是订单，一会儿又是分类，order 的逻辑查看在一个文件的犄角旮旯，修改在另一个文件的犄角旮旯。代码复杂度 +1\n- 假设查询订单和修改订单两个接口查询，查看与修改所查询的业务逻辑是一样的。由于物理距离过于远，则大概率会写两遍这个代码。Same Logic, Write Everywhere\n\n我在 tifa 这个 fastapi 项目里尝试了使用这种组织 view 层代码的姿势\n\n这种组织代码的方式可以用 restful 的开发体验，获得 graphql 的效果\n\nhttps://link.zhihu.com/?target=https%3A//github.com/twocucao/tifa/blob/master/tifa/apps/admin/graphql.py\n\n```python\nrouter = GQLRouter()\n\nclass TPost(gr.ObjectType):\n    id = gr.Int(description=\"博客 ID\")\n    name = gr.String(required=True, description=\"博客标题\")\n\n@router.item(\"ok\", output=gr.Boolean)\ndef test_ok():\n    \"\"\"\n    做一个简单的 healthcheck\n    \"\"\"\n    return True\n\n@router.item(\"test_exception\", output=gr.Boolean)\ndef test_exception():\n    raise ApiException(\"raise an api exception\")\n\n@router.item(\"post\", output=TPost)\nasync def post_by_id(id: gr.Int):\n    \"\"\"\n    文章详情\n    \"\"\"\n    return await Post.get(id)\n\n@router.list(\"posts\", output=TPost)\nasync def posts():\n    \"\"\"\n    文章列表\n    \"\"\"\n    return await Post.all()\n\nclass PPostPagination(gr.InputObjectType):\n    q = gr.String(description=\"标题，等等\")\n\n@router.pagination(\"posts2\", output=TPost)\ndef posts_pagination(params: PPostPagination):\n    return {\n        \"items\": [\n            {\n                \"id\": i,\n                \"name\": \"testName\",\n            }\n            for i in range(10)\n        ],\n        \"per_page\": 10,\n        \"page\": 1,\n    }\n\nclass ParamsCreatePost(gr.InputObjectType):\n    name = gr.String(required=True)\n\n@router.mutation(\"create_post\", output=TPost)\nasync def create_post(params: ParamsCreatePost):\n    post = await Post.add(\n        name=params.name\n    )\n    await db.session.commit()\n    return post\n```\n\n可以看出，这种组织方式有如下的优点\n\n1.  depth 为 1 的 query / mutation 字段为一个 route\n2.  简单粗暴的权限可以做在 route 上\n3.  与 restful 完全一致的代码组织方式。RESTFul 代码几乎无缝迁移。\n\n### 权限问题\n\n接口的正交性带来的是细粒度的控制，而聚合起来之后，权限则不是很好管控。\n\n一个请求打过来包含了越权和非越权的请求。服务端需要如何判断？\n\n\u003e **保大保小？**\n\n在 Restful 里依据路由可以做简单粗暴的首次鉴权。并且程序设计之初就会考虑到权限问题。\n\n在我 18 年研究 graphql 的时候，几乎就没有关于权限的最佳实践..\n\n当然，graphql 已经流行了好久了，现在也有一些成熟的解决方案了。\n\n### 版本更迭\n\n随着业务的变更，往往需要新增 / 废弃一些接口。\n\n在原先 RESTFul 的实践下\n\n1.  接口新增只需要考虑 v2 版本\n2.  接口移除通过监控接口的请求次数来解决这个问题。\n\ngraphql 社区推荐的是不废弃接口，只做兼容。尝试遵循了 graphql 社区的意见。最后还是改回和 restful 类似的方案了。\n\n还有另外一些痛点，以往想把一些性能敏感的接口拆出来的时候，一般可以\n\n1.  运维手段：直接起另一个服务，然后在网关那边直接转发请求即可。\n2.  非运维手段：请求依旧由现在的服务接收，然后由再次发起请求到新服务上。\n\n如果采用 graphql 之后，就只能用第二种方案了。\n\n### required vs nullable vs blank\n\n```\n  not required 表示这个字段不是必须的，可传可不传。\n  required 表示这个字段是必须的，但可为 null/none, 也可不为。\n  not nullable 表示这个字段是必须的，但是不能为 null/none\n  nullable 表示这个字段是必须的，但可为 null/none, 也可不为。\n  not blank 表示这个字段是可为空的\n  对于字符串，则必须要不为 \"\"\n  对于列表，则必须要存在至少一个 item\n```\n\n举个例子来说明，如果要表示如下的响应内容\n\n订单没有支付状态，就没有支付方式，即不应该有支付方式这个字段。\n\n```\n\n# 未支付订单\n{\n  \"status\": \"NOT_PAID\"\n}\n# 已支付订单\n{\n  \"status\": \"PAID\",\n  \"pay_method\": \"WECHAT\"\n}\n```\n\n\u003e 这样的接口是**无法表示**, 如果有这个字段，就展示在界面上，没有这个字段就不展示在界面上的\n\ngraphql 没法做到未支付订单无 pay_method 这种情况，在响应体里 pay_method 总是为 null\n\n```\n# 未支付订单\n{\n  \"status\": \"NOT_PAID\"\n  \"pay_method\": null\n}\n```\n\n当然，如果硬是要做的话，只能借助 UNION[PaidOrder,NotPaidOrder] 来实现。使用 Union 本身就造成了序列化的成本急剧上升。\n\n### 服务端缓存\n\n要查什么，往往不可知（无法预知查询语句），随前端来定。不知道该怎么缓存响应内容。\n\n以往通过 URI 定位资源，Http 协议无状态，非常容易实现对应用层透明的缓存。\n\n而 GraphQL 重新定义了资源的定位方式，设计缓存的时候往往不知道该怎么设计。\n\n### 嵌套式 API\n\n在 graphql 的场景下，重写 resolver 是一个非常的影响是未知的。\n\n因为，你不知道有多少个 query 用了这个 field, 为了知道这个问题，你还得打点知道有多少个场景的 query 用到了这个字段。\n\n现实生活中情况可能复杂一些。\n\n这个例子旨在说明，存在一些改动的心智负担比较严重。\n\n比如，前端变动，接口层次，所有商家级别的数据落到店铺级别。\n\n这个例子正确的解法是联合前端一起升级到 V2\n\n### N+1 问题\n\n有的时候需要看情况来解决不同的 N+1 问题，也是比较迷惑的....\n\n客户端不见得会按照你的预期来查询。\n\n这就意味着，同一个结构，有的时候要依据情况 A 来重写查询，有的时候要依据情况 B 来重写查询。\n\n### 为名所困\n\n项目写了半年，由于 graphene 玩的不熟，我（后端）一直在各种起名困难症中度过。\n\n明明业务流程都差不多，但最后结果全是在改各种各样 ObjectType 的前缀。\n\n## 0x06 结论\n\n**GraphQL 这一套玩的熟悉的话，效率确实非常高。(前提是团队里面的人能玩的熟悉)**\n\n如果团队里面缺少全栈人才的话，在很多地方的比较难推进的动。graphql 用起来确实爽，特别是前端。\n\n由于是较新的技术，**引入进来算上折腾出最佳实践的成本和折腾过程中诞生的技术债，收益可能并没有想象的那么大。**\n\nrestful 其实也并不是做不到不少 graphql 能做到的东西。schema 生成工具其实蛮多的.\n\n\u003e 不过，搞技术嘛，**折腾不止 生命不息**, 说不一定这次折腾收益就很高了呢？\n\n## 0xEE 参考链接\n\n- Photo by [Sigmund](https://link.zhihu.com/?target=https%3A//unsplash.com/%40sigmund%3Futm_source%3Dunsplash%26utm_medium%3Dreferral%26utm_content%3DcreditCopyText) on [Unsplash](https://link.zhihu.com/?target=https%3A//unsplash.com/s/photos/compute%3Futm_source%3Dunsplash%26utm_medium%3Dreferral%26utm_content%3DcreditCopyText)\n- [「FastAPI 脚手架」](https://link.zhihu.com/?target=https%3A//github.com/twocucao/tifa)\n- https://link.zhihu.com/?target=https%3A//graphene-python.org/\n- https://link.zhihu.com/?target=https%3A//graphql.org/\n- https://link.zhihu.com/?target=https%3A//www.apollographql.com/docs/react/data/operation-best-practices/\n- https://link.zhihu.com/?target=https%3A//graphql-code-generator.com/docs/plugins/typescript\n"}],"total":2},{"name":"2021-04","posts":[{"tags":["业务系统"],"path":"20210430_FastAPI.md","title":"如何评价最近爆红的FastAPI？","slug":"如何评价最近爆红的FastAPI？","date":"2021-04-27","category":"系统设计","lastMod":"2021-06-20","description":"系统设计","thumbnail":"","content":"\n# 如何评价最近爆红的 FastAPI\n\n用 fastapi 写过两个项目。\n\n两个系统写下来后，对 fastapi 的使用有了比较粗浅的认识。也封装了一个极简脚手架，希望能帮助到有缘人。**（文末有对这个脚手架的介绍）**\n\nhttps://link.zhihu.com/?target=https%3A//github.com/twocucao/tifa\n\n首先抛出结论\n\n\u003e **fastapi 长远看好, 保持关注，但截至目前 (2021 年 4 月）写业务还是比较倾向于 django/flask。**\n\ngevent + flask/django 对比 async fastapi\n\n当然, 本文的比较是不公平的, 因为我比较的是「现有服务迁移到 FastAPI」的一些痛点\n\n综合了『上手成本』 『开发成本』 『迁移成本』后，我得出一个结论『迁移的边际效益不高』\n\n分开说的话，主要有如下几个原因。\n\n1.  「**相对较弱的生态**」 django/flask 相比生态太丰富了, 当我遇到一个问题, 当我想找一个插件, 都能比较轻松的找到。但 fastapi 尽管出来了好几年，但依然不如。async/await 的生态也是不如 sync 的生态。\n\n2.  「**其实 FastAPI 的一些卖点可以很方便的集成到你的项目中**」比如 Pydantic + django/flask 甚至可以做的更加简单清晰。\n\n3.  「**async await 调试成本较高**」async await 对代码的侵入性很强，迁移简单的项目还行，成年老项目，迁移过程不见得很顺畅。对常规的 Web 性能的提升也没有到非要它不可的地步。gevent+django/flask 性能虽然没有那么强，但是依旧是耐打。\n\n## 原因 1\\. 相对较弱的生态\n\n生态粗略分为三种\n\n1.  围绕着框架本身的插件生态，比如 flask-sqlalchemy 很好的集成了 flask 框架本身和 sqlalchemy\n\n2.  一些开放平台的 sdk 生态，比如有的是官方出品 - aliyun-oss-sdk, 有的是社区贡献 - wechatpy 。\n\n3.  io 的生态，由于上了异步，那么原先的请求库，数据库驱动等等 io 相关的库也要拿出来重新踩坑。\n\n在挑选这些插件的时候，则会遇到这种或者那种的问题，比如\n\n1.  django-debug-toolbar / flask-debug-toolbar 的 fastapi 替代品是啥？\n\n2.  celery 的 async 替代品是啥，即使有我为何要抛弃一个成熟的 celery 去踩坑？听说, faust 挺火的, 但用了这个库, 代码组织结构都变太多了. 听说 aiotasks 也不错, 仔细一看, 代码最后更新时间是**3 年前**\n\n3.  为了新开启一个项目，我还得把支付宝 sdk 从同步代码改成异步代码？直接用他们的 sdk+gevent 不改一行代码不香嘛？数据库驱动，redis 库，请求库，支付宝 sdk，微信 sdk，各类开放平台 sdk，只要是涉及到 io 的库基本上都要换一套，但是现有的 codebase 线上已经踩过不少的坑了，为何要换？甚至要重写？\n\n在经过很长时间的调研和一个一个插件的测试之后，我一拍脑袋，下了结论。\n\n\u003e 还是用成熟的东西省心呀，顺畅跑了那么多年的老代码，拷贝在身边，一用好多年。\n\u003e\n\u003e **django/flask + gevent 赛高！**\n\n## 原因 2\\. 其实 FastAPI 的一些卖点可以很方便的集成到你的项目中\n\nfastapi 所说的亮点是什么性能好、编码速度快、减少人为的 BUG 符合直觉等等\n\n但回过头来想想，除了 asyncio 和 自带 openapi/json schema, 其他的框架也有这些特点嘛比如写起来很快，简单、简洁\n\n\u003e 有人说，Pydantic 用来做校验器很好用。所以，我们要用 fastapi\n\n可是，当我写 flask + pydantic 代码的时候，我写的代码是这样的\n\n```python\nclass LoginType(str, enum.Enum):\n  MOBILE_CODE = \"MOBILE_CODE\"\n  USER_PASSWORD = \"USER_PASSWORD\"\n\nclass VLogin(BaseModel):\n  mobile_or_username: str # 这里可以加上更加复杂的校验\n  password: Optional[str]\n  type: LoginType\n\n@bp.post(\"/login\")\n@validator\ndef do_login(data: VLogin):\n  # read data and do login logic\n  return user_dict\n\n```\n\n**这个 validator 装饰器实现连换行加起来才 60 行。**\n\n所以说，在 flask/django 里，你完全不需要懂依赖注入。就可以把校验做的很干净。\n\n啥，你还要文档? pydantic 可以直接导出 jsonschema ，写个简单的解析放到文档里就行了。\n\n啥，你还要更加详细的文档丢给前端，那我觉得 graphql 可能是更加合适的选择。\n\n\u003e **你说 asyncio 并发量高, 但 gevent 并发量相比也不低呀**\n\n## 原因 3\\. async/await 调试成本比较高\n\n为何说，调试成本较高\n\nasync await 对代码的污染性太强。\n\n比如，**风陵渡口初相遇， 一 await 误终身。** 开发者深恶痛绝的「一次 await，处处 async」\n\n底层模块一旦 await/async 了，则依赖于上面的所有模块函数都要 await, 如果不 await 代码就出问题。\n\n\u003e **设想一下，如果你用了别人写的函数，这个函数突然 async 了。万一 ci 跑过了发了版本，是不是感觉今天要先回滚后加班了？**\n\u003e\n\u003e 当然，如果某一天有一种方法可以做到调用的时候，自动 await 的话，调试成本倒是低了不少。\n\n## 那么这是否代表我不看好/不喜欢 FastAPI 呢？\n\n\u003e **恰恰相反，我很喜欢这个让人耳目一新的框架。**\n\n对于 FastAPI 的一些诟病，大多来自于我本人对 async/await 生态不了解(**也可以理解为老了, 懒得踩坑了**)。以及「**我已经用好了这 flask/django, 没有必要再去为了踩坑新 Web 框架而踩坑**」。\n\n**但这可以说成是「我懒」的问题, 也可以说是「新框架挑战老框架」的问题**\n\n毕竟某种角度上，苹果手机贵不一定是「苹果手机的贵」的问题，也可以说是「我穷」的问题。如果不能飞花摘叶, 那便老老实实玄铁重剑.\n\n当我要做一个纯业务的系统，我的目标是快速上线验证市场。在这个阶段其实 gevent+flask/django 的性能是完全足够的。性能不足，扩容来凑。\n\n在 gevent + flask/django 这种既有成熟解决方案的面前，FastAPI 的一些优点并没有解决我的痛点。\n\nfastapi 实实在在解决了我的痛点的，是对 websocket 良好的支持。 如果我要写系统是聊天室系统，比如弹幕系统，比如实时协作。fastapi 应该是目前为止最好的解决方案了(相比 django channel/gevent)\n\n\u003e **总而言之 如果我的下一个系统没有历史负担, 需要的是并发数+Python, 而不是狂怼业务, 接各种 SDK, 那么 FastAPI 就是我的首选.**\n\n## 关于脚手架\n\n我在踩坑 fastapi 的过程中封装了一套极简脚手架。\n\n1.  FastAPI + Python 3.9 + poetry + Makefile\n2.  tortoise-orm + tortoise-migration\n3.  自带 shell plus (如下图)\n\nhttps://link.zhihu.com/?target=https%3A//github.com/twocucao/tifa\n"}],"total":1},{"name":"2020-12","posts":[{"tags":["业务系统"],"path":"20201222_BusinessLogic.md","title":"业务系统的一些碎碎念","slug":"业务系统的一些碎碎念","date":"2020-12-22","category":"系统设计","lastMod":"2020-01-01","description":"Odoo","thumbnail":"","content":"\n# 业务系统的一些碎碎念\n\n## 0x00 前言\n\n## 0x01 业务逻辑从不讲逻辑\n\n## 0x02 基于字段开发 or 基于业务开发\n\n加字段本质是加业务 加表来加字段\n\n## 0x04 扩展内容\n\n这个时候需要来了一个需求，要统计上报接口错误率和延迟。所有协议的所有实现，都要修改一遍，添加上统计上报的代码。这里包括遍历所有的业务方法，找到 HTTP 调用的地方。\n\n然后又来了一个需求，要对接口进行容错，对故障节点进行自动摘除。然后又要全文遍历一遍。\n\n然后又来了一个需求，因为下游接入了弹性的云服务，不能使用域名进行服务发现，因为端口号会变化。于是又要改一遍所有的地方加上服务发现的代码。\n\n然后又来了一个需求，需要对 RPC 调用进行染色，支持流量镜像等。需要在 RPC 协议中都加入一个 trace id 以及透传的字段，于是所有的 RPC 调用都要改一遍。\n\n我们可以总结出以下规律：\n\n非功能性需求有很强的复用性，不仅是可以独立出来，而且是必须独立出来。 破坏了 consistency，导致的就是重复实现，重复修改 本质上仍然是分工问题，破坏了 autonomy。如果所有的 RPC\n框架都由基础架构负责，稳定性也有基础架构负责。那么可以由基础架构团队一方自主完成所有的工作。\n\n## 0xEE 扩展阅读\n\n- https://github.com/taowen/modularization-examples\n\n---\n\nChangeLog:\n\n- **2020-12-15** 重修文字\n"},{"tags":["开源项目"],"path":"20201215_Odoo.md","title":"Odoo 对于 B 端业务开发的一些启示","slug":"Odoo 对于 B 端业务开发的一些启示","date":"2020-12-15","category":"系统设计","lastMod":"2020-01-01","description":"Odoo","thumbnail":"","content":"\n## 0x00 前言\n\n最近几个月一直在做 B 端的业务开发。\n\n写着写着便想从 Odoo 里面借鉴一些特性。\n\n于是便诞生了本文。\n\n## 0x01 业务逻辑从不讲逻辑开始\n\n众所周知，B 端\n\n\u003e Odoo 如何应对不确定性\n\n## 0x02 基于字段开发 or 基于业务开发\n\n## 0x03 Use Addon to Build App\n\nHotel Management = BizLogic + Pos + Inventory + Invoicing\n\nAppointment = BizLogic + Pos + Inventory + Invoicing\n\n## 0x04 需求理解\n\n- Accounting\n- Marketing\n- Product\n- https://apps.odoo.com/apps/modules/14.0/product_advanced_attribute/\n- Inventory\n- Appointment\n- https://apps.odoo.com/apps/modules/13.0/itlibertas_timesheet/\n- https://apps.odoo.com/apps/modules/13.0/business_appointment/\n- https://apps.odoo.com/apps/modules/12.0/odoo_jewellery_management/\n- CRM\n- 销售追踪\n\n- 网站设计\n  - 小程序设计？\n- 电子商务\n- 调研\n- 预约和排期\n\n## 0x04 扩展内容\n\n## 0xEE 扩展阅读\n\n---\n\nChangeLog:\n\n- **2020-12-15** 重修文字\n"},{"tags":["React"],"path":"20201202_React_Stack.md","title":"我的 React 技术栈","slug":"我的 React 技术栈","date":"2020-12-02","category":"前端开发","lastMod":"2020-12-01","description":"未描述","thumbnail":"","content":"\n# 我的 React 技术栈\n\n## 0x00 前言\n\n16 年 ~ 20 年先后折腾过\n\n1. vue 2\n2. angular 4\n3. react class component\n4. angular 4\n5. react hooks\n6. vue 3\n\n综合考虑了\n\n- 开发工具链\n- 社区生态\n- 跨端方案\n- 与 Typescript 的结合程度\n\n最后形成了较为稳定的 react 技术栈\n\n## 0x01 桌面端\n\nhttps://github.com/twocucao/react-starter\n\n- react hooks\n- typescript\n- mobx\n- css tailwindcss\n- format with prettier\n- lint with eslint\n\n## 0x02 移动端\n\nhttps://github.com/twocucao/react-starter\n\n## 0x03 小程序端\n\nhttps://github.com/twocucao/react-starter-remaxjs\n\nhttps://github.com/twocucao/react-starter-taro\n\n- All Feature Supported By RemaxJS\n- Type Hint - Typescript for better multi-user developing experience\n- style management - tailwind like utils which called minimal.css\n- store management - mobx-react-lite\n- components management - mostly functional components plus react hooks\n- auto lint \u0026\u0026 format by eslint \u0026\u0026 prettier \u0026\u0026 husky\n- optimized only for wechat mini-app\n\n## 0x04 RN\n\n\u003e 无完整上线经历，不做评论\n\n## 0x05 桌面 electron\n\n\u003e 热更新速度很快\n\n---\n\nChangeLog:\n\n- **2020-12-01** 重修文字\n"}],"total":3},{"name":"2020-11","posts":[{"tags":["Golang"],"path":"20201130_ORY.md","title":"开源认证基础服务","slug":"开源认证基础服务","date":"2020-11-30T18:03:01+08:00","category":"开源项目","lastMod":"2020-12-01","description":"未描述","thumbnail":"","content":"\n## 0x00 前言\n\n随着业务的增长，往往需要统一体系内的服务的账户。\n\n经过一番调研，决定尝试一下 ory 的开源认证基础服务\n\n## 0x01 ORY 尝试解决问题？\n\nORY 提供了四个主要项目，每个项目着力于解决一个边界清晰的认证 / 鉴权问题\n\n- ORY Kratos 提供了用户认证服务\n- ORY Hydra 提供了 OAuth 2.0 \u0026 OpenID Connect provider.\n- ORY Keto 提供了 访问控制\n- ORY Oathkeeper 提供了认证访问代理\n\n## 0x02 用户认证服务 Kratos\n\n### 常见方案\n\n1. 方案 1, 选择全栈式解决方案 - 比如 Java 社区的 JGroups\n2. 方案 2, 选择 IDaas - 比如 Login With Apple, Google\n3. 方案 3, 选择自己来 - 比如 Java 社区的 JGroups\n\n三种方案各有利弊\n\n1. 全栈式解决方案上手极快，但\n   - 扩展性不强\n   - 绑定 Java 技术栈\n   - 数据模型固定\n   - 登陆流程固定\n\n- 更新迭代慢\n\n2. Login With Google 虽然方便，但是并没有解决如下的问题\n\n- 更新 Profile\n  - 添加第二个恢复邮箱\n  - 2FA\n  - 存储管理 Sessions\n- 全局登出\n\n3. 自己来，需要处理事情也挺多\n\n- 方案二遇到的问题，一个不会少\n- 加密算法\n  - 流程可能较为复杂，比如先用邮箱注册，然后用 Sign Up Using Google, 或者先用 Sign Up Google, 然后使用邮箱登陆。(PS: 我国的登陆姿势就更多了）\n\n是不是某种方案是最好的呢？其实未必\n\n就我个人经验来说，\n\n- 第一种方案比较适合稳定的，技术栈相同的团队使用。如果对原先应用进行少量裁剪就可以使用，其实未尝不可。\n- 第二种方案如果登陆入口仅是 Login With Google, 并且内网服务数量就几个，也不需要做全局登出，那么其实做起来比较省事。我工作过的一个公司就喜欢这么干。\n- 第三种方案虽然处理的问题看起来比较多，但是社区现有的 Building Block 已经比较多了。如果流程没有特别复杂，一手打造的非常容易往自己的项目发展情况发展。\n\n### Kratos 的方案\n\nKratos 提供了如下的解决方案\n\n- 登陆与注册\n- track sesison/devices\n- MFA/2FA\n- 账户验证\n- 账户恢复\n- Profile \u0026 Account Management\n- 管理后台接口 API\n- 消费 OAuth2 and OpenID Connect\n\n## 0x03 Ory Hydra\n\n\u003e You May Not Need It\n\n- Provider OAuth2 and OpenID Connect via https://github.com/ory/hydra\n\n## 0x03 Ory Keto\n\n权限系统一般放在按照产品需求，最好跟着产品走。而不是随随便便提取出来做一个权限系统。\n\n\u003e You May Not Need It\n\n## 0x04 Ory Oathkeeper\n\n同样，如果你不是有做 zero trust\n\n\u003e You May Not Need It\n"},{"tags":["Shell"],"path":"20201201_Modern_Shell.md","title":"Modern Shell","slug":"Modern Shell","date":"2020-11-30","category":"善用佳软","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x01 更好的替代品\n\n### find -\u003e fd\n\n```bash\n{}: A placeholder token that will be replaced with the path of the search result (documents/images/party.jpg).\n{.}: Like {}, but without the file extension (documents/images/party).\n{/}: A placeholder that will be replaced by the basename of the search result (party.jpg).\n{//}: Uses the parent of the discovered path (documents/images).\n{/.}: Uses the basename, with the extension removed (party).\n```\n\n```bash\n# Convert all jpg files to png files:\nfd -e jpg -x convert {} {.}.png\n\n# Unpack all zip files (if no placeholder is given, the path is appended):\nfd -e zip -x unzip\n\n# Convert all flac files into opus files:\nfd -e flac -x ffmpeg -i {} -c:a libopus {.}.opus\n\n# Count the number of lines in Rust files (the command template can be terminated with ';'):\nfd -x wc -l \\; -e rs\n```\n\n### grep -\u003e ripgrep\n\n### ls -\u003e exa\n\n### cat -\u003e bat\n\n## Dev\n\n### json_pp\n\n### FZF\n\n### Autojump\n\n## Tools\n\n### mycli\n\n### pgcli\n\n### convert\n\n### k9s\n\n### tokei\n\n### git\n\n### FTP\n\n```bash\nFTP Client 提交文件\n#!/bin/bash \nlftp \u003c\u003cSCRIPT\nset ftps:initial-prot \"\"\nset ftp:ssl-force true\nset ftp:ssl-protect-data true\nset ssl:verify-certificate no\nopen \u003cftp://xxx.xxx.xxx.xxx:21\u003e user ftpuser ftppass\nlcd /Users/\u003cusername\u003e/Ftps/Workspace/libs\nput /Users/\u003cusername\u003e/Ftps/Workspace/repos/xxx.jar\nexit SCRIPT\n```\n\n## 0x05 网络\n\n```\ndig ns baidu.com\n\n### 如何查看占用 TCP/UDP 端口\nlsof -i -P -n | grep LISTEN\nnetstat -tulpn | grep LISTEN\nlsof -i:22 ## see a specific port such as 22 ##\nnmap -sTU -O IP-address-Here\n```\n\n## 0x07 文件浏览\n\n## 0x08 多媒体处理\n\n### 图片处理\n\n```\nconvert {{image1.png}} {{image2.png}} {{image3.png}} -delay {{100}} {{animation.gif}}\n```\n\n### 视频处理\n\n```bash\n# 抽取 mp4 中的音频并保存为 mp3\nmkdir outputs\nfor f in *.mp4;\n    do ffmpeg -i \"$f\" -c:a libmp3lame \"outputs/${f%.mp4}.mp3\";\ndone\n```\n\n## 0x09 Tmux\n\n```bash\ntmux new -s you_tmux_name\ntmux ls\ntmux a\ntmux a -t you_tmux_name\nc-b + d\ntmux kill-session -t you_tmux_name\n# 进阶工具 tmuxp\n```\n\n## 0x10 OhMyZsh\n\n```bash\n# https://github.com/ohmyzsh/ohmyzsh\nwget https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh\nsh install.sh\n```\n\n```bash\n# https://github.com/twocucao/dotfiles\nmkdir ~/Cystem\ncd ~/Cystem \u0026\u0026 git clone git@github.com:twocucao/dotfiles.git \u0026\u0026 cd dotfiles\nln -sfv `pwd`/zshrc ~/.zshrc\n```\n\n其他配置\n\n- powerlevel10k\n- autojump\n- zsh-autosuggestions\n- zsh-syntax-highlighting\n- zsh-completions\n- https://github.com/ryanoasis/nerd-fonts\n"},{"tags":["Python","性能优化"],"path":"20201201_PythonProfiling.md","title":"Python Profiling/Tracing Tools","slug":"Python Profiling/Tracing Tools","date":"2020-11-30","category":"Python","lastMod":"2020-12-01","description":"未描述","thumbnail":"","content":"\n- Profiling 定位与优化耗时、内存使用、CPU 使用\n- Tracing 用于追踪内存布局\n\n## 0x00 前言\n\n本篇讨论的是优化\n\n当我们在谈优化的的时候，首先要背诵下面三个口诀\n\n    优化口诀 1: 先做对，布监控，再做好。\n    优化口诀 2: 过早优化是万恶之源。\n    优化口诀 3: 去优化那些需要优化的地方。\n\n可以参考之前的文章 https://zhuanlan.zhihu.com/p/58754459\n\n本文讨论的是基于现有代码的诊断。也顺带讨论了无侵入线上 trace 的原理和技巧\n\n优化分为两种：\n\n1. 侵入性诊断\n2. 侵入性诊断\n\n## 0x01 侵入性诊断\n\n### 基础工具\n\n- print\n- logging\n- timeit\n\n### Profile vs cProfile\n\ncProfile overhead 较高，\n\n```python\nimport cProfile\nimport re\ncProfile.run('re.compile(\"foo|bar\")')\n\n   197 function calls (192 primitive calls) in 0.002 seconds\n\nOrdered by: standard name\n\nncalls  tottime  percall  cumtime  percall filename:lineno(function)\n     1    0.000    0.000    0.001    0.001 \u003cstring\u003e:1(\u003cmodule\u003e)\n     1    0.000    0.000    0.001    0.001 re.py:212(compile)\n     1    0.000    0.000    0.001    0.001 re.py:268(_compile)\n     1    0.000    0.000    0.000    0.000 sre_compile.py:172(_compile_charset)\n     1    0.000    0.000    0.000    0.000 sre_compile.py:201(_optimize_charset)\n     4    0.000    0.000    0.000    0.000 sre_compile.py:25(_identityfunction)\n   3/1    0.000    0.000    0.000    0.000 sre_compile.py:33(_compile)\n```\n\n### SpeedScope\n\n- speedscope\n- pyspeedscope\n\n### PyInstrument\n\n- https://github.com/joerick/pyinstrument\n- https://github.com/joerick/pyinstrument_cext\n\n### Line Profiler\n\nhttps://github.com/pyutils/line_profiler\n\n```bash\nPystone(1.1) time for 50000 passes = 2.48\nThis machine benchmarks at 20161.3 pystones/second\nWrote profile results to pystone.py.lprof\nTimer unit: 1e-06 s\n\nFile: pystone.py\nFunction: Proc2 at line 149\nTotal time: 0.606656 s\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents\n==============================================================\n   149                                           @profile\n   150                                           def Proc2(IntParIO):\n   151     50000        82003      1.6     13.5      IntLoc = IntParIO + 10\n   152     50000        63162      1.3     10.4      while 1:\n   153     50000        69065      1.4     11.4          if Char1Glob == 'A':\n   154     50000        66354      1.3     10.9              IntLoc = IntLoc - 1\n   155     50000        67263      1.3     11.1              IntParIO = IntLoc - IntGlob\n   156     50000        65494      1.3     10.8              EnumLoc = Ident1\n   157     50000        68001      1.4     11.2          if EnumLoc == Ident1:\n   158     50000        63739      1.3     10.5              break\n   159     50000        61575      1.2     10.1      return IntParIO\n```\n\n### 其他侵入性 Profiling 方案\n\n- https://github.com/vmprof/vmprof-python\n- https://github.com/bdarnell/plop\n\n### Overhead 基数\n\nDjango template render × 4000\n\n- Base 0.33s\n- pyinstrument 0.43s 30%\n- cProfile 0.61s 84%\n- profile 6.79s 2057%\n\n### 内存布局\n\n- memory profiler 检查内存消耗\n- pympler 快照未 GC 的对象\n\n\u003e TODO: python 有无侵入检查内存布局的工具么？\n\n## 0x02 无侵入诊断\n\n以上的代码都是侵入代码，Java 生态中存在着一些黑科技。可以在线打断点。\n\nhttps://github.com/qunarcorp/bistoury/blob/master/docs/cn/debug.md\n\n从而实现无侵入在线 tracing 代码，可以理解为一个无需 reload 代码即可实现的热插拔 logging\n\nPython 世界里存在 2 个这样的工具\n\n### pyflame\n\n- https://github.com/uber-archive/pyflame\n\n原理\n\n- https://man7.org/linux/man-pages/man2/ptrace.2.html\n\n### py-spy\n\n- https://github.com/benfred/py-spy\n\n直接读取 python 程序的内存信息\n\n- Linux https://man7.org/linux/man-pages/man2/process_vm_readv.2.html\n- macOS https://developer.apple.com/documentation/kernel/1585350-vm_read?language=objc\n- Windows https://msdn.microsoft.com/en-us/library/windows/desktop/ms680553(v=vs.85).aspx\n\n## 0x03 其他利器\n\n### Django Debug Toolbar\n"}],"total":3},{"name":"2019-09","posts":[{"tags":["Python","系列文章"],"path":"20190924_PyCode_08.md","title":"如何写出整洁的 Python 代码 下","slug":"如何写出整洁的 Python 代码 下","date":"2019-09-24","category":"Python 项目代码健壮性和性能","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n**本文是《提升你的 Python 项目代码健壮性和性能》系列的第八篇文章。**\n\n本文是《整洁下篇》，本文的诞生，要感谢我前公司的技术主管豪蔚老师和产品主管刚哥，在上海工作这几年，总是和能优秀的人工作，确实是我幸运的地方。\n\n这篇文章憋了很久，思考了许久，《整洁下篇》干脆就聊聊编程中，不是写代码的部分；\n\n如果说，写代码是硬技能，那么本期就是来聊软技能的。更确切的说，是复盘几年的工作经验中，我发现的一些有趣的，影响效率的事情以及我的解决方案。\n\n\u003e 凡用兵之法，全国为上，破国次之；全军为上，破军次之；全旅为上，破旅次之；全卒为上，破卒次之；全伍为上，破伍次之。是故百战百胜，非善之善者也；不战而屈人之兵，善之善者也。 --- 《孙子兵法·谋攻篇》\n\n什么叫做有效率，不战而屈人之兵，善之善者也。\n\n\u003e **最整洁的代码，是少写代码，甚至不写代码。**\n\n如何做到？\n\n几年的工作经验下来，我发现我**处理的往往不是技术问题，而是大量的非技术性问题以及伴随着非技术问题带来的成倍的技术问题**。\n\n1.  **因需求的变化的返工。**\n2.  **因追求完美而为了不必要优化的地方而优化。**\n3.  **因沟通不到位导致的加班加点。**\n4.  **因缺乏单元测试导致的重构没有底气，甚至懒得重构。**\n5.  **因缺乏话语权导致的被动开发。**\n6.  **因考虑不周到而导致的硬着头皮加班。**\n7.  **因命名不够规范，代码可维护性低下，导致后面定位问题的时间指数性上升。**\n\n应然如此？实然如此！\n\n## 0x01 处理需求的姿势\n\n以前呢，我自以为编程水平还算不错，撸起代码来像是一道春天的闪电。但时间长了，发现技术行，但总体产出不高效。为什么呢？\n\n比如有如下的问题：\n\n- 问题一：战术上很勤奋，一个需求过来，我的第一反应是把这个功能『通过系统』做出来。\n- 问题二：没有深入和产品运营沟通，于是后期被动的应对需求的变动\n- 问题三：没有三思而行，做项目没有计划性，想到哪里做到哪里。\n- 问题一的结果：这导致了很多时候，把这个功能『通过系统』做出来了，但是其实是个伪需求。或者，是个没必要做到系统里面的需求。\n- 问题二的结果：导致了一些过度设计或者过于粗糙的设计。最后忙于返工，以及各种数据迁移和逻辑修改\n- 问题三的结果：没有做好足够的规划，『码在当下』, 没有前瞻性。\n\n\u003e 速度再快，也要返工，唯一不变的就是变化本身。\n\n我想了很久，才意识到，很多时候，产品在传递需求的时候是存在很多的信息损失的。\n\n背后的原因，可能来源于产品的态度和能力上，可能是产品的上一级需求传递过来的问题，也可能是团队对待产品以及自己的错误的态度上。\n\n经验告诉我，作为对项目负责的程序员千万不要跟着产品经理的思路走。\n\n如果是新功能，一定要就要展开一番对话。\n\n1.  问清楚为什么要做这个需求 / 变动，藏在后面的思路是什么。对于用户、对于产品有什么价值。\n2.  和产品经理互杠，用户的具体使用场景是什么。\n3.  看看是不是一定要放在系统里面解决。如果放在系统里面解决，那么应该怎么做。让产品方给出一个粗糙的方案。\n4.  化简这个方案后再次和产品互杠。\n5.  确定方案后分解安排任务。\n6.  任务上线之后如何确定这个功能是有效果的。\n\n还记得上面的话么？不战而屈人之兵。\n\n要做的需求，如果产品经理不能简单清晰的描述，做出来一定是一坨。\n\n作为合格的工程师，则是必须要将不清晰、不合理的、拍脑袋的需求拒掉。所谓上梁不正下梁歪，出题人的思路是混乱的，解答者的思路肯定不会清晰到哪里去。\n\n当然，这也存在一些例外的情况，如果你到了一个工作地方，没什么话语权，认真推进事情发展也没什么暖用的地方的话，好好反思一下自己为什么在这种地方干活，然后认真修炼自己。\n\n早些年，我还以为有时间不够的情况，后来也逐渐明白，没有开发不了的任务，**程序写到后面都是妥协，无非就多快好省的妥协**\n\n- 多 - 功能的数量和完成度\n- 快 - 完工时间\n- 好 - 软件最终质量，满意程度\n- 省 - 成本，花多少个人力和精力\n\n鱼和熊掌不能得兼\n\n- **如果产品说『反正下周要上线』, 你砍不了『快』，就砍『好』和『省』。**\n- **如果产品说『我要加需求』, 你砍不了『多』, 那就砍『快』和『省』**\n\n如何去做这些妥协，则是工程师的内力。\n\n还有，如果工程师本身不得势，也没有啥话语权，也就没办法推进你的产品了。\n\n**砍需求不是坏事情，树苗不也还是要经常剪去多余的枝桠来防止过度吸收养分。**\n\n## 0x02 敏捷开发\n\n国内的敏捷开发一般也称为『怎么方便怎么来的作坊式开发』\n\n### 看板和晨会\n\n一般会采用以下的做法来敏捷一些\n\n1.  使用看板来管理任务。看板上的卡片无非就是放在『需求确认』,『正在开发』,『正在测试』,『已发布』里面。\n2.  晨会，轮流发言讲解进度。\n\n任务的安排往往要细分到方便追踪。\n\n举例来说，如果是简单版本的『支付商城』的功能，则会有\n\n1.  支付模块\n2.  商品模块\n3.  订单模块\n4.  物流模块\n\n但是，商品模块和订单模块要和前后端交互，假设后端叫做小后，前端叫做小前，H5 端和 Admin 端的统一模块不是同一时间段完成的。\n\n如果放在一起的话，则会难以追踪。**会出现这个卡片属于『正在开发』或者『正在测试』的薛定谔状态。**\n\n于是这么细化会更加合理一些\n\n1.  支付模块\n2.  商品模块 - Admin\n3.  商品模块 - H5\n4.  订单模块 - Admin\n5.  订单模块 - H5\n\n如果是大一点的系统，则需要划分的更细致。务必不要出现薛定谔的状态卡片。\n\n一般如果看板划分的详细的话，晨会就很轻松了。\n\n### 敏捷的时间安排：周一到周五\n\n- 周一：**一周的开始，就应该发布新版本，选择这个时间段是因为团队都在一起，出问题可以及时修复。**\n- 周二 / 周三：复盘以下迭代过程中出现的一些问题。同时进行本周任务的开发。\n- 周四：产品负责人与技术负责人等相关人员规划下周的任务，并且过一遍需求评审。\n- 周五：在预发布环境完成本周功能的测试。留待下周进行正式版本的发布。\n\n### 人员安排\n\n《人月神话》这本书里面有一个观点，\n\n\u003e **需要写作沟通的人员数量影响着开发成本，人数越多，沟通和交流次数越多，更正沟通不当所引起的不良结果也就越多。**\n\n对此，我的解决方案是：\n\n1.  减少人数。做业务的人选择全栈，从前端到后端负责。这样即便是前后端分离之后，也不会有扯皮的情况。\n2.  做基础架构的选择专才。\n3.  精英制度。点子最好都由几个立场上需要对产品负责的人来想。如果异想天开的人和做\n    事的人不是同一个人，则往往就很麻烦。当然，也需要给予推进产品的人一定的鼓励。\n\n## 0x03 代码全局观\n\n我遇到过的代码问题大致分为两类\n\n1.  给你的变量，函数，模块，类等等起个好名字的问题。\n2.  理解本质复杂度（Essential Complexity）和偶然复杂度（Accident Complexity）的问题。\n\n### 起个好名字\n\n对于工程师来说，第一点非常非常重要。\n\n因为，这需要你非常理解业务逻辑并且在某个上下文中用准确的变量名来命名。代码是写给\n人看的，顺带着能在机器上运行。并且，尽量跟着业务来命名 （参考 DDD\\)，这点也就不再赘述了。\n\n当然，其实这也是整洁前两篇讲的东西，也就不再赘述了。\n\n### 本质复杂度和偶然复杂度\n\n第二点，这是师从我的技术主管豪蔚老师之后获取的最大经验。\n\n- **本质复杂度，就是不管你怎么搞，A 点到 B 点，没有捷径可走的，该踩的坑一个都逃不了。**\n- **偶然复杂度，就是 A 点到 B 点，命名走几步就到了，但偏偏走了不少弯路。**\n\n写程序之前，**务必要做到尽可能的规避掉偶然复杂度**。\n\n\u003e **Less Is More**\n\n## 0xEE 后记\n\n本文简单说了一些我知道的可以规避掉成吨的技术问题的一些非技术性技巧，本文还是不够全面，比如就没有介绍自动化的工具，没有介绍 CI, 没有用实例介绍怎么应对产品经理的不合理要求，这些就留待以后吧\n\n本想着，《整洁下》的这篇可以多写点编程技巧上的东西的。但想了半天，还是选择了从软技能方面入手。**与其说是为了写好代码，倒不如说是为了好写代码。**\n\n所谓**汝果欲学诗，工夫在诗外。**写代码之外的活，其实很重要。\n\n---\n\nChangeLog:\n\n- **2019-09-24** 重修文字\n\nPhoto by [Larm Rmah](https://link.zhihu.com/?target=https%3A//unsplash.com/%40larm%3Futm_source%3Dunsplash%26utm_medium%3Dreferral%26utm_content%3DcreditCopyText) on [Unsplash](https://link.zhihu.com/?target=https%3A//unsplash.com/s/photos/girl%3Futm_source%3Dunsplash%26utm_medium%3Dreferral%26utm_content%3DcreditCopyText)\n"}],"total":1},{"name":"2019-05","posts":[{"tags":["Python","系列文章"],"path":"20190526_PyCode_07.md","title":"如何写出整洁的 Python 代码 中","slug":"如何写出整洁的 Python 代码 中","date":"2019-05-26","category":"Python 项目代码健壮性和性能","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n本文是《提升你的 Python 项目代码健壮性和性能》系列的第七篇文章。\n\n上篇《如何写出整洁的代码 上》 从变量命名 / 函数 / 注释整洁 / 格式整洁上写出干净的代码\n\nhttps://zhuanlan.zhihu.com/p/59510165\n\n本文还是通过代码上的一些小技巧和一些原则来让代码更加整齐。\n\n## 0x01 避免过深的缩进\n\n场景，你在做一个 B2B2C 的商城系统。商家的活动需要在某些比较严格的条件下才能参与（假设有五个字段吧）。\n\n如果不动手捋一捋判断的路径，上来就动手写代码，则很容易写出如下的代码。\n\n```python\nif cond1:\n\tdosomething()\n\tif cond2:\n\t\tdosomething()\n\t\tif cond3 and cond4:\n\t\t\tdosomething()\n\t\t\telse:\n\t\t\t\tdosomething()\n\t\t\tif condx:\n\t\t\tdosomething()\nelse:\n\tif cond2:\n\t\tdosomething()\n\t\tif cond3 and cond4:\n\t\t\tdosomething()\n\t\t\tif condx:\n\t\t\tdosomething()\n\n```\n\n想想你这个时候才判断了 5 个字段... 如果想都不想就开始写这种代码的话，就做好修改的时候崩溃吧。\n\n当你写出 if 超过两层缩进的时候，代码的复杂度就值得注意了。\n\n这个时候，应该火速的拿出纸和笔出来，快速的捋一捋所有的变量和情况，\n\n『以减少缩进为目标』\n\n能提前判断掉的就提前判断掉\n\n```python\n# 能提前判断掉的就提前判断掉\nif cond2:\n\traise AlreadPaid():\nif cond3:\n\traise ActivityExhaused():\nif cond4:\n\traise ActivityCancel():\n```\n\n代码的缩进越浅，代表着代码越容易维护，用学长的话说，老手才知道『九浅一深』的奥妙......\n\n## 0x02 使用异常\n\n使用异常而不是状态码，这点重点点名一下 Go 语言的状态码....\n\n遇到异常返回状态码写业务的话，很容易抓狂。如果你在深层抛出一个错误，使用状态码的话，必须一层一层的返回状态码。\n\n1. 遇到问题，抛出异常，raise ApiException 。就可以在上层捕获错误进行处理。这样的\n   话，就没有必要每次都在函数签名上返回状态码了。\n2. 让代码更佳清晰的是 try except finally 机制。try 块定义了一个范围，try 中的结果可以看执行中有没有遇到一些奇奇怪怪的情况，然后把 try 块里面的东西取消掉。甚至抛出一个错误，丢到 catch 里面执行。这种接近于事务的做法是状态码机制没法比的。\n\n拿第一小节的代码来说，可以在最深层抛出异常，然后在最外面统一处理异常，有些异常可能只是报 apiexception, 有的异常可能还要针对情况打日志，或者有的情况是你在写代码的时候没有考虑到的情况，都可以进行各种灵活的处理。\n\n这样的话，代码就非常的清晰了。\n\n## 0x03 类与 OOP\n\n注意！\n\n1. OOP 语言让封装 / 继承 / 多态更佳方便快捷安全。\n2. 封装 / 多态 / 继承 并不是 OOP 对象的专利，实际上利用指针 C 也可以写出来具备封装 / 继承 / 多态的程序。只是相对危险一些罢了。\n\n比如，你有这么个场景，计算购物车里面东西的价格：\n\n1. 面向过程思考方式，用户我选了一些商品，然后把商品放到购物车里，然后我算一下物品价格。\n2. OOP 思考方式，用户我需要一个购物车，帮我把这些物品放到购物车里面，购物车告诉我价格。这个时候，你封装一个购物车类会比较合适。\n\n你这个时候就问了，这不就是一个 calcPrice(cart) 和 cart.calcPrice 的区别么？\n\n区别在哪？\n\n1. 『真实世界建模』购物车的是一个对真实世界的建模。\n2. 『职责转移』。计算价格这件事情就是『购物车』这个 Object 的事情了。\n3. 封装性：我不需要维护一个物品集合。都交给购物车来做这件事情。\n\n什么情况下需要类，用 OOP 的方式思考是合理的，明显的，清晰的，就可以了。\n\n当然，采用了 OOP, 可以更快的结合继承 / 多态来完成『依赖反转』。\n\n这个名词听起来不明觉厉，但其实很简单。\n\n```python\n# base.py\nclass Human:\n\tdef perform(self):\n\t\tpass\n\n# foo/man.py\nclass Man(Human):\n\tdef perform(self):\n\t\tprint(\"大哥，真不会唱歌\")\n\n# bar/woman.py\nclass Woman(Human):\n\tdef perform(self):\n\t\tprint(\"大哥，真不会跳舞\")\n```\n\n如果老大哥让你跳舞，就必须要把你的代码给 import 到老大哥的源代码里面。\n\n```python\n# bar/bigbother.py\nfrom foo.man import man_instance\nfrom bar.woman import woman_instance\n\nman_instance.perform()\nwoman_instance.perform()\n\n```\n\n这样会带来一个问题，产生了源代码上面的依赖。这样带来结果是老大哥依赖于几个具体 man 和 woman, 这是不合理的，应该是铁打的老大哥，流水的 man 和 woman\n\n```python\n# 源码不依赖 bigbother.py\n\ndef order_perform(h):\n\th.perform()\n\nhumans = scan_humans()\n\nfor human in humans:\n\torder_perform(human)\n\n```\n\n利用多态，则将这个问题完美的解决了。当然，考虑到动态语言，本身就可以很『多态』.... 你甚至\n都不需要继承了...\n\n策略层与实现完美分离。甚至可以分开进行独立部署。\n\n结论：\n\n1. 对真实世界的建模\n2. 代码清晰为主，如果能用简单函数解决的事情，就不要封装成类。\n3. 以多态为手段对源代码中的依赖关系进行控制的能力。借此，可以构建\n   出插件式架构，让高层策略性组件和底层实现性组件分离。底层实现可以编译成插件，实\n   现独立于高层组件的开发和部署。\n\n## 0x04 SOLID 设计原则\n\n- SRP 单一职责 原则\n- OCP 开闭原则\n- LSP 里式替换原则\n- ISP 接口隔离原则\n- DIP 依赖反转原则\n\n原则是原则，是追求，是启迪思路的思想，但也要随机应变。\n\n1. 假如你不了解业务，强行用依赖反转原则写了抽象层，后面 PM 过来说，我有这么一个思路。那么，你的代码写起来就很痛苦了。\n2. 假如你不了解场景，在使用单一职责的时候，往往就会业务区分不明确。\n\n在现实场景中，往往是先保持足够的清晰简单的代码，随着代码的演进，用上面的原则再次思\n考一下可不可以做的更好。\n\n### 单一职责\n\n比如说，单一职责原则听起来很简单，一个函数只完成一个功能（事情）。\n\n但现实情况是这种往往只是一个追求，站在不同的角度有不同的看法：\n\n比如说，\n\n1. 你说，你今天想学习。这是一件事情。\n2. 你说，你今天上午想学习数学。这是一件事情。\n3. 你说，你今天上午想学习高数第三章，接着做完笔记，回头抽卡默背一遍公式。这是三\n   件事情，并且也可以是一件事情。\n\n你的拆分粒度决定了一件事情的指代范围。\n\n### 开闭原则\n\n开闭原则强调的事情是计算机系统应该在不需要修改的前提下被扩展。将系统划分为一系列组件，并且将这些组件的依赖关系按照层次结构进行组织，使得高阶组件不会因为低阶组件被修改而受到影响\n\n### 里氏替换原则\n\n在不改变软件行为的基础上，衍生类可以替换掉基类\n\n### 接口隔离原则\n\n任何层次的软件设计如果依赖了它并不需要的东西的时候，就会带来意料之外的麻烦。\n\n### 依赖反转原则\n\n什么叫做依赖反转？\n\n依赖反转就是设计软件的时候设计稳定的抽象层。针对抽象的东西编程。\n\n## 0x05 边界和第三方库的挑选\n\n在软件包膨胀的今天，应该如何挑选第三方库呢？\n\n我给出几个挑选的原则。\n\n1. 靠谱依赖原则：如果 flask 是靠谱的，那么，flask 依赖的 click 包，werkzeuk 包一定是靠谱的。\n2. 浓缩精华原则：如果一个库依赖少，代码清晰简单，那么可以采用。\n3. 活跃维护原则：如果维护很活跃，证明前景相对较好。\n4. 多人维护原则：如果是多人维护，则不会因一个人的喜好和个人状态而断了维护。别问我怎么知道的，都是泪\n\n挑选有这个原则，那么，使用有什么原则么？\n\n就一条，尽量减少依赖库对你现有代码的侵入性。\n\n比如，你用了 cryptography 之后，应该封装一个接口用来调用 cryptography 防止以后这个项目挂了，这样你可以只修改该接口，和 pycrypto 对接。\n\n这和里氏替换的思路也是比较类似的\n\n## 0xDD 结论\n\n\u003e 所谓『不能谋万世者不能谋一时，不能谋全局者不能谋一隅』\n\n在软件开发中，其实最重要的过程是梳理流程，流程梳理的足够清楚，代码就足够简单。\n\n不管是避免深缩进，还是使用异常，还是 Solid 原则。都是建立在全局观足够高，对当前的流程非常熟悉的基础上的。\n\n当然，考虑到需求变更的不确定性，代码还是足够简单清晰为上策。\n\n## 0xEE 参考\n\n- 《架构整洁之道》\n- 《代码整洁之道》\n- Photo by Joseph Kellner on Unsplash\n"},{"tags":["Python","系列文章"],"path":"20190525_PyCode_06.md","title":"如何写出整洁的 Python 代码 上","slug":"如何写出整洁的 Python 代码 上","date":"2019-05-25","category":"Python 项目代码健壮性和性能","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n本文是《提升你的 Python 项目代码健壮性和性能》系列的第六篇文章。\n\n接下来的三篇，围绕另一个主题\n\n\u003e 如何写出整洁的代码\n\n『整洁』三篇是基于**『代码整洁之道』和『架构整洁之道』**的一些切身的理解和体会。\n\n感谢这两本书的作者 Bob 大叔。\n\n\u003e PPS: 某东读书 VIP 会员有不少 IT 资源类的书籍可以免费看，比如『代码整洁之道』\n\n## 0x00 前言\n\n### 软件系统的腐败之路\n\n随着项目代码行数的增加，不可避免的遇到软件架构腐败的问题。\n\n具体表现为：**随着每一次产品版本的发布，对现有流程进行优化和修改就格外的费事和吃力。工程师的生产力就开始直线下降。**\n\n![](https://pic2.zhimg.com/v2-8c681642ce7e6a9230ce7f45d3e92cf5_b.jpg)\n\n所谓\n\n\u003e **眼看他起朱楼，眼看他宴宾客，眼看他楼塌了。 清 孔尚任《桃花扇》**\n\n## 0x01 讨论\n\n### 为什么会出现腐败的系统\n\n原因可能是多方面的，比如常见的场景：\n\n```bash\n步骤 1. 领域建模的人对业务里概念的理解不到位，流程不深入了解。\n步骤 2. 工程师在实现的时候，按照自己的理解，没有梳理整个流程。就开始动手实现。并且全程人肉测试。\n步骤 3. 需求变动，流程更改。\n```\n\n**第一步容易埋下坑点：**\n\n1.  对『该领域』理解的不到位，导致『流程』就不清晰，也导致原型设计等同于 Axure 画的『表单』。\n2.  『关键概念』没有解释，『关键字段』没有解释，也没有『流程图』，也没有关于业务主体『状态图』，前后端面向表单开发。\\(Form Oriented Programming\\)\n\n接着，领域理解不到位就会带来另一个问题。\n\n1.  对于需要『建模的实施者』一般是后端工程师，将花费比较多的时间来梳理流程。\n2.  前后端代码结构不清晰。比如，前端页面的路由命名不清晰，Page 组件命名不清晰，请求 API 接口不清晰。比如，后端路由命名不清晰，view func 不清晰，serializer 不清晰，table 命名不清晰。\n\n经验老道的程序员会通过一些手段，比如让这些命名不清晰的东西统一一下，然后等概念清晰了。再改回来。\n\n**第二步容易埋下坑点：**\n\n1.  全程口头对需求，『没有文档』落下来，产品之间和开发之间**『缺乏共通的文档理解指南』**。\n\n当更改已有流程或者是出问题的时候，除了一脸懵逼就还剩下甩锅了。\n\n**第三步容易继续在坑里埋坑：**\n\n**资本市场里，树欲静而风不止，想重构而时不我待。**\n\n1.  领域建模的产品经理会继续叠加新的功能，至于是否已经牵扯到了已有功能，最多和工程师口头说明一下，是不会考虑落实到具体文档里面的。\n2.  工程师需要不断的去满足需求，而疯狂叠加代码。不但要搬砖，而且要快速的把方螺丝强行拧到圆螺母里面。\n\n**最后，**\n\n\u003e **屠龙少年变成了恶龙，而产品和工程师们经过不懈努力，终于堆出了『代码屎山』-- 腐败系统**\n\n### 衡量系统的两个指标\n\n腐败系统有一句成语可以概括，叫做**金玉其外，败絮其中。**\n\n什么是外，什么是中？\n\n- **所谓外，就是软件的行为价值 -- 软件系统的行为是否正常运行，是否满足需求**\n- **所谓内，就是软件的架构价值 -- 软件系统的架构是否清晰，是否灵活，是否可维护**\n\n看起来有点抽象，打个比方就清晰多了。\n\n所谓软件系统，可以比作是人。\n\n- 所谓外，就是人的能力 -- 即革命的本事。\n- 所谓内，就是人的健康 -- 即革命的本钱。\n\n身体是革命的本钱，所以，要经常锻炼身体。同理可知系统也是如此。\n\n业务方和管理层仅在意软件系统的外在。\n\n优秀的软件工程师，做的就是平衡这两者。必要的时候，需要和业务方以及管理层进行沟通。\n\n### 代码是写出来的吗？\n\n不一定。\n\n假如你是做业务逻辑的。\n\n首先，好代码可能是聊出来的。\n\n比如需求确认这一块，多问多画流程图少动手。就可以减少后期很多麻烦事情。\n如果在没有理解透需求的情况下动了手，就会做得越多，错的越多。我相信很多工程师都有\n这种感觉。\n\n当然，这是基本上不怎么可控的外部条件。所以，不在本文的讨论范围之内。\n\n其次，好代码可能是边读边写出来的。\n\n回顾一下一天的工作，你会发现，不管是，你写文章，或者是做一些其他的东西。\n\n1.  **读代码，大部分都是跳转代码，文件内跳转，文件外跳转，分屏浏览。**\n2.  **在这个过程中不断整理和梳理原有的概念。最后落实到代码上。**\n3.  **代码的直接修改。占到你很少的时间。**\n\n最后，好代码是改出来的。\n\n### 好代码的标准\n\n我们只讨论如何保持代码的清晰整洁\n\n\u003e 什么是好的代码？\n\n引用 C++ 创始人的说法，我喜欢优雅而高效的代码，\n\n1.  **代码逻辑应该直截了当，叫缺陷难以隐藏；**\n2.  **尽量减少依赖关系，使之便于维护；**\n3.  **依据某种分层战略完善错误处理代码；**\n4.  **性能调至最优，省的引诱别人做没规矩的优化。**\n5.  **整洁的代码只做好一件事情。**\n\n其实还有一些保证代码整洁的手段：\n\n\u003e 比如本系列的文章讲解\n\n## 0x02 变量命名之道\n\n\u003e **名不正，则言不顺；言不顺，则事不成。事不成，则礼乐不兴；**\n\n写代码就是这样。\n\n### 使用业务领域命名\n\n对于具体业务而言，**起不好名字有一半的锅都是产品经理的锅，因为这是概念认知不清晰的表现。**不要小看这一点，产品经理对项目的理解不到位会在编写代码的过程中被放大。\n\n遇到这种情况，务必要把产品经理拉过来认认真真的扯扯犊子。\n\n### 代码命名\n\n对于实际代码而言，\n\n- 涉及到具体业务名称，起不好名字就是程序员的锅，因为这是跟着产品经理犯傻，继续坚持概念认知不清晰的表现。\n- 涉及到非业务的名称，务必要统一，比如 Button 就是 Button, 如果团队统一叫做 Btn 那就统一叫做 Btn.\n\n\u003e 务必不要用单字母命名，取名字要准确，如无必要，也尽量规避掉缩写。\n\n```python\n# 差\nd = Column # 消逝的时间\n\n# 好\nelapsedTimeInDays\ndaysSinceCreation\ndaysSinceModification\nfileAgeInDays\n```\n\n- 一个单词一个意思，假设你需要往 group 里面添加 member, 那么出现 add/insert/append 三个词的意义就应该完全不一致。\n\n\u003e 不要做无意义的区分\n\n```python\nfetchAccountList 就不如 fetchAccounts\nfetchAccountRecord / fetchAccountInfo / fetchAccountData 就不如 fetchAccount\n```\n\n\u003e 变量是名词，路由是名词，方法是动宾结构。\n\n**即便是名字起的不好，也应该很统一。**\n\n## 0x03 函数整洁之道\n\n### 短小精悍\n\n每个函数都要做到短小精悍\n\n1.  短小\n2.  只做一件事（无副作用）\n3.  一个函数一个抽象层级\n\n### 调用层次清晰\n\n不同抽象层级\n\n```python\ndef 日常 ():\n\t用 XX 点外卖 ()\n\t去厨房拿筷子 ()\n\t等小哥送来外卖 ()\n\n\t睡觉 ()\n\t打豆豆 ()\n```\n\n为什么是不同抽象层级呢？ 点外卖不一定是日常。可能自己偶尔也会做饭。\n\n并且，从业务角度来说，吃饭，睡觉，打豆豆比较符合业务人员的认知。\n\n同一抽象层级\n\n```python\ndef 点外卖吃饭 ():\n\t用 XX 点外卖 ()\n\t去厨房拿筷子 ()\n\t等小哥送来外卖 ()\n\ndef 吃饭 ()\n\tif 今天比较懒：\n\t\t点外卖吃饭 ()\n\ndef 日常 ():\n\t吃饭 ()\n\t睡觉 ()\n\t打豆豆 ()\n```\n\n这样写出来的函数，比较符合自顶向下的阅读方式。\n\n### 控制参数\n\n参数尽量不要超过三个。\n\n因为超过三个之后，就很难用几个单词把这个方法的意义给概括出来。\n\n如果超过三个，这就需要谨慎的考虑将其中的一部分参数是封装为结构体或者是类。\n\n### 如何写函数\n\n1.  不要为了炫技而炫技。\n2.  先写对函数。\n3.  然后打磨函数，即修改名称，消除重复，适当重构\n\n## 0x04 注释整洁之道\n\n1.  注释不能美化糟糕的代码。\n2.  适当解释意图。有的时候 hardcode 却是最好的解决方案。\n3.  能用变量名 / 方法名 / 函数名表达清楚的，就不要讲废话。\n\n## 0x05 格式整洁之道\n\n### 排版整齐\n\n代码一定要排版整齐\n\n- 缩进\n- 每行最大字符串数？\n- 字符串选择单引号还是双引号？\n- 团队协作 diff 同一段代码的时候还是 diff 出来不同的效果。\n\n反正是我记不住 pep8 里面要求的那些标准的。当然，flake8 为你提供了比较好的 lint 标准。\n\n在这里推荐两个工具：\n\n1.  flake8\n2.  black [https://github.com/ambv/black](https://link.zhihu.com/?target=https%3A//github.com/ambv/black)\n\n至于 black, 是类似于 javascript 圈里面的 prettier 的存在。\n\n在每次 commit 的时候，执行 flake8 和 black, 让你的代码整整齐齐。\n\n### 上下文相关\n\n1.  如果我使用了一个方法，如果不是从其他文件里使用，一般会在我编写的代码块的上方不远处。\n2.  如果我使用了一个变量，应该只在起到作用的作用域里。\n3.  如果我针对一个概念编写方法，那么在这个文件里，相关概念的代码应该是放在一起的。\n\n## 0xEE 参考连接\n\n- 《代码整洁之道》\n- 《架构整洁之道》\n"}],"total":2},{"name":"2019-04","posts":[{"tags":["Python","ORM","SQLAlchemy"],"path":"20190412_PythonORM.md","title":"Python ORM","slug":"Python ORM","date":"2019-04-12","category":"Python","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\nPython 圈内三大 ORM SQLAlchemy VS Django ORM VS Peewee\n\n1. SQLAlchemy 复杂程度最高，同时，这也意味着 SQLAlchemy 可以做更多的事情。使用 DataMapper 方式实现\n2. Django ORM 个人最喜欢，使用 ActiveRecord 实现 如果不是因为现在 Flask 项目已经是用了 SQLAlchemy , 否则的话我甚至会考虑将 Django ORM 配置到 Flask 项目中。当然，也有蛋疼的 SqlAlchemy 使用者已经移植给 django 配置了 SQLAlchemy 的库。\n3. Peewee 没用过，不好评论。以后有机会试试。\n\n## 0x01 如何访问数据库\n\n那，既然已经可以访问数据库，本着『如无必要，勿增实体』的原则，为什么要不辞劳苦的用个库呢？\n\n## 0x02 数据库抽象的两种理论\n\n### 理论一：Active Record\n\n### 理论二：Data Mapper\n\n## 0x03 数据库抽象的两种实现\n\n### 实现一：Django ORM\n\n### 实现二：Sqlalchemy\n\n## 0x04 工具的强弱\n\nhttps://www.thoughtfulcode.com/orm-active-record-vs-data-mapper/\n\n### 2.0 SQLAlchemy VS DjangoORM\n\nORM 通常有 DataMapper 实现和 ActiveRecord 实现两种。\n\n依照我的经验，ActiveRecord 使用起来的更接近对象 (Object) 的操作，DataMapper 使用起来更接近 (Table) 的操作。\n\n\u003e SQLAlchemy 是 DataMapper 模式的实现，在该模式下，session 会暴露出来，即 Model 与 session 并不耦合。\n\n\u003e DjangoORM 是 ActivityRecord 模式的一种实现，在该模式下，session 并不暴露出来，即 Model 与 session 耦合。\n\n使用 Django ORM 的时候，往往是\n\n```python\nb = Blog(**data)\nb.save()\n```\n\n使用 SQLAlchemy 的时候，往往是\n\n```python\nb = Blog(**data)\nsession.add(b)\nsession.session(b)\n```\n\n由于 Django 帮你屏蔽了 session 的操作。\n\n在通常情况下，\n\n1. DjangoORM 使用起来更加接近 Object 的操作。\n2. SQLAlchemy 使用起来更加接近 Table 的操作。\n\n举个例子，\n\n一对多，Father 添加两个小孩（其中一个小孩是已经存在的）\n\n在 DjangoORM 里面， 这里更像是一个 Set 的 add 操作。\n\n```python\nfather.children.add(new_child,exsit_child)\n```\n\n在 SQLAlchemy 里面，这里更像是一个 table 的 insert 操作。（麻蛋，你要说是一个 list 的 append 操作也行）\n\n```python\nfor child in (new_child,exsit_child):\n    if child in father.children:\n        father.children.append(child)\n```\n\n\u003e 写 SQLAlchemy 更接近操作放在数据库里面的数据记录，而 DjangoORM 更接近操作一批放在数据库里面的对象。\n\n由于 session 的使用姿势不同，所以往往会有很多使用上面的区别。\n\n至于孰优孰劣，难以评判。\n\n- 技术老大 (Flask 和 React 大神）倾向于使用 SQLAlchemy, 他认为\n\n  - 对于一个技术『知其然，知其所以然』\n  - 对于 ORM\n    - 操作数据库，操作最好要落实在成 SQL\n    - 如果有可能的话，每一个 SQL 语句都要经过推敲，而且写这个 SQL 和 ORM 过程要反复练习\n  - 对于 Migration 机制\n    - Alembic 这个迁移工具是为了省事用的，甚至在某些情况下没必要用。完全可以写 SQL 代替\n\n- 我 (Django 和 Vue 弱鸡）倾向于使用 DjangoORM, 我认为\n  - 对于一个技术『先知其大致然，需要深入的时候知其所以然』\n  - 对于 ORM\n    - 操作数据，最好抽象为对对象的操作。\n    - 测试到位的情况下，快糙狠先出东西。到需要优化的时候该怎么 Profile 怎么 Profile\n  - 对于 Migration 机制\n    - 用起来啊，能操作对象为什么还要强行到数据库操作？\n\n```python\nActive Record, properly defined, is a design pattern where an object is represented as a record on a table in a relational database.\n```\n\n### 2.1 模型定义\n\n先看一组模型\n\n```python\nfrom sqlalchemy.ext.declarative import declarative_base\nBase = declarative_base() # 模型基类\nfrom sqlalchemy import Column, Integer, String\nclass User(Base):\n    __tablename__ = 'users'\n\n    id = Column(Integer, primary_key=True) # 主键\n    name = Column(String)\n    fullname = Column(String)\n    password = Column(String)\n\n    def __repr__(self):\n       return \"\u003cUser(name='%s', fullname='%s', password='%s')\u003e\" % (\n                            self.name, self.fullname, self.password)\nBase.metadata.create_all(engine)\n```\n\n可以看出，包含如下的部分：\n\n1. Model 与 Model 内部的 Meta\n2. Field 与 Field 内部的 Options\n3. Model 与 Model 之间的关系\n4. 其他，比如索引\n\n#### Models 与 Meta\n\nhttps://github.com/zzzeek/sqlalchemy/blob/master/lib/sqlalchemy/sql/schema.py#L3685\n\n#### 关系\n\n##### One To Many\n\n母亲有若干个孩子，外键在孩子上。\n\n```python\nclass Parent(Base):\n    #...\n    children = relationship(\"Child\", backref=\"parent\")\n\nclass Child(Base):\n    #...\n    parent_id = Column(Integer, ForeignKey('parent.id'))\n```\n\n##### Many To One\n\n多个母亲共享一个孩子，外键在母亲上。\n\n```python\nclass Parent(Base):\n    child_id = Column(Integer, ForeignKey('child.id'))\n    child = relationship(\"Child\")\n\nclass Child(Base):\n    # ...\n```\n\n##### One To One\n\nOne to One 是 One to Many 或者是 Many to One 的简化版本\n\n```python\n# Many To One\nclass Parent(Base):\n    # ...\n    child_id = Column(Integer, ForeignKey('child.id'))\n    child = relationship(\"Child\", backref=backref(\"parent\", uselist=False))\n\nclass Child(Base):\n    # ...\n\n# One To Many 改 One To One\nclass Parent(Base):\n    # ...\n\nclass Child(Base):\n    # ...\n    parent_id = Column(Integer, ForeignKey('parent.id'))\n    parent = relationship(\"Parent\", backref=backref(\"child\", uselist=False))\n```\n\n##### Many To Many\n\n```python\nassociation_table = Table('association', Base.metadata,\n    Column('left_id', Integer, ForeignKey('left.id')),\n    Column('right_id', Integer, ForeignKey('right.id'))\n)\n\nclass Parent(Base):\n    # ...\n    children = relationship(\"Child\",\n                    secondary=association_table,\n                    backref=\"parents\")\n\nclass Child(Base):\n    # ...\n```\n\n注意事项\n\n执行删除 mapping 表的时候尽量这样。\n\n```bash\nmyparent.children.remove(somechild)\n```\n\n当你想干掉 somechild 的时候，会执行\n\n```\nsession.delete(somechild)\n```\n\n1. 假如 Child 没有 ref Parent 的话，Secondary Table 无删除，则无法删除。\n2. 假如 ref 了的话，则删除 secondary 里面的记录。\n3. TODO\n\n##### 邻接列表关系\n\n```python\nclass Node(Base):\n    __tablename__ = 'node'\n    id = Column(Integer, primary_key=True)\n    parent_id = Column(Integer, ForeignKey('node.id'))\n    data = Column(String(50))\n    children = relationship(\"Node\",\n                backref=backref('parent', remote_side=[id])\n            )\n```\n\n##### relationship 详解\n\n### 2.1 Query\n\n#### Create\n\n```python\nc1 = Child(name=\"苏轼\")\nsession.add(c1)\nsession.flush()\np = Parent(name=\"苏辙\")\np.best_child = c1\nfor c in [c1,c2,c3,c4]:\n    p.children.append(c)\nsession.add(c1)\nsession.commit()\n```\n\n#### Retrieve\n\n过滤\n\n```python\nfilter(**kwargs)\nfilter(Singer.name == \"周杰伦\")\nfilter(Singer.name =! \"周杰棍\")\n```\n\n##### 跨关系（跨表）查询\n\n```\nsession.query(Entry).join(Blog,Blog.entry_id == Entry.id).filter(Blog.name = \"SqlAlchemy CheatSheet\")\n```\n\n##### Limit / Offset / 分页\n\n- limit()\n- offset()\n\n##### 链式调用\n\n```python\nquery = session.query(Order) # query = session.query(Order)\nquery = query.filter(Order.name.like(f\"%name%\"))\n```\n\n##### 二进制表达式\n\n我们先 type 一下表达式，找到 eq 的类型\n\n```python\ntype(model.column_name == 'asdf') → sqlalchemy.sql.elements.BinaryExpression\n```\n\n是一个二进制表达式。\n\n```python\n# 等于\nquery.filter(User.name == 'ed')\n# 不等于\nquery.filter(User.name != 'ed')\n# Like（有的数据库不区分大小写）\nquery.filter(User.name.like('%ed%'))\n# ILIKE (case-insensitive LIKE)\nquery.filter(User.name.ilike('%ed%'))\n# IN\nquery.filter(User.name.in_(['ed', 'wendy', 'jack']))\n# Not in\nquery.filter(~User.name.in_(['ed', 'wendy', 'jack']))\n# IS NULL\nquery.filter(User.name == None)\n## 如果你用了 pep8/linter 的话\nquery.filter(User.name.is_(None))\n# IS NOT NULL:\nquery.filter(User.name != None)\n## 如果你用了 pep8/linter 的话\nquery.filter(User.name.isnot(None))\n# AND\n## use and_()\nquery.filter(and_(User.name == 'ed', User.fullname == 'Ed Jones'))\n## or send multiple expressions to .filter()\nquery.filter(User.name == 'ed', User.fullname == 'Ed Jones')\n## or chain multiple filter()/filter_by() calls\nquery.filter(User.name == 'ed').filter(User.fullname == 'Ed Jones')\n# OR\nquery.filter(or_(User.name == 'ed', User.name == 'wendy'))\n# MATCH\nquery.filter(User.name.match('wendy'))\n```\n\n##### 执行查询\n\n```python\nall()\nfirst()\none()\none_or_none()\nscalar()\n```\n\nYourModel.query.get((pk1, pk2))\n\n##### 比较\n\n\u003e 同一个 Session 下面，取到的某一条数据对应的 objects 应该是一样的？\n\n##### 复制 实例\n\n##### 其他\n\n```python\n# 查询的是 SomeModel 里面所有的字段 即 select *\nquery = session.query(SomeModel)\n# 查询的是 SomeModel 里面部分的字段 即 select acol, bcol\nquery = session.query(SomeModel.acol,SomeModel.bcol)\n# 即 select acol , bcol\n# alias\nuser_alias = aliased(User, name='user_alias')\nfor row in session.query(user_alias, user_alias.name).all():\n    # 即相当于 select name as name_label\n    print(row.user_alias)\n\n# limit 和 offset\nfor u in session.query(User).order_by(User.id)[1:3]:\n    print(u)\n\n# distinct\nsession.query(model.Name).distinct(model.Name.value).order_by(model.Name.value)\n# order_by\nUser.query.order_by(User.popularity.desc(),User.date_created.desc()).limit(10).all()\n```\n\n#### Update\n\n单个 object 更新\n\n```python\nblog.title = \"大宝天天见\"\nsession.add(blog)\nsession.commit()\n```\n\n批量更新\n\n```python\nsession.query.filter(Blog.content.like(\"% 敏感词 %\")).update({\n    Blog.content: \"依照相关 XX 无法查看\"\n})\n```\n\n一对多的更新\n\n```\nappend\n```\n\n#### Delete\n\nquery.delete()\n\n#### JOIN\n\nhttps://stackoverflow.com/questions/6044309/sqlalchemy-how-to-join-several-tables-by-one-query\n\n##### 两表 InnerJoin\n\n```python\nfor u, a in session.query(User, Address).\\\n                    filter(User.id==Address.user_id).\\\n                    filter(Address.email_address=='jack@google.com').\\\n                    all():\n    print(u)\n    print(a)\n# \u003cUser(name='jack', fullname='Jack Bean', password='gjffdd')\u003e\n# \u003cAddress(email_address='jack@google.com')\u003e\n\n```\n\n##### 多表 InnerJoin + LeftJoin\n\n```python\nquery.outerjoin(User.addresses)   # LEFT OUTER JOIN\n```\n\n#### 聚集查询\n\n```python\nsession.query(User).filter(User.name.like('%ed')).count()\n```\n\n```python\nfrom sqlalchemy import func\nsession.query(Table.column, func.count(Table.column)).group_by(Table.column).all()\n\nself.session.query(func.count(Table.column1),Table.column1, Table.column2).group_by(Table.column1, Table.column2).all()\n\nfrom sqlalchemy.sql import func\nsession.query(func.avg(Rating.field2).label('average')).filter(Rating.url==url_string.netloc)\n```\n\n#### 缓存机制\n\nQuery 对象，下文中，我会聊到这个 Query 对象。这里先跳过。\n\n### 2.2 原生查询\n\n```python\nfrom sqlalchemy import text\n\nsql = text('select name from penguins')\nresult = db.engine.execute(sql)\nnames = []\nfor row in result:\n    names.append(row[0])\n\nprint names\n\nfrom collections import namedtuple\n\nRecord = namedtuple('Record', result.keys())\nrecords = [Record(*r) for r in result.fetchall()]\nfor r in records:\n    print(r)\n\nfrom sqlalchemy.sql import text\n\nconnection = engine.connect()\n\n# recommended\ncmd = 'select * from Employees where EmployeeGroup == :group'\nemployeeGroup = 'Staff'\nemployees = connection.execute(text(cmd), group = employeeGroup)\n\n```\n\nget_or_create\n\n```python\ndef get_or_create(session, model, defaults=None, **kwargs):\n    instance = session.query(model).filter_by(**kwargs).first()\n    if instance:\n        return instance, False\n    else:\n        params = dict((k, v) for k, v in kwargs.iteritems() if not isinstance(v, ClauseElement))\n        params.update(defaults or {})\n        instance = model(**params)\n        session.add(instance)\n        return instance, True\n```\n\n### 2.3 更新查询\n\n```python\nsession.query(Stuff).update({Stuff.foo: Stuff.foo + 1})\n```\n\n```python\n1) for c in session.query(Stuff).all():\n       c.foo += 1\n   session.commit()\n\n2) session.query().\\\n       update({\"foo\": (Stuff.foo + 1)})\n   session.commit()\n\n3) conn = engine.connect()\n   stmt = Stuff.update().\\\n       values(Stuff.foo = (Stuff.foo + 1))\n   conn.execute(stmt)\n```\n\n```python\n1) user.no_of_logins += 1\n   session.commit()\n\n2) session.query().\\\n       filter(User.username == form.username.data).\\\n       update({\"no_of_logins\": (User.no_of_logins +1)})\n   session.commit()\n\n3) conn = engine.connect()\n   stmt = User.update().\\\n       values(no_of_logins=(User.no_of_logins + 1)).\\\n       where(User.username == form.username.data)\n   conn.execute(stmt)\n\n4) setattr(user, 'no_of_logins', user.no_of_logins+1)\n   session.commit()\n```\n\n### 2.4 删除\n\nhttps://stackoverflow.com/questions/5033547/sqlalchemy-cascade-delete\n\n#### OnDelete\n\nondelete='CASCADE'))\n\n#### 批量操作\n\nmodels.User.query.delete()\n\n### 如何从 Object 到一个 ORM\n\n如何追踪 Object 的变化？\n\n## 0x03 SQLAlchemy 的高级特性\n\n### 表继承\n\nhttps://stackoverflow.com/questions/1337095/sqlalchemy-inheritance\n\n### 啥玩意\n\nFlush 和 commit\n\nhttps://stackoverflow.com/questions/4201455/sqlalchemy-whats-the-difference-between-flush-and-commit\n\n```\nx = Foo(bar=1)\nprint x.id\n# None\nsession.add(x)\nsession.flush()\n# BEGIN\n# INSERT INTO foo (bar) VALUES(1)\n# COMMIT\nprint x.id\n```\n\n```\nqry = DBSession.query(User).filter(\n        and_(User.birthday \u003c= '1988-01-17', User.birthday \u003e= '1985-01-17'))\n```\n\n## 0x04 SQLAlchemy 的基础特性 Under The Hood\n\n### Loading 策略\n\n#### Lazy Loading\n\n#### Eager Loading\n\n```\n\u003e\u003e\u003e from sqlalchemy.dialects import postgresql\n\u003e\u003e\u003e print str(q.statement.compile(dialect=postgresql.dialect()))\nWhere q is defined as:\n\n```\n\n## 0x05 SQLAlchemy 的高级特性 Under The Hood\n\n### 多线程\n\nhttps://stackoverflow.com/questions/6297404/multi-threaded-use-of-sqlalchemy\nhttps://stackoverflow.com/questions/9619789/sqlalchemy-proper-session-handling-in-multi-thread-applications\n\n```\n\nhttps://stackoverflow.com/questions/34322471/sqlalchemy-engine-connection-and-session-difference\nhttps://stackoverflow.com/questions/11769366/why-is-sqlalchemy-insert-with-sqlite-25-times-slower-than-using-sqlite3-directly\nhttps://stackoverflow.com/questions/12223335/sqlalchemy-creating-vs-reusing-a-session\nsession 是个容器\n\nhttps://stackoverflow.com/questions/18199053/example-of-what-sqlalchemy-can-do-and-django-orm-cannot\nhttps://stackoverflow.com/questions/7389759/memory-efficient-built-in-sqlalchemy-iterator-generator\n\n# 日志\nimport logging\nlogging.basicConfig()\nlogging.getLogger('sqlalchemy.engine').setLevel(logging.INFO)\n```\n\n## 0x06 DEBUG 和 Profile 技巧\n\n```\nSQLALCHEMY_TRACK_MODIFICATIONS = False\n```\n\n### 6.1 查看技巧\n\ndict(u)\nu.**dict**\n\nhttps://stackoverflow.com/questions/1171166/how-can-i-profile-a-sqlalchemy-powered-application\n\n如果用上 Flask+SQLAlchemy 一般也要带上，Flask-Migration 与 Flask-SQLAlchemy, 这两个库也是对 Alembic 和 SQLAlchemy 的浅封装。\n\n那么，对于这个 ORM 库还有那些通用性的知识需要了解？\n\n嗯，是时候了解本质了。\n\nhttp://derrickgilland.com/posts/demystifying-flask-sqlalchemy/\n\n## 0x07 ORM 的本质\n\nORM 的本质是 Data Access Layer 上的一层封装。如果你写原生 SQL, 即手写 DAL 的话，开发效率可能会大打折扣。\n\n### ORM 的两种类型 Active Record 与 Data Mappers\n\n```\n# ActiveRecord 风格写起来类似于 Django ORM, 大致是这样的\n\n## AR 的模型定义\n\nclass User(db.models):\n    name = db.StringField(verbose=\"xyz\")\n\n## AR 的新增\nuser = User()\nuser.name = \"123456\"\nuser.save() ## 正好对应数据库中的一行\n\n## AR 的查询\n\nusers = User.objects.filter(Q(name=\"黄老板的小姨子\")).all()\n\n# Data Mappers 风格写起来类似于 SQLAlchemy ORM, 大致是这样的\n\n## SA 的定义\n\nfrom sqlalchemy.ext.declarative import declarative_base\n\nBase = declarative_base()\n\nfrom sqlalchemy import Column, Integer, String\nclass User(Base):\n    __tablename__ = 'users'\n\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n\nBase.metadata.create_all(engine)\n\n## SA 的新增\n\nuser = User()\nuser.name = \"123456\"\nsession.add(user)\nsessoon.commit() ## 嗯？其实也是对应数据库中的一行。\n\n## SA 的查询\n\nsession.query(User).filter(User.name)\n\n```\n\n问题来了，这两者到底是什么，看起来似乎相差不大。\n\n```\nclass Person:\n\n    lastname\n    firstname\n    children\n\n    # 数据操作\n    def findone(self):\n        pass\n\n    def insert(self):\n        pass\n\n    def update(self):\n        pass\n\n    def delete(self):\n        pass\n\n    # 业务逻辑\n    def getChildrenTax(self):\n        pass\n\n```\n\nlastName firstName numberOfDependents\n\ninsert update delete\n\ngetExemption isFlaggedForAudit getTaxableEarnings\n\nAn object that wraps a row in a database table or view, encapsulates the database access, and adds domain logic on that data.\n\nThe essence of an Active Record is a Domain Model (116) in which the classes match very closely the record structure of an underlying database. Each Active Record is responsible for saving and loading to the database and also for any domain logic that acts on the data. This may be all the domain logic in the application, or you may ﬁnd that some domain logic is held in Transaction Scripts (110) with common and data-oriented code in the Active Record.\n\nThe data structure of the Active Record should exactly match that of the database: one ﬁeld in the class for each column in the table. Type the ﬁelds the way the SQL interface gives you the data—don’t do any conversion at this stage. You may consider Foreign Key Mapping (236), but you may also leave the foreign keys as they are. You can use views or tables with Active Record, although updates through views are obviously harder. Views are particularly useful for reporting purposes.\n\nobjects correspond directly to the database tables: an isomorphic schema. If your business logic is complex, you’ll soon want to use your object’s direct relationships, collections, inheritance, and so forth. These don’t map easily onto Active Record, and adding them piecemeal gets very messy. That’s what will lead you to use Data Mapper (165) instead.\n\nAnother argument against Active Record is the fact that it couples the object design to the database design. This makes it more difﬁcult to refactor either design as a project goes forward.\n\nActive Record is a good pattern to consider if you’re using Transaction Script (110) and are beginning to feel the pain of code duplication and the difﬁculty in updating scripts and tables that Transaction Script (110) often brings. In this case you can gradually start creating Active Records and then slowly refactor behavior into them. It often helps to wrap the tables as a Gateway (466) ﬁrst, and then start moving behavior so that the tables evolve to a Active Record.\n\n其实为什么不选择设计成 ActiveRecord , 而是选择设计成 Data Mapper, 其实就可以回答这个问题：\n\n\u003e 虽然要设计成 ORM, 考虑到数量和性能因素，SQL 数据库（多个表）并不应该是表现像 Object 集合那样（换言之，也就是 AR 表现的像 Object 的集合一样）。\n\u003e 同时，出于更好的抽象，object 集合也应该表现的像表以及行\n\n于是我们可以得出结论，可以在 SQLAlchemy 上面进行一定的封装，使得最后用起来非常的 Django ORM like，其实 SQLAlchemy 稍加定制还是可以很 Django ORM-like 的。\n\n:TODO: 有机会看看那本书再修改一下本小节\n\n这不，果然有人就这么搞了 https://github.com/absent1706/sqlalchemy-mixins\n\n## 0x09 踩坑集\n\n### 关系持久化坑\n\n1. Rows that point to themselves : 比如一个 insert 一个推荐自己的用户，则需要保存 id / ref_id , 但是在这个 user 插入之前，并不存在 id. 所以，一般情况下是先 insert, 然后保存 ref_id\n2. Mutually Dependent Rows\n\n### SQL 注入\n\nsession.query(MyClass).filter(\"foo={}\".format(getArgs['val']))\n\n## 0xEE 参考链接\n\n- https://www.eversql.com/django-vs-sqlalchemy-which-python-orm-is-better/\n- https://stackoverflow.com/questions/2546207/does-sqlalchemy-have-an-equivalent-of-djangos-get-or-create\n- 除了文档本身，作者在 Stack Overflow 上的回答都是非常值得阅读的。https://stackoverflow.com/users/34549/zzzeek\n- Patterns of Enterprise Application Architecture - Martin Fowler\n- http://aosabook.org/en/sqlalchemy.html\n\n  http://techspot.zzzeek.org/\n\n---\n\nChangeLog:\n\n- **2018-03-09** 重修文字\n"},{"tags":["Windows"],"path":"20190413_如何优雅的使用Windows10.md","title":"如何优雅的使用 Windows 10","slug":"如何优雅的使用 Windows 10","date":"2019-04-03","category":"善用佳软","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n最近入手了 SP6, 于是把 2015 年写的这篇文章修订为 2019 版\n\n\u003e 笔者已过了爱折腾的年纪，仅从提升工作效率方面来说。\n\n背景：\n\n0. Pythonista \u0026\u0026 Nodejs\n1. 工作机 MBP 2017 款机器\n2. 生活机 Surface Pro 6, 轻办公，有时也用来调试 Windows 上的程序。\n\n本文目录\n\n```markdown\n▼ 0x00 前言 : section\n0x01 文件整理 : section\n▼ 0x02 自带功能 : section\n2.1 快捷键 : section\n2.2 触摸板 : section\n2.3 Win+R -- 运行 : section\n▼ 0x03 必备软件 : section\n3.1 文件管理 : section\n3.2 资讯浏览 : section\n3.3 学习软件 : section\n3.4 播放器 : section\n0x04 Autohotkey : section\n▼ 0x05 编程配置 : section\n5.1 Windows Subsystem Linux : section\n5.2 终端 : section\n5.3 Python : section\n5.4 Node : section\n5.5 其他 : section\n0x06 实用主义的工具论 : section\n0xEE 后续 : section\n```\n\n## 0x01 文件整理\n\n文件整理一般从类型上进行划分子文件夹。\n\n贴上我的几张图来看一下我的文件夹命名：\n\n一级文件夹如下：\n![](http://upload-images.jianshu.io/upload_images/52890-b6a5322beca48d2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n二级文件夹如下：\n![](http://upload-images.jianshu.io/upload_images/52890-656d90e16abaff66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n三级或者三级以上文件夹\n\n![](http://upload-images.jianshu.io/upload_images/52890-bdf7349fccedda52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n文件命名规范（因为涉及到后面使用 Everything，所以我们的命名尽量追求便于搜索）\n\n举个例子，对于读书笔记 ：读书笔记、\\_设计模式、\\_20150303_v2.1.xmind\n\n对于照片这种文件比较多的，优先命名文件夹，其次按照地址人物日期命名，比如：大明湖胖、\\_夏雨荷、\\_20150101\n\n\u003e 无需刻意追求命名，方便搜索，方便管理就好。\n\n不妨参考下面文章：\n\n[电脑上的文件夹该如何命名（整理）才能做到很久都不用重新整理的那种？ - 文件整理](http://www.zhihu.com/question/21537488)\n\n由于 Windows 的文件没有标签系统。则可以从命名上强行打上标签，比如加上年份。\n\n嗯这样你在搜索笔记的时候在 Everything 里面只需要键入 2015 笔记就可以查看 2015 笔记文件。\n\n是不是很方便？\n\n![](http://upload-images.jianshu.io/upload_images/52890-f4a815755900d627.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![](http://upload-images.jianshu.io/upload_images/52890-1fb3ac3766e59044.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n当然桌面上尽量少放或者不放文件夹，我的桌面上仅仅有一个链接到 OneDrive 里面的 TEMP 文件夹的快捷方式，用于存放临时没有整理的文件。\n\n![](http://upload-images.jianshu.io/upload_images/52890-be22e9252b149d1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 0x02 自带功能\n\n### 2.1 快捷键\n\n能看到本文的读者应该都可以搜索到这些东西。就不赘述了。\n\n仅仅说一些重点快捷键。Win+ 数字键 把常用的软件附在任务栏上。\n\n建议四个以内，方便单手操作。Win+X Alt+tab 切换窗口 Win+R 运行\n\n### 2.2 触摸板\n\n嗯，没有苹果的触摸板好用。但 Windows 的快捷键好用多了。\n\n### 2.3 Win+R -- 运行\n\n主要用于启动一些程序或者一些 DOS 小命令。\n\n![](http://upload-images.jianshu.io/upload_images/52890-d39ea3f078f1d800.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n我将所有的便携与非便携软件的快捷方式放在这里并且配置环境变量。\n\n比如，我需要启动为知笔记，我就仅仅需要闭上眼睛输入 Win+R + wz +\u003cEnter\u003e\n\nPS: 景观\n\n其他软件同理。\n\n```python\n# sublime text 打开需要输入 \nWin+R + st +\u003cEnter\u003e\n# 欧路词典 打开需要输入 \nWin+R + ol +\u003cEnter\u003e\n# 这里省去若干软件打开方式。\n```\n\n关于 Win+R 你可以参考善用佳软  [最绿色最高效，用 win+r 启动常用程序和文档](http://xbeta.info/win-run.htm)  的介绍。\n\n## 0x03 必备软件\n\n### 3.1 文件管理\n\n- 图片方面，如果不是 RAW 格式，可以考虑使用 Eagle 这个神器\n- 文字方面，如果是简单的图文素材，可以直接丢到印象笔记 / 有道云笔记里。\n- 文档管理，如果是比较 Geek 一些的话，可以考虑用 TotalCMD 管理文档，Everything 快速搜索\n\n- PS: 没有足够的需求，不要搞 TC.\n- PS2: 无坚不摧，为快不破。 everything 是搜索效率最快的软件。没有之一。\n\n### 3.2 资讯浏览\n\n- 浏览器 Chrome / 新版 Edge 浏览器\n- 欧陆词典：可以外挂其他的开源词库，查词速度超级快。\n\n### 3.3 学习软件\n\n- Xmind\n- OneNote\n- Office\n\n### 3.4 播放器\n\n- PotPlayer\n- foobar2000 -- 逼格提升必备\n\n![](http://upload-images.jianshu.io/upload_images/52890-1d8bc57d69948d60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- 网易云音乐 -- 这货真的不错。\n\n## 0x04 Autohotkey\n\n早年刚接触这个软件的时候，是为了在魔兽争霸里面快速输入文本....\n\n但这个软件可以帮你少装很多软件，\n\n比如：\n\n1. 可以针对快捷键进行编程，\n2. 节省大量的时间，比如一大段文字中有一个网址，你需要访问它，我的解决方法就是选中那些文字，然后一个 Win+b，直接打开 chrome 进行搜索，如果文字中没有网址，那么对选中文字进行百度。同理可以推淘宝，京东 github 等等。\n3. 你需要大量的文本编辑，但是上下左右离自己的工作区比较远，你可以小拇指按住大写锁定按键，然后使用 HJKL 进行移动。\n\n而且，作为曾经的 Geek , 不写点代码定制一下使用流程，你都不好意思说优雅。\n\n教程参考 [AutoHotkey 之美 - 知乎专栏](http://zhuanlan.zhihu.com/autohotkey)\n\n新手可以先拿我搜刮整理的 AHK 代码看看。[twocucao/ChortHotKey · GitHub](https://github.com/twocucao/ChortHotKey)\n\nPS：AHK/TotalCMD 神级软件，都是入门容易精通难的深坑，想调教好也不是想象中呢么简单的，但，书到用时方恨少，你可以先挑一些使用。如果你以后有不少的文件需要管理，在未来，你一定会用到。\n\n\u003e PS: 站在 2019 年回头看，其实 AHK 的语法还是蛮糟糕的。相比于顺手打出很多快捷键。倒不如先优化自己的工作流程。甚至，很多 AHK 的场景完全可以用 Python 之类的语言来写。当我在 Windows 上的时候一味追求 APM, 即高效的操作，但其实最高效的还是自己的思路清晰，想好了再动手。\n\n毕竟，AHK 作为脚本语言，确实语法不美，数据结构也少，没有主流编程语言的社区支持。\n\n嗯，其实还是推荐学 Python\n\n## 0x05 编程配置\n\n### 5.1 Windows Subsystem Linux\n\n如何配置 WSL （我死了？哈哈哈哈好逗的缩写）\n\nhttps://zhuanlan.zhihu.com/p/49227132\n\nhttps://zhuanlan.zhihu.com/p/47733615\n\n### 5.2 终端\n\ncmder 相当于 windows 上的 iterm\n\nhttps://github.com/cmderdev/cmder\n\n### 5.3 Python\n\nhttps://www.anaconda.com/distribution/#download-section\n\n由于笔者要调试 Win32 程序，而大部分这些 dll 文件都是在 32 位的情况下编译出来的。\n\n### 5.4 Node\n\nhttps://nodejs.org/en/download/\n\n### 5.5 其他\n\n- beyond compare 代码比对\n- jetbrain\n- vscode\n\n## 0x06 实用主义的工具论\n\n当你选择用一个工具的时候，务必把精力放在解决问题上。\n\n能满足你的要求，就是好工具，须知『梅须逊雪三分白，雪却输梅一段香』\n\n孰高孰下取决于使用者。\n\n\u003e 你是张三丰，你就能徒手夺来灭绝师太的倚天剑。\n\n并不是说用了一个操作系统，用了某个软件，就会显得自己多么高明，如果不能给日常工作生活提高效率，让自己节省时间，再好的工具，那又有什么意义呢？\n\n\u003e 抓到老鼠的猫才是好猫呀！\n\n## 0xEE 后续\n\n\u003e 2016-01-04 已换 Macbook Pro, 依然挂念 Windows.\n\u003e 2017-05-01 已换 2016 年 Macbook Pro With Multi-Touchbar.\n\u003e 2019-04-13 新增 SP6 作为生活机。\n\nChangeLog:\n\n- 2017-03-08 09:32:15 整理知乎回答，搬运到博客上。\n- 2017-05-01 09:32:15 补充现在使用的电脑信息\n- 2017-06-10 09:32:15 重新排版，增加后续章节。\n- 2019-04-13 13:57:02 重新排版\n"}],"total":2},{"name":"2019-03","posts":[{"tags":["Python","系列文章"],"path":"20190216_PyCode_02.md","title":"如何通过测试提升 Python 代码的健壮性","slug":"如何通过测试提升 Python 代码的健壮性","date":"2019-03-23","category":"Python 项目代码健壮性和性能","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n本文是《提升你的 Python 项目代码健壮性和性能》系列的第二篇文章。\n\n本文的测试更多专注于 Python 后端的程序员。\n\n在上一篇文章中，我提到了代码覆盖率，即测试的一种指标。\n\n本期就聊聊测试这件小事情。\n\n## 0x01 测试的分类\n\n测试有很多种，\n\n按照测试设计的方法可以分为：\n\n1\\. 黑盒\n2\\. 白盒\n\n按照测试目的：\n\n1\\. 功能测试\n\n```bash\n单元测试\n\t功能测试\n\t集成测试\n\t场景测试\n\tA/B 测试\n\n2. 非功能测试\n\n\t压力测试\n\t安全性测试\n\t可访问性测试\n```\n\n其他\n\n```bash\n回归测试\n易用性测试\n还有不少，懒得去整理了.....\n```\n\n代码覆盖率顾名思义，就是测试用例覆盖运行代码的比重。\n\n### 后端主要关注哪些测试\n\n- 单元测试\n- 功能测试\n- 端对端测试\n- 性能测试\n\n## 0x02 为什么要写测试\n\n来讲讲测试的优点。\n\n为什么要写测试来覆盖代码。\n\n1.  **适当的测试可以让发布代码的时候更加有底气。**\n2.  **适当的测试可以让新手更快的了解代码。**\n3.  **适当的测试可以让程序更容易重构。**\n4.  **适当的测试可以加快团队的开发速度。**\n\n既不是不写，也不是狂写一气。看到这里你可能有些疑惑？写测试还加快速度？Are you kidding\\?\n\n一个一个来解释吧。\n\n举个简化版本的例子，『用户下单』到『用户收货』。\n\n1.  用户『查询产品』\n2.  用户『使用优惠券』下单\n3.  用户『在线支付』。当然，用户也可以让不付款，让订单失效。或者直接取消订单。\n4.  商家『确认发货』。\n5.  物流公司更新运单『发货中』。\n6.  用户『确认收货』。当然，用户也可以发起退款。\n\n### 让新手更快的了解代码\n\n测试用例里的数据，往往是能跑通某段代码的最佳测试数据集合。\n\n假如，有个程序员写了 『下单-在线支付-确认收货』的集成测试。作为刚接手这段代码的人。可以在最短的时间内，通过阅读测试代码从而理解整个流程。\n\n有 fixture, 新手可以在很短的时间内知道 setup 能让项目跑起来的基本数据\n\n当然，如果过多的写了测试，也会导致阅读起来比较困难。\n\n### 让发布代码的时候更加有底气\n\n写测试，是为了验证代码运行正确。\n\n一个流程，通常包含若干个子流程，子流程是对的，整个流程才是对的。\n\n如果不写测试对一些关键的流程进行全面的覆盖，则会导致\n\n1.  修改或者新增了一个子流程，需要重新跑个流程进行人肉测试。\n2.  如果人肉测试太费事，则一般程序员就会跳过这个步骤导致线上出问题。\n\n### 让程序更容易重构\n\n当你知道写测试代码有这么多优点的之后，你的第一反应是，这我都知道，但是，写测试还能加快开发速度？\n\n\u003e 当然，你要知道，一个需要去维护的有价值的产品，往往需要不断的修改流程。\n\n一开始，PM 告诉你只需要下单买个东西，后来，要加上满减券，再后来要加上各种类型的券，然后你要对接第三方服务，接下来你要对付各种不按照你设定的流程出牌的用户....\n\n写测试，则是通过不断的补充一些测试，实现整个流程的测试自动化。形成一套测试该项目的测试代码。流程长的令人发指，你指望全靠人肉来测试？\n\n1.  当我修改或者新增子流程的时候，在已经构建出来的测试代码上，可以花少量的代码直接保证修改或者新增的子流程输入和输出被测试到位。\n2.  多人合作的时候，如果 A 原先维护了一套子流程，而 B 来改了一波 A 写的子流程。在有适当的测试的情况下，基本上改出问题来，都会跑不过测试的。\n\n当然，前提是\n\n1.  A 用心写了测试，而不是写了仅仅能让 A 的代码跑的过去的测试。\n2.  是测试如果写过多的话，也会造成团队精力的分散。这下面谈到测试的缺点的时候就会知道。\n\n### 加快团队的开发速度\n\n虽然说，我写的是加快团队的开发速度，但实际上，也适用于个人。\n\n\u003e **除非，你是写渲染页面的.... 所见即所得。无需任何测试**\n\n## 0x03 为什么不要写测试\n\n依照软件界著名的『没有银弹』理论，说完了测试的优越性，也要来说说测试的局限性，主要有三点：\n\n1.  **测试不能解决什么问题？**\n2.  **不适当的测试，往往是负担。**\n3.  **并不是所有地方都容易测试的。**\n\n### 测试不能解决的问题\n\n\u003e 测试能确保代码的运行质量，但无法确保代码编写质量，也无法保证产品设计逻辑上的问题。\n\n也就是说\n\n1.  **代码写的烂，测试代码只能确保编写代码是可以正常运行的。并不能改善代码质量。最多给烂代码的重构提供比较好的运行保证。**\n2.  **产品设计逻辑上的问题，测试代码也只能保证这个设计逻辑落地。**\n\n\u003e 当你觉得测试代码写起来比较难受的时候，你应该考虑重构一下你的程序了。\n\n### 不适当的测试为什么是负担\n\n人总要习惯的是：\n\n1.  东西，学，是学不完的。未知的东西永远存在。新的事物总是在出现，老的事物也不断在演进。\n2.  时间有限，精力有限\n\n\u003e **放到测试上来说，测试，也是测不完的。**\n\n写了一个 IF ELSE , 你需要测两组，多写了一个 IF ELSE, 你就要测四组。如果是一个比较复杂的流程的话，基本上全面测试就很难写完了。\n\n**我的想法是：**\n\n1.  **挑选关键的地方进行测试**\n2.  **减少用户不必要的数据获取**\n\n### 并不是所有地方都容易测试的\n\n并不是所有地方都容易测试的。\n\n1.  特别依赖其他服务商的业务。比如，支付宝 / 微信的预支付。微信小程序的登陆。\n2.  跨端的业务。\n\n这类业务如果做的比较深入，需要 Mock 掉很多逻辑。\n\n## 0x04 写 Python 测试的一些注意事项\n\n### 项目的环境隔离\n\n从整体项目角度，代码的运行环境应该区分 Local/Test/Stage/Prod 四种环境。\n\n- 本地环境：开发者电脑上的环境\n- 测试环境：开发者电脑上 / 持续集成上的环境，之前比较喜欢用 GitlabCI, 后来 团队上了 jenkins, 用起来也还行。\n- 预发布环境：预发布环境，对后端来说，通常情况下就是前端可以通过调用 API 的环境。\n- 生产环境：生产环境。\n\n之所以要做这种区分，是因为不同的环境侧重点不同。\n\n- Local 环境 针对开发者设置的，这个环境的代码变更比较频繁。Web 应用 / Worker / Beat / Deamon 在本地环境中，一般报错比较多，一般我会在禁掉日志。\n- Test 环境 用于执行 make lint \\\u0026\\\u0026 make test，用于检查 lint 相关代码并运行测试。\n- Stage 环境\n- Prod 环境 和 Stage 环境就比较接近了。但也不完全一致。比如生产环境的组织或商家的一些开发资料。\n\n### 测试的基本环境\n\n一般起一个 Docker-Compose 文件，来快速初始化测试环境。\n\n比如 WebApp / Celery Worker / Celery Beats / Redis / RabbitMQ / MySQL 可以 make start 直接起这些服务。\n\n### 单测 / 功测 / 端对端\n\n之前说，后端需要注意下面的测试\n\n- **单元测试**\n- **功能测试**\n- **端对端测试**\n- 性能测试\n\n\u003e 性能测试一般可以通过监控来提前对系统在哪些地方有瓶颈。看场景，一般观察监控会更加容易预测系统的瓶颈，这个更多偏向于调优，放到后面来说吧。\n\n框架假设我们使用 Flask , 再假设有这么一个 BBS（我知道你想吐槽为什么又拿博客 /BBS 举例子，懒得交代过多的业务场景背景知识了，逃...）\n\n1.  **组织 Organization 发布了一个 Thread**\n2.  **用户 User 在这个 Thread 进行了 Reply 『未注册的用户能看见』**\n3.  **管理员 Admin 发现了 User 似乎发布了不该发布的信息。删 Reply。『未注册的用户看不见 / 所有者是能看见的』**\n4.  **最后 User 进行申诉，Admin 发现其实发布的东西挺 OK 的，给予通过。『未注册的用户能看见』**\n\n```bash\ntests # 测试文件目录\n├── __init__.py\n├── conftest.py # 这里存放可能被子目录引用到的集合\n├── e2e # 『端对端测试』\n│   ├── __init__.py\n│   ├── test_viewer.py\n│   ├── test_user.py\n│   ├── test_admin.py\n│   └── test_organization.py\n├── functional # 『功能测试』\n│   ├── __init__.py\n│   ├── test_do_simple_reply.py\n│   ├── test_do_complex_reply.py\n│   └── test_helper.py\n├── unit # 『单元测试』\n|   ├── __init__.py\n|   ├── test_auth.py\n|   └── test_calc_some_thing.py\n├── test_auth_helper.py # 存放基本的用于切换身份的代码\n├── test_const.py\n└── test_factory_helper.py # 可以用来批量初始化数据\n```\n\n这个流程并不算复杂，但足以写测试了。\n\n1.  **在 test_factory_helper 完成数据的基本初始化。**\n2.  **在端对端测试中简单测试浏览。包含未注册用户 viewer 的访问，user/admin/org 的带有效 / 无效 / 过期登陆凭据访问**\n3.  **在 unit 中测试一些和业务联系不紧密的逻辑。比如，计算时间**\n4.  **在 functional 进行比较独立的测试。有的时候也会把几个功能拉起来做测试。相对独立的测试，就是新建一个 User 的 Thread, 删除 Reply, 拉起来测试就是 1/2/3/4 一个测试就完了。**\n\n前者比较简单，后者相对而言更加靠近集成测试。各有利弊。我一般在关键流程上多做几个拉起来测试的代码。\n\n但拉起来测试要解决的问题就多了一个，即，用户登陆认证。你调用某个 Service 的时候，是以匿名用户 / 用户身份 / Admin / Org 调用的。\n\n即在调用不同的 Service 解决问题的时候，你可能需要快速的切换身份。切换完身份再速\n度切换回来。于是，test auth helper 出来了。helper 里面有个 switch as 函数，每次需\n要切换身份的时候，把 g 变量里面的登陆快照 g.user g.admin [http://g.org](https://link.zhihu.com/?target=http%3A//g.org) push 到 LocalStack 栈里 \\(from werkzeug.local import LocalStack\\), 调用完 Service 再 Pop 出来。\n\n拉起来测试的效果是这样子的。\n\n```python\ndef test_complex_process(org, user, admin):\n\twith switch_as_org(org) as org:\t\t# 1. 组织 Organization 发布了一个 Thread\n\t\tthread = publish_thread_by_org()\n\t\twith switch_as_user(user) as user: # 2. 用户 User 在这个 Thread 进行了 Reply\n\t\t\treply = reply_thread(thread)\n\t\t\tassert reply\n\t\t\twith switch_as_anonymous() as anonymous_user:\n\t\t\t\t_thread = see_thread(thread)\n\t\t\t\tassert reply in _thread.replies # 『未注册的用户能看见』\n\t\t\twith switch_as_admin() as admin: # 3. 管理员 Admin 发现了 User 似乎发布了不该发布的信息。删 Reply。\n\t\t\t\tdelete_reply(reply)\n\t\t\t\tassert reply.deleled\n\t\t\twith switch_as_anonymous() as anonymous_user:『未注册的用户看不见』\n\t\t\t\t_thread = see_thread(thread)\n\t\t\t\tassert reply not in _thread.replies\n\t\t\t# 在这里，我的身份还是 user\n\t\t\t_thread = see_thread(thread)\n\t\t\tassert reply in _thread.replies # 『Ower 用户能看见』\n\t\t# 4. 最后 User 进行申诉，Admin 发现其实发布的东西挺 OK 的，给予通过。『未注册的用户能看见』\n```\n\n作为开发者，你只需要让这个测试跑通就基本开发完毕了。在这个过程中，你也可以更好的梳理你的代码。\n\n### 如何处理外部服务\n\n在拉起来做测试的时候，假如我们多了一个流程，用户可以通过微信支付赞赏 reply, 这就不得不依赖于外部的服务。\n\n而拉起来做测试的时候，就会遇到一个非常尴尬的问题，因为我上面的接口都粒度都比较大，是赞赏这个流程里面的非常小的流程，必须要走微信的 http 请求。\n\n解决方式也很简单。 mock 掉请求微信的函数。手动调用一下支付回调函数，即可。\n\n当然，对于 http 请求，也可以使用 **responses** 这个神器来快速 mock 神器 requests 的 response\n\n大致的用法如下\n\n```python\ndef mock_success_pay():\n    def request_callback(request):\n        headers = {}\n        dispatch_callback(data=data)\n        return 200, headers, resp_body\n\n    responses.add_callback(\n        responses.POST,\n        PAY_URL,\n        callback=request_callback,\n        content_type=\"application/json\",\n    )\n\n@responses.activate\ndef test_pay(user):\n    mock_success_pay()\n\t\tswitch_as_user(user) as u:\n\t\t\torder = pay_order(u)\n\t\tassert order.status == \"PAID\"\n```\n\n### 其他 Pytest 小技巧\n\n有的时候 ipdb 比 pdb 用起来不止好了一点点。如何在 pytest 里用上呢？\n\n```bash\npytest -v --pdb --pdbcls=IPython.terminal.debugger:Pdb\n```\n\n## 0xEE 参考\n\n- [https://www.zhihu.com/question/21017354/answer/589574939](https://www.zhihu.com/question/21017354/answer/589574939)\n- [https://www.zhihu.com/question/312395573/answer/604772703](https://www.zhihu.com/question/312395573/answer/604772703)\n"},{"tags":["Python","系列文章"],"path":"20190310_PyCode_05.md","title":"为你的项目快速搭建 ELKFA 日志系统","slug":"为你的项目快速搭建 ELKFA 日志系统","date":"2019-03-10","category":"Python 项目代码健壮性和性能","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n本文是《提升你的 Python 项目代码健壮性和性能》系列的第五篇文章。\n\n讲的是日志系统 ELKFA 的搭建\n\n## 0x00 前言\n\n什么是 ELKFA\\?\n\n这五个字母分别代表着五个开源软件\n\n- **E - ElasticSearch**\n- **L - Logstash**\n- **K - Kibana**\n- **F - FileBeat**\n- **A - APM-Server**\n\n利用这五个软件的组合，我们可以在比较短的时间打造两个系统：\n\n1.  日志系统，分析 Nginx 日志，Gunicorn 日志，Flask 日志，Django 日志\n2.  APM 系统，解决两个问题\n    2.1 Metric 分析：Flask 是否正常运行，接口请求信息定期发送到 APMServer 这边，方便我观察服务是否正常，接口和业务逻辑的执行的时间是否在预期范围内。\n    2.2 Trouble Shooting: 如果程序报了异常，我想把需要报的异常堆栈信息打出。方便我快速的 Trouble Shooting\n\n## 0x01 任务 1: 分析 Nginx 日志\n\nNginx 众所周知，Nginx 日志是个宝库，所以本文选取了 Nginx 作为日志分析的案例。\n\n对于 Nginx 日志，可以采用 FileBeat 上传到 Logstash, 由 Logstash 对文件进行解析，并存储到 ElasticSearch\n\n然后从 Kibana 进行分析。\n\n### 第一步：配置 Nginx\n\n首先，让 Nginx 的配置输出的日志符合某种模式，方便软件进行解析。\n\n```text\nlog_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n\t\t\t\t\t\t\t'$status $body_bytes_sent \"$http_referer\" '\n\t\t\t\t\t\t\t'\"$http_user_agent\" \"$http_x_forwarded_for\"';\n\naccess_log /var/log/nginx/access.log main;\n```\n\n然后重启 nginx\n\n### 第二步：拉取 Nginx 日志\n\n一天后，从 Nginx 服务器上拉一下 access.log 放到\n\nelastic-labs/logs/prod/nginx 下\n\n### 第三步：开启 ELFKA\n\n```text\ngit clone git@github.com:twocucao/elastic-labs.git\ncd elastic-labs\ndocker-compose up\n```\n\n\u003e 啥、? 不会搭 Docker\\? 见文末\n\u003e 啥、? 不知道 ElasticSearch 怎么用、? 见文末\n\n如果运行正常，终端应该是这样的\n\n![](https://pic1.zhimg.com/v2-15a6f7c35277ca34f035a0996ed1d23c_b.jpg)\n\n打开 kibana 进行观察\n\nhttp://localhost:5601/\n\n![](https://pic2.zhimg.com/v2-52689881c9e9610d37c0fb88016ed5b5_b.jpg)\n\n### 第四步：日志探秘\n\n默认情况下，每一天的 Nginx 日志会在 ES 里创建一个 Index, 所以，你需要用 Index Pattern 来进行统计\n\n![](https://pic2.zhimg.com/v2-52d45736112286a549e1e216fa0dab95_b.jpg)\n\n来看看我们可以得到哪些内容\n\n![](https://pic1.zhimg.com/v2-341fb82fdf1615c6180fea381bca8c44_b.jpg)\n\n1.  用户 IP 以及通过 GeoIP 得到的大致地理位置。\n2.  OS 的类型 \\(Win/Mac/Linux/IOS/Android\\)\n3.  客户端的类型，浏览器 / 小程序 / 客户端\n4.  访问的接口，类型，频率\n5.  访问服务的频率\n6.  还有很多其他可以深挖的地方，比如通过用户访问的次序推断用户的使用姿势和思考方式等等\n\n对于第六点，有些人可能有些疑惑，这也能？\n\n\u003e **当然咯，假设用户在搜索引擎里面，先搜索了『美女』, 然后搜索了『雪白』, 然后又搜索了『白-洁』, 那基本上这个人搜索的三个词就具备一定的关联性，想搜索的这个雪白就不是『雪白』的意思** \u003e **而是你懂的。**\n\n### 第五步：扩展思考，日志解决方案\n\n上面四个步骤是为了解决分析 Nginx 日志的问题\n\n一条日志从打印出来，到能在 Kibana 进行分析，需要经过如下的步骤：\n\n1.  按照某种日志格式写到文件里，然后被 FileBeat 接收，FB 判断为『 Nginx 模块的日志之后』上传到 Logstash\n2.  Logstash 按照一个端口一个类型的方式接受该类型的日志。通过 filters 和插件进行匹配和修改，比如 grok 的 pattern 来匹配每一条日志（类似于正则匹配）, 抽出需要独立成字段的部分。比如通过 geoip 进行地址匹配，比如对字段进行 convert\n3.  输出匹配结果到 ElasticSearch\n4.  Kibana 通过更加边界的工具来查询 ElasticSearch\n\n如果你想要自定义日志获得更加完美的解决方案，那就需要对这几个流程进行进行细化。\n\n比如你想通过 Flask 的日志来达到更好的用户操作定位。这就需要读者自行依照自己的理解来 hack 了\n\n## 0x02 任务 2: 监控 Flask App 的 APM\n\n### 第一步：开启 ELFKA\n\n同任务一的启动方式\n\n### 第二步：开启 flask app\n\n```bash\npip3 install poetry # 比 pip / pipenv 更好的依赖管理和构建工具\npoetry install -vvv\npoetry shell\nflask run\n```\n\n写一个简单的管理和依赖工具\n\n```bash\nfrom flask import Flask\nfrom elasticapm.contrib.flask import ElasticAPM\n\napp = Flask(__name__)\n\napp.config[\"ELASTIC_APM\"] = {\n    \"SERVICE_NAME\": \"dev-flask\",\n    'SECRET_TOKEN': '',\n}\napm = ElasticAPM(app)\n\n@app.route(\"/\")\ndef hello():\n    return \"Hello, World!\"\n\n@app.route(\"/home\")\ndef home():\n    return \"home!\"\n\n@app.route(\"/\u003cint:num\u003e\")\ndef hello_num(num):\n    import random\n    if random.randint(1, 100) \u003e 95:\n        raise Exception(f\"num\") # 有接近 1/5 的概率会故意抛出异常\n    return f\"Hello, {num}!\"\n```\n\n随手写一个脚本 20 分钟内持续不断的访问接口\n\n```bash\nSECONDS=0\nwhile [[ SECONDS -lt 1200 ]] ; do\n\tfor (( i = 0; i \u003c 20; i++ )); do\n\t\tcurl \"http://localhost:5000/$i\"\n\t\tcurl \"http://localhost:5000/$i\"\n\t\tcurl \"http://localhost:5000/$i\"\n\t\tcurl \"http://localhost:5000/$i\"\n\t\tcurl \"http://localhost:5000/$i\"\n\t\tcurl \"http://localhost:5000/$i\"\n\t\tcurl \"http://localhost:5000/$i\" \u0026\n\t\tcurl \"http://localhost:5000/$i\" \u0026\n\t\tcurl \"http://localhost:5000/$i\" \u0026\n\t\tcurl \"http://localhost:5000/$i\" \u0026\n\t\tcurl \"http://localhost:5000/$i\" \u0026\n\t\tcurl \"http://localhost:5000/$i\" \u0026\n\t\tcurl \"http://localhost:5000/$i\" \u0026\n\t\tcurl \"http://localhost:5000/$i\" \u0026\n\tdone\ndone\n```\n\n### 第三步：APM 探秘\n\n20 分钟过去了，我们可以获知到什么呢？\n\n1.  Metric 分析：Flask 是否正常运行，接口请求信息定期发送到 APMServer 这边，方便我观察服务是否正常，接口和业务逻辑的执行的时间是否在预期范围内。\n2.  Trouble Shooting: 如果程序报了异常，我想把需要报的异常堆栈信息打出。方便我快速的 Trouble Shooting\n\n先设置时间为最近 30 分钟\n\n![](https://pic4.zhimg.com/v2-8076c883c59df6d2ff0821d82c2b1f7f_b.jpg)\n\n在这里可以看到接口的访问情况\n\n![](https://pic2.zhimg.com/v2-776f3bf0834fc827edf2264ca76049f1_b.jpg)\n\n先看 Metric 分析\n\n![](https://pic1.zhimg.com/v2-9352ae0740081699d5692df34df9f724_b.jpg)\n\n这里可以看到接口的稳定性，服务器的基本负载，以及 Error 的出现频次。\n\n再看 Error\n\n![](https://pic2.zhimg.com/v2-1d63b7048a6144cdbf14e8543fb31225_b.jpg)\n\n**看到这里简直泪目 这就是 ELK 版本的 Sentry 啊**\n\n\u003e **Time Saving \\\u0026\\\u0026 防脱发利器**\n\n### 第四步：扩展思考\n\n从 App 被监控到能在 Kibana 进行分析，需要经过如下的步骤：\n\n1.  在原有的 Flask App 里面进行添加 elastc-apm 的 agent \\(apm-client\\)\n2.  agent 会定期将收集完毕的性能信息以及异常信息，发到 apm-server\n3.  输出结果到 ElasticSearch\n4.  Kibana 通过更加边界的工具来查询 ElasticSearch\n\n如果你想要自定义日志获得更加完美的解决方案，那就需要对这前两个流程进行进行细化。\n\n比如公司用 Graphql 的接口，那么，在这种情况下，自带的 contrib 下的 flask 包的路由基本就是废掉的，你需要再 Hack 一下。\n\n## 0xDD 结论\n\n本来这篇文章打算写日志的最佳实践的，结果在查找资料的时候发现了一篇更好的文章\n\n- [https://zhuanlan.zhihu.com/p/27363484](https://zhuanlan.zhihu.com/p/27363484)\n\n看完之后打消了这个念头，转而写如何使用 ELK 的系统落实这种日志分析系统\n\n代码见 [twocucao/elastic-labs](https://link.zhihu.com/?target=https%3A//github.com/twocucao/elastic-labs)\n\n\u003e **欢迎点赞 / 关注 /star 文明三连**\n\n## 0xEE 参考链接\n\n- [https://zhuanlan.zhihu.com/p/27363484](https://zhuanlan.zhihu.com/p/27363484)\n- Photo by[Tan Kaninthanond](https://link.zhihu.com/?target=https%3A//unsplash.com/photos/rr8DvtQL9X8%3Futm_source%3Dunsplash%26utm_medium%3Dreferral%26utm_content%3DcreditCopyText)on[Unsplash](https://link.zhihu.com/?target=https%3A//unsplash.com/%3Futm_source%3Dunsplash%26utm_medium%3Dreferral%26utm_content%3DcreditCopyText)\n- **关于 elasticsearch 可以参考我以前的文章** [Django 全栈教程系列番外篇 - ElasticSearch CheatSheet](https://zhuanlan.zhihu.com/p/35143409)\n- 关于 **docker 的搭建** 可以参考我以前的文章 [Django 全栈教程系列之一 - YaDjangoBlog 开发环境配置](https://zhuanlan.zhihu.com/p/33920401)\n"},{"tags":["Python","系列文章"],"path":"20190308_PyCode_03.md","title":"如何保证 Django 项目的数据一致性","slug":"如何保证 Django 项目的数据一致性","date":"2019-03-08","category":"Python 项目代码健壮性和性能","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n本文是《提升你的 Python 项目代码健壮性和性能》系列的第三篇文章。\n\n- **第一篇，讲的是如何 [用 Type Annotation 提升你的 Python 代码健壮性](https://zhuanlan.zhihu.com/p/56863684)**\n- **第二篇，讲的是[如何通过测试提升 Python 代码的健壮性](https://zhuanlan.zhihu.com/p/57510222)**\n\n第三篇，即本文，我们来谈谈 Django 项目并发可能带来的问题以及如何保持 Django 项目的数据一致性。\n\n本文目录如下：\n\n```text\n   0x00 前言 : section\n▼ 0x01 背景知识 : section\n\t\t并发会带来数据不一致 : section\n▼ 0x02 Django 项目如何解决项目 : section\n\t\t悲观的方式 : section\n\t\t乐观的方式 : section\n\t\t没有银弹 : section\n\t0x03 解决超卖问题 : section\n▼ 0x04 番外篇 数据库隔离级别 : section\n\t\tREAD-UNCOMMITTED : section\n\t\tREAD-COMMITTED : section\n\t\tREPEATABLE-READ : section\n\t\tSERIALIZABLE : section\n\t0xEE 参考链接 : section\n```\n\n本文讨论的场景如下：\n\n**一个简单的秒杀系统，商品还剩 200 件。有一些用户来访问并下单。**\n\n这个项目的接口的简单写法就是：\n\n```text\n@db_transaction\ndef user_order_by_product(user,product):\n    if product.quantity \u003e 0:\n        product.quantity = product.quantity - 1\n        make_order(user,product)\n        product.save()\n```\n\n显然，这个写法确实简洁。\n\n但问题就来了。\n\n\u003e **商品会超卖**, 除非你的应用没什么人访问。\n\n为什么呢？\n\n## 0x01 背景知识\n\n### 并发会带来数据不一致\n\n看图\n\n![](https://pic1.zhimg.com/v2-c016d0d69ca5facc17cdc5cbadc5bac0_b.jpg)\n\n知道问题出在哪儿了吧？\n\n- **理解了？**\n- **你确定理解了？**\n- **你确定你真的理解了？**\n\n![](https://pic2.zhimg.com/v2-f766e78611ac56f55e8984f950a94149_b.jpg)\n\n其实是我给读者挖了一个坑，**我画的这张图其实是有预设的，比如 NOTE2 处确保了 B 用户读到的是 2。**\n\n如果数据库隔离级别是 read uncommitted, NOTE2 处读到的也有可能是 1 ,\n\n本文仅仅针对于 read committed 隔离级别下的 **MYSQL** **/ PostgreSQL**。\n\n在上图中。\n\n一般人写程序\n\n1.  **往往不是**用 Django 的 F 表达式，来实现 update balance = balance - 20 的操作。 **update balance = balance - 20 where id = 1**\n2.  **而是计算** 出新的 balance 然后 user.balance = 80, 接着 user.save\\(\\)\n\n\u003e **这就会放大了问题**\n\n在低并发量的情况下，这个用户手动不断的下单，下单到 200 的时候，后端准时的报卖完了。\n\n假如我现在是 20 个用户同时在下单，很可能机会出现上图的情况。\n\n\u003e **出了问题要解决问题 看到问题就要想法子**\n\n- **鲁迅说过，一见短袖子，立刻想到白臂膊，立刻想到全 X 体，立刻想到....**\n- **我也说过，提到并发，就想到锁，就想到乐观锁，就想到悲观锁。**\n\n## 0x02 Django 项目如何解决项目\n\n有乐观的方式和悲观的方式，即所谓的乐观锁和悲观锁。是不是有高下之分呢、? 不一定。\n\n\u003e 这就好比乐观和悲观本身也并不见的有高下之分。如同有的人乐观，并不见得一定就是乐观，搞不好是傻乐呵，有的人的悲观，只是底色比较悲凉，但内心还是积极向上的。\n\n本小节内容依照自己的理解厚颜无耻的援引了这篇文章的代码\n\n[https://medium.com/\\@hakibenita/how-to-manage-concurrency-in-django-models-b240fed4ee2](https://link.zhihu.com/?target=https%3A//medium.com/%40hakibenita/how-to-manage-concurrency-in-django-models-b240fed4ee2)\n\n### 悲观的方式\n\n悲观的方式就是锁住某个资源，不让其他人使用（排他），直到完成工作后释放。\n\n为什么使用数据库的锁（准确来说是关系型数据库的锁）\n\n1.  数据库非常擅长处理锁来完成数据一致性。\n2.  数据库级别的锁可以保护其他进程修改数据。\n\n```text\n@classmethod\ndef deposit(cls, id, amount):\n   with transaction.atomic():\n       account = (\n           cls.objects\n           .select_for_update()\n           .get(id=id)\n       )\n\n       account.balance += amount\n       account.save()\n    return account\n\n@classmethod\ndef withdraw(cls, id, amount):\n   with transaction.atomic():\n       account = (\n           cls.objects\n           .select_for_update()\n           .get(id=id)\n       )\n\n       if account.balance \u003c amount:\n           raise errors.InsufficentFunds()\n       account.balance -= amount\n       account.save()\n\n   return account\n```\n\n使用 select_for_update 锁住这个 object 直到事务结束\n\n在使用悲观锁的情况下，存钱和取钱流程如下\n\n![](https://pic2.zhimg.com/v2-1c75458108c69d13bcb0d07bdacab0c5_b.jpg)\n\n### 乐观的方式\n\n乐观的方式就是新建一个 version column, 每次修改余额的时候，版本增 1\n\n同样我厚颜无耻的援引了 hakibenita 的代码\n\n```text\ndef deposit(self, id, amount):\n   updated = Account.objects.filter(\n       id=self.id,\n       version=self.version,\n   ).update(\n       balance=balance + amount,\n       version=self.version + 1,\n   )\n   return updated \u003e 0\n\ndef withdraw(self, id, amount):\n   if self.balance \u003c amount:\n       raise errors.InsufficentFunds()\n\n   updated = Account.objects.filter(\n       id=self.id,\n       version=self.version,\n   ).update(\n       balance=balance - amount,\n       version=self.version + 1,\n   )\n\n   return updated \u003e 0\n```\n\ndjango 默认会返回修改成功的行数，于是，是不是存取成功，就看 updated 是否大于 0 了\n\n### 没有银弹\n\n计算机世界里面，多快好省的场景就不存在。一切看场景。\n\n同样在并发量大的情况下\n\n1\\. 如果对某几行修改比较频繁，版本更新频繁，可能乐观锁的 retry 就比较浪费了。\n2\\. 如果是对整张表的更新比较频繁，而不是频繁修改某几行。乐观锁，就比较合适了。\n\n- 乐观方式在应用层，无法阻拦数据库的操作。不会存在死锁的问题。\n- 悲观方式是数据库实现，他阻止数据库写操作。\n\n## 0x03 如何解决超卖问题\n\n1.  把数量和已卖放到 redis 里面呢？\n2.  交给 deamon 呢？\n3.  用 celery 然后排个队异步任务呢？\n\n搞个再复杂一点点的，\n\n1.  在 Redis 里面直接生成 200 个订单号\n2.  然后用户来一个取走一个订单号码\n3.  通过 Celery 削峰 排队走异步任务\n4.  最后通过数据表的 uniq 约束来防止下单超过 200 个。\n\n嗯，就是这么简单。\n\n## 0x04 番外篇 数据库隔离级别\n\n提到了数据库隔离级别，就利用上面的例子顺手讲解一下数据库隔离级别吧。\n\n### READ-UNCOMMITTED\n\n![](https://pic1.zhimg.com/v2-739b559c1747e1d7365187d00a7e3b78_b.jpg)\n\n### READ-COMMITTED\n\n![](https://pic4.zhimg.com/v2-5750ab71fb047d99465912af95a6d323_b.jpg)\n\n### REPEATABLE-READ\n\n![](https://pic4.zhimg.com/v2-200ffcc69005fe5d6e37034f72c4a5f3_b.jpg)\n\n### SERIALIZABLE\n\n这个就不放图了。没啥好讲的。性能太低.... 我是基本上没怎么使用过的\n\n性能上 RU \u003e RC \u003e RR \u003e S\n\n一般人用 RC 和 RR 会多一些，比如我的项目里就使用了 RC , 但什么时候我可能会考虑用 RR 呢、? 比如，我想在一个 Session 里面选两次 最近两个月的用户数据，但是并不希望 出现新的用户。\n\n## 0x05 番外篇 Django ORM\n\n**评论区**\n\n[\\@灵魂对撞机](//www.zhihu.com/people/f4ca959f981c310af429ca25b3b4721d)\n\n提出了防止超卖的另一种解决方案\n\n```python3\n先做订单记录，在直接 sql 改数量，前提库存大于 0，失败一个就事务回滚，抢购失败。\n\n即如下\n\ndef do_order(product):\n   with transaction.atomic():\n       order = make_order(product)\n       # 他的思路 是 RawSQL\n       # updated = sqlexecute(f\"update from product set quantity = quantity - 1 where id = {product.id} and quantity \u003e 0 \")\n       # 在这个基础上，其实可以写出 django orm 对应的语句\n       updated = Product.objects.filter(\n           id=id,\n           quantity_gt=0\n       ).update(\n           quantity=quantity - 1,\n       )\n       if updated == 0:\n           transaction.rollback()\n```\n\n面向业务设计的表，和面向数据分析的表应该是两种设计思路。orm 是实体和记录的映射，比较适合面向业务设计的表。\n\n[\\@灵魂对撞机](//www.zhihu.com/people/f4ca959f981c310af429ca25b3b4721d)\n\n也提到**表关联查询太痛苦了**\n\n**在我的认知里**\n\n1.  **Django 本身是支持 RawSQL 查询的**\n2.  当你想要的 object 和 row 是一一对应关系的时候，ORM 写起来特别舒服\n\n```text\n- django orm 写过滤条件是很舒服的。（抛开性能来说）\n- 针对 Object 的修改也很方便，比如商品数量减少。比如自增 update。\n```\n\n这也是 orm 的不足之处，显式多表连续 join 的话过滤条件就很麻烦。\n\n如果需要**关联查询**这也应该看情况\n\n1.  **如果一般的多表连续 join 如果能使用 nested queries 的话，用 Django 写起来也是特别的舒服。（如果你不是使用 mysql 这种对 nested query 几乎无优化的数据库）**\n\n```python\nVoteActivity.objects.filter\\(category=obj.category, user\\_\\_name\\_contains\\(\"王\"\\), user\\_\\_city\\_\\_type=\"一线城市\"\\) # 伪代码\n```\n\n**2\\. 或许是应该走 ETL 或者是把数据丢到 ES 或者针对查询优化的表会更加合适、?**\n\n当然，这也就看具体的情况了。\n\n## 0xEE 参考链接\n\n1.  [https://www.cnblogs.com/huanongying/p/7021555.html](https://link.zhihu.com/?target=https%3A//www.cnblogs.com/huanongying/p/7021555.html)\n2.  [Django and MySQL](https://link.zhihu.com/?target=https%3A//ewencp.org/blog/django-and-mysql-isolation-levels/index.html)\n3.  [https://medium.com/\\@hakibenita/how-to-manage-concurrency-in-django-models-b240fed4ee2](https://link.zhihu.com/?target=https%3A//medium.com/%40hakibenita/how-to-manage-concurrency-in-django-models-b240fed4ee2)\n"},{"tags":["Python","系列文章"],"path":"20190309_PyCode_04.md","title":"这几招，让你快速提升 Python 项目的性能","slug":"这几招，让你快速提升 Python 项目的性能","date":"2019-03-05","category":"Python 项目代码健壮性和性能","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n本文是《提升你的 Python 项目代码健壮性和性能》系列的第四篇文章。\n\n本文讲的是\n\n```\n**当你觉得某个地方运行比较慢了，此时此刻的你，有哪些小技巧可以快速的帮**\n**你定位性能问题。**\n```\n\n## 0x00 前言\n\n本文主要目的在于介绍一些 Python 项目常规的性能优化的姿势与技巧。\n\n优化的最简单的途径就是，**没用户 + 调用次数少**\n\n嗯？但这种优化方式...... 实在是没什么好说的。\n\n- **优化口诀 1: 先做对，布监控，再做好。**\n- **优化口诀 2: 过早优化是万恶之源。**\n- **优化口诀 3: 去优化那些需要优化的地方。**\n\n即\n\n- Step 1. Get it right.\n- Step 2. Test it's right.\n- Step 3. Monitor.\n- Step 4. Profile if slow.\n- Step 5. Try Optimize.\n- Step 6. Repeat from 2.\n\n有的人站出来说，**我写程序就是要一步到位，把能优化的点一次性搞定。**\n\n请不要听他的，因为优化是无止境的。唯快不破\n\n**能一次写出优雅清晰而且性能高的代码的人，一般很少见到。毕竟需要考虑的点太多了。**\n\n基于上面的认知，**代码的可维护性是第一位的。**\n\n- 写代码的首先应该是代码很清晰，非常容易维护。\n- 然后在没有过分降低可维护性的情况下，作出性能的优化。\n\n## 0x01 Python 优化的五件武器\n\n钟声响起归家的讯号，刚回到家。\n\n公司群响起加班的讯号，用户反应服务响应总是超时。\n\n你打开电脑，隐隐约约觉得是某个函数的问题。这个函数的功能比较多，调试了很久才调试通。\n\n浏览代码。大致定位了这个问题可能会在下面的几个函数中。\n\n```text\ndef red_packet_calculation_algorithm():\n\tpass\n\ndef user_stats_calculation_algorithm():\n\tpass\n\ndef dashboard_calculation_algorithm():\n\tpass\n```\n\n**如何确定是哪个函数需要优化呢？**\n\n很简单，到 IPython 里面执行一下就就知道了。感觉慢的就是目标函数。\n\n**总觉得执行一下这个操作有点不稳定。如果有个工具，可以直接执行很多次，然后作出统计就好了。**\n\n这就是 Python 代码优化第一件武器 timeit\n\n### 第一件武器 timeit\n\n通常某段代码有问题，最直接的方法就是跑一下这段代码。\n\n在 IPython 里执行\n\n```text\n# ipython\n%time your-algorithm\n```\n\ntimeit 将代码执行多次，取均值\n\n一般这个时候，你就可以初步定位问题所在了。\n\n\u003e **比如，发现 user_stats_calculation_algorithm 在 一个 for 循环里面走了数据库查询。**\n\n也有一些函数并不是那么容易定位。\n\n即，通过这个 timeit 知道了某个函数执行比较慢，但那个函数 里面还有很多函数，通过肉眼观察，还是没有办法来解决呀。\n\n这个时候你想了，如果能看到哪些语句执行的次数多一些，耗时长一些，就好了。\n\n这就是 Python 代码优化第二件武器 profile 。\n\n### 第二件武器 profile 与 cprofile\n\n在 ipython 中运行\n\n![](https://pic4.zhimg.com/v2-e71500556d16329b6c785611297364ab_b.jpg)\n\n这么一看，耗时操作一览无遗。\n\n语句级别的 Profile 有了，但其实，很多时候也并不能解决你的问题。\n\n**如果能有这么个东西，即，能在代码旁边注释一下，执行次数和耗时就好了。**\n\n这就是 Python 代码优化第三件武器 line profile。\n\n### 第三件武器 line profiler\n\n能在代码旁边注释，执行次数和耗时。如下\n\n```bash\nPystone(1.1) time for 50000 passes = 2.48\nThis machine benchmarks at 20161.3 pystones/second\nWrote profile results to pystone.py.lprof\nTimer unit: 1e-06 s\n\nFile: pystone.py\nFunction: Proc2 at line 149\nTotal time: 0.606656 s\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents\n==============================================================\n   149                                           @profile\n   150                                           def Proc2(IntParIO):\n   151     50000        82003      1.6     13.5      IntLoc = IntParIO + 10\n   152     50000        63162      1.3     10.4      while 1:\n   153     50000        69065      1.4     11.4          if Char1Glob == 'A':\n   154     50000        66354      1.3     10.9              IntLoc = IntLoc - 1\n   155     50000        67263      1.3     11.1              IntParIO = IntLoc - IntGlob\n   156     50000        65494      1.3     10.8              EnumLoc = Ident1\n   157     50000        68001      1.4     11.2          if EnumLoc == Ident1:\n   158     50000        63739      1.3     10.5              break\n   159     50000        61575      1.2     10.1      return IntParIO\n```\n\n这个可谓是 Python 世界里时间性能优化的顶级工具了。\n\n### 第四件武器 memory profiler\n\n**说完了时间上的优化，再说说空间上的优化。**\n\n如何检查内存呢？\n\n这需要 Python 代码优化第四件武器 memory profiler。\n\n这个工具用于查看 Python 程序的内存占用情况\n\n但，知道了执行某些代码之后，内存是多少又能如何呢？\n\n不见得能定位出来是什么东西\n\n内存中这么多 objects 我上哪看去？\n\n**假设内存泄漏了，我再怎么 profile, 内存都是一直泄漏的呀。**\n\n总要想办法定位出是哪些类型的有问题。\n\n### 第五件武器 pympler\n\n这需要 Python 代码优化第五件武器 pympler。这是我从雨痕的《 Python 学习笔记 》里看到的\n\n**这个工具特别适合给当前所有的 objects 的内存占用情况做简单统计。**\n\n之前的一次线上代码出内存泄漏，检查了自己的代码确定没有问题之后，将目光放在了第三\n方库上。\n\n但第三方库也有不少，检查半天依旧没有什么进展。\n\n```text\nfrom pympler import tracker\n\n# 在多处打点，并且将结果打到日志里。\nmemory_tracker = tracker.SummaryTracker()\n```\n\n每次打印出来的结果大致是这样子的。\n\n```text\ntypes |   # objects |   total size\n================== | =========== | ============\n              dict |           1 |     280    B\n              list |           1 |     176    B\n  _sre.SRE_Pattern |           1 |      88    B\n             tuple |           1 |      80    B\n               str |           0 |       7    B\n```\n\n刚开始都还挺正常，**运行了一段时间之后，日志中的部分涉及到 flask-sqlalchemy**\n**的 objects 和 total size 保持了坚挺的增长。**\n\n最后发现 flask-sqlalchemy 如果 设置了 SQLALCHEMY_RECORD_QUERIES 为 True 的话，\n\n每次查询都会往 current_app.sqlalchemy_queries 里增加 DebugQueryTuple, 很快就内存泄漏了。\n\n```text\nqueries = _app_ctx_stack.top.sqlalchemy_queries\nqueries.append(_DebugQueryTuple((\n\t\tstatement, parameters, context._query_start_time, _timer(),\n\t\t_calling_context(self.app_package)\n)))\n```\n\n### 其他神器\n\n可视化调用\n\n当然，也有一些比较方便的工具是用来查看函数的调用信息的\n\n效果大概是这样子\n\n![](https://pic1.zhimg.com/v2-58d927fe1a204ec13df79ef255749830_b.jpg)\n\n当然，也有其他的工具\n\n[https://stackoverflow.com/questions/582336/how-can-you-profile-a-python-script](https://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/582336/how-can-you-profile-a-python-script)\n\n## 0x02 优化 Web 项目\n\n### 提前优化\n\n在使用 Django 项目的时候，我必须要安装的第三方库就是 djangodebugtools\n\n这个工具用起来有多舒服呢？\n\n可以直接 Profile SQL 语句\n\n![](https://pic2.zhimg.com/v2-84e70f363b220d0560191d53338e6961_b.jpg)\n\n甚至可以直接 explain sql 以及 查看缓存情况\n\n![](https://pic3.zhimg.com/v2-fbfd51e4936fe23a158f41840cd22f36_b.jpg)\n\n![](https://pic1.zhimg.com/v2-6dc91c81ed6a76c02493b152e4ae8a3c_b.jpg)\n\n### 做好监控\n\n如何监控，监控什么指标？这属于日志的范畴了。\n\n日志的道术器分别是什么，这将在下一篇文章来具体介绍一下如何打日志。\n\n## 0x03 性能优化建议\n\n笔者列了一些大方向上的优化建议，具体是要靠积累。\n\n### 建议 1. 务必了解 Python 里面的负优化常识\n\n1.  不要在 for loop 里面不断的链接 string, 用列表 +JOIN 的方式会更加合适。\n\n### 建议 2. 能用内置的模块就不要手动实现\n\n1.  比如，当你想做一些字符串上的变动的时候，不防先查看一下 string / textwrap / re / difflib 里是不是满足你的要求了\n2.  比如你操作一组比较类似的数据类型，可以考虑看下 enum / collection / itertools / array\n    / heapq 里面是不是已经满足你的要求了。\n\n笔者在 [https://zhuanlan.zhihu.com/p/32504320](https://zhuanlan.zhihu.com/p/32504320) 中曾经遇到过统计的问题。\n\n当时遇到的问题场景是\n\n有 400 组 UUID 集合，每个列表数量在 1000000 左右，列表和列表之间重复部分并不是很大。我想拿到去重之后的所有 UUID，应该怎么处理\n\n```text\n# 版本一，运行遥遥无期\nlist_of_uuid_set = [ set1 , set2 ... set400 ]\nall_uuid_set = reduce(lambda x: x | y, list_of_uuid_set)\n\n# 版本二，运行遥遥无期\n\ndef merge(list1,list2):\n    list1.append(list2)\n    return list1\n\nlist_of_uuid_list = [ list1 , list2 ... list400 ]\nall_uuid_set = set(reduce(merge, list_of_uuid_list))\n\n# 版本三，5s\n\nlist_of_uuid_list = [ list1 , list2 ... list400 ]\nall_uuid_set = set(list(itertools.chain(*list_of_uuid_list)))\n```\n\n合适的数据结构和合适的算法，确实能让代码变得清晰，高效，优雅。\n\n### 建议 3. 能用优质的第三方库就不要手动实现\n\n除了一些内置的模块，\n\n- 一些优秀的软件所依赖的第三方包也是非常值得留意的。\n- 一般能上 C 库的，用于解析的依赖包性能不错，比如 LXML/Numpy 这类包\n\n## 0xDD 结论\n\n\u003e **本文讲的是，当你觉得某个地方运行比较慢了，此时此刻的你，有哪些小技巧可以快速的帮** \u003e **你定位性能问题。**\n\n其实还有很多悬而未决的问题：\n\n1.  定位了问题，如何解决问题？\n2.  如何觉察到某个地方运行比较慢呢？\n\n对于第一点，还是得多看多搜多练。用《亮剑》中的李云龙的话说：\n\n\u003e **真正的神枪手是战场上用子弹喂出来的。打得多了，感觉就有了，眼到手就到，抬枪就有，弹弹咬肉，这就叫神枪手。**\n\n对于第二点，就是下一篇文章需要解决的问题了。\n\n1.  通过日志来判断。\n2.  通过打点和结合 APMServer 来判断。\n\n## 0xEE 参考链接\n\n- [https://zhuanlan.zhihu.com/p/32504320](https://zhuanlan.zhihu.com/p/32504320)\n- [https://pynash.org/2013/03/06/timing-and-profiling/](https://link.zhihu.com/?target=https%3A//pynash.org/2013/03/06/timing-and-profiling/)\n- [https://wiki.python.org/moin/PythonSpeed/PerformanceTips](https://link.zhihu.com/?target=https%3A//wiki.python.org/moin/PythonSpeed/PerformanceTips)\n- Photo by[Tim van der Kuip](https://link.zhihu.com/?target=https%3A//unsplash.com/photos/CPs2X8JYmS8%3Futm_source%3Dunsplash%26utm_medium%3Dreferral%26utm_content%3DcreditCopyText)on[Unsplash](https://link.zhihu.com/?target=https%3A//unsplash.com/t/business-work%3Futm_source%3Dunsplash%26utm_medium%3Dreferral%26utm_content%3DcreditCopyText)\n"}],"total":4},{"name":"2019-02","posts":[{"tags":["秒杀"],"path":"20190210_秒杀系统的一些注意点.md","title":"秒杀系统的一些注意点","slug":"秒杀系统的一些注意点","date":"2019-02-10","category":"系统设计","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n## 秒杀常见问题\n\n### 01 卖超问题\n\n假设有 20 个商品要卖，1W 个请求打过来。\n\n1. SQL 加上数量判断，防止数量超掉\n\n应用层的检查，并发量上来，肯定要加行级锁，开销比较大。\n\n2. redis 集合预先缓存好相关的数量，然后从 redis 上进行应用层的数量检查。\n\n然后走异步队列。\n\n因为对于数据库来说，我只要 20 个请求即可，redis 起到了一个阻挡多余的请求穿透到 DB 中的作用。\n\n即便如此，redis 依然可能会出现一些意外的情况，比如为负数，这个时候多打进去几个请求，变成 24 个，这个时候 MQ 的作用就出来了。排好队伍。\n\n3. 唯一索引\n\n数据库层的检查，可以从根本上防止问题\n\n### 02 缓存问题\n\n1. page 级别的缓存，由于 wsgi 协议本身在 flask 中返回的就是文本，所以，当作文本处理即可\n2. obj 级别的缓存\n\n能走内存的走内存，能走 redis 就走 redis, 能通过 mq 削减峰值的就走 mq, 能走 mongodb 的走 mongodb, 最后是数据库。\n\n### 03 安全\n\n1. 验证码\n2. 接口防刷限流\n3. 秒杀接口隐藏\n\n### 04 分布式锁\n\n1. 不加锁，并发起来资源浪费\n2. 加锁，然而，线路抖动会导致不能及时释放锁\n3. 加过期锁，或者加带有时间的锁，然后重新获取锁。\n4. redisson 封装好的方法\n\n### 06 减少数据库访问时间\n\n1. 首先考虑在 where 和 order by 设计的列上建立索引\n2. 索引越多，插入越慢，这个要做好平衡\n3. 避免过长的事务级操作，提高并发能力\n\n其他的可以参考 MySQL 的一些优化原则，油管上很多。\n\n### 07 分布式事务\n\n分布式事务，准确来说，是分布式\n\n## 0xEE 参考\n\n### PEP\n\n- PEP 3107\n- PEP 483\n- PEP 3107\n- PEP 3107\n\n- [关于 gradual typing](http://wphomes.soic.indiana.edu/jsiek/what-is-gradual-typing/)\n\nhttps://mypy.readthedocs.io/en/latest/cheat_sheet_py3.html\n\nhttps://blog.zulip.org/2016/10/13/static-types-in-python-oh-mypy/\n\n---\n\nChangeLog:\n\n- **2018-11-25** 初始化本文\n"}],"total":1},{"name":"2018-12","posts":[{"tags":["FCPX"],"path":"20181210_PyCode_01.md","title":"用 Type Annotation 提升你的 Python 代码健壮性","slug":"用 Type Annotation 提升你的 Python 代码健壮性","date":"2018-12-10","category":"整洁Python代码","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n# 用 Type Annotation 提升你的 Python 代码健壮性\n\n## 0x00 前言\n\n本文是《提升你的 Python 项目代码健壮性和性能》系列的第一篇文章。\n\n当我刚知道 Python 要添加类型的时候，我的内心是拒绝的。\n\nWhy, Why, Why? 就是因为不喜欢类型，也不喜欢特别动态的语言。\n\n但是，尝试了俩个疗程之后，腰也不疼了，腿也不疼了，走起路来都有劲了\n\n\u003e 嗯，真香。\n\n## 0x01 Why Type Annotation\n\n人们常说\n\n\u003e 动态类型一时爽，代码重构火葬场。\n\n在刚写 Python 的前两年里并没有感受很深。\n\n直到，开始和别人协作的时候，才发现各种莫名其妙的问题。\n\n1. 大量的使用魔法方法\n2. flake8 分析出某个函数过于复杂\n3. send_message 里面有不少的参数，一不小心就传参错误\n4. None 值\n\n动态类型给人极大的灵活性，写的时候很爽，但如果解放了双手，撸起袖子一通写，自己写起来爽了，自己重构的时候或者其他人来看代码的时候，头发就会加速掉落。\n\n聪明的你很容易反问，只要我们团队不犯这些错误，不就好了么？\n\n是的，当我们讨论 Python Annotation 的时候，往往陷入类型之争。\n\n我并不想讨论静态类型和动态类型孰好孰坏。\n\n我想讨论的是**加了 Typing 极大的提升代码的健壮性。**\n\n先从 Gradual Typing 说起吧。\n\n## 0x02 Gradual Typing\n\n在你刚入门一门编程语言的时候，我们常常说，Java 是强类型静态语言，Python 是强类型动态语言\n\n从这两位诞生开始，静态类型和动态类型就一直进行旷日持久的圣战。\n\n然而，而现在的发展趋势是：\n\n- 静态类型的语言觉得自己太过静态，以至于写起来很啰嗦。于是引入了很多类型推断。 Java / Go\n- 动态类型的语言觉得自己太过动态，以至于协作的过程中总是出现低级错误。于是引入了 Gradual Typing , Typescript / Flow / Python Type Annotation\n\n什么是 Gradual Typing?\n\nGradual typing 允许开发者仅在程序的部分地区使用 Annotate/Type. 即，既不是黑猫（静态）, 也不是白猫（动态），从而诞生了熊猫（动静结合）。\n\n话说回来，要知道为什么这么搞，首先要知道动态类型和静态类型会给程序带来什么。\n\n### 静态类型 VS 动态类型\n\n静态类型的语言，比如在写 Java 的时候，如果你把一个 int 赋值给了 string 的变量，IDE 会通过**类型检查器**立即报错并告诉你，你这个值赋值错啦。这个就是 Java 程序的检查阶段。 动态类型的语言，比如在写\nPython 的时候，如果不用一些额外的手段，这种低级的错误，并不会在检查时爆出来，只会在运行时爆出来。如果线上还是出这个问题，就蛋疼了。\n\n为了进行友好的讨论，本人将精分成 Javaer 和 Pythonist, 通过两人对话的方式，来讨论类型。\n\n- Javaer: 我先喝杯咖啡\n- Pythonist: 生命苦短，我用 Python。\n\n- Javaer: P 哥，请（为什么叫 P 哥？Python 1989 年出生，Java 1995 年）\n- Pythonist: J 弟，请\n\n- Javaer: 静态类型可以较低成本的提早捕获 BUG, 比如：\n  1. 你在写 Python 的时候，如果不用一些额外的手段，这种低级的错误，并不会在检查时爆出来，只会在运行时爆出来。\n  2. 如果线上还是出这个问题，就蛋疼了。我这个类型检查可以在**使用 IDE 的时候给我分析出方法参数的类型和返回值**。所谓『上医治未病，中医治已病，下医治大病』, 防范于未然，善之善者也。\n- Python: 等等，你小子还广征博引了还，首先，提早捕获 Bug, 我这里也有呀，比如我这里可以通过 flake8 来检查出有些没有定义的变量，**仅仅是类型没有检查而已**。其次，IDE\n  给我的补全又不是完全无法补全。弱一点罢了。你说的类型检查的问题：\n  1. 可以通过**提升程序员的素质**来解决这个问题，或者让他们长点脑子，别特么在这种低级错误上犯错误。\n  2. 写测试来**提升测试代码的代码覆盖率**（这个我会在本系列的第二篇文章里深入讲解）来解决这个问题\n  3. 看看写的代码检查时出现问题，我完全可以**把代码拖到 IPython 里面跑一遍**。这可不仅仅能解决类型不正确带来的问题，还能快速解决代码的逻辑问题\n- Java: 关于你说的第三点，我完全可以提升测试代码的覆盖率。哎？似乎我这个开发测试成本也上来了。看来**类型检查也不能解决这个问题**\n\n- Javaer: 来 P 哥\n  1. 静态类型确实以**较低的成本**解决了这种类型的问题，不是么？\n  2. 并且，如果我其中一小块功能进行了修改，我总不能每次都跑 IPython 吧？我也不能因为想检查一下类型这种小操作就写测试代码覆盖一下？\n- Python: 你每次修改，都要加类型，加类型，改类型，直到类型检查器完全接受。不麻烦嘛？面向类型检查器编程？\n- Javaer: 来，\n  1. 每次改代码的时候，又不是改一大推，你是小部分改的，能有多少项目是海量海量改？高内聚，低耦合，模块化开发。\n  2. 好的代码是重构出来的，修改你的类型来让类型检查器通过。你的代码会被更好的组织起来。\n  3. 我大 Java 就是面向重构的语言！我有 Jetbrain 的 IDE, 重构代码我怕谁\n- Python: 来，你说的没错，\n  1. **每次改代码的时候，又不是改一大推，你是小部分改的**。这话你说的没错，我也能用啊，因为代码总是一小部分一小部分改的，所以，改完了跑一下 IPython 就结了。\n  2. 好的代码是重构出来的，修改你的类型来让类型检查器通过。你的代码会被更好的组织起来。这话你说的也没错，可**我重构的时候没有写测试就重构**，是不是有点莽撞？写了测试了，我还要花时间在类型检查器上，不啰嗦么？\n  3. 我也有 Jetbrain 的 IDE, 重构代码我又不是不能重构。\n- Python: 再来，\n  1. 需求变更上来了，结果往往会出现，你本来是想专注于业务逻辑的更改的，但最后变成了大型**为了让类型检查器通过类型检查而艰苦奋斗的现场**, 我这个场景直接传 int/str/ 字典 / 传对象就很方便，你非要让我写四个函数来\n     override 方法。\n  2. 虽然说，好代码确实可以通过重构出来，但动态语言表达能力强呀，你 Java HashMap 啰啰嗦嗦 put 写了半天，我 Python 一个 Dict 一把梭，看起来，清晰，改起来方便。\n\n再比如说，\n\nLeetCode 上面有一道题目，叫做最长连续 1\n\nInput 是 [1,1,0,1,1,1] Output 是 3\n\n我们尝试用 Python 来看下\n\n```python\ndef find_max_consecutive_ones(num):\n\treturn max(map(lambda x: len(x), ''.join([str(num) for num in nums]).split('0')))\n```\n\n我们尝试用 Java 来看下\n\n```java\npublic class Solution {\n\tpublic int findMaxConsecutiveOnes(int[] nums) {\n\t\tint result = 0;\n\t\tint tmp = 0;\n\t\tfor (int i = 0; i \u003c nums.length; i++) {\n\t\t\tif (nums[i] == 0)\n\t\t\t\ttmp = 0;\n\t\t\telse {\n\t\t\t\ttmp += 1;\n\t\t\t\tresult = Math.max(tmp, result);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n```\n\n- Javaer: 啊咧？P 哥你确实有点短啊！\n- Pythonist: 你敢说我短？你看看 java 的创始人的头发！\n\n『贴图』\n\n- Javaer: 我不是那个意思，浓缩就是精华嘛，表达能力弱又怎么样，我 Javaer 可以直接封装好这个功能当成工具类用，从外部使用上用起来差不多好吧，从项目角度表达力并不是决定性因素，静态类型检查可以提早在编译阶段做字节码优化。你的\n  GIL...\n- Pythonist: 好了，咱就不要提 GIL 了\n\n- Pythonist: 动态类型不需要花时间写 type annotation, 写起来速度杠杠的。\n- Javaer: 静态语言一时爽，动态类型火葬场好伐？举个例子，太动态的东西，就是不好做类型推断，比如贵圈的著名的 sqlalchemy 做的那么动态，query.get() 结合 flask\n  来用，YouModel.query.get() 出来的 YouModel 你还要点进去查看一下具体属性，你要用 title 还是 name, 拼错了，怎么办？都不报错的。\n\n- Javaer: 静态类型迫使你思考程序的时候更加严谨认真，这将会提升你的代码质量。\n- Pythonist: 这点我是不服的，你只是花费了大量的时间在类型检查上，写的认不认真不完全取决于你编程的水平和态度好伐？假如你的观点成立，语言只是武器，峨眉师太拿一把倚天剑，不还是被张三丰空手取来？\n- Javaer: 但你不能否认，峨眉师太拿着倚天剑确实可以秒杀很多人。\n\n\u003e 旁白君：有道是，梅须逊雪三分白，雪却输梅一段香。\n\n- Guido van Rossum: 好了，我觉得类型不错，我在 dropbox 带领团队实现了 python 的 typing，python 3.7 内置哦。\n- Pythonist: 我自己打脸一下，动态类型花点时间写 type annotation 代码健壮性杠杠的。\n- Javaer: 你走开... 你怎么不去解决 GIL 的问题。\n\n### 静态类型 + 动态类型\n\nGradual Typing 就是在动态语言的基础上，增加了可选的类型声明 (Type Annotation)\n\n这对于我这种人是福音，\n\n对于我个人而言，我是希望 Python 是有类型的\n\n1. 作为某段程序的开发者和维护者，我可以提升我重构的速度。\n2. 作为某段程序的调用方，可以快速的知道我调用后得到的东西究竟是什么。\n\n但我又不希望这个声明不是强制性的\n\n1. 我在构思程序的时候，想专注于接口的设计。在落实编码并且把代码写的足够的 dry 之后，在被调用的一些地方加上类型声明，这样可以提升我写代码的速度。\n\n## 0x03 Python Typing 实战 - MyPY\n\n### MyPy\n\nmypy 是一个可选的静态分析器，官网介绍上说，mypy 将使你的程序更加易懂，调试和维护。\n\n这个程序\n\n- 对于 PHP 有 Hack , 对 JavaScript 有 Flow 和 TypeScript, 对于 Python 有 MyPy\n- 对于 Python, 则有 MyPy , MyPy 彼时还不是很成熟 (2016 年 10 之前）。\n\nDropbox 的团队开发，Guido van Rossum 领导开发\n\n### 快速入门\n\n本小节部分摘录 Type hints cheat sheet\n\n建议读者收藏原网址 https://mypy.readthedocs.io/en/latest/cheat_sheet_py3.html\n\n```python\n# 内置类型\nx: int = 1\nx: float = 1.0\nx: bool = True\nx: str = \"test\"\nx: bytes = b\"test\"\n\nchild: bool\nif age \u003c 18:\n    child = True\nelse:\n    child = False\n\n# 普通函数\ndef stringify(num: int) -\u003e str:\n    return str(num)\n\n# 生成器\ndef f(n: int) -\u003e Iterable[int]:\n    i = 0\n    while i \u003c n:\n        yield i\n        i += 1\n```\n\n直接看起来似乎，加不加 typing 对现在的代码改善并不是很明显嘛。\n\n我们可以给复杂类型起别名：\n\n```python\n比如：\ndef f() -\u003e Union[List[Dict[Tuple[int, str], Set[int]]], Tuple[str, List[str]]]:\ndef b() -\u003e Union[List[Dict[Tuple[int, str], Set[int]]], Tuple[str, List[str]]]:\n\nAliasType = Union[List[Dict[Tuple[int, str], Set[int]]], Tuple[str, List[str]]]\ndef f() -\u003e AliasType:\n    ...\ndef b() -\u003e AliasType:\n    ...\n```\n\n看起来还行，但还是没有感觉到很明显的代码质量改善。\n\n好，再看一例，使用 ClassVar 禁止属性无法在实例上设置\n\n```python\nfrom typing import ClassVar\n\nclass A:\n    x: ClassVar[int] = 0  # Class variable only\n\nA.x += 1  # OK\n\na = A()\na.x = 1  # Error: Cannot assign to class variable \"x\" via instance\nprint(a.x)  # OK -- can be read through an instance\n```\n\n举个例子，flask-sqlalchemy, 可以通过 YouModel.query.get(id) 来拿到 YouModel 的实例，但 IDE 不能推断出这个实例是什么。\n\n```python\n# 方法一，Cast\nyou_model_ins: YouModel = YouModel.query.get(id)\n# 方法二，包装一下 get 方法\n\nclass YouModel(base):\n\tdef get(id) -\u003e \"YouModel\": # 注意这里的字符串\n\t\tpass\nyou_model_ins = YouModel.get(id)\n\n```\n\n细心的读者可能看到这里的 YouModel 的返回值类型居然使用了 YouModel 的字符串，如果是 Java 的话，是可以直接写 YouModel 的。\n\n```python\n# 加上类型延迟求值\nfrom __future__ import annotations\n\nclass YouModel(base):\n\tdef get(id) -\u003e YouModel:\n\t\tpass\nyou_model_ins = YouModel.get(id)\n```\n\n还有其他的用法，请参考 MyPY 的官方文档\n\n## 0x04 常见问题\n\n### 如何忽略 mypy 警告\n\n有的地方的代码不进行检查的话会方便很多。\n\n与 flake8 类似，在注释后面写上标志就可以忽略了。\n\n```bash\nyoucode  # type: igonre\n```\n\n### 循环导入\n\n我现在有两个文件，一个是 user.py 另一个是 order.py\n\n在 user 里面有个方法需要返回 order 里面的 Order 列表，order 里面有个 order.owner 需要返回 User 实例。\n\n如果不用类型声明的话，在 user 需要 order 的时候 import 进来即可规避循环导入。\n\n在使用类型声明之后，建议在 user 里面这么写\n\n```python\nif TYPE_CHECKING:\n    from project.models.order import Order # noqa\n\n```\n\n## 0x05 Typing Anotation 项目最佳实践\n\n通过本文了解了基本的 Typing Anotation 的用法，其实效果还不够，本着对爱学习的读者老爷的负责的态度。\n\n所谓『纸上得来终觉浅，绝知此事要宫刑』, 哦不『躬行』\n\n推荐一个超级牛的大项目来让大家了解一下 typing annotation 的最佳实践。\n\nhttps://github.com/zulip/zulip/\n\n当然，从这个项目里面不仅仅能学到 typing annotation, 还能学到大项目下，牛 X 的公司的做法\n\n1. 如何组织和划分模块\n2. 如何帮助开发者快速启用开发环境。\n3. 如何做测试，如何做 CI\n4. 如何优化自己的 Workflow\n\n有机会的话，我会挑其中的一小部分讲解一下。\n\n## 0xEE 参考\n\n### PEP\n\n- PEP 3107\n- PEP 483\n\n### 扩展文章\n\n- [关于 gradual typing](http://wphomes.soic.indiana.edu/jsiek/what-is-gradual-typing/)\n- https://mypy.readthedocs.io/en/latest/cheat_sheet_py3.html\n- https://blog.zulip.org/2016/10/13/static-types-in-python-oh-mypy/\n- https://www.zhihu.com/question/21017354/answer/589574939\n\n---\n\nChangeLog:\n\n- **2018-11-25** 初始化本文\n- **2019-02-16** 重新整理文章\n"},{"tags":["vlog"],"path":"20181223_VlogCheatSheet.md","title":"旅拍 Vlog CheatSheet","slug":"旅拍 Vlog CheatSheet","date":"2018-12-10","category":"摄影摄像","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n最近剪辑了几个 Vlog, 借着这个机会复盘一下几次从拍摄到出片的流程。\n\n## 0x01 拍摄准备\n\n目前笔者的拍摄装备如下：\n\n主力拍摄器材：\n\n1. Sony A6500\n\n辅助拍摄器材：\n\n1. GoPro Hero 7 Black\n\n相机的设备还氛围 + 三块电池 + 充电宝\n\n1. 辅助 IPhone 8P\n2. 充电宝\n\n## 0x02 工作流\n\n可以找司机询问最佳的视角\n\n## 0xEE 参考\n\n---\n\nChangeLog:\n\n- **2018-11-25** 初始化本文\n"}],"total":2},{"name":"2018-11","posts":[{"tags":["FCPX"],"path":"20181125_FinalCutProX.md","title":"Final Cut Pro X CheatSheat","slug":"Final Cut Pro X CheatSheat","date":"2018-11-25","category":"善用佳软","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n本文诞生于用 Final Cut Pro X 剪了几次视频之后的复盘总结\n\n部分内容来自于\n\n- Final Cut Pro X 10.1 非线性编辑高级教程\n- Final Cut Pro X 影视包装剪辑完全自学教程\n\n## 0x01 剪辑流程\n\n所有的剪辑流程都是想法的具体实现，这意味着在剪辑之前，需要做好前期准备\n\n    1. 确定大致思路\n    2. 调好参数摄影\n\n然后\n\n1. 素材导入\n2. 片段整理\n3. 前期剪辑\n4. 精剪\n5. 分享\n\n## 0x01 前期准备\n\n本文复盘的是古墓丽影暗影假预告片剪辑。\n\n热血的预告片通常具有如下的特征：\n\n1. 有一条主线，但不剧透，通常这个主线往往是有人在说话，引出了整个故事\n2. 霸气磅礴的背景音乐\n3. 频繁而不冗余的镜头切换\n4. 踩节奏踩的非常精准\n\n## 0x02 素材导入\n\n1. 建立 Library 游戏\n2. 建立 Event 古墓丽影暗影，导入游戏视频\n3. 建立 Project 古墓丽影暗影盗梦空间预告片\n\n素材导入没什么好说的，因为 PS4 里录制成什么样子，就是什么样子。\n\n开启转码和分析的话，可以分析出更多的片段类型。\n\n### 注意点\n\n- 建议开启『创建优化的媒体』\n- 看存储情况如果存储不是很足的话，开启『创建优化的代理文件』\n\n尽量将素材管理的任务交给 FCPX 来做，所以，如果可能的话，直接拷贝进资料库最好。\n\n对于个人剪辑的话，比较适合两个 Library, 即一个常用 Library, 另一个是本项目的 Library 当然，其实也可以\n\n## 0x03 片段整理\n\n对于不同类型的影片，需要不同类型的整理方式\n\n1. 对于预告片来说，两三秒的镜头可以带出大量的信息，引人遐想。\n2. 而对于普通综艺 / 电视剧 / 电影来说，如果遵循着预告片的节奏的话，则会交代不清楚事情。\n\n对于预告片来说，就仅仅剩下挑选中上片段这一个选项了。\n\n1. 快速浏览片段内容\n2. 挑选片段里面的片段打上关键字\n3. 进入了某个关键字的视频列表，对它进行评价 (f/u/del)\n\n快速浏览\n\n1. FCPX 提供了缩略图模式，可以按 1s/5s/10s 的间隔显示视频内容，合理使用的话，可\n   以达到事半功倍的效果。\n2. 善用 jkl 快速浏览视频\n\n打关键字\n\n1. 调出关键词管理器，然后设置关键词的快捷键，FCPX 可以快速选中一个片段中的片段（也可以通过 i/o 快捷键进行选择），选择 ctrl + num 打一个关键字。\n2. 这里也不需要把关键词的片段弄的特别的精准。因为其实放到视频里面还是可以前后拖拽的。（这只是个浅拷贝）\n\n评价系统\n\n嗯？上了关键字的都是不错的镜头，似乎评价体系就没那么重要了\n\n经过这些操作，之后，可以快捷的进行搜索。筛选出自己需要的片段。\n\n嗯，由于项目本身并不算复杂。就关键字一波流搞定好了。\n\n当然，题外话，如果我后期会基于这些素材做很多其他的事情的话，我就会认真的重新给片段\n划分精细的关键字。\n\n## 0x04 前期剪辑\n\n笔者遇到的剪辑基本分为两种：\n\n1. 踩情节类型\n2. 踩节奏类型\n\n3. 踩情节类型的剪辑只需要往上怼素材，然后依据磁力线调整即可。比如采访类，比如综艺。\n4. 踩节奏类型的剪辑这比较繁琐，因为要不断的增加，修改，删除片段。\n\n本次的剪辑就遇到了这个偏移问题，对于音乐的几个转节奏的地方，把视频 / 字幕放在磁力线上，删掉调整节奏前的片段，则导致后面的片段发生偏移。\n\n为了解决偏移带来的踩节奏问题：\n\n1. 设定一个标尺，奈何 FCPX 没有这个概念。于是，我采用了通过字幕来进行项目骨架的构建和注释。在音频的关键的地方，Marker 来注释.（经过仔细思考后，我认为可以弃用字幕的方式了，直接加一个调整层，在调整层上做 marker 来注释就好了）\n2. 当我要先空着预告片的前面，直接到后面编辑需要踩节奏的点位，则先 Q 放一个片段到这个踩节奏的点，然后创建故事线。在故事线里调整完毕之后，合并到主线上。\n3. 当我现在转到前面进行编辑的时候，Q 放一个片段到这个踩节奏的点，然后创建故事线，同上。\n4. 当我需要修改的时候把多个视频片段提出来，在视频上方调整好片段，合并到主线上。\n\n于是，骨架搭好，进入精细剪辑阶段吧。\n\n## 0x05 精细剪辑\n\n在精细剪辑的时候，记得先复制当前项目的一个快照。给快照名称升级个版本。\n\n### 5.1 调整片段\n\n1. 视频长度太长可以剪掉 (B)\n2. 速度过快过慢可以调整速度 (cmd+r)\n3. 滑动编辑 (Trim)\n   3.1 时间范围对了，似乎需要该片段的更前或者更后的部分.(T trim 一下） PS: 可以搭配 Marker 在细节上踩节奏。\n   3.2 片段和片段之间需要前面少点，后面多点 (T trim 一下）\n4. 移动故事线的片段而不发生位移 (postion 拖动 / lift + select 拖动）\n\nPS: 调整速度上 blade speed 是个利器\n\n### 5.2 调整效果\n\n#### 色彩改变 - 调色\n\n1. 苹果自带了平衡颜色。\n2. 手动调整\n\n#### 画面聚焦 - 晕影\n\n#### 关键帧动画\n\n### 5.3 调整转场\n\n少用转场，尽量保持转场的一致性。\n\n### 5.5 调音\n\n## 0x06 分享文件\n\n1. 直接输出 cmd + e\n2. 调用 Compressor 制定更多的输出规则\n\n### 分享技巧\n\n1. 素材很重要 -- 『保留 Library』\n2. 作品已定型 -- 『输出模板文件』\n3. Compressor -- 输出多格式的文件\n\n## 0x07 其他\n\n### 7.1 插入的四种方式\n\n1. 连接：放置在磁力线上方，磁力线上方可以使用 N 进行片段之间的吸附\n2. 插入\n3. 追加\n4. 覆盖\n\n当 range 选中在主故事线选中时间范围内的话，可以插入某个时间段的视频\n\n### 7.2 提升格调\n\n提升格调的两种方法：\n\n1. 镜头感\n2. 电影感\n\n## 0xEE 参考\n\n---\n\nChangeLog:\n\n- **2018-11-25** 初始化本文\n"}],"total":1},{"name":"2018-09","posts":[{"tags":["Python"],"path":"20180908_ThinkingInProgrammingLanguage.md","title":"Thinking In Programming Language","slug":"Thinking In Programming Language","date":"2018-09-08","category":"技术未分类","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n笔者对于涉猎的语言都是草草了解，深入不敢谈。能用罢了。\n\n即便是用过几种语言，得出的经验依然是片面的。\n\n很多人得出一些结论，往往是样本就一个。比如说一个只用过 PHP 的人叫嚣 PHP 是最好的语言。\n\n所以，我得出的结论，不过是一家之言罢了。\n\n本文文章就是总结一下，我使用的一些语言的经验，我整理出一个大致的框架，方便我以后切换到其他编程语言可以更顺滑一些。\n\n## 0x01 语言胡论\n\n在我看来，一个人说他会且只精通一门编程语言是很让我不能理解的事情，在我看来，什么编程语言框架上手两三天就能去写，但是这严格意义上应该叫做能用，和精通相差甚远。那是不是说写的时间长的人经验就老道了呢？也不见得。下棋下了一辈子是烂棋篓子的人比比皆是。\n\n那我认为什么样子的人才是懂写代码的人。\n\n    拥有良好的组织代码的能力的人。\n\n恩，组织代码的能力，一个文件排布混乱的人，不太可能写出整齐严谨的代码，当然，人也可能是复杂的，比如，这个人写的代码挺好，但是生活住处一团糟。\n\n当然这是题外话了，依个人经验而言，学习任何一个复杂的系统，也需要像组织一个东西一样，系统性的学习。\n\n系统化的东西往往像《如何阅读一本书》里面描述一本书的复杂架构那样。\n\n    没有一种物质或产品是绝对简单的。所有的东西都是复杂的组合体。当你看一个整体组成复杂的东西的时候，如果只看它如何呈现一体的面貌，那是还没有掌握精髓，你还必须要明白它怎样呈现多个的面貌，但不是各自为政、互不相干的多个面貌，而是互相融合成有机体的多个面貌。如果组成的各个部分没有有机的关联，仅仅是一个集合体罢了。\n\n    这就像是一堆砖头跟一栋又砖头建造起来的房子是有区别的。而单一的房子与建造的房子也不相同。一本书就像是一栋单一的房子。一栋大厦，拥有许多房间，每层楼都有房间，有不同的尺寸和形状，不同的外观，不同的用途，这些房间是独立的，分离的，每个房间都有自己的架构和装潢设计，但却不是完全独立与分离的，这些房间使用普通门 / 拱门 / 走廊 / 楼梯串联起来的，即建筑师错位的动线架构，因为这些架构师彼此联结的，因此每一个部分在整体的使用功能上要贡献出自己的力量。否则这栋房子便是不适合居住的。\n\n### 独一无二\n\n有的人认为所有的编程语言都是一样的。\n\n依我看，所有的编程语言都是有特点的，也是有优缺点的。\n\n举一个我朋友的爱说的很粗俗的例子：\n\n    虽然说关了灯全都一个样，但是每一个女孩子都有是独一无二的存在。\n\n编程语言也是一样。\n\n- 有的偏向于运行效率，有的偏向于开发效率。\n- 有的据说是让人编程时候感到快乐 (ruby)，有的说你生命苦短，为什么不用 Python。\n- 有的偏向于 Web 开发 (PHP)，有的偏向于并发操作\n- 有的是 Windows 上面自动化的小白工具 (Autohotkey)\n- 有的是据说是一次编译，到处运行 (Java)\n- 有的是亲妈平台万金油 (C#), 当然，最近也在亲妈的带领下往其他方向前进了。\n\n编程语言往往是上面这些因素的取舍。\n\n- 你要运行效率，往往开发效率就会打折。\n- 你要开发效率，往往就需要堆更多的机器来提升性能。\n- 你要充分利用某个平台，往往就没有极高兼容性。\n- 你要编程语言帮你处理掉不需要考虑的问题，有的程序员就站出来了，你是不相信我控制\n  内存的能力么？\n\n有的语言生态好，比如 对于我定位于全栈工程师（其实是全干工程师）的程序员来说：\n\n文能写虫爬数据\n武能后端写网站\n进能数据搞 AI\n退能机器跑运维\n\n十八般武艺武艺样样稀疏的 API 搬运工，那，那就 Python 好了。你还要啥自行车？\n\n## 0x02 语言的工具链\n\n工欲善其事必先利其器\n\n### 编辑器 \u0026\u0026 IDE\n\n大学里有个老师喜欢用 Notepad 手撸 Pascal 代码，然后拖到 IDE 里面运行。\n\n集成开发环境 (IDE) = 编辑器 + 编译器 + 构建系统 + 调试 + 其他编辑提升（补全，重构，格式化）\n\n到底是 IDE 好，还是 Editor 好。其实你看到这里就差不多明白了。一般情况下，选择\nJetBrain 的 IDE 总是没问题的。\n\n那么什么情况下，会选择编辑器呢？\n\n多个\n\n对于，这个经典的问题，可以这么回答：抓到好猫的猫，你管他是黑猫还是白猫。\n\n那么，这个问题就变成了另一个问题。编辑器或者 IDE 可以满足我当前的开发工作流么？\n\n### Workflow\n\n那么，我们从编辑器 + 集成环境\n\n- Mac Homebrew\n- 开发环境里面的 shell\n- cmake\n\n## 0x03 语言的学习资源\n\n官网的文档是最应该反复查看的东西，这是我现在依然喜欢强调的。\n\n而官网的文档也分为四种\n\n- 一种是 tutorial -- 用于**上手**对应的软件 / 编程语言\n- 一种是 guide -- 用于** Topic Reading **\n- 一种是 api document -- 用于**查看细节**\n- 一种是 RTFSC ( Read The Fucking Source Code ) 阅读源码\n\n\u003e 注：把 StackOverFlow 中某个标签的 Most Votes 的答案，是除了大略看看 tutorial 之外的另一种快速熟悉入门时候的痛点的手段。\n\n当然，其实代码写的足够好的话本身就是一种注释。\n\n### 社区\n\n社区一般情况下都会有的，但有几个网站特别值得提出来\n\n- 官网上一般都会放一些比较出色的社区\n- Github\n- reddit\n- 某个技术对应的 Weekly 订阅\n\n### 书籍\n\n特别值得一提的是有一个持续不断阅读到有趣的文章的方法：\n\n1. Google 出对应的 书 / Weekly 周报 / 博客，比如 Python Weekly 然后订阅\n2. 接着不断的查看列入优质文章的作者的文章，Github 地址啦，他关注的 Repo 啦等等等等。\n3. 然后去阅读他的代码 / 博客。\n\n## 0x04 基础概念\n\n\u003e 程序 = 算法 + 数据结构\n\n这句话当然是不全面的，这句话经典就经典在高度概括了程序中算法和数据结构的重要性，但并不影响这句话在计算机世界里面的地位。\n\n依我看来，对我的启发是：\n\n\u003e 我会把 API 的调用和数据结构以及算法想清楚，然后才动手把代码分解成伪代码。最后写成代码。\n\n### 数据类型\n\n按照复杂性可划分为：\n\n- 简单类型\n- 复杂类型\n\n按照复杂性可划分为：\n\n- 基本类型\n- 引用类型\n\n按照数据结构可划分为：\n\n- 集合结构 : 串\n- 线性结构 : 线性表 （单链表，静态链表，循环链表，双向链表，**栈，队列**)\n- 树形结构 : 树（二叉树，B+ 树，红黑树）\n- 图形结构 : 图\n\n对于一些基本的数据类型，操作为 加减乘除取余数位运算等等\n\n对于复杂的一些数据类型，则需要对数据结构多一些了解。\n\n比如，对队列而言，增删改查在算法复杂度上意味着什么？对机器的性能会不会有很多影响呢？\n比如，对 hash 而言，增删改查在算法复杂度上意味着什么？对机器的性能会不会有很多影响呢？\n比如，对字典而言，增删改查在算法复杂度上意味着什么？对机器的性能会不会有很多影响呢？\n比如，对字符串而言，增删改查在算法复杂度上意味着什么？对机器的性能会不会有很多影响呢？\n\n那字符串来说，Java 推荐使用 StringBuilder 来合并多个字符串，Python 推荐 join 多个字符串等等。\n\n### 语句\n\n- 声明语句\n- 赋值语句\n- 条件语句\n\n  1. 判断的时候不确定操作符优先级的时候，加括号\n  2. 尽量显式判断，不要用隐式判断。\n\n- 循环语句\n\n  1. Break 和 Continue\n\n### 函数\n\n1. 传值还是传引用\n2. 参数\n\n函数或者叫做方法，叫法不同。\n\n函数，我有个很私人的称呼，称它为最小操作模块。\n\n实际上，在编程的过程中，程序员用面向对象的思想进行编码的人可能真的不是很多。把一段长程序按照自己的需求进行切分成若干个函数的倒是比比皆是。\n\n不过按照什么样子的标准来切分一段程序为多个函数，仁者见仁智者见智。\n\n这里面需要注意的事情是：\n\n- 1.  注意传值（基本类型）和传引用（引用类型）\n- 2.  函数重载\n\n对于不同的编程语言，传值（基本类型）和传引用（引用类型）基本上达成了共识。\n但在实现函数重载的时候则是有所不同，\n\n比如，Java 里面选择了多写几个函数，Python 则没有这个机制，不过，通过默认参数却可以曲线救国，实现这个机制。\n\n递归\n函数式编程\n高阶函数 mapreduce/ filter / sorted / 返回函数 / 匿名函数 / 装饰器 / 偏函数\n\n#### 作用域\n\n```python\ndef outer():\n    a = 1\n    def inner():\n        a = 2\n    print(a)\n\nouter()\n# 1\n\ndef outer():\n    a = 1\n    def inner():\n        a = 2\n    print(a)\n    inner()\n    print(a)\n\nouter()\n# 1\n# 1\ndef outer():\n    a = [1]\n    def inner():\n        a.append(2)\n    print(a)\n    inner()\n    print(a)\n\nouter()\n# [1]\n# [1, 2]\n```\n\n```javascript\nvar outer = function(){\n    var a = 1;\n    var inner = function(){\n        a = 2\n    };\n    console.log(a);\n    inner();\n    console.log(a);\n}\nouter()\n# 1\n# 2\n\nvar outer = function(){\n    var a = 1;\n    var inner = function(){\n        var a = 2\n    };\n    console.log(a);\n    inner();\n    console.log(a);\n}\nouter()\n# 1\n# 1\n```\n\n#### 高阶函数\n\n- map\n- reduce\n- filter\n\n#### 递归\n\n## 0x05 中级概念\n\n### 类和对象\n\n面向对象有三大概念：\n\n- 封装\n- 继承\n- 多态\n\n### 模块与包\n\n模块，这个概念，可大可小，大的时候，把一个程序说成是模块，小的时候，可以把一个文件，甚至你说这一个函数是一个模块，也行。\n\n这里的模块指的是一个包下的函数。\n\n### 错误 / 调试测试\n\n异常处理实际上可以考验一个程序员编写代码的健壮性。\n\n事实上来说，代码写的健壮是一个程序员必备的素养。但其实在开发过程中，出于对项目进行赶工上线，需要对程序的健壮性做出一定的取舍。并且，在编写客户端，服务端，网页前端的时候基本上都会遇到这个问题。什么时候选择健壮的程序，什么时候选择是还可以的程序。需要自己的经验。\n\n### IO 编程\n\n### 正则表达式\n\n## 0x06 高级概念\n\n### 元编程\n\n### 进程\n\nSpawn - 产卵，为什么叫做产卵呢，因为生出大量的 child process\nSpawn = fork + exec\n\n### 并发 / 并行\n\n#### 并行架构\n\n并行并不完全等同与多核并行\n\n1. bit-level 并行 : 即 8bit 与 32bit 的区别\n2. instrction-level 并行：CPU 的并行度：流水线，乱序执行，猜测执行\n3. data-level 并行：比如 GPU 在调整图像亮度的时候。\n4. task-level 并行：即多处理器，按照内存模型氛围共享内存模型与分布式内存模型\n\n#### 七个并发 / 并行模型\n\n1. 线程与锁\n2. 函数式编程\n3. 分离标志与状态\n4. Actor\n5. 通信顺序进程 (CSP)\n6. 数据级并行\n7. Lambda 架构\n\n#### 模型 1. 线程与锁\n\n互斥\n竞态条件\n死锁\n\n##### 内置锁\n\n当若干个线程进行对某个变量进行一个非原子性的操作的时候，比如\n(read-modify-write), 就吹出现竞态条件。解决方式就是进行对某个变量使用同步访问 (java 中的 synchronized)。\n\n内存可见性\n\n当一个线程使用了多把锁的时候，就可能出现死锁。简单避开死锁的方式就是总是按照一个\n全局的固定思路获取多把锁\n\n哲学家进餐：五个哲学家围绕着桌子，两边五双筷子，如果饿了，就拿起两边的筷子吃饭。则迟早会出现一个情\n况，所有的哲学家在同一时刻决定吃饭。于是两边都拿不到筷子。\n\n最终的解决方案就是按照全局的顺序来获取多把锁。\n\n##### 可重入锁 Reentrant Lock\n\n可以用 try lock 来和超时时间来避免无尽死锁。\n\n交替锁，避免锁整个链表，而是锁上下结点。\n\n#### 模型 2. 函数式编程\n\n#### 模型 3. 分离标志与状态\n\n#### 模型 4. Actor\n\n#### 模型 5. 通信顺序进程 (CSP)\n\n#### 模型 6. 数据级并行\n\n#### 模型 7. Lambda 架构\n\n## 0x05 标准库\n\n### 数据结构与算法\n\n### 字符串与文本\n\n### 数字日期与时间\n\n### 迭代器与生成器\n\n### 文本处理\n\n## 0x07 番外篇\n\n## 0x08 调试和 Profile\n\n### 8.1 测试\n\nhash 算法\n\nrehash | redis 渐进式 rehash\n\n## 0xEE 参考\n\n- http://www.yinwang.org/blog-cn/2017/07/06/master-pl\n\n---\n\nChangeLog:\n\n- **2017-03-21** 初始化本文\n- **2017-05-11** 增加代码质量模块\n- **2018-08-29** 重修文字\n- **2018-09-08** 阅读七周七并发之后，针对并发章节做了补充\n"},{"tags":["Web Develop"],"path":"20180904_系统设计入门笔记.md","title":"Thinking In Web Developing","slug":"Thinking In Web Developing","date":"2018-09-04","category":"系统设计","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n## 0x02 前端\n\n### CDN\n\n代理服务器分布式网络，它从靠近用户的位置提供内容\n\n#### 更新方式\n\n推送 PUSH\n\n当服务器内容发生变动，推送 CDN 接受新的内容。\n\n- 更新最快\n- 流量最小化\n- 存储最大化\n\n拉取 PULL\n\n当用户请求该资源的时候，从服务器拉取资源。\n\n- 更新有延迟\n- 存储最小化\n\n#### 缺点\n\n1. CDN 成本可能会很高\n2. TTL 过期之前更新内容，CDN 缓存内容可能会过时\n\n## 0x02 后端组件\n\n### 负载均衡器\n\n负载均衡起到了一个均衡负载的作用\n\n1. 防止请求进入运行情况糟糕的服务器。\n2. 防止资源过载。\n3. 帮助消除单一故障点。\n\n额外的功能：\n\n1. SSL 终结：解密传入的请求，并加密服务器响应。\n\n工作-备用 / 双工作\n\n#### 选 Worker\n\n- Random\n- Round Robin\n- Least Busy\n- Sticky session / Cookie\n- By request paramters\n\n#### 路由流量\n\n- 随机\n- 最少负载\n- Session/Cookie\n- 轮询调度或加权轮询调度\n- 四层负载均衡\n- 七层负载均衡\n\n### 反向代理\n\n- 安全性：隐藏后端服务器信息\n- 可扩展性和灵活性：客户端只能看到服务器，服务端\n- 本地终结 SSL 会话：\n- 压缩：\n- 缓存：\n- 静态内容：\n\n## 0x08 Http Server Model\n\n### Master\n\n主进程监听不同的进程信号，并且作出反馈。\n\n- TTIN TTOU 告诉 master 升高或者降低运行的 worker\n- CHLD 子进程已结束\n\n### 四种 Worker\n\n#### 同步 Workers\n\n单请求单 worker, 并且不支持 persistent connections\n\n在 CPU 和网络贷款上资源有限。（啥意思，,,,)\n\n即请求时间不定的情况应该是要避免的。\n\n#### 异步 Workers\n\n异步场景\n\n- Applications making long blocking calls (Ie, external web services)\n- Serving requests directly to the internet\n- Streaming requests and responses\n- Long polling\n- Web sockets\n- Comet （其实就是推送）\n\n通过 eventlet / gevent 使用 Greenlets\n\n#### Tornado Workers\n\ntornado\n\n#### AsyncIO Workers\n\n- gthread\n- gaiohttp\n\n### Pre-fork Web Server\n\nhttps://stackoverflow.com/questions/25834333/what-exactly-is-a-pre-fork-web-server-model\n\npre-forking 意味着 一个 master 创建了多个 fork 来处理请求。每一个分叉意味着一个独立的 \\*nix 进程（不一定吧，异步 worker 怎么算？)。\n\nThe pre in pre-fork means that these processes are forked before a request comes in. They can however usually be increased or decreased as the load goes up and down.\n\nlibev / libuv\n\nepoll or kqueue, it is always indispensable to the asynchronous topic.\n\nasyncio\n\nsanic\nlibuv\nuvloop\n\n## 0xEE 结论\n"}],"total":2},{"name":"2018-08","posts":[{"tags":["Golang","CheatSheat"],"path":"20180829_GoLang.md","title":"写给 Pythonista 的 Golang 入门指北","slug":"写给 Pythonista 的 Golang 入门指北","date":"2018-08-29","category":"Golang","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n原计划是去年 8 月份入 Golang 大法的，然后开一篇帖子进行写个入门指北来着。这一拖就拖到了今年。\n\n同样是快速上手教程，这篇文章和其他的文章的不同点在于，完全假设你是 Pythonista 的入门。\n\n## 0x00 前言\n\n## 0x01 安装\n\nGolang 安装\n\n```\n# 如果你是在 mac 上，建议先安装下面的 SDK 以防不测\nopen /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg\n# 安装 golang\nbrew install golang\n# 配置环境变量\necho $GOPATH # /Users/twocucao/Codes/ReposGo\n\ncd /Users/twocucao/Codes/ReposPublic/\n\nmkcd thanos # mkdir \u0026\u0026 cd\ngo mod init github.com/twocucao/thanos\ngit remote add origin git@github.com:twocucao/thanos.git\n```\n\n接下来，需要解决卡 golang.org 的网络问题。\n\n```\nexport GOPROXY=https://goproxy.io\ngo get -v -u github.com/hqpko/go-mod-tidy\ngo mod tidy\n```\n\n接下来就是随便找一些带有依赖库的代码。放到该文件夹下面。\n\n你也可以直接从这里 https://github.com/twocucao/thanos.git 拉取代码\n\n## 0x01 基本概念\n\n### 工具链\n\n### 文档\n\n### 社区\n\n### 书籍\n\n### 内置简单类型\n\n对于一些基本的数据类型，操作为 加减乘除取余数位运算等等\n\n- 数字类型\n- 布尔类型\n- 字符串类型\n- 数组 / 列表\n- 字典\n\n### 内置复杂类型\n\n- 集合结构 : 串\n- 线性结构 : 线性表 （单链表，静态链表，循环链表，双向链表，**栈，队列**)\n- 树形结构 : 树（二叉树，B+ 树，红黑树）\n- 图形结构 : 图\n\n### 对象\n\n### 字符串\n\n## 0x02 中级概念\n\n### 函数\n\n#### 作用域\n\n### 模块\n\n模块，这个概念，可大可小，大的时候，把一个程序说成是模块，小的时候，可以把一个文件，甚至你说这一个函数是一个模块，也行。\n\n这里的模块指的是一个包下的函数。\n\n### 面向对象\n\n面向对象有三大概念：\n\n- 封装\n- 继承\n- 多态\n\n### 错误 / 调试测试\n\n异常处理实际上可以考验一个程序员编写代码的健壮性。\n\n事实上来说，代码写的健壮是一个程序员必备的素养。但其实在开发过程中，出于对项目进行赶工上线，需要对程序的健壮性做出一定的取舍。并且，在编写客户端，服务端，网页前端的时候基本上都会遇到这个问题。什么时候选择健壮的程序，什么时候选择是还可以的程序。需要自己的经验。\n\n### IO 编程\n\n### 进程和线程\n\n#### 多线程\n\n\u003e Go 多线程约等于并发。\n\n#### 多进程\n\n##### 协同式多任务处理\n\n如果有两个线程，同时进行 IO 请求，当其中一个线程连接之后，立即会**主动让出 GIL**, 其他线程就可以运行。\n\n\u003e 当 N 个线程在网络 I/O 堵塞，或等待重新获取 GIL，而一个线程运行 Python。\n\n让出之后还要执行代码呀，所以要有个收回 GIL 的动作。\n\n##### 抢占式多任务处理\n\n##### 线程安全\n\n原子操作：sort 之类不需要\n非原子操作：n=n+2 的字节码分为 加载 n , 加载 2 , 相加，存储 n, 四个步骤，由于不是原子性，很可能被由于 15 ms 而被打断。\n\n当然，懒人一向是 : **优先级不决加括号，线程不决加 lock**\n\n对于 Java, 程序员努力在尽可能短的时间内加锁存取共享数据，减轻线程的争夺，实现最大并行。但 Python 中，线程无法并行运行，细粒度的锁就没有了优势。\n\n### 正则表达式\n\n## 0x03 高级技巧\n\n## 0x04 标准库\n\n### 常用内建模块\n\n### 系统化模块\n\n## 0x05 第三方库\n\n- Requests : API 人性化\n\n## 0x06 代码质量\n\n### 正确性\n\n### 可维护性\n\n### 可读性\n\n### 安全性\n\n### 性能\n\n## 0x07 常用命令\n\n```\ngo build\ngo install -v\ngo clean\ngo fmt\ngo get\ngo test\ngo tool fix . # 修复老代码到新版本\ngo tool vet directory|files\ngo tool yacc -o gopher.go -p parser gopher.y\ngodoc -http=:8080\ngo version 查看 go 当前的版本\ngo env 查看当前 go 的环境变量\ngo list 列出当前全部安装的 package\ngo run 编译并运行 Go 程序\n```\n\n## 0xEE 文章更新\n\n```\n# 如果你是在 mac 上，建议先安装下面的 SDK 以防不测\nopen /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg\n\n```\n\n# Golang\n\n## 模块 01：Go 语言实践 - Runtime\n\n### Goroutine 的调度原理\n\n- Goroutine 和线程的区别\n- Goroutine 的实现、GPM 调度模型、调度状态及流转、调度原理、协作式抢占以及和网络库的协作\n\nhttps://www.jianshu.com/p/105719434c29\n\nhttps://zboya.github.io/post/go_scheduler/\n\nhttps://studygolang.com/articles/16407\n\n### 内存模型\n\nGo 的内存分配机制\nGo 内存分配的内部结构和分配机制\n\nhttps://deepu.tech/memory-management-in-golang/\n\nhttps://medium.com/a-journey-with-go/go-memory-management-and-allocation-a7396d430f44\n\n### GC（垃圾回收）的原理\n\nGC 三色标记算法\n\nhttps://blog.golang.org/ismmkeynote\n\nGC 介绍、三色标记的实现原理、GC 的流程以及 GC 的一些优化方案\n\n### channel 的消息通讯原理\n\nchannel 的底层实现\nchannel 的通讯机制、环形队列的结构、调度和唤醒的原理\n\nhttps://stackoverflow.com/questions/19621149/how-are-go-channels-implemented\n\n## 模块 02：Go 语言实践 - 并行编程\n\n### Memory Model\n\nGo 中内存模型和同步语义\n\nhttps://zhuanlan.zhihu.com/p/110032965\nhttps://golang.org/ref/mem\nhttps://golang.org/doc/\n\n内存模型：Happens Before、同步语义、channel 通讯、锁\n\n### 并发特性并发编程模式\n\nhttps://blog.golang.org/pipelines\n\nTimeout、Pipeline、Cancellation、Fanout、errgroup 等模式\n利用 channel 完成并行开发的设计模式，包含超时控制、管道、扇出、errgroup 并发\n无法熟练使用基于 channel 通讯方式的并行编程模式\n\n### Context 的原理并掌握其使用方法\n\nContext 传播式传递有什么意义\n使用 Go 标准库 Context 的原理和最佳实践，包含超时控制、元数据传递、生命周期控制\n\nhttps://blog.golang.org/context\nhttps://levelup.gitconnected.com/context-in-golang-98908f042a57\n\n## 模块 03：Go 语言实践 - 网络编程\n\n### Golang TCP 网络编程\n\nGo 实现高性能的 TCP Server\n\ngoim 项目了解 Go 语言中 TCP Server 的基础库和性能优化方案\n\n### Golang HTTP 网络编程\n\nHTTP 框架选型\n针对业务需求对 HTTP 框架做针对性的扩展\n结合 gin 项目了解 Go 语言中的 HTTP Server 的基础库和框架\n\n## 模块 04：Go 语言实践 - 异常处理\n\n### error 的处理方法\n\n### 业务错误的处理方法\n\nerror 的处理复杂，不会正确使用\n业务错误定义和 error 整合难度较高\n\nGo 语言中的 error 处理实践：检查错误、定义错误、追加上下文\nGo 项目中的业务错误码如何结合 error 的最佳实践\n\n## 模块 05：Go 工程化实践\n\n### 良好的项目目录组织原则和规范\n\n### API 的设计方法和规范\n\n### Package 的管理和设计方法\n\n### 单元测试\n\n1. Go 项目的标准化管理\n2. 设计 API\n3. 包管理\n\n4. 良好的 Go 项目中的分层目录结构组织和代码规范\n5. Go 项目中 API 的设计原则和方法：定义、状态和业务错误码处理\n6. Go 项目中包的设计和最佳实践、go mod 的使用\n7. go test 工具链的使用方法、单元测试的最佳实践以及 Mock 技术\n\n## 模块 06：Go 架构实践 - 分布式架构（前端负载均衡）\n\n### 高可用 DNS 的最佳实践\n\n### CDN 的架构和应用场景\n\n### 深入理解 4/7 层负载均衡的原理\n\n在线服务的全链路视野\n应用服务上层的负载均衡\n\nDNS 的原理、防劫持的方法、HTTPDNS + IP 长连接\nCDN 的系统架构、应用领域以及保证数据一致性的方法\nLVS、Nginx 4/7 层负载均衡的原理和实践\n\n## 模块 07：Go 架构实践 - 分布式架构（数据分片）\n\n### 数据 Sharding 的设计原则\n\n### 了解 Hash 分片的算法和演进历史\n\nSharding 的应用场景，不会合理使用\nHash 算法的使用场景\n\n数据分片设计，如：分库分表、多活的 Shard 设计等等\n分片算法的 Hash 实现和演进：Hash 求余、一致性 Hash、有界负载一致性 Hash、节点映射\n\n## 模块 08：Go 架构实践 - 微服务（微服务概览与治理）\n\n### 微服务的演进历史及优缺点\n\n### 微服务的设计方法\n\n### 微服务中 RPC 的底层原理\n\n微服务的服务角色：API Gateway、BFF 还是 Service？\n微服务拆分\nRPC 的原理，不知道如何进行微服务 RPC 框架的选型\n\n微服务的原理、概念，以及微服务的实现细节\nAPI Gateway、BFF、Service 等概念精讲\n微服务通讯 RPC 框架的细节和选型\n\n## 模块 09：Go 架构实践 - 微服务（可用性设计）\n\n### 可用性设计的最佳实践\n\n### 可用性设计的几大关键点：隔离、超时控制、过载保护、限流、容错 \u0026 重试\n\n如何设计高可用的分布式服务\n何提升服务自愈能力\n\n微服务的隔离实现，以及架构设计中的隔离实现\n进程内超时控制和跨进程超时控制\n程序自保护避免过载，抛弃一定的流量完成自适应限流\n单机限流、多租户场景的分布式限流\n节点故障的容错逻辑、重试容错的策略和设计\n\n## 模块 10：Go 架构实践 - 中间件（日志、指标、链路追踪）\n\n### 日志收集\n\n### 监控指标体系\n\n### 分布式链路追踪\n\n如何解决微服务的可观测性难题\n怎么做微服务的可视化和标准化\n出故障后，难以对微服务进行问题诊断\n\n实现一个可以集中收集所有微服务实例的日志，并能统一查看和检索的日志采集架构\n指标监控、使用 Prometheus 解决监控可视化、指标采集\n微服务中的跨服务性能问题诊断，结合 Jaeger 实现分布式链路追踪\n\n## 模块 11：Go 架构实践 - 中间件（缓存、数据库）\n\n### Redis、Memcache 的原理和实战技巧\n\n### MySQL 的常用设计和优化方法\n\n1. 解决缓存的一致性问题\n2. 怎样合理地设计 MySQL 的表\n\n3. Redis、Memcache 的应用场景、最佳实践，以及缓存的一致性设计\n4. MySQL 的表设计、常用优化手段，以及如何解决分布式事务\n\n## 模块 12：Go 架构实践 - 中间件（消息队列、服务发现）\n\n### 深入理解消息队列的原理，掌握基于消息队列的架构设计方法\n\n### 服务发现原理、选型策略，以及服务发现实现的微服务多租户架构\n\n1. 消息解耦的架构设计\n2. 如何实现服务发现对平滑发布的支持\n3. 怎样利用多租户实现多测试环境\n\n4. Kafka 的实现原理、异步消息系统的架构设计\n5. RPC 服务发现、动态地址的选型和实现原理，以及基于服务发现的平滑重启和多租户架构\n\n---\n\nChangeLog:\n\n- **2018-08-22** 初始化接口\n"},{"tags":["VueJS","项目经验"],"path":"20180801_VueProjectTalking.md","title":"Vue 项目漫谈 2018 版","slug":"Vue 项目漫谈 2018 版","date":"2018-08-01","category":"前端开发","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n之前草草整理过一些 Vue 的小技巧，最近温习了一遍文档，重聊一遍。\n\n鉴于 VueCLI 越做越臃肿，我最后还是选择了自己搭架子。\n\nhttps://github.com/twocucao/vue-starter-kit\n\n## 0x01 项目结构\n\n```bash\n# 根文件\npublic/ # 部署文件\nsrc/ # 源码\n.babelrc\n.editorconfig\n.eslintignore\n.eslintrc\n.gitignore\n.postcssrc.js\nLICENSE\nREADME.md\njsconfig.json\npackage-lock.json\npackage.json\nwebpack.common.js\nwebpack.dev.js\nwebpack.dll.js\nwebpack.prod.js\n```\n\n\u003c!-- more --\u003e\n\n```bash\n# 在 src 文件夹下面\n\napi # 相关的 Web API 定义\nassets # 静态资源，对于已经压缩的，还是直接放在 Static 下面\ncomponents # 公用组件\nmixins # mixin\ndirectives # 定义指令，比如 v-loading\npages # 页面\nstore # Store\nApp.vue # CORE 组件\nconsts.js #定义常量名称\nindex.js # 用于初始化项目，注册组件等等\nroutes.js # 路由\nutils # 工具方法\n```\n\n值得一提的就是 index.js 应该要做的事情\n\n- 注册全局组件和过滤器\n- 给 Vue 实例加戏，哦，说错了，给实例加一些全局性的方法，比如 $comfirm 等对话框 $verbose $warning 等日志\n- 完成刷新界面之后的从 localStorage 的重新赋值\n- 注册路由切换的时候的调用的各类方法\n\n## 0x02 开发技巧\n\n### 1. 登录，登录校验以及权限\n\n通过路由的 meta 属性来区分\n\n### 8. 日志管理\n\n我觉得日志管理也应该是比较重要的部分，不管是调试程序，还是用于检查用户浏览器这块的错误日志，甚至是埋点。\n\n依据具体技术栈可以考虑上个 sentry 或者 ELK\n\n### 7. 首屏 Loading\n\n这个可以放在 index.html 里面\n\n### 4. 路由管理与嵌套路由\n\n路由管理\n\n嵌套路由有什么优点？\n\n1. 使得子路由里的页面可以复用父级路由的页面的组件\n2. 减少手动硬编码 meta 和 props 的代码量\n3. 便于定制面包屑组件\n4. 其他\n\n## 0x03 构建技巧\n\n### 3.1 离线 IconFont\n\n经常需要离线调试网页，顺手写了这个脚本。\n\n之前在研究某个网站的反爬机制的时候发现时动态生成 iconfont, 然后通过 unicode 码来实现数字的显示，从而让爬虫小白无法爬取。研究了一下他们的 iconfont, 知道了 font-carrier, 然后调用 node 脚本打包字体文件，并在这个过程中自动生成对应的 iconfont.css\n\n最后的结果就是，当我放一个文件到 svg 文件夹下面的时候，比如 bank.svg , 我执行一下脚本，生成对应的字体文件，在 html 里面编写脚本\n\n```\n\u003cspan class=\"iconfont iconfont-bank\" \u003e\u003c/span\u003e\n```\n\n然后对应图标就呈现出来了。\n\n### 3.2 Webpack 构建工具\n\n日常开发用的是 VueCli, 配置还是非常人性化的。开箱即用。\n\n#### 开发环境与部署环境\n\nVueCLI 内置了变量的管理，你可以定义 config/dev.js\n\n```javascript\nmodule.exports = merge(prodEnv, {\n  NODE_ENV: '\"development\"',\n  API_ROOT: '\"http://dev-data.twocucao.xyz\"',\n})\n```\n\n其实，开发的环境用一组变量是不行的。比如，开发的人分为纯前端，纯后端，我这样的前后都会一些的人，每个对于环境的配置都是不太一样的。\n\n- 对于前端 Windowser 直接执行 npm run dev 对接到局域网服务器\n- 对于单个人同时调试后端和前端的时候，一般要把 Web API 对应到本地的机器上。可是使用环境便来配置不同的 DEBUG_MODE=True npm run dev\n\n```javascript\n\n```\n\n#### DLL 打包\n\n大约在半年前，开发过程中突然在使用 ECharts 后，仅仅不到 10M 大小的项目居然开发 build 的时间需要 5MIN, 打包出来的文件超级大。居然接近了 100 多 M\n\n震惊之余，差点准备写一篇骗点击量的文章：**看完震惊了！！前端和后端男程序员都无法忍受的大小！**, 然后文章内就介绍 Webpack 打包文件居然没有避免重复引入依赖库导致打包文件太大提出抗议。\n\n回到主题，使用 npm run analyze 发现问题出现在 ECharts 上， 每一个图表组件都是依赖于 ECharts, 而每一个组件都包含了一个完整的 ECharts 库的大小。\n\n于是，我一边吐槽 webpack 考虑不周，另一方面寻找解决方案。最后找到了 DLL 方案\n\n这个方案的原理大致是：\n\n- 编写独立的脚本，把几个需要复用的库一个配置文件 (manifest.json), 以及打包库到一个 JS 文件中。\n- 然后从 index.html 引入这个 JS 文件。\n- 接着在 webpack 配置中使之每次引入一个库的时候，避免重复引入。\n\n\u003e 但这不应该是 Webpack 本身就应该做的吗？为嘛还要配置，还要不伦不类的生成一个配置文件和一个 JS 文件，再从 index.html 里面导入？\n\n当然，Webpack 生态还是很丰富的，后来出来了一个 https://github.com/asfktz/autodll-webpack-plugin 尝试了之后。感觉很赞。\n\n```javascript\n\n```\n\n可惜在 mac 上一切安好，Windows 上晴天霹雳，debug 了一下，发现是这个库的一个依赖库对 windows 的路径处理好像还有点小问题。而公司的前端小伙伴是 Windowser, 只好作罢。\n\nMacer 可以先用试试，至于 Windowser, 那就去这个 ISSUE 下面催催作者吧... 哈哈哈\n\n\u003e update: 现在 windows 已经可以用了。\n\n## 0x03 代码质量工程管理\n\n### 1. 语义化与可读性\n\n### 2. 提取公共逻辑（通过 Service, Mixin 来）\n\n### 3. CSS 管理\n\n在项目中，我采用 SCSS 来管理 CSS 代码，\n\n过去的时候有两种 css 的代码命名方法\n\n第一种，我管他叫做**配置式写法**，通过将 CSS 语法的几个片段转化成名称，从而实现快速配置出效果的的 CSS\n\n```css\n.fl {\n  float: left\n}\n\n.fr {\n  float: right\n}\n.mr10 {\n  margin-right: 10px\n}\n\n.pb10 {\n  padding-bottom: 10px\n}\n....\n```\n\n这种写法对于简单页面来说确实也是可以使用的。缺点就是当页面变得复杂一些的时候，则比较难控制这种短小精捍（不直观）的变量。比如\n\n```css\n.tmd01{\n  padding-bottom: 10px\n  font-size: 16px;\n  position: relative;\n  top: 0;\n  color: #2d3c48;\n  line-height: 1.6;\n}\n```\n\n\u003e 请脑补一下我的黄人问号脸\n\n当然，如果用得好的话，自然是 OK, 如果用不好的话，\n\n后来进入了嵌套写法时代（感谢伟大的 Rails 社区出的 SASS）, 下面的语法都是 SCSS.\n\n第二种写法就变成了这样\n\n```scss\n.actions {\n  .card_wrapper {\n    .card {\n      .title {\n      }\n      .content {\n        .list {\n          .fa {\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n外加变量和 mixin 以及函数的话，基本上就可以完成代码的组织了。\n\n这种写法倒是比原来不知道高到哪里去了，但问题依旧存在，比如 title,content 这些玩意太多，完完全全的看不懂。更加糟糕的事情是，有的小伙伴直接是乱用嵌套，也不用伪类和伪选择器，从而达到单页面调出来小伙比较快，但因为代码不能重用，调多个页面的时候速度巨慢无比。\n\n```\n.apage {\n  bbizlogic {\n    .actions {\n      .card_wrapper {\n        .card {\n          .title {\n          }\n          .content {\n            .list {\n              .fa {\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n我本人推荐（其实我是写 Python Web 后端的，逃... ) 代码风格比较倾向于 BEM 命名，关于 BEM 的介绍，请参考简单心理团队的教程。\n\n- https://jiandanxinli.github.io/2016-08-11.html\n- https://juejin.im/post/58d0e5caa22b9d00643e8b51\n\n然而，最好的方式，就是读一个非常使用 SCSS 来组织项目的 CSS 代码的成熟项目。\n\n我推荐两个：\n\n- BOOTSTRAP V4: Bootstrap V4 使用 SCSS 来写\n- ELEMENT UI: 饿了么的团队出的，前段时间从 v1 版本升级到 v2 版本，发现网站大部分样式都没有出现大变动，在这里给个赞。\n\n#### 0. 先从整体上设计好骨架\n\n接着才是 HTML, 然后才是 CSS\n\n现在前端入行的人越来越多，很多的新手前端 er 会用比较快的思维来编写，这就导致代码质量奇差无比。\n\n- 哎，我看看，面粉加多了，我加点水，水加多了，我再加点面粉。\n- 哎，我看看，面粉又加多了，我加点水，水加多了，我再加点面粉。\n- 哎，我看看，面粉又加多了，我加点水，水加多了，我再加点面粉。\n- 哎，我看看，面粉又加多了，我加点水，水加多了，我再加点面粉。\n- 哎，我看看，面粉又加多了，我加点水，水加多了，我再加点面粉。\n\n当设计出来的网页本身的 HTML 写的就很混乱，CSS 能写的好在哪里呢？\n\n命名都很混乱，遑论代码可维护性？\n\n可以多去参考一些成熟的项目的 CSS 是怎么命名的呀，HTML 是怎么设计的呀\n\n#### 1. Scoped 的滥用\n\n我印象中，有个小伙伴把一个比较大的 CSS 库多次 import 到被 Scoped 的组件中，于是开发时猛然发现 head 处多了大量的 style 标签，除了 css 选择器后面随机的属性 hash, 文件内容都一样。\n\n\u003e 公共组件往往可以通过嵌套和加前缀的方式来防止污染。如果 scoped 的属性里面有成吨的 style, 慎用 import.\n\n还有小伙伴喜欢在很多七七八八的组件各种 import scss. 其实对于中小型项目，完全可以直接全局一个文件 style 即可。\n\n我现在的做法，是直接在 src 的上方直接用 gulp 搭建一个只用来编译 SCSS 到 CSS 的项目，每次编译后输出到页面里面。\n\n如果项目是小项目，建议直接在 app.vue 里面 import pages\n\n```\n├── common\n├── fonts\n├── global.scss\n├── index.scss\n├── mixins\n├── pages.scss\n└── reset.scss\n```\n\n#### 2. 保持代码的通用性\n\n一般，当同一段逻辑出现三次的时候，是要停下来重构一下的，这样的话，就可以节省很多时间。\n\n套用在 CSS 的样式上也是如此。\n\n## 0x04 Tmux 和 Tmuxnator 打造工作流\n\n具体参考我的文章 [用 Tmux 和 Tmuxnator 打造工作流](l)\n\n---\n\nChangeLog:\n\n- **2017-09-25** 初始化本文\n"}],"total":2},{"name":"2018-07","posts":[{"tags":["调色"],"path":"20180727_ToneColor.md","title":"Tone Color","slug":"Tone Color","date":"2018-07-27","category":"摄影摄像","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n不定期更新。\n\n\u003c!-- more --\u003e\n\n## 0x01 摄影与录像\n\n## 0x02 接口\n\n## 0x03 Sony 录像 Picture Profile\n\n```\nPP1: \"Movie\"\nPP2: \"Still\"\nPP3: \"Natural\"\nPP4: \"Faithful\"\nPP5: \"Cine1\"\nPP6: \"Cine2\"\nPP7: \"S-Log2\"\nPP8: \"S-Log3\" [S-Gamut3.Cine]\nPP9: \"S-Log3\" [S-Gamut3]\n```\n\n## 0xEE 参考链接\n\n---\n\nChangeLog:\n\n- **2018-07-27** 初始化本文\n"},{"tags":["摄像"],"path":"20180718_Portrait.md","title":"人像摄影指北","slug":"人像摄影指北","date":"2018-07-18","category":"摄影摄像","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n### 本文目录\n\n## 0x01 风格特点\n\n### 小清新\n\n- 安静\n- 温暖\n- 舒适\n- 平缓\n- 清新\n- 淡雅\n- 自然\n- 干净\n- 随意\n- 青春的小故事，小情绪\n\n### 色调\n\n冷色系\n\n蓝天\n大海\n白色窗纱\n\n青色 / 蓝色 / 绿色\n\n衣服：白衬衫\n背景：白色窗纱\n曝光补偿\n\n## 0x02 拍摄场景和服装搭配\n\n## 0x03 器材与参数设置\n\n## 0x04 学会用光\n\n最佳时间：日出日落前后两小时。\n\n### 直射光\n\n#### 顺光角度\n\n优点：面部充分受光，皮肤细腻，光滑，水嫩。背景细节丰富，颜色亮丽。\n缺点：面部扁平\n\n#### 侧光角度\n\n优点：五官非常有立体感\n缺点：容易造成阴阳脸\n\nPS: 白种人五官立体，高鼻梁，高眉骨，眼神深邃，立体感强，而黄种人一般面部比较平，一般需要借助侧面打光的的效果。\n\n一般选择 30 度左右即可，看模特身材，要么拍摄对象偏向光源或者摄影师移动。\n\n#### 逆光角度\n\n优点：主体的轮廓光，以及画面中的光晕。\n\n注意点：\n\n- 避免选择比较明亮的天空作为背景\n- 如果正逆光太过明亮，则选择侧逆光，或者主体部分遮挡光晕\n- 大黑脸的问题：设置相机曝光补偿 / 点测光。闪光灯，反光板，白色的墙面，书籍。\n\n### 散射光\n\n阴天，树荫\n\n画面比较单调，人物缺乏立体感，可以通过增加主体的颜色鲜艳度或者加上背景的一些对比（但不要喧宾夺主）\n\n### 夜晚人造灯\n\n商店的微侧面灯光，加上后面的光斑\n\n### 室内光\n\n1. 避免直射光。选择散射光。\n2. 跳闪，反光板\n\n### 其他技巧\n\n1. 让模特走动，然后观察光线，可以先拍一下，查看照片情况\n2. 偏色可以考虑调整白平衡\n3. 杂色过多可以调整\n4. 单光源的，可以考虑墙面 / 闪光灯塑造人瘦脸胖，或者直接暴力点，拿手或者其他东西遮挡。\n\n## 0x05 摆姿技巧\n\n## 0x06 取景技巧\n\n### 跟着光线走\n\n逆光\n局部光\n\n### 跟着背景走\n\n颜色单一的背景，墙面 / 卷帘门 / 复古色墙壁 / 橙色墙壁 / 蓝天 / 草坪\n颜色单一 + 基本点缀的背景，在单一背景的基础上加上另一个单一颜色，对比强烈，但是又不喧宾夺主\n\n### 跟着线条走\n\n- 栏杆 / 护栏\n  - 模特坐 / 靠 / 趴\n- 台阶 / 窗台\n- 两排树 / 过道 / 走廊\n\n### 巧用前景遮挡物\n\n- 虚化掉墙 / 栏杆 / 护栏之类的遮挡物可以引导视线\n\n### 花卉绿植\n\n上下结构，也包括了构图\n单簇，也包括了构图\n\n## 0x08 人像后期\n\n### 磨皮\n\n磨皮包含：\n\n去污\n明度\n饱和度\n色相\n\n#### 简易磨皮 HSL + 清晰度\n\n使用场景\n\n具体操作\n\n1. 降低清晰度 = 磨皮\n2. 提升 HSL 橙色 明度 = 提亮皮肤\n3. 降低 HSL 橙色 饱和度 = 皮肤更白\n4. 微调 HSL 橙色 色相 = 皮肤更粉或者黄一些\n5. 提亮 相机校准-蓝色-饱和度 = 让皮肤更加粉嫩通透\n\n#### 插件磨皮\n\nPortraiture\n\n#### 高反差保留磨皮\n\n高反差保留磨皮，通过通道计算，选出皮肤中脏点污点，然后曲线提亮。\n\n#### 高低频磨皮\n\n高底频 = 图层分为高频图层与低频图层，高频就是所谓的质感（头发，纹理，细节等）, 低频就是光影，也就是皮肤的明暗。在低频图层用插件磨皮或者污点修复，图层工具随意涂抹，也不会影响皮肤的纹路。\n\n复制两个图层，命名为高频和低频。\n\n- 低频启用滤镜-模糊-高斯模糊，值 =6\n- 高频启用图像-应用图像，图层 = 低频，混合 = 相加，缩放 =2\n- 高频混合模式改为线性光，然后污点去除。\n\n#### 中性灰磨皮\n\n#### 双曲线磨皮\n\n### 胶片风格 VSCO\n\n#### Modern Films\n\nModern Films is an excellent all-around pack, emulating the look of contemporary, popular film stocks. Classic, clean, and universal, this collection is well-balanced and ideal for an array of settings, from wedding photography to editorial, and everything in between.\n\n#### Classic Films\n\nClassic Films is a diverse pack of film emulations that recreates the look of many discontinued and expired film stocks. With a vintage-inspired and slightly gritty aesthetic, this collection is perfect for lifestyle, wedding, and portrait photography.\n\n#### Instant Films\n\nInstant Films features digital emulations of beautiful tones and magical tints. Classic and nostalgic, this highly-stylized collection recreates the looks of traditional instant films.\n\n#### Slide Films\n\nSlide Films features digital emulations of positive film — a slide film that produces a positive image when developed. With high contrasts and bold colors, this collection is ideal for travel, landscape, street, and fashion photography.\n\n#### Archetype Films\n\nArchetype Films is a collection of mass market, consumer film emulations from the golden era of analog. With familiar fade and grit aesthetics, VSCO Film 05 captures the nostalgia of old childhood photos, and is great for portraits, weddings, and lifestyle photography.\n\n#### Alternative Process Films\n\nAlternative Process Films is a well-balanced pack that includes a wide range of push and pull processed looks, which alter grain, contrast, and richness. It also includes cross processed looks, which are best suited for dramatic color effects and vibrancy. From subtle enhancements to bold stylistic editing, this collection is ideal for outdoor and lifestyle photography, modern portraiture, and sunwashed settings.\n\n#### Eclectic Films\n\nEclectic Films features a wide range of looks in our largest release to date, with 18 films and over 100 presets in total. The spectrum of this collection translates to versatility in use and includes muted, vivid, tungsten-balanced, and black and white films — all of which embody an elegant and modern aesthetic. This pack is ideal for most settings and subjects, particularly portraits, night photography, and architecture.\n\n### 小清新日系\n\n### 港系风格\n\n高对比，欠曝光，部分过曝光\n\n图层 1 高斯模糊 screen 25% 复制一层 soften light 50%\n\n---\n\nChangeLog:\n\n- **2018-07-17** 初始化本文\n- **2018-09-17** 重修文字\n"},{"tags":["Windows"],"path":"20180710_PhotographyDevice.md","title":"摄影入门指北","slug":"摄影入门指北","date":"2018-07-10","category":"摄影摄像","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n### 本文目录\n\n## 0x01 硬件选择\n\n### 机身\n\na6000 是笔者的第一款相机，a6500 是第二款相机。\n\n之所以这么选择，其实原因很简单 --- 因为贫穷限制了我的设备。\n\n如果觉得花在机身和镜头的钱可以在 3W-4W 左右，出门右转索尼 A7RM3 + 中高端镜头配置。\n\n在预算不足的情况下，为什么是 A6000 和 A6500？\n\n\u003e A6000 基本上入门微单的性价比之王。\n\n所以，我刚入门的时候，选择的是 A6000，当然，如果站在现在的需求角度来说的话，肯定应该是一步到位，直接 A6500 合适（因为现在舍得花这个钱了，当时不舍得）。\n\n当时选择 a6000\n\n1. 具备足够使用的基本功能\n2. 对焦速度快\n3. 性价比高\n4. WIFI/NFC 导图，Sony Play Memory 还是很实用的。\n\n当然，其实这些特点往往都会有个前提，即：\n\n比如说对焦速度快，我实际想说的是，在这个价位下，对焦速度快。\n\n机身往往代表的是机身性能和操作体验上的不同。也就是说，如果只是基本的拍照，比如说只拍人物小清新，A6500 和 A6000 都可以胜任。\n\n我觉得有什么是 A6500 做得到但是 A6000 做不到的呢\n\n但比如说，你拍运动场景或者是拍视频，A6000 的对焦速度明显就跟不上了。究其原因，无非是对焦点位数量少，机器处理性能也不足。究其本质经济原因，无非就是一个字 -- 穷。\n但比如说，你拍完照片相机需要写照片到 SD 卡中。这个过程对于 A6000 是同步的，也就是等待写入完毕才可以进行操作。但是对于 A6500 几乎算是异步的（我猜应该是图片渲染是同步，写入是异步，但由于渲染速度比较快，写入速度比较慢，所以将写入做成了异步）\n\n我觉得有什么是 A6500 改善了我的拍照工作流，但是 A6000 没有改善我的工作流呢？\n\n- 更加流畅：机身性能摆在那\n- 无脑的对焦：触屏对焦 + 加上更加强悍的追焦系统\n- 更好的防抖：在不带三脚架的情况下，五轴防抖的功能可以减少我拍糊掉的几率，特别是光线不够好的情况下。可以让我在一些场景里不需要动用三脚架，轻装上阵。拥有更好的防抖时候可以在 M 档选择更慢的快门，弥补光线上的不足。\n\n笔者比较倾向于抓拍，这两点可以让笔者显著提升抓拍数量和质量，从而选出高质量照片。\n\n摄影是一个综合性的技能，如果你的目的是拍出好看的照片，而不是尝试各种风格 / 场景。 笔者认为选一个超出预算的器材会让你的工作流更加顺畅一些，但并不是必须要换个。\n\n1. 机身性能不足，防抖功能不足的情况下，可以通过预先在心里构思好拍摄。心里多做些推演工作，就好了。\n2. 光线亮度不够，一来可以通过提升周围环境的亮度来解决（打光，闪光灯加柔光罩之类），二来可以提升光圈大小，带上三脚架来提升曝光。三来比如你在夜景下，可以找选择一个比较好场景来拍。比如借助商场的灯完全可以拍个人像大片出来。天时地利人和就没得调整么？非要选个乌漆麻黑的伸手不见五指的拍夜景？\n\n虽然说，一般是越贵的机身越好。\n\n但机身真的那么万能嘛：\n\n- 能解决烂手骚操作么？\n- 能解决烂场景强行拍好片么？\n- 能解决审美问题么？\n- 能引导模特的摆姿么？\n- 能解决外部光线么？\n- 能解决构图么？\n- 能解决后期不会调整么？\n\n帮助真的很有限。\n\n### 镜头\n\n我入手了几款镜头，用下来觉得还行的镜头如下：\n\n#### 适马 E 16\n\n- 根本目标：夜拍\n- 优点：画质好，光学防抖，夜景强行压 ISO\n\n#### 索尼 E 18135\n\n- 根本目标：用于覆盖焦距\n- 优点：画质好，光学防抖\n- 使用状况： 带出\n\n#### 索尼 E 50 1.8\n\n- 根本目标：人像室外专用\n- 优点：近中距离拍妹子好看拍妹子好看拍妹子好看\n- 缺点：小室内拍摄距离比较不好控制。\n- 使用状况： 带出\n\n#### 适马 E 30 1.4\n\n- 根本目标：室内人像、室外人像纪实\n- 优点：近距拍妹子好看拍妹子好看拍妹子好看\n- 缺点：近中距内拍摄容易乱入路人甲。\n- 使用状况： 带出\n\n#### 七巧匠 E 12 2.8\n\n- 根本目标：覆盖广角\n- 优点：经济\n- 使用状况： 带出\n\n```\n# 自带头 E 16-50\t相对而言一般般\t闲置（不过录像效果还是不错滴）\n# 索尼 E 55-210\t远距离拍摄 / 小动物\t看情况（不过拍出来的画面比较肉）\n\n```\n\n### 灯光\n\n布光是摄影师必备技能之一\n\n我入手了一款闪光灯 + 柔光罩，用于弥补某些暗场景下的光线不足的问题。毕竟笔者是业余爱好者，也懒得动用专业的设备了，太折腾。\n\n光线过强的时候，也不是无解，比如阴凉地，透光物体遮挡（透光白色伞 / 镂空的帽子）\n\n### 其他\n\n- 摄影包\n- 充电器\n- 存储卡\n- 其他牌子的电池\n\n## 0x02 摄影参数\n\n曝光正常的参数\n\n### 曝光三要素\n\n#### 光圈\n\n##### 如何影响照片\n\n通关孔的大小影响： - 进光量\n\n##### 影响照片参数\n\n亮度\n景深\n\n##### 使用基本方法\n\n1. 大光圈\n\n- 背景虚化\n- 提升快门速度\n\n2. 小光圈\n\n- 整体清晰\n- 降低快门速度\n\n#### 快门\n\n##### 如何影响照片\n\n进光时间\n\n##### 影响照片参数\n\n##### 使用基本方法\n\n#### 感光度\n\n##### 如何影响照片\n\n    CCD 感光敏感度\n\n##### 影响照片参数\n\n    1. 亮度\n    2. 噪点\n\n##### 使用基本方法\n\n    1. 通常情况下设置比较低\n    2. 除非是光圈和快门被限制\n\n#### 曝光三要素综合应用\n\n    1. 大光圈\n    2. 大长焦\n    3. 镜头离主体要近\n    4. 主体离背景要远\n\n### 曝光模式\n\n自动 / 手动控制曝光\n\n1. 智能自动\n2. P 档：光圈和快门由相机设置，但是 ISO/ 对焦区域 / 测光模式 （比如夜景，当然，可能需要三脚架）\n3. A 档：快门由相机设置，光圈和 ISO 可以自己调节 （比如大光圈的人像，小光圈的风景）\n4. S 档：快门和 ISO 由相机设置，快门 /ISO 由自己调节。（比如快速移动的物品 / 慢速快门拍尾灯拉丝）\n5. M 档：手动档位，可以用于更加细腻的操作。\n\n### 测光模式\n\n1. 多重测光 （多重测光的弊病在于如果整体较亮，而主体较暗，就容易拍不亮主体）\n2. 点测光 （适用于拍摄夕阳 / 逆光人像，缺点就是 ISO 的值会比较高）\n\n### 曝光补偿\n\n笔者一般会用 LR 做一个简单的后期，所以用 RAW 作为图片格式。\n\nRAW 格式要设好曝光参数，一定要曝光相对准确，因为 raw 里面的曝光参数受相机设置直接影响。曝光不准确，特别是曝光过度，希望通过 raw 里面调整，是很难做到曝光准确的画面层次的。\n\n## 0x03 拍清照片\n\n### 对焦错误\n\n    1. 半按快门对焦\n    2. 对焦对偏了\n    \ta. 拍人对焦不准 : 笑脸 / 人脸检测\n    \tb. 拍静物 / 风景时对焦不准 : 自由点对焦\n    \tc. 给自己打光\n    3. 对焦模式不对\n    \ta. AF-S 单次自动对焦 - 静物\n    \tb. AF-C 连续自动对焦 - 动物\n    \tc. AF-A 智能自动对焦 - 对方可能动 / 可能不动\n\n### 手抖了\n\n    1. 拍照姿势不对\n    2. 安全快门时间 = 1 / （焦距 * 1.5)\n    3. 光线比较暗导致快门低于 1/30 s\n\n## 0x04 布光\n\n## 0xEE 结论\n"}],"total":3},{"name":"2018-06","posts":[{"tags":["Nas"],"path":"20180610_SynologyNas.md","title":"Synology 群晖 NAS 入门指北","slug":"Synology 群晖 NAS 入门指北","date":"2018-06-10","category":"碎碎念","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n百度云的人工智障总是误删我的文件，于是开始寻找其他存储方案。决定入手一台 NAS.\n\n### 组装机 / 品牌机\n\n视具体情况，笔者缺乏足够的精力去折腾，如果精力足够，我还是很倾向于自己组装一台 nas 的。不过，现在年纪大了，还是老老实实买个品牌的 NAS 好了，折腾大抵是年轻人的事情。\n\n为啥买群晖？因为看到很多喜欢折腾的人都安装黑群晖，所以直接买了个白群晖。\n\n### 本文目录\n\n```\n▼ 0x00 前言 : section\n    组装机 / 品牌机 : section\n  ▼ 0x01 安装 / 配置 : section\n      STEP-0 设备 : section\n      STEP-1 组装 : section\n      STEP-2 组网 : section\n      STEP-3 安装系统 : section\n  ▼ 0x02 一些私人化的需求 : section\n      2.1 内网 NAS 使用 : section\n      2.2 外网 NAS 使用 : section\n    ▼ 2.3 与百度云结合 : section\n        如何同步数据 : section\n      2.3 Time Machine : section\n    0xEE 结论 : section\n```\n\n## 0x01 安装 / 配置\n\n### STEP-0 设备\n\n- 路由器一台\n- 网线一根\n- Synology 一台，笔者使用的是 DS218j 2 盘位 NAS （这款家用基本上够用了）\n- 硬盘两个，推荐 WD 的红盘或者希捷的狼盘。\n\n### STEP-1 组装\n\n把硬盘安装在 nas 里需要三个步骤\n\n1. 打开 nas 外壳\n2. 把硬盘塞进去\n3. 把盒子盖上\n\n### STEP-2 组网\n\n1. 如果你的路由器可以直连宽带接口的话，则直接连接。\n2. 如果你的路由器上一级有个路由器的话，可以使用桥接模式，把这台路由器连到上一台路由器上。\n\nnas 建议直接用网线连接到路由器上。\n\n那么，现在你的手机 / 笔记本 / 平板等等放到该局域网中。\n\n\u003e PS: 为什么需要这么做？因为所有环境放在一个局域网内的话，安全性和速度较好。\n\n### STEP-3 安装系统\n\n打开群晖机器开关，在同一局域网内的访问\n\nhttp://find.synology.com/\n\n然后按照要求进行注册登陆\n\n期间需要注册群晖的账号，以及本台机器的用户名和密码。\n\n## 0x02 一些私人化的需求\n\n### 2.1 内网 NAS 使用\n\n笔者使用的是 Mac 电脑，在 Finder 中直接链接服务器，输入 smb://mynas 即可访问。剩下的操作基本上和本地磁盘使用起来没有什么大的差别。\n\n对于手机和平板，安装群晖对应的 Drive 即可。\n\n### 2.2 外网 NAS 使用\n\n外网可以直接使用群晖的账号登录群晖的官网，接着控制这台群晖的机器进行下载。但速度不够。\n\n使用下来感觉效果并不好。建议阅读下一章和百度云配合使用。\n\n### 2.3 与百度云结合\n\n百度云这个东西让人又爱又恨。\n\n- 爱的是，容量不错，部分热门资源的下载速度也可。\n- 恨的是，老是莫名其妙删掉我的文件。冷门资源那下载速度真的是....\n\n而现在，现在我的文件就分为两种：\n\n- 一种是合规的不可丢失的文件\n- 一种是合规的可丢失的文件\n\n像我这样贯彻社会主义核心价值观的人，所有文件都是合法合规的。接受文件的审查倒也能接受，但人工智障老是误删我的合法文件这尼玛给我工作生活带来困扰啊。\n\n所以，\n\n- 对于丢失零容忍的文件可以考虑放在 Nas 中。\n- 对于丢失可容忍的文件可以考虑放在百度云中。\n- 对于日常使用的文档可以放在百度云中。\n\n#### 如何同步数据\n\n鉴于百度云开放了应用接口，群晖的 Nas 也可以实现百度云同步数据到 Nas 上。\n\n安装 CloudSync 选择第三方供应商。百度云，完成授权。\n\n设置双向同步到 DMS 的某个文件夹下。比如，笔者同步百度云的文件到本地 DSM /CloudDrive/BaiduPan/ 即完成最基本的设置了。\n\n**如何同步本地数据到云端呢？**\n\n然后随便复制一个文件到该文件夹下，然后在百度云的 Web 端的『我的应用数据 /Cloud Sync 』 文件夹下就可以看到资源了。\n\n**那么，如何同步云端的数据到本地呢？**\n\n把云端的数据（文件 / 文件夹）拖动到 『我的应用数据 /Cloud Sync 』里即可。\n\n像一些非私密性的文件，扔百度云就好了。\n\n这个 Nas 就相当于一个远程的拥有高容量的弱鸡服务器，可以用来跑跑一些下载任务之类。\n\n### 2.3 Time Machine\n\nNas 另一个吸引我的地方就是可以 Time Machine 进行备份了。步骤大致如下。\n\n1. 『共享文件夹』里面新建文件夹 Time Machine\n2. 『文件服务』中开启 SMB/AFP 服务，在高级设置中启用 Bonjour , 启用 SMB/AFP 的 TimeMachine 播送，指定为 Time Machine 文件夹\n3. 『用户管理』里新建用户 TimeMachine, 容量限制一下，建议 1TB 即可。\n4. 打开 Mac 电脑，选择磁盘，然后开始备份。\n\nPS: 但我这边初次备份 TM 的时候，需要备份 300+GB 的文件，速度确实堪忧。和直接外接接口连接硬盘完全没法比。但慢慢备份下来，其实速度也能接受。\n\n## 0xEE 结论\n\nNAS 解决了我的几个痛点。\n\n- 跨平台共享文件\n- 文件集中化管理\n- 硬盘容量大\n- 私密性较好\n- 不会有人工智障来删我东西\n- 速度在可接受范围内。我在用 LR 修图的时候只是稍微比本地的慢一点。\n\n不过似乎还有一些其他的功能可以继续发掘一下。以后有机会再分享一下。\n"},{"tags":["CPython","源码解读"],"path":"20180606_CPython.md","title":"CPython 源码初步阅读笔记","slug":"CPython 源码初步阅读笔记","date":"2018-06-06","category":"Python","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n先挖坑，以后有机会填\n\n├── Grammar # 语法\n├── Include # C 语言头文件，如果需要自定义模块扩展 Python, 也需要这块。\n├── Modules # C 语言编写的模块，对速度要求高，比如 random\n├── Objects # 内建对象 包含整数，list,dict 等。\n├── Parser # Scanner 和 parser\n├── Python # 各种 Python 共享库\n├── Lib # Python 自带的所有标准库\n├── Doc # 文档\n├── Tools # 一些 Python 程序，方便扩展 Python\n├── Misc # 不清楚放哪，就放这里好了\n├── PC # Windows 编译姿势\n├── PCbuild # Windows 编译姿势\n├── Mac # Mac 上编译姿势\n├── Programs\n├── README.rst\n├── aclocal.m4\n├── config.guess\n├── config.sub\n├── configure\n├── configure.ac\n├── install-sh\n├── m4\n├── pyconfig.h.in\n├── setup.py\n├── LICENSE\n├── Makefile.pre.in\n\n## Ch01 Python 对象初探\n\n一切都是对象\n\n类型对象\n\n- 内置对象：int / string / dict\n- 自定义对象：class A\n\n实例对象\n\n### 1.1 Python 内的对象\n\nPython 里的对象就是 C 中结构体在堆上申请的一块内存。\n"}],"total":2},{"name":"2018-05","posts":[{"tags":["Python","DevOps"],"path":"20180523_Fabric2.md","title":"Python 自动化工具 Fabric 支持 Python3","slug":"Python 自动化工具 Fabric 支持 Python3","date":"2018-05-23","category":"DevOps","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n当大家还在纠结 Python2 与 Python3 的时候，我其实早就入了 python3 的门了。\n\n后来\n\n- \u003cdel\u003e我总算学会了如何去爱。\u003cdel\u003e\n- 我喜欢的工具陆陆续续支持了 Python3\n- Scrapy 支持了 Python3\n- Ansible 支持了 Python3\n\n只有 Fabric 这个工具，死撑着没有支持 Python3 的的迹象。\n\n2018-05-08 的时候，Fabric 悄悄升级了 2.0 版本。\n\n而就在前两天，我升级网站的时候，突然发现 fabric (1.14 版本） 不能用了。\n\n查了一下版本，发现 fabric 更新到了 2.0 版本，支持了 python3.4\n\n在发现这个问题之后，火速刷了一波官方文档，把手头 Fabric 1.14 版本的脚本做了一些升级。\n\n### 从 V1 到 V2\n\nFabric v2 基于 invoke 和 paramiko 两个库构建而成。\n\n- invoke 库提供了 subprocess command execution 和 command-line\n- paramiko 提供了 ssh 协议实现\n\n在这两者的基础上，做了一些扩展。\n\n甚至，如果你只用其中的本地功能，你都完全不需要使用 fabric, 直接用 invoke 即可。没错，我已经打算把我的本地脚本全部使用 invoke Python3 化了。\n\nv1 版本和 v2 版本初步用起来，个人觉得 v1 用起来 API 更加符合直觉一些。\n\n这东西怎么用呢？\n\n我们先定义 fabfile\n\n```\n# fabfile.py\nfrom invoke import task\n\ndef expand_path(c, path):\n    return '\"$(echo %s)\"' % path\n\ndef exists(c, path):\n    cmd = 'stat %s' % expand_path(c, path)\n    return c.run(cmd, warn=True, hide=True).ok\n\n@task\ndef deploy(c):\n    c.local(\"youcmd\")\n    c.put()\n    c.get()\n    c.run()\n    c.run(\"sudo youcmd\")\n    ......\n\n@task\ndef other_stuff(c):\n    ......\n```\n\n需要注意的是，invoke 里面默认的 replace_env 设置为了 False ,fabric 里面给 runner 设置了 replace_env 为 True , 这也就意味着默认情况下，执行 c.local 的时候会找不到自定义的环境变量，这意味着：\n\n1. 你的 PATH 被重置了，这意味着你用 brew 安装的软件可能已经完全找不到了。\n2. 你的环境变量 LANG 并不一定是 en_US.UTF-8 了\n\n于是设置一下。\n\n```\n# ~/.fabric.py\n#!/usr/bin/env python\n# encoding: utf-8\n\nrun = {\n    \"replace_env\": False\n}\n```\n\n当我要部署的时候直接执行\n\n```\nfab -H webserver01,webserver02,webserver03,webserver04 deploy\n```\n\n到这里大家基本上看出来了，我并没有在文件中 import fabric 只是简单了配置了一个配置文件和执行一下 fab 命令。\n\n这个 v2 版本的 fabric 相当于 invoke 的包装。但我们也可以显式的 import fabric 里面的东西进行更加进阶的操作。\n"},{"tags":["PipEnv"],"path":"20180523_PipEnv.md","title":"PyCon 2018 之 pipenv -- 未来的 Python 依赖管理工具","slug":"PyCon 2018 之 pipenv -- 未来的 Python 依赖管理工具","date":"2018-05-23","category":"Python","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\nPyCon 2018 有很多精彩的演讲，今天的文章里，介绍一下 K 神的演讲 『Python 未来的包管理工具 pipenv』\n\nKenneth Reitz 出品，必属精品。\n\n### Python 打包历史\n\n刚开始的时候，我们是这样安装包的。\n\n```\ncurl http://pypi.python.org/packages/alsdasdl/requests.tar.gz | tar zxf\ncd requests/\npython setup.py install\n```\n\n这个问题初看起来不是问题，但是随着你安装程序的增多就知道有多么痛苦了。\n\n1. 有的依赖库依赖别的库你怎么解决？比如 pandas 需要安装 numpy\n2. 有的依赖库依赖 c 库怎么办？比如 LXML\n3. 在 python2.6.5 下，如果我需要安装两个不同版本的 Django 开发不同的软件怎么办？难道只能动态复制文件到 site-packages 里面？\n\n后来，我们是这样安装包的。\n\n```\neasy_install requests\n```\n\n我们可以直接从 pypi 进行安装了。但尼玛，为什么 easy_install 安装很 easy, 但是没有 easy_uninstall?\n\n好，2010 年后，我们继续前进：\n\n- 可以通过 pip 替代 easy_install 了。\n- 可以通过 virtualenv 管理项目的依赖库了。虽然说，还是不能像 ruby gem 一样同时把多个版本的的软件装在同一个系统里。\n- 可以通过 requirements 锁依赖了。\n\n但，同期的其他编程语言社区分别出现了如下的包管理工具：\n\n- node -\u003e yarn \u0026\u0026 npm , 有 lockfile\n- php -\u003e composer , 有 lockfile\n- rust -\u003e cargo , 有 lockfile\n- ruby -\u003e bundler , 有 lockfile\n\n而我大 Python 居然没跟上潮流\n\n- python -\u003e pip \u0026\u0026 virtualenv/venv , 无 lockfile\n\n\u003e PS: Python3.3 之后，默认可以直接使用 venv 模块，不需要再安装 virtualenv 了。但还是需要手动，并且用起来比较反直觉。\n\n关于 requirements.txt\n\n- 如果你使用 pip freeze 来形成这个文件，则不直观，完全看不出来哪个依赖库依赖哪个依赖。\n- 如果你直接手动指定你所需要的库，比如 flask 的话，似乎又有些太直观了。\n\n如果能有一个东西，既可以表示 freeze 的结果 (what you want)，又可以表示你需要的库 (what you need). 就好了。\n\n\u003e 这当然可以考虑用两份 requirements 来解决。先安装 what you need 用来开发，然后 freeze 为 what you want 去部署。\n\n当然，铺垫了这么多 K 神肯定是来介绍他的 pipenv 的。\n\n比如说，我想查看，本项目的依赖库，直接 pipenv graph\n\n```\ncoverage==4.5.1\nfabric==2.0.1\n  - cryptography [required: \u003e=1.1, installed: 2.2.2]\n    - asn1crypto [required: \u003e=0.21.0, installed: 0.24.0]\n    - cffi [required: \u003e=1.7, installed: 1.11.5]\n      - pycparser [required: Any, installed: 2.18]\n    - idna [required: \u003e=2.1, installed: 2.6]\n    - six [required: \u003e=1.4.1, installed: 1.11.0]\n  - invoke [required: \u003c2.0,\u003e=1.0, installed: 1.0.0]\n  - paramiko [required: \u003e=2.4, installed: 2.4.1]\n    - bcrypt [required: \u003e=3.1.3, installed: 3.1.4]\n      - cffi [required: \u003e=1.1, installed: 1.11.5]\n        - pycparser [required: Any, installed: 2.18]\n      - six [required: \u003e=1.4.1, installed: 1.11.0]\n    - cryptography [required: \u003e=1.5, installed: 2.2.2]\n      - asn1crypto [required: \u003e=0.21.0, installed: 0.24.0]\n      - cffi [required: \u003e=1.7, installed: 1.11.5]\n        - pycparser [required: Any, installed: 2.18]\n      - idna [required: \u003e=2.1, installed: 2.6]\n      - six [required: \u003e=1.4.1, installed: 1.11.0]\n    - pyasn1 [required: \u003e=0.1.7, installed: 0.4.2]\n    - pynacl [required: \u003e=1.0.1, installed: 1.2.1]\n      - cffi [required: \u003e=1.4.1, installed: 1.11.5]\n        - pycparser [required: Any, installed: 2.18]\n      - six [required: Any, installed: 1.11.0]\nflake8==3.5.0\n  - mccabe [required: \u003e=0.6.0,\u003c0.7.0, installed: 0.6.1]\n  - pycodestyle [required: \u003c2.4.0,\u003e=2.0.0, installed: 2.3.1]\n  - pyflakes [required: \u003e=1.5.0,\u003c1.7.0, installed: 1.6.0]\n# 其他省略\n```\n\n如何尝鲜？我最近更新到了之前写的一个库（代码写的惨不忍赌，最近准备重构，勿喷）\n\n```\ngit clone git@github.com:twocucao/YaPyLib.git\ncd YaPyLib/\nbrew install pipenv\npipenv --three\npipenv install --dev\npipenv shell\n```\n\n记住几个命令\n\n```\npipenv --venv # 查看 venv 位置\npipenv --python 3.6.5\nexit 退出 pipenv shell\n```\n\n至于其他的功能，参考官网自己摸索吧。\n\n### FAQ 环节\n\nFAQ 环节有一个问题非常有趣，应该把 lockfile 放在 git 仓库里面吗？\n\nk 神是这么回答的 yes。 这个问题很久之前就在 issue 上回答过了\n\nhttps://github.com/pypa/pipenv/issues/598\n\n我刚开始觉得不提交会好一些，后来觉得 track 一下也无妨。\n\n## 写在最后\n\n\u003e 在用 npm 和 yarn 的时候，我有这么一个想法，希望 python 圈子里面能出一个类似于包管理工具。今年 2 月份的时候把自己的项目迁移过来，发现 pipenv 用起来很挺舒服的。\n\n\u003e pipenv 是未来。火速用上吧。\n\n\u003e 觉得有趣就点个赞或者关注下呗。\n"},{"tags":["Django"],"path":"20180516_PyConDjango.md","title":"PyCon 2018 之 Django 专题","slug":"PyCon 2018 之 Django 专题","date":"2018-05-16","category":"Django","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\nPyCon 2018 有很多精彩的演讲，今天的文章里，挑出 Django 的几篇演讲大致讲讲。\n\n\u003e 注意：为什么是大致讲讲呢？因为即便是你看了我的这篇文章，依然需要多下点功夫自己去看演讲，自己去查资料，自己去消化。我的这篇文章只不过是我看演讲查资料慢慢消化过程中的产物而已。\n\n## 0x01 演讲 1 - Taking Django Async\n\n本演讲其实就是为了推广 Django 的新库。django-channels\n\n这个库从 2015 年首发，现在已经经过了三年的进程。应该算是相对成熟了。\n\n这个库有什么不走寻常路的地方吗？答案是有的：\n\n1. 使得 Django 增加了异步协议，比如说 WebSocket 协议\n2. 使得 Django 可运行后台任务。\n\n作为 v2 版本的核心开发，作者必然是要吐槽一下 v1 版本，然后推荐一下 v2 版本。\n\nv1 版本的架构设计是这样的。\n\n核心开发给出了这样的评价：\n\n1. 在 Python2.7 的时候，就只能这么搞了。\n2. 需要维护的东西太多\n3. 没有 asyncio support\n4. 搬砖时候一不小心容易砸到脚\n\n\u003e TODO : 补充一些其他的缺点\n\n异步与同步接口耦合\n\n作者认为此并非长久之计。\n\nv2 时候，\n\n重写 75% 的代码\n\n异步与同步接口分离\n\n这么设计的话，需要解决接下来的一个问题，同步转异步，异步转同步。\n\n比如，我访问 view, 实际上是 async 转 sync, 然后才能调用 django 相关的方法，接着返回响应内容的时候，我还需要 sync 转 async.\n再比如，我使用 websocket, 访问一条数据，但 ORM 是 sync 的方法，我还是要 async 转 sync 再转 async\n\n这个 async 和 sync 的相互转换应该怎么做呢？\n\n于是，两个适配方法就诞生了：\n\n- sync_to_async : 接收一个 async 的 function, 使之 awaitable, 然后使之在后台线程里运行。\n- async_to_sync : 接收一个 awaitable 的 coroutine , 使之转化成一个同步的 function, 该 function 暂停你调用的当前的线程，跳转到包含 eventloop 的主线程执行完毕，然后跳转回来。\n\nhttps://www.aeracode.org/2018/02/19/python-async-simplified/\n\n### WSGI 如何运行 async\n\n### ASGI 如何运行 A\n\n### 这对 Django 意味着什么？\n\n### 如何保持兼容性\n\n## 0x02 演讲 2 - Beyond Django Basic\n\n作为一名有一定经验的 Django 开发者，用快进的方式看完了这个演讲。毕竟，我已经不是 Django 新手了。\n\n\u003e 毕竟这篇演讲只是给那些学完 tutorial 的人\n\n想深入了解 Django, 多刷几遍文档比什么都好。\n\n嗯，就不介绍了。\n\n## 0x03 演讲 3 - Introduction to TDD with Django \u0026\u0026 Intermediate testing with Django\n\n本演讲主要内容是 TDD 测试和 Mock 的技巧。\n\n建议熟手直接看演讲者的书吧，本视频本人仅仅匆匆倍速看了一遍，估计并没有超出他的书的范围。\n\n简单介绍了以下内容\n\n- 单元测试和功能性测试\n- 通过 Selenium browser 进行自动化测试\n- unittest 标准库\n- Django models, views and templates\n- 测试前后端代码\n- 基于测试的重构\n- TDD workflow\n\n地址如下\n\nhttps://www.obeythetestinggoat.com/book/praise.harry.html\n\n说说个人对测试和 TDD 测试的基本态度，我觉得测试是好事，适当的测试是可以提升代码质量和程序稳定性的。\n\n说测试会降低开发速度的，八成是没有善用测试。如果测试拖慢了你的开发速度，只能说明没有进行合适的测试，比如对一些无关紧要的功能进行测试。\n\n但，这篇演讲和配套资料很好，不过有些美中不足。 这里基本上都还在用 Django 的 MTV 这一套。\n\n\u003e 我反正是不用这一套了。这个年头流行 SPA 呀。\n\n所以，我们这篇演讲指的关注的内容就变成如下内容了。\n\n- 单元测试和功能性测试\n- unittest 标准库\n- Django models\n- 基于测试的重构\n- TDD workflow\n\n而且，对于 API 的测试，现在基本上流行 POSTMAN\n\n用 POSTMAN 的优点就在于可以把参数缓存下来下次接着用。有个小技巧就是从 chrome 拷贝一下 curl 到 postman 中。非常好用。\n\n既然流行 SPA, 那么本次有没有介绍开 API 的利器呢？\n\n## 0x04 演讲 4 - API-Driven Django\n\n嗯，Django + django-rest-framework 实在是开 WebAPI 的神器。\n\n这篇演讲，算是普及了一下常识。并没有想象当中的深入。\n\n想用 Django 和 DjangoRestFramework 搞事情的，可以过来看我这篇文章。\n\nhttps://zhuanlan.zhihu.com/p/33903527\n\n\u003e 需要注意的是，本次 PyCon 中有很多人已经用上了 pipenv 了。\n\n## 0x05 演讲 5 - pipenv 未来的 Python 包管理工具\n\nKenneth Reitz 出品，必属精品。\n\n### Python 打包历史\n\n刚开始，我们是这样安装包的。\n\n```\ncurl http://pypi.python.org/packages/alsdasdl/requests.tar.gz | tar zxf\ncd requests/\npython setup.py install\n```\n\n这个问题初看起来不是问题，但是随着你安装程序的增多就知道有多么痛苦了。\n\n1. 有的依赖库依赖别的库你怎么解决？比如 pandas 需要安装 numpy\n2. 有的依赖库依赖 c 库怎么办？比如 LXML\n3. 在 python2.6.5 下，如果我需要安装两个不同版本的 Django 开发不同的软件怎么办？难道只能动态复制文件到 site-packages 里面？\n\n后来，我们是这样安装包的。\n\n```\neasy_install requests\n```\n\n我们可以直接从 pypi 进行安装了。但尼玛，为什么 easy_install 安装很 easy, 但是没有 easy_uninstall?\n\n好，2010 年后，我们继续前进：\n\n- 可以通过 pip 替代 easy_install 了。\n- 可以通过 virtualenv 管理项目的依赖库了。虽然说，还是不能像 ruby gem 一样同时把多个版本的的软件装在同一个系统里。\n- 可以通过 requirements 锁依赖了。\n\n但，其他编程语言社区分别出现了如下的包管理工具：\n\n- node -\u003e yarn \u0026\u0026 npm , 有 lockfile\n- php -\u003e composer , 有 lockfile\n- rust -\u003e cargo , 有 lockfile\n- ruby -\u003e bundler , 有 lockfile\n\n而生命苦短一方居然\n\n- python -\u003e pip \u0026\u0026 virtualenv/venv , 无 lockfile\n\n\u003e PS: Python3.3 之后，默认可以直接使用 venv 模块，不需要再安装 virtualenv 了。但还是需要手动，并且用起来比较反直觉。\n\n关于 requirements.txt\n\n- 如果你使用 pip freeze 来形成这个文件，则不直观，完全看不出来哪个依赖库依赖哪个依赖。\n- 如果你直接手动指定你所需要的库，比如 flask 的话，似乎又有些太直观了。\n\n如果能有一个东西，既可以表示 freeze 的结果 (what you want)，又可以表示你需要的库 (what you need). 就好了。\n\n\u003e 这当然可以考虑用两份 requirements 来解决。先安装 what you need 用来开发，然后 freeze 为 what you want 去部署。\n\n当然，铺垫了这么多 K 神肯定是来介绍他的 pipenv 的。\n\n比如说，我想查看，本项目的依赖库，直接 pipenv graph\n\n```\ncoverage==4.5.1\nfabric==2.0.1\n  - cryptography [required: \u003e=1.1, installed: 2.2.2]\n    - asn1crypto [required: \u003e=0.21.0, installed: 0.24.0]\n    - cffi [required: \u003e=1.7, installed: 1.11.5]\n      - pycparser [required: Any, installed: 2.18]\n    - idna [required: \u003e=2.1, installed: 2.6]\n    - six [required: \u003e=1.4.1, installed: 1.11.0]\n  - invoke [required: \u003c2.0,\u003e=1.0, installed: 1.0.0]\n  - paramiko [required: \u003e=2.4, installed: 2.4.1]\n    - bcrypt [required: \u003e=3.1.3, installed: 3.1.4]\n      - cffi [required: \u003e=1.1, installed: 1.11.5]\n        - pycparser [required: Any, installed: 2.18]\n      - six [required: \u003e=1.4.1, installed: 1.11.0]\n    - cryptography [required: \u003e=1.5, installed: 2.2.2]\n      - asn1crypto [required: \u003e=0.21.0, installed: 0.24.0]\n      - cffi [required: \u003e=1.7, installed: 1.11.5]\n        - pycparser [required: Any, installed: 2.18]\n      - idna [required: \u003e=2.1, installed: 2.6]\n      - six [required: \u003e=1.4.1, installed: 1.11.0]\n    - pyasn1 [required: \u003e=0.1.7, installed: 0.4.2]\n    - pynacl [required: \u003e=1.0.1, installed: 1.2.1]\n      - cffi [required: \u003e=1.4.1, installed: 1.11.5]\n        - pycparser [required: Any, installed: 2.18]\n      - six [required: Any, installed: 1.11.0]\nflake8==3.5.0\n  - mccabe [required: \u003e=0.6.0,\u003c0.7.0, installed: 0.6.1]\n  - pycodestyle [required: \u003c2.4.0,\u003e=2.0.0, installed: 2.3.1]\n  - pyflakes [required: \u003e=1.5.0,\u003c1.7.0, installed: 1.6.0]\n# 其他省略\n```\n\n如何尝鲜？我最近更新到了之前写的一个库（代码写的惨不忍赌，最近准备重构）\n\n```\ngit clone git@github.com:twocucao/YaPyLib.git\ncd YaPyLib/\nbrew install pipenv\npipenv --three\npipenv install --dev\npipenv shell\n```\n\n至于其他的功能，参考官网自己摸索吧。\n\n\u003e 在用 npm 和 yarn 的时候，我有这么一个想法，希望 python 圈子里面能出一个类似于包管理工具。今年 2 月份的时候把自己的项目迁移过来，发现 pipenv 用起来很挺舒服的。\n\n\u003e pipenv 是未来。火速用上吧。\n\n## 0xEE 参考链接\n\n---\n\nChangeLog:\n\n- **2018-03-09** 重修文字\n"}],"total":3},{"name":"2018-04","posts":[{"tags":["Django","ORM"],"path":"20180428_DjangoORMCheatSheet.md","title":"DjangoORM CheatSheet","slug":"DjangoORM CheatSheet","date":"2018-04-28","category":"Django","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n本文是《Python ORM 三部曲的第二部 - Django ORM 的用法 / 原理 / 优化》\n\n上一部的地址为《Python ORM 三部曲的第一部 - Python ORM 的三种实现模式》\n\n本文基于最新 Django 版本\n\n1. 模型定义\n2. Create/Update/Delete\n3. 各种查询 / 链式调用 / F 表达式 / Window 函数 /Lazy Loading / Eager Loading\n4. Join\n5. DEBUG 和 Profile 技巧\n\n本文是《Python ORM 三部曲的第一部 - Python 的三种数据源架构模式》\n\n本文适用于：\n\n1. 好奇 or 喜欢折腾的程序员\n2. 想深入了解 ORM 的程序员\n\n本文将解决你以下的疑惑：\n\n1. 能不能不用 ORM?\n2. ORM 为什么在某些场景下会胜于写 SQL\n3. 不同的 ORM 实现机制会带来什么差异？\n\n## 0x00 前言\n\n新工作的技术栈是以 Flask 为主，SQLAlchemy 是 许多玩 Flask 的人的标配。好，文档读起来，笔记搞起来。\n\n\u003e 所以，本文记录的是 Django ORM\n\n逃。\n\n这篇文章也是我对比 SqlAlchemy 以及 DjangoORM 的产物\n\n## 0x01 如何快速上手\n\nDjango 世界里面，Django 的文档每次刷都会有新的发现。\n\n## 0x02 DjangoORM 的基本功能\n\n### 2.1 模型定义 Model\n\n```\nfrom django.db import models\n\nclass Musician(models.Model):\n    first_name = models.CharField(max_length=50) # Field\n    last_name = models.CharField(max_length=50)\n    instrument = models.CharField(max_length=100)\n\nclass Album(models.Model):\n    artist = models.ForeignKey(Musician, on_delete=models.CASCADE)\n    name = models.CharField(max_length=100)\n    release_date = models.DateField()\n    num_stars = models.IntegerField()\n\n    class Meta: # Model Meta\n        order_with_respect_to = 'question'\n```\n\n可以看出，包含如下的部分：\n\n1. Model 与 Model 内部的 Meta\n2. Field 与 Field 内部的 Options\n3. Model 与 Model 之间的关系\n4. 其他，比如索引\n\n#### Models 与 Meta\n\n\u003e DjangoORM 是 ActivityRecord 模式的一种实现，在该模式下，Model 与 session 耦合。\n\n#### Field 与 Field Options\n\n##### Field\n\n- AutoField\n- BigAutoField\n- BigIntegerField\n- BinaryField\n- BooleanField\n- CharField\n- DateField\n- DateTimeField\n- DecimalField\n- DurationField\n- EmailField\n- FileField\n- FileField and FieldFile\n- FilePathField\n- FloatField\n- ImageField\n- IntegerField\n- GenericIPAddressField\n- NullBooleanField\n- PositiveIntegerField\n- PositiveSmallIntegerField\n- SlugField\n- SmallIntegerField\n- TextField\n- TimeField\n- URLField\n- UUIDField\n\n虽然有这么多东东，其实常用的如下\n\n- BigIntegerField\n- BooleanField\n- CharField\n- DateField\n- DateTimeField\n- DecimalField\n- IntegerField\n- TextField\n- TimeField\n\n有的字段属于那种，有也可以，没有也可以的。\n\nFileField 之类的 往往现在都被 CDN 取代\n\n##### Field Options\n\n- null\n- blank\n- choices\n  - p.shirt_size\n  - p.get_shirt_size_display()\n- db_column\n- db_index\n- db_tablespace\n- default\n- editable\n- error_messages\n- help_text\n- primary_key\n- unique\n- unique_for_date\n- unique_for_month\n- unique_for_year\n- verbose_name\n- validators\n\n如此可见，Django 的 ORM 比起 SQLAlchemy 做了不少应用层的校验，一些 help_text\n\n#### Relationship\n\n表和表之间的关系\n\n1. A 表和 B 表 一对多 / 多对一\n2. A 表和 B 表 一对一 （特殊的一对多）\n3. A 表和 B 表 简单多对多 （借助中间的 Mapping 表进行映射）\n4. A 表和 B 表 复杂多对多\n5. A 表和 B 表 一对多\n\n```\nfrom django.db import models\n\nclass Manufacturer(models.Model):\n    # ...\n    pass\n\nclass Car(models.Model):\n    manufacturer = models.ForeignKey(Manufacturer, on_delete=models.CASCADE)\n    # ...\n```\n\n```\nfrom django.db import models\n\nclass Topping(models.Model):\n    # ...\n    pass\n\nclass Pizza(models.Model):\n    # ...\n    toppings = models.ManyToManyField(Topping)\n```\n\n```\nfrom django.db import models\n\nclass Person(models.Model):\n    name = models.CharField(max_length=128)\n\n    def __str__(self):\n        return self.name\n\nclass Group(models.Model):\n    name = models.CharField(max_length=128)\n    members = models.ManyToManyField(Person, through='Membership')\n\n    def __str__(self):\n        return self.name\n\nclass Membership(models.Model):\n    person = models.ForeignKey(Person, on_delete=models.CASCADE)\n    group = models.ForeignKey(Group, on_delete=models.CASCADE)\n    date_joined = models.DateField()\n    invite_reason = models.CharField(max_length=64)\n```\n\n```\nModels across files\n```\n\n```\nobjects\n```\n\n```\nModels 重写方法\n```\n\n```\nModels 继承\nhttps://docs.djangoproject.com/en/2.0/topics/db/models/#model-inheritance\n```\n\n```\n组织代码 - 以及应对循环引用\n```\n\n### 2.2 QuerySet\n\n#### Create\n\n```\nc = Child(name=\"苏轼\")\nc.save()\np = Parent(name=\"苏辙\")\np.best_child = c\np.children.add([c,c2,c3,c4])\np.save()\n```\n\n#### Retrieve\n\n过滤\n\nfilter(**kwargs)\nexclude(**kwargs)\n.all()\n\n##### 跨关系（跨表）查询\n\nBlog.objects.filter(entry**headline**contains='Lennon')\n\nhttps://docs.djangoproject.com/en/2.0/topics/db/queries/#lookups-that-span-relationships\n\nhttps://docs.djangoproject.com/en/2.0/topics/db/queries/#spanning-multi-valued-relationships\n\n##### prefetch_related \u0026\u0026 select_related\n\n```\nselect_related\n\n生成 join 的 SQL, 可以用来减少 N+1 , 不过仅仅支持一对多，和一对一\n\nprefetch_related\n```\n\n##### Limit / Offset / 分页\n\nBlog.objects.filter(entry**headline**contains='Lennon')[30:20]\n\n##### 链式调用\n\nquery = query.filter(**kwargs)\nquery = query.exclude(**kwargs)\n\n##### 表达式\n\nDjango 里面最强大的就是其 Q 表达式了\n\nQ(question**startswith='Who') | Q(question**startswith='What')\n\nPoll.objects.get(\nQ(question\\_\\_startswith='Who'),\nQ(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6))\n)\n\n这个表达式甚至可以嵌套超级深从而完成一个比较深的跨表查询。\n\n\u003e 并且，这种 API 查询反而在写前端 API 的时候，可以传入 question\\_\\_startswith 这类参数，从而直接完成一组搜索。\n\nQ / F\n\n##### 执行查询\n\n需要注意的的是，SQLAlchemy 必须显式执行查询，而 Django 不一定。\n\nhttps://docs.djangoproject.com/en/2.0/ref/models/querysets/#when-querysets-are-evaluated\n\n在 Django 内部实现的时候，一个 queryset 创建 / 过滤 / 切片 / 传送，**除非这个 queryset 被 evaluated 了**, 否则不会做数据库的操作。\n\n- iteration\n- Slicing\n- Pickling/Caching\n- repr\n- len\n- list\n- bool\n\n```\nall()\nfirst()\nlast()\nexist()\n```\n\n##### 比较\n\n- pk\n- model\n\n##### 复制 实例\n\n```\nblog = Blog(name='My blog', tagline='Blogging is easy')\nblog.save() # blog.pk == 1\n\nblog.pk = None\nblog.save() # blog.pk == 2\n\n# 但这个并不拷贝外键？???\nhttps://docs.djangoproject.com/en/2.0/topics/db/queries/#copying-model-instances\n```\n\n##### 其他\n\n```\n# 默认查询的是所有字段，但我希望查询部分字段\n# TODO: 阿萨德\n# Distinct\n# OrderBy\n\n```\n\n##### 缓存机制\n\nhttps://docs.djangoproject.com/en/2.0/topics/db/queries/#caching-and-querysets\n\n#### Update\n\n单个 object 更新\n\n```\nblog.title = \"大宝天天见\"\nblog.save()\n```\n\n批量更新\n\n```\nquery.update(headline=F('blog__name'))\n```\n\n一对多的更新（类似于 Set 操作）\n\n```\nadd(obj1, obj2, ...)\ncreate(**kwargs)\nremove(obj1, obj2, ...)\nclear()\nset(objs)\n```\n\n#### Delete\n\n##### ForeignKey\n\n```\nclass Car(models.Model):\n    manufacturer = models.ForeignKey(\n        'production.Manufacturer', # 用来解决循环 circular import\n        on_delete=models.CASCADE,\n    )\n```\n\non_delete 的情况\n\n- PROTECT 阻止\n- CASCADE 应用层的级联删除\n- SET_NULL 应用层的级联 SET_NULL\n- SET_DEFAULT\n- DO_NOTHING\n- SET() 一个 callback\n\n#### 聚集查询\n\nhttps://docs.djangoproject.com/en/2.0/topics/db/aggregation/\n\n```\nBook.objects.all().aggregate(Max('price'))\nBook.objects.aggregate(price_diff=Max('price', output_field=FloatField()) - Avg('price'))\nBook.objects.annotate(num_authors=Count('authors'))\nBook.objects.annotate(num_authors=Count('authors')).aggregate(Avg('num_authors')) # {'num_authors__avg': 1.66}\n```\n\n#### Search\n\nhttps://docs.djangoproject.com/en/2.0/topics/db/search/\n\n#### Window Function\n\n```\nOption.objects.annotate(\n\t\trank_num=Window(\n\t\t\t\texpression=Rank(),\n\t\t\t\tpartition_by=F(\"vote_id\"),\n\t\t\t\torder_by=[F(\"current_vote_count\").desc(), F(\"id\").desc()],\n\t\t),\n\t\tlag_vote_num=Window(\n\t\t\t\texpression=Lag(\"current_vote_count\"),\n\t\t\t\tpartition_by=F(\"vote_id\"),\n\t\t\t\torder_by=[F(\"current_vote_count\").desc(), F(\"id\").desc()],\n\t\t),\n)\n.filter(vote=obj.vote)\n.order_by(\"-current_vote_count\", \"id\")\n.values(\"id\", \"rank_num\", \"current_vote_count\", \"lag_vote_num\")\n```\n\n### 2.2 Model Instances\n\nhttps://docs.djangoproject.com/en/2.0/ref/models/instances/\n\n### 2.3 模型实例\n\n### 2.4 迁移机制\n\n1. 加 INSTALLED_APPS\n\n## 0x03 Django ORM 的高级功能\n\n### maneger\n\nhttps://docs.djangoproject.com/en/2.0/topics/db/managers/\n\n### raw sql\n\nhttps://docs.djangoproject.com/en/2.0/topics/db/sql/\n\n#### database-fuction\n\nhttps://docs.djangoproject.com/en/2.0/ref/models/database-functions/\n\n## 0x04 Database Access Optimization\n\n### 4.1 使用连接池\n\n连接池是一种永远在线模型的实现\n\n连接池：驱动程序类型\n\n连接池：代理类型\n\n### 4.2 减少对 MySQL 的访问\n\n```\nselect count(*) from pg_stat_activity where pid \u003c\u003e pg_backend_pid() and usename = current_user;\n\n```\n\n### Before\n\n```\nselect count(*) from pg_stat_activity where pid \u003c\u003e pg_backend_pid() and usename = current_user;\n\n```\n\n### Profile First\n\n1. django-extentions\n2. django-debug-toolbar\n\n手动\n\n```\nqueryset.explain\n\nfrom django.db import connection\nconnection.queries\n\nfrom django.db import reset_queries\nreset_queries()\n```\n\n## 0x05 Django ORM Under The Hood\n\n### 理解 QuerySet\n\n- querysets-are-lazy when-querysets-are-evaluated\n  - Iteration\n  - Slicing\n  - Pickling/Caching\n  - len\n  - repr\n  - list\n  - bool\n\n```\nobj == nobj # obj.id == nobj.id\n```\n\n- caching-and-querysets\n\n### 理解 cached attributes\n\n```\n\u003e\u003e\u003e entry = Entry.objects.get(id=1)\n\u003e\u003e\u003e entry.blog   # Blog object is retrieved at this point\n\u003e\u003e\u003e entry.blog   # cached version, no DB access\n\n\u003e\u003e\u003e entry = Entry.objects.get(id=1)\n\u003e\u003e\u003e entry.authors.all()   # query performed\n\u003e\u003e\u003e entry.authors.all()   # query performed again\n```\n\n## 0xEE 参考链接\n\n---\n\nChangeLog:\n\n- **2018-03-09** 重修文字\n"}],"total":1},{"name":"2018-03","posts":[{"tags":["Flask","ORM"],"path":"20180331_SQLAlchemyCheatSheet.md","title":"SQLAlchemy CheatSheet","slug":"SQLAlchemy CheatSheet","date":"2018-03-31","category":"Flask","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\nSQLAlchemy 入门，看本文就好了\n\n## 0x00 前言\n\n大约一年前，工作从 Django 开发切到 Flask 开发，ORM 选用的是 SQLAlchemy, 用了大半年后，借着这个机会重新回顾一下 SQLAchemy 和 Django ORM, 补充一下文档。\n\n这篇文章算是笔记吧\n\nPython 圈内有两大 ORM 框架\n\n- SQLAlchemy\n- Django ORM\n\n当然，也有 peewee 之类的其他 ORM。\n\n## 0x01 ORM 解决了什么问题？\n\n了解一个框架，最好是从下面几处入手：\n\n- 官方 Tuorial\n- 官方 Example\n- 官方 Guide\n- 官方 APIDocument\n- 源码\n\n对框架掌握越深，就越需要使用者多多从上开始逐渐向下了解。\n\n其实还有一些途径：\n\n- Github 上面的 issue\n- Stack Overflow 的高 vote 常见问题\n- **如果作者有一些活跃的社区的话，可以火速前往**\n\n鉴于我们的目标在于入手，所以可以火速过一下：\n\n- 官方 Tuorial\n- 官方 Example\n- 官方 Guide\n- Github 上面的 issue\n- Stack Overflow 的高 vote 常见问题\n- **如果作者有一些活跃的社区的话，可以火速前往**\n\n## 0x02 SQLAlchemy 的基本功能\n\n### 2.0 SQLAlchemy VS DjangoORM\n\nORM 通常有 DataMapper 实现和 ActiveRecord 实现两种。\n\n依照我的经验，ActiveRecord 使用起来的更接近对象 (Object) 的操作，DataMapper 使用起来更接近 (Table) 的操作。\n\n\u003e SQLAlchemy 是 DataMapper 模式的实现，在该模式下，session 会暴露出来，即 Model 与 session 并不耦合。\n\n\u003e DjangoORM 是 ActivityRecord 模式的一种实现，在该模式下，session 并不暴露出来，即 Model 与 session 耦合。\n\n使用 Django ORM 的时候，往往是\n\n```\nb = Blog(**data)\nb.save()\n```\n\n使用 SQLAlchemy 的时候，往往是\n\n```\nb = Blog(**data)\nsession.add(b)\nsession.session(b)\n```\n\n由于 Django 帮你屏蔽了 session 的操作。\n\n在通常情况下，\n\n1. DjangoORM 使用起来更加接近 Object 的操作。\n2. SQLAlchemy 使用起来更加接近 Table 的操作。\n\n举个例子，\n\n一对多，Father 添加两个小孩（其中一个小孩是已经存在的）\n\n在 DjangoORM 里面， 这里更像是一个 Set 的 add 操作。\n\n```\nfather.children.add(new_child,exsit_child)\n```\n\n在 SQLAlchemy 里面，这里更像是一个 table 的 insert 操作。（麻蛋，你要说是一个 list 的 append 操作也行）\n\n```\nfor child in (new_child,exsit_child):\n    if child in father.children:\n        father.children.append(child)\n```\n\n\u003e 写 SQLAlchemy 更接近操作放在数据库里面的数据记录，而 DjangoORM 更接近操作一批放在数据库里面的对象。\n\n由于 session 的使用姿势不同，所以往往会有很多使用上面的区别。\n\n至于孰优孰劣，难以评判。\n\n- 技术老大 (Flask 和 React 大神）倾向于使用 SQLAlchemy, 他认为\n\n  - 对于一个技术『知其然，知其所以然』\n  - 对于 ORM\n    - 操作数据库，操作最好要落实在成 SQL\n    - 如果有可能的话，每一个 SQL 语句都要经过推敲，而且写这个 SQL 和 ORM 过程要反复练习\n  - 对于 Migration 机制\n    - Alembic 这个迁移工具是为了省事用的，甚至在某些情况下没必要用。完全可以写 SQL 代替\n\n- 我 (Django 和 Vue 弱鸡）倾向于使用 DjangoORM, 我认为\n  - 对于一个技术『先知其大致然，需要深入的时候知其所以然』\n  - 对于 ORM\n    - 操作数据，最好抽象为对对象的操作。\n    - 测试到位的情况下，快糙狠先出东西。到需要优化的时候该怎么 Profile 怎么 Profile\n  - 对于 Migration 机制\n    - 用起来啊，能操作对象为什么还要强行到数据库操作？\n\n### 2.1 模型定义\n\n先看一组模型\n\n```python\nfrom sqlalchemy.ext.declarative import declarative_base\nBase = declarative_base() # 模型基类\nfrom sqlalchemy import Column, Integer, String\nclass User(Base):\n    __tablename__ = 'users'\n\n    id = Column(Integer, primary_key=True) # 主键\n    name = Column(String)\n    fullname = Column(String)\n    password = Column(String)\n\n    def __repr__(self):\n       return \"\u003cUser(name='%s', fullname='%s', password='%s')\u003e\" % (\n                            self.name, self.fullname, self.password)\nBase.metadata.create_all(engine)\n```\n\n可以看出，包含如下的部分：\n\n1. Model 与 Model 内部的 Meta\n2. Field 与 Field 内部的 Options\n3. Model 与 Model 之间的关系\n4. 其他，比如索引\n\n#### Models 与 Meta\n\nhttps://github.com/zzzeek/sqlalchemy/blob/master/lib/sqlalchemy/sql/schema.py#L3685\n\n#### 关系\n\n##### One To Many\n\n母亲有若干个孩子，外键在孩子上。\n\n```\nclass Parent(Base):\n    #...\n    children = relationship(\"Child\", backref=\"parent\")\n\nclass Child(Base):\n    #...\n    parent_id = Column(Integer, ForeignKey('parent.id'))\n```\n\n##### Many To One\n\n多个母亲共享一个孩子，外键在母亲上。\n\n```\nclass Parent(Base):\n    child_id = Column(Integer, ForeignKey('child.id'))\n    child = relationship(\"Child\")\n\nclass Child(Base):\n    # ...\n```\n\n##### One To One\n\nOne to One 是 One to Many 或者是 Many to One 的简化版本\n\n```\n# Many To One\nclass Parent(Base):\n    # ...\n    child_id = Column(Integer, ForeignKey('child.id'))\n    child = relationship(\"Child\", backref=backref(\"parent\", uselist=False))\n\nclass Child(Base):\n    # ...\n\n# One To Many 改 One To One\nclass Parent(Base):\n    # ...\n\nclass Child(Base):\n    # ...\n    parent_id = Column(Integer, ForeignKey('parent.id'))\n    parent = relationship(\"Parent\", backref=backref(\"child\", uselist=False))\n```\n\n##### Many To Many\n\n```\nassociation_table = Table('association', Base.metadata,\n    Column('left_id', Integer, ForeignKey('left.id')),\n    Column('right_id', Integer, ForeignKey('right.id'))\n)\n\nclass Parent(Base):\n    # ...\n    children = relationship(\"Child\",\n                    secondary=association_table,\n                    backref=\"parents\")\n\nclass Child(Base):\n    # ...\n```\n\n注意事项\n\n执行删除 mapping 表的时候尽量这样。\n\n```bash\nmyparent.children.remove(somechild)\n```\n\n当你想干掉 somechild 的时候，会执行\n\n```\nsession.delete(somechild)\n```\n\n1. 假如 Child 没有 ref Parent 的话，Secondary Table 无删除，则无法删除。\n2. 假如 ref 了的话，则删除 secondary 里面的记录。\n3. TODO\n\n##### 邻接列表关系\n\n```\nclass Node(Base):\n    __tablename__ = 'node'\n    id = Column(Integer, primary_key=True)\n    parent_id = Column(Integer, ForeignKey('node.id'))\n    data = Column(String(50))\n    children = relationship(\"Node\",\n                backref=backref('parent', remote_side=[id])\n            )\n```\n\n##### relationship 详解\n\n### 2.1 Query\n\n#### Create\n\n```\nc1 = Child(name=\"苏轼\")\nsession.add(c1)\nsession.flush()\np = Parent(name=\"苏辙\")\np.best_child = c1\nfor c in [c1,c2,c3,c4]:\n    p.children.append(c)\nsession.add(c1)\nsession.commit()\n```\n\n#### Retrieve\n\n过滤\n\nfilter(\\*\\*kwargs)\nfilter(Singer.name == \"周杰伦\")\nfilter(Singer.name =! \"周杰棍\")\n\n##### 跨关系（跨表）查询\n\nsession.query(Entry).join(Blog,Blog.entry_id == Entry.id).filter(Blog.name = \"SqlAlchemy CheatSheet\")\n\n##### Limit / Offset / 分页\n\n- limit()\n- offset()\n\n##### 链式调用\n\n```\nquery = session.query(Order) # query = session.query(Order)\nquery = query.filter(Order.name.like(f\"%name%\"))\n```\n\n##### 二进制表达式\n\n我们先 type 一下表达式，找到 eq 的类型\n\n```python\ntype(model.column_name == 'asdf') → sqlalchemy.sql.elements.BinaryExpression\n```\n\n是一个二进制表达式。\n\n```python\n# 等于\nquery.filter(User.name == 'ed')\n# 不等于\nquery.filter(User.name != 'ed')\n# Like（有的数据库不区分大小写）\nquery.filter(User.name.like('%ed%'))\n# ILIKE (case-insensitive LIKE)\nquery.filter(User.name.ilike('%ed%'))\n# IN\nquery.filter(User.name.in_(['ed', 'wendy', 'jack']))\n# Not in\nquery.filter(~User.name.in_(['ed', 'wendy', 'jack']))\n# IS NULL\nquery.filter(User.name == None)\n## 如果你用了 pep8/linter 的话\nquery.filter(User.name.is_(None))\n# IS NOT NULL:\nquery.filter(User.name != None)\n## 如果你用了 pep8/linter 的话\nquery.filter(User.name.isnot(None))\n# AND\n## use and_()\nquery.filter(and_(User.name == 'ed', User.fullname == 'Ed Jones'))\n## or send multiple expressions to .filter()\nquery.filter(User.name == 'ed', User.fullname == 'Ed Jones')\n## or chain multiple filter()/filter_by() calls\nquery.filter(User.name == 'ed').filter(User.fullname == 'Ed Jones')\n# OR\nquery.filter(or_(User.name == 'ed', User.name == 'wendy'))\n# MATCH\nquery.filter(User.name.match('wendy'))\n```\n\n##### 执行查询\n\n```\nall()\nfirst()\none()\none_or_none()\nscalar()\n```\n\nYourModel.query.get((pk1, pk2))\n\n##### 比较\n\n\u003e 同一个 Session 下面，取到的某一条数据对应的 objects 应该是一样的？\n\n##### 复制 实例\n\n##### 其他\n\n```\n# 查询的是 SomeModel 里面所有的字段 即 select *\nquery = session.query(SomeModel)\n# 查询的是 SomeModel 里面部分的字段 即 select acol, bcol\nquery = session.query(SomeModel.acol,SomeModel.bcol)\n# 即 select acol , bcol\n# alias\nuser_alias = aliased(User, name='user_alias')\nfor row in session.query(user_alias, user_alias.name).all():\n    # 即相当于 select name as name_label\n    print(row.user_alias)\n\n# limit 和 offset\nfor u in session.query(User).order_by(User.id)[1:3]:\n    print(u)\n\n# distinct\nsession.query(model.Name).distinct(model.Name.value).order_by(model.Name.value)\n# order_by\nUser.query.order_by(User.popularity.desc(),User.date_created.desc()).limit(10).all()\n```\n\n#### Update\n\n单个 object 更新\n\n```\nblog.title = \"大宝天天见\"\nsession.add(blog)\nsession.commit()\n```\n\n批量更新\n\n```\nsession.query.filter(Blog.content.like(\"% 敏感词 %\")).update({\n    Blog.content: \"依照相关 XX 无法查看\"\n})\n```\n\n一对多的更新\n\n```\nappend\n```\n\n#### Delete\n\nquery.delete()\n\n#### JOIN\n\nhttps://stackoverflow.com/questions/6044309/sqlalchemy-how-to-join-several-tables-by-one-query\n\n##### 两表 InnerJoin\n\n```python\nfor u, a in session.query(User, Address).\\\n                    filter(User.id==Address.user_id).\\\n                    filter(Address.email_address=='jack@google.com').\\\n                    all():\n    print(u)\n    print(a)\n# \u003cUser(name='jack', fullname='Jack Bean', password='gjffdd')\u003e\n# \u003cAddress(email_address='jack@google.com')\u003e\n\n```\n\n##### 多表 InnerJoin + LeftJoin\n\n```\nquery.outerjoin(User.addresses)   # LEFT OUTER JOIN\n```\n\n#### 聚集查询\n\n```\nsession.query(User).filter(User.name.like('%ed')).count()\n```\n\n```\nfrom sqlalchemy import func\nsession.query(Table.column, func.count(Table.column)).group_by(Table.column).all()\n\nself.session.query(func.count(Table.column1),Table.column1, Table.column2).group_by(Table.column1, Table.column2).all()\n\nfrom sqlalchemy.sql import func\nsession.query(func.avg(Rating.field2).label('average')).filter(Rating.url==url_string.netloc)\n```\n\n#### 缓存机制\n\nQuery 对象，下文中，我会聊到这个 Query 对象。这里先跳过。\n\n### 2.2 原生查询\n\n```\nfrom sqlalchemy import text\n\nsql = text('select name from penguins')\nresult = db.engine.execute(sql)\nnames = []\nfor row in result:\n    names.append(row[0])\n\nprint names\n\nfrom collections import namedtuple\n\nRecord = namedtuple('Record', result.keys())\nrecords = [Record(*r) for r in result.fetchall()]\nfor r in records:\n    print(r)\n\nfrom sqlalchemy.sql import text\n\nconnection = engine.connect()\n\n# recommended\ncmd = 'select * from Employees where EmployeeGroup == :group'\nemployeeGroup = 'Staff'\nemployees = connection.execute(text(cmd), group = employeeGroup)\n\n```\n\nget_or_create\n\n```\ndef get_or_create(session, model, defaults=None, **kwargs):\n    instance = session.query(model).filter_by(**kwargs).first()\n    if instance:\n        return instance, False\n    else:\n        params = dict((k, v) for k, v in kwargs.iteritems() if not isinstance(v, ClauseElement))\n        params.update(defaults or {})\n        instance = model(**params)\n        session.add(instance)\n        return instance, True\n```\n\n### 2.3 更新查询\n\n```\nsession.query(Stuff).update({Stuff.foo: Stuff.foo + 1})\n```\n\n```\n1) for c in session.query(Stuff).all():\n       c.foo += 1\n   session.commit()\n\n2) session.query().\\\n       update({\"foo\": (Stuff.foo + 1)})\n   session.commit()\n\n3) conn = engine.connect()\n   stmt = Stuff.update().\\\n       values(Stuff.foo = (Stuff.foo + 1))\n   conn.execute(stmt)\n```\n\n```\n1) user.no_of_logins += 1\n   session.commit()\n\n2) session.query().\\\n       filter(User.username == form.username.data).\\\n       update({\"no_of_logins\": (User.no_of_logins +1)})\n   session.commit()\n\n3) conn = engine.connect()\n   stmt = User.update().\\\n       values(no_of_logins=(User.no_of_logins + 1)).\\\n       where(User.username == form.username.data)\n   conn.execute(stmt)\n\n4) setattr(user, 'no_of_logins', user.no_of_logins+1)\n   session.commit()\n```\n\n### 2.4 删除\n\nhttps://stackoverflow.com/questions/5033547/sqlalchemy-cascade-delete\n\n#### OnDelete\n\nondelete='CASCADE'))\n\n#### 批量操作\n\nmodels.User.query.delete()\n\n### 如何从 Object 到一个 ORM\n\n如何追踪 Object 的变化？\n\n## 0x03 SQLAlchemy 的高级特性\n\n### 表继承\n\nhttps://stackoverflow.com/questions/1337095/sqlalchemy-inheritance\n\n### 啥玩意\n\nFlush 和 commit\n\nhttps://stackoverflow.com/questions/4201455/sqlalchemy-whats-the-difference-between-flush-and-commit\n\n```\nx = Foo(bar=1)\nprint x.id\n# None\nsession.add(x)\nsession.flush()\n# BEGIN\n# INSERT INTO foo (bar) VALUES(1)\n# COMMIT\nprint x.id\n```\n\n```\nqry = DBSession.query(User).filter(\n        and_(User.birthday \u003c= '1988-01-17', User.birthday \u003e= '1985-01-17'))\n```\n\n## 0x04 SQLAlchemy 的基础特性 Under The Hood\n\n### Loading 策略\n\n#### Lazy Loading\n\n#### Eager Loading\n\n```\n\u003e\u003e\u003e from sqlalchemy.dialects import postgresql\n\u003e\u003e\u003e print str(q.statement.compile(dialect=postgresql.dialect()))\nWhere q is defined as:\n\n```\n\n## 0x05 SQLAlchemy 的高级特性 Under The Hood\n\n### 多线程\n\nhttps://stackoverflow.com/questions/6297404/multi-threaded-use-of-sqlalchemy\nhttps://stackoverflow.com/questions/9619789/sqlalchemy-proper-session-handling-in-multi-thread-applications\n\n```\n\nhttps://stackoverflow.com/questions/34322471/sqlalchemy-engine-connection-and-session-difference\nhttps://stackoverflow.com/questions/11769366/why-is-sqlalchemy-insert-with-sqlite-25-times-slower-than-using-sqlite3-directly\nhttps://stackoverflow.com/questions/12223335/sqlalchemy-creating-vs-reusing-a-session\nsession 是个容器\n\nhttps://stackoverflow.com/questions/18199053/example-of-what-sqlalchemy-can-do-and-django-orm-cannot\nhttps://stackoverflow.com/questions/7389759/memory-efficient-built-in-sqlalchemy-iterator-generator\n\n# 日志\nimport logging\nlogging.basicConfig()\nlogging.getLogger('sqlalchemy.engine').setLevel(logging.INFO)\n```\n\n## 0x06 DEBUG 和 Profile 技巧\n\n```\nSQLALCHEMY_TRACK_MODIFICATIONS = False\n```\n\n### 6.1 查看技巧\n\ndict(u)\nu.**dict**\n\nhttps://stackoverflow.com/questions/1171166/how-can-i-profile-a-sqlalchemy-powered-application\n\n如果用上 Flask+SQLAlchemy 一般也要带上，Flask-Migration 与 Flask-SQLAlchemy, 这两个库也是对 Alembic 和 SQLAlchemy 的浅封装。\n\n那么，对于这个 ORM 库还有那些通用性的知识需要了解？\n\n嗯，是时候了解本质了。\n\nhttp://derrickgilland.com/posts/demystifying-flask-sqlalchemy/\n\n## 0x07 ORM 的本质\n\nORM 的本质是 Data Access Layer 上的一层封装。如果你写原生 SQL, 即手写 DAL 的话，开发效率可能会大打折扣。\n\n### ORM 的两种类型 Active Record 与 Data Mappers\n\n```\n# ActiveRecord 风格写起来类似于 Django ORM, 大致是这样的\n\n## AR 的模型定义\n\nclass User(db.models):\n    name = db.StringField(verbose=\"xyz\")\n\n## AR 的新增\nuser = User()\nuser.name = \"123456\"\nuser.save() ## 正好对应数据库中的一行\n\n## AR 的查询\n\nusers = User.objects.filter(Q(name=\"黄老板的小姨子\")).all()\n\n# Data Mappers 风格写起来类似于 SQLAlchemy ORM, 大致是这样的\n\n## SA 的定义\n\nfrom sqlalchemy.ext.declarative import declarative_base\n\nBase = declarative_base()\n\nfrom sqlalchemy import Column, Integer, String\nclass User(Base):\n    __tablename__ = 'users'\n\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n\nBase.metadata.create_all(engine)\n\n## SA 的新增\n\nuser = User()\nuser.name = \"123456\"\nsession.add(user)\nsessoon.commit() ## 嗯？其实也是对应数据库中的一行。\n\n## SA 的查询\n\nsession.query(User).filter(User.name)\n\n```\n\n问题来了，这两者到底是什么，看起来似乎相差不大。\n\n```\nclass Person:\n\n    lastname\n    firstname\n    children\n\n    # 数据操作\n    def findone(self):\n        pass\n\n    def insert(self):\n        pass\n\n    def update(self):\n        pass\n\n    def delete(self):\n        pass\n\n    # 业务逻辑\n    def getChildrenTax(self):\n        pass\n\n```\n\nlastName firstName numberOfDependents\n\ninsert update delete\n\ngetExemption isFlaggedForAudit getTaxableEarnings\n\nAn object that wraps a row in a database table or view, encapsulates the database access, and adds domain logic on that data.\n\nThe essence of an Active Record is a Domain Model (116) in which the classes match very closely the record structure of an underlying database. Each Active Record is responsible for saving and loading to the database and also for any domain logic that acts on the data. This may be all the domain logic in the application, or you may ﬁnd that some domain logic is held in Transaction Scripts (110) with common and data-oriented code in the Active Record.\n\nThe data structure of the Active Record should exactly match that of the database: one ﬁeld in the class for each column in the table. Type the ﬁelds the way the SQL interface gives you the data—don’t do any conversion at this stage. You may consider Foreign Key Mapping (236), but you may also leave the foreign keys as they are. You can use views or tables with Active Record, although updates through views are obviously harder. Views are particularly useful for reporting purposes.\n\nobjects correspond directly to the database tables: an isomorphic schema. If your business logic is complex, you’ll soon want to use your object’s direct relationships, collections, inheritance, and so forth. These don’t map easily onto Active Record, and adding them piecemeal gets very messy. That’s what will lead you to use Data Mapper (165) instead.\n\nAnother argument against Active Record is the fact that it couples the object design to the database design. This makes it more difﬁcult to refactor either design as a project goes forward.\n\nActive Record is a good pattern to consider if you’re using Transaction Script (110) and are beginning to feel the pain of code duplication and the difﬁculty in updating scripts and tables that Transaction Script (110) often brings. In this case you can gradually start creating Active Records and then slowly refactor behavior into them. It often helps to wrap the tables as a Gateway (466) ﬁrst, and then start moving behavior so that the tables evolve to a Active Record.\n\n其实为什么不选择设计成 ActiveRecord , 而是选择设计成 Data Mapper, 其实就可以回答这个问题：\n\n\u003e 虽然要设计成 ORM, 考虑到数量和性能因素，SQL 数据库（多个表）并不应该是表现像 Object 集合那样（换言之，也就是 AR 表现的像 Object 的集合一样）。\n\u003e 同时，出于更好的抽象，object 集合也应该表现的像表以及行\n\n于是我们可以得出结论，可以在 SQLAlchemy 上面进行一定的封装，使得最后用起来非常的 Django ORM like，其实 SQLAlchemy 稍加定制还是可以很 Django ORM-like 的。\n\n:TODO: 有机会看看那本书再修改一下本小节\n\n这不，果然有人就这么搞了 https://github.com/absent1706/sqlalchemy-mixins\n\n## 0x09 踩坑集\n\n### 关系持久化坑\n\n1. Rows that point to themselves : 比如一个 insert 一个推荐自己的用户，则需要保存 id / ref_id , 但是在这个 user 插入之前，并不存在 id. 所以，一般情况下是先 insert, 然后保存 ref_id\n2. Mutually Dependent Rows\n\n### SQL 注入\n\nsession.query(MyClass).filter(\"foo={}\".format(getArgs['val']))\n\n## 0xEE 参考链接\n\n- https://www.eversql.com/django-vs-sqlalchemy-which-python-orm-is-better/\n- https://stackoverflow.com/questions/2546207/does-sqlalchemy-have-an-equivalent-of-djangos-get-or-create\n- 除了文档本身，作者在 Stack Overflow 上的回答都是非常值得阅读的。https://stackoverflow.com/users/34549/zzzeek\n- Patterns of Enterprise Application Architecture - Martin Fowler\n- http://aosabook.org/en/sqlalchemy.html\n\n  http://techspot.zzzeek.org/\n\n---\n\nChangeLog:\n\n- **2018-03-09** 重修文字\n"},{"tags":["Python","Flask"],"path":"20180309_Flask文档阅读笔记.md","title":"Flask 文档阅读笔记","slug":"Flask 文档阅读笔记","date":"2018-03-09","category":"Flask","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n因为最近需要新增一个 Flask 技术栈，所以准备趁这休息的时候更新关于 Flask 的两篇文章。\n\n前者是文档阅读笔记，后者是源码初步解析。\n\n\u003e 嗯，其实这篇就是做了一些搬运的活。\n\n## 0x01 文档\n\n由于 Flask 还依赖 Jinja2 与 Werkzeug, 并且往往大家在使用 Flask 的时候还是会使用 itsdangerous. 所以，当大家说 Flask 代码少的时候，我还是不服的。但如果你说，Flask 本身实现确实是简洁，扩展性强，我还是服气的。\n\nFlask 的文档有三种类型（其他框架类文档也是如此）：\n\n- Tutorial 类，即教程类\n- Guide 类，即指南类\n- API 类，即接口级别的文档\n\n当你是一个老手，还想快速上手一个框架的时候，认真读一读前两者，然后挑选一个项目多看几遍即可。\n\n但是当你深入到框架里面的设计与实现的时候，则必须要多读读 API Document , 由于通常情况下 API Document 的内容往往是代码中的注释，加上 Flask 代码量本来就不多。所以，有的时候阅读 Flask 代码代码也会比 API 好很多。\n\n## 0x02 Guide\n\n### 2.1 Templates\n\n快速 Get 模板语言无非就是掌握：\n\n1. 上下文变量\n2. 条件语法\n3. 列表语法\n4. 模板的继承 (extend 语法）与组合 (include)\n5. 额外的一些语法糖，比如 filter 的使用 / 组成\n\n### 2.2 Testing Flask Applications\n\n\u003e Something that is untested is broken.\n\n这里的测试，有哪些测试呢？\n\n1. 非 flask 相关逻辑的测试。比如，我对一小段无关于 View 层的纯粹的逻辑进行测试，我比较喜欢使用 pytest 进行测试。\n2. Flask 相关\n\n- Setup\n- TearDown\n- 登录前 / 登陆后\n\n### 2.3 Application Errors\n\n比如测试请求与响应结果。比如测试路由。测试某个与 View 层绑定的数据操作是否执行成功。\n\n首先，大致扫一眼 tutorial ，知道了 Flask 的教程讲了如下的东西：\n\n1. 路由\n2. 静态文件\n3. 模板渲染\n4. 接触请求数据\n5. 重定向和错误\n6. 响应\n7. Session\n8. Message Flash\n9. 日志\n10. 扩展\n\n当然，我们都是老手了，肯定是挑重点来看了。\n\nRouting, 发现现在的问题在于\n\nFlask 有两个主要依赖：\n\n- 路由、调试、WSGI\n- 模板\n\n## 0x02 社区支持\n\n## 0x04 读文档产生的疑问\n\n1.\n\nFor web applications it’s crucial to react to the data a client sends to the server. In Flask this information is provided by the global request object. If you have some experience with Python you might be wondering how that object can be global and how Flask manages to still be threadsafe. The answer is context locals:\n\nContext Locals\nInsider Information\nIf you want to understand how that works and how you can implement tests with context locals, read this section, otherwise just skip it.\n\nCertain objects in Flask are global objects, but not of the usual kind. These objects are actually proxies to objects that are local to a specific context. What a mouthful. But that is actually quite easy to understand.\n\nImagine the context being the handling thread. A request comes in and the web server decides to spawn a new thread (or something else, the underlying object is capable of dealing with concurrency systems other than threads). When Flask starts its internal request handling it figures out that the current thread is the active context and binds the current application and the WSGI environments to that context (thread). It does that in an intelligent way so that one application can invoke another application without breaking.\n\nSo what does this mean to you? Basically you can completely ignore that this is the case unless you are doing something like unit testing. You will notice that code which depends on a request object will suddenly break because there is no request object. The solution is creating a request object yourself and binding it to the context. The easiest solution for unit testing is to use the test_request_context() context manager. In combination with the with statement it will bind a test request so that you can interact with it. Here is an example:\n\n### Thread Local\n\nOne of the design decisions in Flask was that simple tasks should be simple; they should not take a lot of code and yet they should not limit you. Because of that, Flask has a few design choices that some people might find surprising or unorthodox. For example, Flask uses thread-local objects internally so that you don’t have to pass objects around from function to function within a request in order to stay threadsafe. This approach is convenient, but requires a valid request context for dependency injection or when attempting to reuse code which uses a value pegged to the request. The Flask project is honest about thread-locals, does not hide them, and calls out in the code and documentation where they are used.\n"},{"tags":["Python","Flask"],"path":"20180309_Flask源码解析.md","title":"Flask 源码初步解读","slug":"Flask 源码初步解读","date":"2018-03-09","category":"Flask","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n系列文章先暂时停更一下。今天换换口味。\n\n久闻 Flask 是众多 Pythonist 喜欢的框架。这次借着换工作的机会熟悉一下 Flask\n\n1. 本文先分享我阅读代码的一些小经验\n2. 接着通过最简单的一个 WSGI APP 开始，带着**如何设计一个 Web 框架**这个问题，先头脑风暴，从而脑补（而不是实现）出一个 Web 框架的基本要素。\n3. 从源码角度理解，Flask 从启动到接受第一个请求、返回第一个响应期间都发生了什么。\n4. 最后交代一些自己在这个过程中的一些突发的想法。\n\n\u003e 将解读 Flask 的源码放在一篇文章里，势必会造成广度有余而深度不足。所以本想定位于 Flask 源码初步解读。\n\n## 0x01 阅读 Flask 代码的一种较好的姿势\n\n之前在 https://www.zhihu.com/question/28509408/answer/299763091 分享过自己一点阅读代码的粗浅的经验，是以阅读一个 Django 的应用为案例的。这里借着读 Flask 本身分享一下我的看法。\n\n读源码，是一个技术活。一是忌讳要想读懂全部，另一个忌讳是以为自己能一下子毫无障碍的读懂全部代码。\n\n0. 建议 0 : 看源码的时候，**务必务必带着问题去读**。每一次阅读其实都是在尝试回答或小或大的问题（当然，读书看文章莫不如是）。\n1. 建议 1 : 先读现成的文档，不要上来就对着代码一通瞎看。\n2. 建议 2 : 所谓『横看成岭侧成峰，远近高低都不同』 你需要从不同的角度来读源码。\n3. 建议 3 : 抓大放小，该略读就略读（比如知道 Nginx 的大致作用就好，做优化请求响应的时候再翻看文档），该精读则精读（具体一个关键的功能）。\n\n\u003e 好，坐好，预备，开车。\n\n## 0x02 问题 1: 如何设计一个 Web 框架\n\n### 头脑风暴\n\nFlask 是一个微 Web 框架，换而言之，代码量少的 Web 框架。当然，其实 Flask 框架是一个微框架，但『常规的 Flask 应用』本身的代码加起来一点都不比『Django 应用』少。这个地方我们后面会讲到。\n\n在阅读 Flask 相关代码的之前，先头脑风暴一下：\n\n\u003e 如何设计一个 Web 框架？\n\n当心中对这个问题有一定的了解之后，读 Flask 代码会更好。\n\n首先，Web 框架是为了提升 Web 开发的。(XX 框架是为了提升 XX 开发的）, 这种提升可能会是 开发体验 / 性能。\n\n我们来看看那个 Python 世界最基础的 wsgi app 相关代码。\n\n```python\ndef application(environ, start_response):\n    start_response('200 OK', [('Content-Type', 'text/plain')])\n    return ['Hello World!']\n```\n\n在之前的文章，我也借 Django 的 DRF 提到过这个极简的代码。\n\n但这个简单的 webapp，显然是啥玩意都不够用的。比如说：\n\n- 没有路由，我访问啥玩意都是 hello world。\n- 单线程 IO 阻塞模型基本上啥都不能干。你比如说，启动这个 webapp 的时候在 return 数据之前直接 sleep 十秒，然后请求都进不来。\n- 没有数据存取，连个数据库链接 CURDE 啥玩意都没有\n- environ 太过于底层，如果是判断 headers 啥的太麻烦，要是像 django 里面一样能拿到一个 request 对象返回一个 response 对象就好了。\n- 没有模板语言\n- 还有其他能够提升开发体验的东西，比如自带 http server 代码热加载之类。\n\n```python\ndef application(environ, start_response):\n    # 直接 thread local 支持多个请求。\n    # 依据 environ 判断路由\n    # 依据 路由 执行相关 view 层方法\n    # 在相关 view 层方法内执行相关逻辑\n    start_response('200 OK', [('Content-Type', 'text/plain')])\n    # 返回对应响应\n    return response\n```\n\n当然，思路是这么个思路，这个思路也确实非常的命令式，非常的面向过程。\n\n至于我们如何把这个面向过程的思路变成面向对象的设计与实现，则需要更加细致的思考这些问题。\n\n1. 能不能把 request 和 response 封装一下？方便在 view 里面处理？\n2. 能不能有个 URLDisparch 之类的东西，帮你解决 url 和 view 的 mapping 问题。或者路由能不能直接搞成 装饰器类型的比如 @router(\"/\") 直接放在 view 层的 function 上。\n3. 能不能有个方便对数据库进行 CURDE 的东西？比如 ORM/ODM\n4. 这玩意会不会线程不安全，假如我想每一个请求都有单独的变量集合的话，线程怎么管理？\n5. ......\n\n### 设计 Web 框架\n\n利用 Flask 作者的另一个库 werkzeug 的案例中有这么一个东西。\n\nhttps://github.com/pallets/werkzeug/blob/master/examples/shortly/shortly.py\n\n几百行代码就不贴在这里了。仔细看看还是挺有趣的。 这个可以算作另一个超简的 Webapp 了。\n\nFlask 算作在这个基础上进行一定的扩展而成。\n\n看完上面这个就可以出去吹牛逼可以自己写一个极简 Web 框架了。\n\n那么，你可能有疑问，为何有了 Flask 之后，是否需要看这个更底层的 Werkzeug 的库，当然，有必要咯，Python 世界除了老牌的比较流行的 Django/Flask, 还有一个新星，叫做 APIStar\n\nhttps://github.com/encode/apistar\n\n## 0x02 问题 2: 请求流程是怎么样的\n\n我们就拿这个 flask 的极简案例，进行**首次**阅读 Flask 代码。\n\n```python\n# hello.py\nfrom flask import Flask\n\napp = Flask(__name__)\n\n@app.route('/')\ndef hello():\n    return 'Hello, World!'\n\n$ FLASK_APP=hello.py flask run\n```\n\n\u003e 从请求到响应的整个流程，Flask 的是怎么处理请求的？\n\n### 2.1 服务器是怎么起来的\n\n首先 flask run 之后，发生了什么？\n\n先初始化环境变量，然后导入 dotenv 文件，然后执行 run_command 方法，找到 hello.py 然后导入\n\n```python\n#cli.py#run_command 方法\napp = DispatchingApp(info.load_app, use_eager_loading=eager_loading)\n# 上一行代表着其实我们每次在本地 flask run 的时候，起的服务并不是 flask_app, 而是被 DispatchingApp 包装了一层的 flask app\n\nfrom werkzeug.serving import run_simple\nrun_simple(host, port, app, use_reloader=reload, use_debugger=debugger,\n            threaded=with_threads, ssl_context=cert)\n```\n\n进行这层包装之后，就可以显示 WERKZEUG 的所谓在浏览器中的 报错信息了。\n\n通常开发时这里的 run_simple 最后会调用 run_with_reloader , 每当程序退出的时候，reloader 就依照策略重新跑一次 reload 一次。\n\n```python\ndef run_with_reloader(main_func, extra_files=None, interval=1,\n                      reloader_type='auto'):\n    \"\"\"Run the given function in an independent python interpreter.\"\"\"\n    import signal\n    reloader = reloader_loops[reloader_type](extra_files, interval)\n    signal.signal(signal.SIGTERM, lambda *args: sys.exit(0))\n    try:\n        if os.environ.get('WERKZEUG_RUN_MAIN') == 'true':\n            t = threading.Thread(target=main_func, args=())\n            t.setDaemon(True)\n            t.start()\n            reloader.run()\n        else:\n            sys.exit(reloader.restart_with_reloader())\n    except KeyboardInterrupt:\n        pass\n```\n\n好，服务起来了。\n\n### 2.2 请求-响应的流程\n\n我们先看 Flask 类里面的比较关键的两个方法：\n\n```python\nclass Flask(_PackageBoundObject):\n    # 一些方法 ......\n    def full_dispatch_request(self):\n        # 主要是执行一些方法，最后返回响应\n        self.try_trigger_before_first_request_functions()\n        try:\n            request_started.send(self)\n            rv = self.preprocess_request()\n            if rv is None:\n                rv = self.dispatch_request()\n        except Exception as e:\n            rv = self.handle_user_exception(e)\n        # ??? TODO\n        return self.finalize_request(rv)\n\n    # 这里是我们熟悉的 environ, 和 start_response\n    def wsgi_app(self, environ, start_response):\n        \"\"\"\n        :param environ: a WSGI environment\n        :param start_response: a callable accepting a status code,\n                               a list of headers and an optional\n                               exception context to start the response\n        \"\"\"\n        # 在这里对 environ 进行封装，创建请求上下文\n        ctx = self.request_context(environ)\n        error = None\n        try:\n            try:\n                # 这里将请求上下文压入 _request_ctx_stack\n                ctx.push()\n                response = self.full_dispatch_request()\n            except Exception as e:\n                error = e\n                response = self.handle_exception(e)\n            except:\n                error = sys.exc_info()[1]\n                raise\n            return response(environ, start_response)\n        finally:\n            if self.should_ignore_error(error):\n                error = None\n            # 这里将创建的请求上下文从中 _request_ctx_stack pop 出来\n            ctx.auto_pop(error)\n```\n\n从 wsgi_app 泪看，就可以看到我们之前在当时在开脑洞时候看到的。\n\n1. 把 request 和 response 封装一下？方便在 view 里面处理？\n2. 有个 URLDisparch 之类的东西，帮你解决 url 和 view 的 mapping 问题。\n\n话说回来？\n\n\u003e 这个 ctx 是啥？\n\u003e 当然，flask 不带 ORM, 这我们也就不研究了。\n\n-- TODO: 在这里需要重构一下\n\n不过话说回来 请求上下文的容器 request_ctx_stack 到底是啥？\n\n\u003e 另一种本地数据存储方式。\n\n在多线程的情况下，每一个请求都会创建一个线程，从这个请求被发起到销毁，我想拥有单独的变量（修改这个变量不会影响到其他变量），比如 sessions 之类。\n\n显然，在多线程的情况下，以上的需求完全可以通过 threadlocal 来实现。\n\n翻了 werkzeug 的文档，找到了原因：\n\n\u003e 因为 python 里面的并发模型并不只有多线程一种。比如 greenlets, 每一个请求，都在一个线程里面。\n\n## 0x02 问题 2: Flask 中 Context 机制\n\n在 Django 完成一个 View 层的逻辑是这样的，Django 封装好了请求，请求经过 middleware 的处理，最后调用 login 函数，并且传入 request 方便 view 函数进行处理。\n\n```python\ndef login(request):\n    if request.method == 'POST':\n        error = someerror\n    return render_template('login.html', error=error)\n```\n\n在 Flask 完成一个 View 层的逻辑是这样的\n\n```python\nfrom flask import request\n@app.route('/login', methods=['POST', 'GET'])\ndef login():\n    if request.method == 'POST':\n        error = someerror\n    return render_template('login.html', error=error)\n```\n\n假如我是一个爱问问题的年轻人，这里肯定会有疑惑：\n\n\u003e 从外部 import 过来，那就是利用了 python 自带的 import 单例模式。 那么线程和线程之间拿到的肯定是同一个 request 呀。但 Django 里面每个 request 都是不一样的，否则一些很基础功能的比如已经认证的用户就无法拿到了。\n\n我已经不是那个爱问问题的年轻人，因为年纪已经不小了。逃...\n\n显然，每一次在 view 层引用的 request 肯定不是同一个 request , 那么，这是如何做到的呢？比如用 ThreadLocal , ThreadLocal 通过每个线程不同的 ID 拿到的本地变量，于是我们查看一下对应的实现。 这个 request 来自于 global.py , 使用了一个 werkzeug.local 里面的 LocalProxy\n\n```python\nfrom functools import partial\nfrom werkzeug.local import LocalStack, LocalProxy\n\ndef _lookup_req_object(name):\n    top = _request_ctx_stack.top\n    if top is None:\n        raise RuntimeError(_request_ctx_err_msg)\n    return getattr(top, name)\n\ndef _lookup_app_object(name):\n    top = _app_ctx_stack.top\n    if top is None:\n        raise RuntimeError(_app_ctx_err_msg)\n    return getattr(top, name)\n\ndef _find_app():\n    top = _app_ctx_stack.top\n    if top is None:\n        raise RuntimeError(_app_ctx_err_msg)\n    return top.app\n\n# context locals\n_request_ctx_stack = LocalStack()\n_app_ctx_stack = LocalStack()\ncurrent_app = LocalProxy(_find_app)\n# 这就是我们需要的注意的地方，LocalProxy\nrequest = LocalProxy(partial(_lookup_req_object, 'request'))\nsession = LocalProxy(partial(_lookup_req_object, 'session'))\ng = LocalProxy(partial(_lookup_app_object, 'g'))\n```\n\n看到这里一阵蛋疼，貌似没有 threadlocal ？再次查看相关实现最后还是定位到了如何区分不同的 request 的核心代码。\n\n```python\n# since each thread has its own greenlet we can just use those as identifiers\n# for the context.  If greenlets are not available we fall back to the\n# current thread ident depending on where it is.\ntry:\n    from greenlet import getcurrent as get_ident\n    # greenlet 的代码是 C, 时间长没看 C 代码了，看了半天没看明白\n    # 翻了文档返回当前的 greenlet, 也就是返回调用此函数的 greenlet\nexcept ImportError:\n    try:\n        from thread import get_ident\n    except ImportError:\n        from _thread import get_ident\n\nclass Local(object):\n    __slots__ = ('__storage__', '__ident_func__')\n\n    def __init__(self):\n        object.__setattr__(self, '__storage__', {})\n        # 这里传递的 ident 就可以直接\n        object.__setattr__(self, '__ident_func__', get_ident)\n\nclass LocalStack:\n    # 用 local 实现的栈\n\nclass LocalProxy:\n    # 一个 local 的代理器\n    def __getattr__(self, name):\n    if name == '__members__':\n        return dir(self._get_current_object())\n    return getattr(self._get_current_object(), name)\n```\n\n即：\n\n1. 当 Flask 以多线程模型运行的时候，则使用的是 threadlocal 方式\n2. 当 Flask 以 greenlet 的模型运行的时候，则使用的是 greenlet 区分不同\n\n接下来回头看一下处理 request 的逻辑\n\n```python\nfrom flask import request\n@app.route('/login', methods=['POST', 'GET'])\ndef login():\n    # 这个 request 哪里来？\n    if request.method == 'POST':\n        error = someerror\n    return render_template('login.html', error=error)\n```\n\n于是，我们就知道了，当引用 request 这个 LocalProxy 的时候，引用的确实是同一个名称为 request 变量，并且这个变量也确实是 LocalProxy 的实例\n\n\u003e 但是当使用 request.method 的时候，LocalProxy 重载了 取到的则是另一个『请求对象』的 method.\n\n于是拿到当前请求的信息。\n\n当然，其实我们也可以依据利用这个技巧写一个 currentuser 的 ProxyLocal, 然后在每个 view 层里面使用 user.has_something 进行操作。\n\n## 0x03 问题 3: Flask 中官方的机制\n\n## 0x04 问题 3: Flask 中是如何做到优雅扩展的\n\n## 0x05 其他问题\n\n### Flask 应用\n\n---\n\nChangeLog:\n\n- **2018-03-09** 重修文字\n"}],"total":3},{"name":"2018-02","posts":[{"tags":["Python","Django","YaDjangoBlog"],"path":"20180224_YaDjangoBlog之前端VueJS篇.md","title":"YaDjangoBlog 之 前端 VueJS 篇","slug":"YaDjangoBlog 之 前端 VueJS 篇","date":"2018-02-25","category":"Django","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n本文是 Django 全栈开发教程的第四篇\n\n目录在这里，已经更新的文章如下\n\n- Django 全栈开发教程 - 2018 年不容错过的 Django 全栈项目 -- 目录篇\n- Django 全栈开发教程 - YaDjangoBlog 的开发环境配置\n\n本文需要完成三件事情：\n\n- 第一件事情，介绍为什么选择 VueJS？\n- 第二件事情，介绍 Vue 项目的一些注意点。\n- 第三件事情，蜻蜓点水搬的带大家过一编，YaDjangoBlog 前端的项目结构，静态资源管理，路由以及组件。\n\n## 0x01 为什么是 VueJS\n\n国产框架 + 语法简洁是我入坑 VueJS 初衷。\n\n后来却是 Vue 的丰富的生态和简洁的语法吸引了继续用下去。\n\n这里要感谢为 VueJS 持续贡献代码的人，从 Vue 本身，到 VueCLI, 到 Router, 到 VueX, 如果没有那么多人为之贡献代码，可能今天这一小节就变成了，『为什么是 React 了』逃。\n\nVue 自称为 Vue 渐进式 JavaScript 框架。\n\n什么是渐进式？\n\n就是你可以逐步按照 Vue 的方式逐渐引入一些 Vue 的组件到项目中。没有必要上来就是 Vue 全家桶，依据场景逐步引入。\n\n参考链接 https://www.zhihu.com/question/51907207\n\n然而，依据我的经验，vue 全家桶用起来还是很舒服的。这里必须要感谢 Vue 社区。\n\n模板语法，数据驱动，双向绑定。写起代码来简直就是一个字，爽。\n\n## 0x02 Vue 项目的一些注意点\n\n从项目角度，我们想想前端项目有哪些地方是需要注意的：\n\n1. 开发环境和线上环境区分\n2. 前端资源打包\n\n- Vue 项目资源打包\n- DLL 打包\n- 字体文件打包\n\n3. CSS/JS 如何管理\n4. 有哪些必要的依赖，如何引入第三方库\n5. 有哪些页面级组件，有哪些小组件？应该安排这些组件？组件与组件应该怎么通讯？\n6. 路由怎么管理\n7. 状态怎么管理\n8. 登录，鉴权怎么做\n\n限于篇幅，我就不一一讲解了。挑在 YaDjangoBlog 中使用到的技术简单介绍一下。\n\n再次感谢 Vue 社区出品的 VueCLI 以及 Webpack 模板。\n\n下面依次介绍：\n\n1. 项目结构\n2. 静态资源管理\n3. 路由\n4. 组件\n\n## 0x03 项目结构\n\n首先，YaDjangoBlog 文件的前端目录如下：\n\n```bash\n.\n├── README.md\n├── build\n│   ├── build.js\n│   ├── build_iconfont.js # 构建 iconfont 脚本\n│   ├── check-versions.js\n│   ├── logo.png\n│   ├── utils.js\n│   ├── vue-loader.conf.js\n│   ├── webpack.base.conf.js\n│   ├── webpack.dev.conf.js # 增加了 AutoDllPlugin 用于自动打包 DLL\n│   └── webpack.prod.conf.js\n├── config\n│   ├── dev.env.js # 可以在这里添加开发环境的环境变脸\n│   ├── index.js\n│   ├── prod.env.js\n│   └── test.env.js\n├── extra\n│   └── svg-icon # 这里存放需要生成 iconfont 的字体文件。\n├── index.html\n├── package.json # 这里添加了一些构建脚本\n├── packages\n│   └── theme-future # 注意，这里是另一个子项目，使用 Gulp 构建的纯 CSS 子项目。\n├── src\n│   ├── App.vue\n│   ├── api # 对 axios 进行初步封装\n│   ├── assets # 从使用 Gulp 生成的 CSS 可以放在这里。\n│   ├── components # 跨页面的组件放在这里\n│   ├── directives # 指令\n│   ├── filters    # 过滤器\n│   ├── main.js    # 初始化 Vue 实例\n│   ├── pages      # 页面\n│   ├── router     # 路由\n│   ├── store      # vuex\n│   └── utils      # 常用工具类\n├── static\n│   ├── hightlight # hightlight 脚本\n│   ├── iconfont   # 本地构建的 iconfont\n│   ├── images\n│   └── js\n├── test           # 没写测试，大家开源项目不要学我.... 逃\n│   ├── e2e\n│   └── unit\n└── yarn.lock\n```\n\n## 0x04 静态资源管理\n\n静态资源管理，主要涉及到 JS/CSS/ 图片 / 字体\n\n首先，由于使用了 VueCli 的模板，所以大可以按照 VueCli 提供的写法来写。\n\n```html\n\u003ctemplate\u003e\n  \u003cdiv id=\"app\"\u003e\n    \u003cheader\u003e\u003c/header\u003e\n    \u003crouter-view /\u003e\n    \u003cfooter\u003e\u003c/footer\u003e\n  \u003c/div\u003e\n\u003c/template\u003e\n\n\u003cscript\u003e\n  export default {\n    name: \"app\",\n    components: {\n      Header: () =\u003e import(\"./pages/commons/Header.vue\"),\n      Footer: () =\u003e import(\"./pages/commons/Footer.vue\"),\n    },\n  }\n\u003c/script\u003e\n\n\u003cstyle lang=\"scss\"\u003e\n  $primary-color: #37b24d;\n  $dark-color: #2b5732;\n  $body-bg: #f9f9f9;\n  @import \"~spectre.css/src/spectre-icons.scss\";\n  @import \"~spectre.css/src/spectre.scss\";\n  @import \"~spectre.css/src/spectre-exp.scss\";\n  @import \"./assets/theme-future/index.css\";\n  a {\n    \u0026:focus,\n    \u0026:hover,\n    \u0026:active,\n    \u0026.active {\n      text-decoration: none;\n      box-shadow: 0 0 0 0;\n    }\n  }\n  #app {\n  }\n\u003c/style\u003e\n```\n\n依据我个人经验，做了一部分的微调：\n\n**第一** 在代码中新建一个主题 CSS, 单独用于处理 SCSS 编译 CSS. 即除了 App.vue, 其他地方的 CSS 直接写在同一个地方。\n\n**第二** 对于字体文件，不引入 IconFont 在线字体，而是使用 SVG 本地编译字体。这样减少对 iconfont cdn 的依赖，可以以后直接迁移这个字体到其他 CDN 上。\n\n**第三** 对于依赖库管理，分为 npm 依赖库和外部 JS 依赖库两种\n\n对于 NPM 依赖库，如果有使用过 ECharts3.0 的 SPA 开发者应该对于万恶的 DLL 非常熟悉了。最早的时候，我们是这样做的：\n\n- 先写一个编译脚本，指定相关依赖包，打包出 dll 和一个 manifest 文件\n- 然后从 index.html 里引入打包好的 dll.\n- 再从 webpack 的配置文件中引入这个文件。\n\n这种恶心的配置随着 autodll-webpack-plugin 的出现从而得到缓解，于是现在的你只需要配置：\n\n```JavaScript\n    new AutoDllPlugin({\n      inject: true, // will inject the DLL bundles to index.html\n      debug: true,\n      filename: '[name]_[hash].js',\n      entry: {\n        vendor: [\n          '@antv/data-set',\n          '@antv/g2',\n          '@antv/g6',\n          'highlight.js',\n          'markdown-it',\n          'markdown-it-abbr',\n          'markdown-it-deflist',\n          'markdown-it-emoji',\n          'markdown-it-footnote',\n          'markdown-it-ins',\n          'markdown-it-katex',\n          'markdown-it-mark',\n          'markdown-it-sub',\n          'markdown-it-sup',\n          'markdown-it-task-lists',\n          'markdown-it-toc-and-anchor',\n          'typed.js',\n          'vue',\n          'vue-router',\n          'vuex'\n        ]\n      },\n      plugins: [new webpack.optimize.UglifyJsPlugin()],\n    })\n```\n\n当然，如果你用了 ECharts, 有的时候会出现莫名其妙的\n\n```\n__DEV__ is not defined\n```\n\n解决方法就是在这上面的插件里面加个插件定义一个 Global 的变量\n\n```\n  new webpack.DefinePlugin({\n    __DEV__: false\n  }),\n```\n\n\u003e PS: 去年的版本由于依赖库的一个路径问题导致 autodll-webpack-plugin 不能在 Windows 上使用，今年可以啦。还不快快用起来？\n\n对于外部的 JS/CSS 依赖库：\n\n1. 直接拷贝到 static 下面，然后从 index.html 引入即可。\n2. 动态创建 script 标签（比如动态引入高德地图）\n\n## 0x04 路由\n\n博客项目，实际上路由比较简单。\n\n```\nexport default new Router({\n  mode: 'history',\n  base: '/',\n  // 注释掉这里是因为和引入的 smooth-scroll 冲突\n  // scrollBehavior (to, from, savedPosition) {\n  //   return { x: 0, y: 0 }\n  // },\n  routes: [\n    {\n      path: '/',\n      name: 'home',\n      component: () =\u003e import('../pages/Home.vue')\n    },\n    // 解决手贱带来的问题\n    {\n      path: '/index:suffix*',\n      name: 'index',\n      component: () =\u003e import('../pages/Home.vue')\n    },\n    {\n      path: '/blog',\n      name: 'blog',\n      component: () =\u003e import('../pages/Blog.vue')\n    },\n    {\n      path: '/blog/post/:title',\n      name: 'post',\n      component: () =\u003e import('../pages/Blog/ArticlePost.vue')\n    },\n    {\n      path: '/blog/:category(category/\\\\d+)?/:tags(tags/\\\\d+)?/:page(page/\\\\d+)?',\n      name: 'blogposts',\n      component: () =\u003e import('../pages/Blog.vue')\n    },\n    {\n      path: '/archive',\n      name: 'archive',\n      component: () =\u003e import('../pages/Archive.vue')\n    },\n    {\n      path: '/gallery',\n      name: 'gallery',\n      component: () =\u003e import('../pages/Gallery.vue')\n    },\n    {\n      path: '/works',\n      name: 'works',\n      component: () =\u003e import('../pages/Works.vue')\n    },\n    {\n      path: '/about',\n      name: 'about',\n      component: () =\u003e import('../pages/About.vue')\n    }\n  ]\n})\n```\n\n除了 import 语法之外，需要注意的就是 '/blog/:category(category/\\\\d+)?/:tags(tags/\\\\d+)?/:page(page/\\\\d+)?' 这个奇怪的表达式。\n\n这个表达式可以用于匹配下面的路由\n\n```bash\n/blog/category/1/tags/2/page/3\n/blog/category/1/page/3\n/blog/tags/3/page/3\n/blog/page/3\n```\n\n匹配完毕之后，就可以拿到 categroy tags page 的值然后提交数据库拿数据咯。\n\n## 0x05 组件\n\n博客里面需要注意的就三个组件\n\n- ArticlePost 组件\n- 分页组件\n- 打字终端组件\n\n第一个，ArticlePost 组件\n\n```html\n\u003ctemplate\u003e\n  \u003cdiv class=\"p-article-post\"\u003e\n    \u003cdiv class=\"columns\"\u003e\n      \u003cdiv class=\"col-1 hide-xl\"\u003e\u003c/div\u003e\n      \u003cdiv class=\"col-2 col-xl-3\"\u003e\n        \u003cdiv class=\"g-sidebar\"\u003e\n          \u003ch4\u003e本文目录\u003c/h4\u003e\n          \u003cdiv v-html=\"articleToc\"\u003e\u003c/div\u003e\n        \u003c/div\u003e\n      \u003c/div\u003e\n      \u003cdiv class=\"col-6 col-xl-8\"\u003e\n        \u003cArticleCard\n          :article=\"article\"\n          @articleTocReady=\"initArticleToc\"\n        \u003e\u003c/ArticleCard\u003e\n      \u003c/div\u003e\n      \u003cdiv class=\"col-2 col-xl-3\"\u003e\n        \u003cdiv class=\"g-sidebar\"\u003e\n          \u003ch4\u003e公告\u003c/h4\u003e\n          \u003cdiv\u003e\n            \u003cp\u003eMG 的编程小屋，其实就是我整理笔记，写写文章的地方。\u003c/p\u003e\n            \u003cp\u003e\n              专注 Python / JavaScript , 爱折腾的全干工程师 (Full Stuff\n              Engineer)\n            \u003c/p\u003e\n            \u003cp\u003e如果我的文章给您的日常开发带来很大帮助的话\u003c/p\u003e\n            \u003cp\u003e您可以关注我的公众号\u003c/p\u003e\n            \u003cdiv\u003e\n              \u003cimg\n                src=\"/static/images/mp_wechat.jpg\"\n                alt=\"\"\n                style=\"width: 200px\"\n              /\u003e\n            \u003c/div\u003e\n            \u003cp\u003e也可以扫描二维码进行投喂\u003c/p\u003e\n            \u003cdiv\u003e\n              \u003cimg\n                src=\"/static/images/tips_wechat.jpeg\"\n                alt=\"\"\n                style=\"width: 200px\"\n              /\u003e\n            \u003c/div\u003e\n            \u003cp\u003e听说关注或者进行投喂的人，技术都越来越牛咯。\u003c/p\u003e\n          \u003c/div\u003e\n        \u003c/div\u003e\n      \u003c/div\u003e\n      \u003cdiv class=\"col-1 hide-xl\"\u003e\u003c/div\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n\u003c/template\u003e\n\n\u003cscript\u003e\n  import { fetchBlogPost } from \"../../api/blog\"\n  export default {\n    name: \"BlogPage\",\n    components: {\n      ArticleCard: () =\u003e import(\"../../components/Common/ArticleCard.vue\"),\n    },\n    data() {\n      return {\n        article: \"\",\n        articleToc: undefined,\n      }\n    },\n    watch: {\n      \"$route.params\": function () {\n        this.initArticle()\n      },\n    },\n    created() {\n      this.initArticle()\n    },\n    mounted() {},\n    methods: {\n      initArticleToc: function (v) {\n        this.articleToc = v\n      },\n      initArticle: function () {\n        let title = this.$route.params.title\n        fetchBlogPost(title).then(res =\u003e {\n          this.article = res\n        })\n      },\n    },\n  }\n\u003c/script\u003e\n```\n\n嗯，其实就是监听 url, 如果匹配上 url 的话，从 url 中取 title, 然后发送请求，接着取回响应的内容交给子组件处理。子组件处理完毕会 emit 出一个 toc 的值，将这个值赋值给左侧 toc 即可。\n\n- 分页组件\n\n见地址吧 https://github.com/twocucao/YaVueBlog/blob/master/src/components/Common/Pagination.vue\n\n- 打字终端组件\n\n终端的样式，当然是抄别人的 CSS, 打字效果，来源于 typed.js 依赖库\n\n## 0x06. 扩展\n\n对于其他的实现，自然是要多多看代码咯。\n\n其实前端工程化是一个很广的概念，本文没有提到代码风格、团队开发工作流、CSS 编写规范、组件优化、Webpack 详细配置等等。这都需要在日常开发中多多练习的。\n\n笔者最近换了份工作，以 React 为技术栈。 加上篇幅和精力有限，也就是不在以 Vue 为前端这一块详细展开了。\n\n下面的文章还是聚焦在后端上面。\n\n## 0xEE. 参考链接\n\n还犹豫啥，Django 前后端分离最佳实践，点赞后，快上车吧\n\n- 前端代码 https://github.com/twocucao/YaVueBlog\n- 后端代码 https://github.com/twocucao/YaDjangoBlog\n\n---\n\nChangeLog:\n\n- **2018-03-18** 重修文字\n"},{"tags":["Python","Django","YaDjangoBlog"],"path":"20180224_YaDjangoBlog的前后端初步设计.md","title":"YaDjangoBlog 的前后端设计","slug":"YaDjangoBlog 的前后端设计","date":"2018-02-24","category":"Django","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n本文是 Django 全栈开发教程的第二篇\n\n目录在这里，已经更新的文章如下\n\n- Django 全栈开发教程 - 2018 年不容错过的 Django 全栈项目 -- 目录篇\n- Django 全栈开发教程 - YaDjangoBlog 的开发环境配置\n\n本文需要完成两件事情：\n\n- 第一件事情，回答一个问题：为什么要选择博客系统作为教程而不是别的？\n- 第二件事情，简单说说 YaDjangoBlog 的前后端设计。\n\n## 0x01 为什么是博客系统\n\n在目录评论区，有个读者问：\n\n为什么选择博客系统？而不是别的系统？\n\n一言以蔽之：因为合适。\n\n为什么说合适？\n\n1. 第一点：代码量相对合适，业务逻辑大家都很清楚，博客系统说简单也简单，说复杂也复杂，待会我们就可以谈到。简单的例子反而是入门和深入了解 Django 技术栈（而不是设计一个优秀的程序）的最佳案例。\n2. 第二点：言简意赅，知识点覆盖全面，注意，我们要学习的 Django 技术栈，Django 技术栈，Django 技术栈。不是学高可用架构设计，不是超级复杂系统的设计，不是业务逻辑设计。\n3. 第三点：日常开发都是见招拆招，依据业务逻辑来，作为开发者，总不能直接把公司的业务代码上传的 Github 上吧？\n\n不妨想想，其实写个博客系统压根就不需要这么麻烦的使用各种组件来给自己的博客系统贴金。那么，我为何还是要『为赋新词强说愁』呢？\n\n答案是『醉翁之意不在酒，在乎山水之间』。通过这个简单的博客，来带大家过一遍 Django 技术栈，具体能学的多好，看个人努力。\n\n当然，借此也吐槽一下，有的人认为，博客系统简单，不就是 Blog / Category / Tag / Comment，有啥可练手的？\n\n其实不然，设计一个博客系统完全可以按照复杂系统的高标准来设计，举例来说：\n\n1. ORM 设计：如果我想把 Category/Tags/Comment 变成通用的，即可以对 Blog 进行分类 / 标签 / 评论，对新建的 Product 模型 也可以进行分类 / 标签 / 评论。\n2. 数据库设计：Category 可能有三到四级子分类怎么办？ Comment 支持评论区互相回复评论。这里的不但要通用，还要用树形结构实现放在一张表里面。\n3. 全文搜索：Blog 的 content 字段是长文对吧？这个总不能每次搜索都是 like 查询吧？Elasticsearch 怎么搞。\n4. 缓存和定时任务：PV 和 UV 量总不能每次访问都更新一次数据库吧？为什么不用 Redis 呢？用上了 Redis, 为什么不加上定时任务呢帮忙把 PV/UV 以及点赞数量啥的定期更新到数据库中？\n5. Celery ：定时任务为啥不用神器 Celery 呢？\n6. 其他问题：如何对某个接口进行 profile? 如果逻辑比较复杂，是不是要补上单元测试。Django 单实例如何使用多域名？\n\n那一套太祖长拳从宋兵甲手里使出来，不过是威力平平；\n\n\u003e 如果是从那乔峰手里使出来，那威力如何？\n\n## 0x02 前后端分离\n\n### 前后端分离的必要性\n\n为什么前后端分离？\n\n- 一是需求：简简单单的套模板已经不够了，还要富交互，代码量上去了。\n- 二是技术条件成熟：NodeJS 横空出世，使得 JS 成了不仅仅可以在浏览器中运行的语言，成了一门和 Java,Python,Ruby 一样的客户端语言。\n- 三是生态：轮子多，这车轱辘如你所愿。\n\n前端的职责变重，代码量则上来了，相应的，模块化工具就自然出来了。\n\n\u003e PS: 前后端分离也不是啥新概念，当年开发客户端的不也是前后端分离？ 当然，这里的前后端分离指的是浏览器与服务器的前后端分离。\n\n前后端分离之后，依旧是前端发送请求，后端返回对应的数据。\n\n那么，哪里变了？我认为，主要有两点：\n\n1. 前后端流程可以并行开发，即前后端可以同时干活。并且责任明确。\n2. JS 可以干客户端语言干的事情。\n\n以前，我们都是由美工设计页面，前端开发模板，后端开发 API, 前端再套 API, 再交给后端，后端接过前端的页面套模板。一切看起来是那么的和谐。\n\n但是，就是这么一个看起来一个简单的套模板 / 开发 API，就是一个时间黑洞。\n\n比如说：\n\n- 小美（美工）设计好设计稿，交给小钱（前端）\n- 小钱完成前端页面的设计，\n- 小侯（后端）开发 API,\n- 小钱套 API 后，完成页面设计，并将这个页面交给小侯\n- 小侯要做的事情，把小钱的前端页面切分成模板引擎里面的语法，从数据库里面取数据，交给模板引擎渲染，完成套前端页面流程。\n\n接着，产品经理跳出来，指出页面设计中有两个地方需要优化，于是：\n\n大家面临的选择就只有两个：\n\n1. 合起伙来，解决掉产品经理\n2. 大家在反反复复，迂迂回回的需求变更、BUG 解决、调试中，浪费了一些不应该浪费的时间。\n\n那么前后端分离了，前后端的开发就如同客户端开发和服务端开发一样：\n\n- 前端 / 客户端 负责路由，负责什么时候请求什么 API, 该去优化性能就去优化性能。\n- 后端 / 服务端 负责折腾后端组件，优化性能。\n\n- 如果调页面，直接找前端去就好了。\n- 如果是数据或者 API 有问题，直接找后端就好了。\n\n这么一分，其实职责就好界定了很多，由于修改与优化不会引发两个工种的交叉合作（前端改完，后端套模板）,BUG 率就减少了很多。\n\n\u003e PS: 其实职责好界定很多，但不能避免推锅。\n\n由于本博客只关注 Django 技术栈，而所谓使用 JavaScript 前后端通吃的『大前端』, 则不在我们的讨论范围之内。\n\n\u003e 比起使用一门语言前后端通吃，笔者还是比较倾向于『见人说人话，见鬼说鬼话』, 即使用多种语言，去处理合适的问题的。\n\n### 前后端分离的成本\n\n前后端分离并不是没有代价的。\n\n对于前端：\n\n- 首次页面 Loading 速度\n- JWT 认证请求\n- 在特定场景下，有些看起来在多页面开发过程中比较简单的事情，反而比较复杂。\n- 需要注意内存的使用率。\n\n对于后端：\n\n- JWT 认证响应，以前是 session 认证，而且 Django 都给你实现好了。现在变了，往往大家使用的都是 JWT 作为认证。\n\n但这些成本相比与节省的开发时间相比都是微不足道的。\n\n当然，我会在本系列的后面抽出一篇教程来专门讲解 Django 内置用户的扩展和前后端分离的登录认证。\n\n## 0x03 博客系统设计\n\n这个博客最初要解决的问题是：\n\n1. hexo 用腻了，想自己写一个简单的博客系统。\n2. 这个博客要可以导入文章，我不需要编辑器功能，在本地编辑完毕之后，导入数据库就好。\n\n### 页面构成\n\n1. 首页\n2. 博客列表页\n3. 博客存档页\n4. 博客历史页\n5. 博客详情页\n6. 关于我页面\n\n### 模型构成\n\n首先 M 模型层\n\n1. PostgreSQL : 博文 / 博文类型 / 博文标签\n2. Elasticsearch : 博文\n3. Redis : 每篇博文的阅读量，点赞量\n\n这里需要注意的是：\n\n- 第一：博文类型-博文：1 对多，博文标签-博文：多对多\n- 第二：博文中的 content 为文章内容，即可以在 Elasticsearch 中作为全文搜索的字段。具体降到 Elasticsearch 的时候我们会详细说明。\n- 第三：博文中的 阅读量和点赞量放在 Redis 里面，由 Celery 的定时任务定期刷到内存中。\n\n再考虑 VT 视图模板层，VT 层，会根据情况 DjangorestFramework 来进行序列化和反序列化。\n\n在设计模型的时候，尽量将涉及到模型的操作放在模型内。\n\n关于如何设计更好的模型，在以后的文章将会讲解，先挖个坑。\n\n### 架构图\n\n理想环境中，我们的架构图如下：\n\n哦，不好意思，放错图了，是这样的。\n\n但这样的架构应该有专门的人来维护。\n\n于是在人力有限的情况下，本项目的架构图是这样的。\n\n哦，不好意思，放错图了，是这样的。\n\n## 0xEE. 参考链接\n\n还犹豫啥，Django 前后端分离最佳实践，点赞后，快上车吧\n\n- 前端代码 https://github.com/twocucao/YaVueBlog\n- 后端代码 https://github.com/twocucao/YaDjangoBlog\n\n---\n\nChangeLog:\n\n- **2018-02-22** 开启本文\n- **2018-02-27** 重修文字\n"},{"tags":["Python","Django","YaDjangoBlog"],"path":"20180223_YaDjangoBlog前后端分离篇.md","title":"YaDjangoBlog 之前后端分离篇","slug":"YaDjangoBlog 之前后端分离篇","date":"2018-02-23","category":"Django","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n本文是 Django 全栈开发教程的第三篇 YaDjangoBlog 之前后端分离\n\n目录在这里，已经更新的文章如下\n\n- Django 全栈开发教程 - 2018 年不容错过的 Django 全栈项目 -- 目录篇\n- Django 全栈开发教程 - YaDjangoBlog 的开发环境配置\n- Django 全栈开发教程 - YaDjangoBlog 的前后端设计\n\n**本文需要成四件事情：**\n\n- 第一件事情，解读 DjangoRestFramework, 通过简单的例子来引入用 DRF 的必要性，并且简单介绍 DRF 的 CBV 实现。\n- 第二件事情，简单介绍 DRF 在本项目 YaDjangoBlog 中的使用\n- 第三件事情，简单聊聊 RESTFULAPI 规范，并给出最佳实践参考。\n- 第四件事情，简单解读一下 Django 处理请求流程代码。\n\nPS: 为了打字方便，下面的：\n\n- DRF 指的是 DjangoRestFramework\n- CBV 指的是 Class Based View\n- FBV 指的是 Function Based View\n\n\u003e 坐稳了，开车了。\n\n## 0x01 DjangorestFramework 解读\n\n### 为什么要用 DRF 呢？\n\n使用一个库的原因，无非就是为了：\n\n1. 节省开发者自己造轮子的时间。\n2. 有利于代码的可维护性 / 或者程序的健壮性。\n\n具体落实到 DRF, 有哪些具体的优点呢？\n\n1. 可直接浏览调试的界面。让前端调试起来欲罢不能的功能。\n2. 用 DRF 的方式快速批量开接口\n3. 分页、序列化、校验、登录、权限、Web 附加文档、限流，高度的可扩展性。哪里不爽扩展哪里，so easy\n4. 算的上是 Django 社区最好的 RESTFUL 框架的轮子了。\n5. 完善的社区支持，比如 guardian/django-filter 等等结合。\n\n### 不使用 DRF 应该如何写 WebAPI 做呢？\n\n我们先看看，不使用 DRF 的时代，API 是如何编写的。\n\n这里我们用 function based view 来简单说明。\n\n```python\n# 最简单版本\ndef simple_hello(request):\n    return JsonResponse({\n        \"这就是 key\": \"这就是 value\",\n        \"时间\": time.time()\n    })\n```\n\n刚开始学 DRF 的时候，我也有这种疑惑，这有必要需要一个 RESTFULAPI 的框架嘛？捋起袖子，JSON API 甩起来开咯。\n\n之所以得出这个结论，是因为这个例子实在是过于简单。\n\n当涉及到一定复杂程度的 API 的时候，问题就来了：\n\n1. 权限是否需要区分？\n2. 分页需不需要做？\n3. 前端人员提交 Form 表单时，只能通过命令行或者是 POSTMAN 之类的工具提交参数，这会不会带来不便？后端人员写这些表单的各个字段，也是很手酸的事情。\n4. 拼接字典或者是字符串倒也还好，能不能有个序列器帮我直接序列化这模型，并且如果模型和模型之间有联系，最好也可以帮我完成模型和模型之间的关联。\n5. Profile API 应该如何做？\n\n这都是我们需要考虑的。\n\n如果不用 DRF, 而是由后端程序员直接写这些代码的话，也不是不行。\n\n1. 对于第一点，可以直接在 fbv 上面加装饰器。\n2. 对于第二点，分页的时候可以直接将逻辑写在 fbv 里面。\n3. 前端 er 直接使用 PostMan 之类的工具就好了。\n4. 序列化，可以借助内置的序列化方法。\n5. Profile 可以在提交参数的时候，附加一个参数比如 debug, 渲染的时候，将使用 HTML 里面内置一个 JSON 字符串的方式渲染出来。这样的话，就可以使用 Django Debug Tools 进行 Profile 了。\n\n很显然，这是个系统性的活。 假如接下来还要考虑限流、RESTFULAPI 的设计，这就相当蛋疼了。\n\n显然，我们的 FBV 就会是这样：\n\n```python\n@a_authority\ndef complex_hello(request):\n    params = getParams(request)\n    .....\n    query_results = SomeModels.some_query()\n    .....\n    results = SomeModelsSerial(query_results)\n    .....\n    return JsonResponse(results)\n```\n\n看起来似乎是有规律可循的，既然有规律可循，就能封装一下，减轻负担。FBV 已经这样了，显然只能每次都要硬编码这些取参数，查询，序列化。当然，如果用生成器也能简化一部分函数代码。yield 实现方法太丑还是弃用吧。\n\n我们试试 CBV 看看如何。\n\n```python\n# 继承并重写方法\nfrom django.views.generic import View\nclass APIView(View):\n\n    def get(self,request):\n        query_results = SomeModels.some_query()\n        .....\n        results = SomeModelsSerial(query_results)\n        .....\n        return results\n\n    def post(self,request):\n        query_results = SomeModels.some_query()\n        .....\n        results = SomeModelsSerial(query_results)\n        .....\n        return results\n\n    .....\n\n    # 这里相当于 view 函数\n    def dispatch(request, *args, **kwargs):\n        # 这里处理正式处理之前的逻辑，比如权限判断。\n        # 如果是 GET 方法，则调用\n        results = self.get(request, *args, **kwargs):\n        # 这里处理正式处理之后的逻辑，比如统计 list 的 total 值，加上时间戳\n        return JsonResponse(results)\n```\n\n于是，除了使用 FBV 进行硬编码之外，还可以使用 CBV 的基类 进行扩展定制。\n\n我们思考一下：\n\n1. 假如我想渲染某个模型的 JSON 列表，就可以定制一个 ListViewAPI 出来。如果需要一个 DetailViewAPI, 就定制一个 DetailViewAPI 出来。\n2. 我们再声明一些 Permission 类，序列化类，模型，然后在 dispatch 中直接使用这些东西的话，就只需要在 get 和 post 里面编写一些最核心的逻辑了。\n3. 甚至，指定了分页器和查询，都完全不需要再 get 和 post 里面写代码。\n\n恭喜你，读到这里，你已经可以写一个极简的 DRF 出来了。\n\n但写成 DRF 这种量级的程序，还需要做很多很多事情。\n\n### DRF 处理请求的流程\n\n要知道 DRF 的处理请求的流程，就要先知道 Django 的处理请求流程。\n\n宏观来看\n\n1. 请求先经过 MiddleWare , 接着判断 urlconf （默认为 ROOT_URLCONF),\n2. 匹配 URL, 将请求上下文 dispatch 到具体的 view.\n3. 处理完毕，经过 MiddleWare\n\nhttps://docs.djangoproject.com/en/2.0/topics/http/urls/\n\n在本文的结尾的时候，我也将带大家从源码角度过一下，涉及到这个流程的相关的源码。这里先跳过。\n\n那么，DRF 是如何处理一个请求的呢？我们忽略路由之类的东西，直接看对应的 CBV 的源码\n\n```python\nclass APIView(View):\n\n    renderer_classes = api_settings.DEFAULT_RENDERER_CLASSES\n    parser_classes = api_settings.DEFAULT_PARSER_CLASSES\n    authentication_classes = api_settings.DEFAULT_AUTHENTICATION_CLASSES\n    throttle_classes = api_settings.DEFAULT_THROTTLE_CLASSES\n    permission_classes = api_settings.DEFAULT_PERMISSION_CLASSES\n    content_negotiation_class = api_settings.DEFAULT_CONTENT_NEGOTIATION_CLASS\n    metadata_class = api_settings.DEFAULT_METADATA_CLASS\n    versioning_class = api_settings.DEFAULT_VERSIONING_CLASS\n\n    # ...... 其他方法\n\n    # Dispatch methods\n\n    def initialize_request(self, request, *args, **kwargs):\n        \"\"\"\n        Returns the initial request object.\n        \"\"\"\n        parser_context = self.get_parser_context(request)\n\n        return Request(\n            request,\n            parsers=self.get_parsers(),\n            authenticators=self.get_authenticators(),\n            negotiator=self.get_content_negotiator(),\n            parser_context=parser_context\n        )\n\n    def initial(self, request, *args, **kwargs):\n        \"\"\"\n        Runs anything that needs to occur prior to calling the method handler.\n        \"\"\"\n        self.format_kwarg = self.get_format_suffix(**kwargs)\n\n        # Perform content negotiation and store the accepted info on the request\n        neg = self.perform_content_negotiation(request)\n        request.accepted_renderer, request.accepted_media_type = neg\n\n        # Determine the API version, if versioning is in use.\n        version, scheme = self.determine_version(request, *args, **kwargs)\n        request.version, request.versioning_scheme = version, scheme\n\n        # Ensure that the incoming request is permitted\n        self.perform_authentication(request)\n        self.check_permissions(request)\n        self.check_throttles(request)\n\n    # Note: Views are made CSRF exempt from within `as_view` as to prevent\n    # accidental removal of this exemption in cases where `dispatch` needs to\n    # be overridden.\n    def dispatch(self, request, *args, **kwargs):\n        \"\"\"\n        `.dispatch()` is pretty much the same as Django's regular dispatch,\n        but with extra hooks for startup, finalize, and exception handling.\n        \"\"\"\n        self.args = args\n        self.kwargs = kwargs\n        # 这里需要注意\n        request = self.initialize_request(request, *args, **kwargs)\n        self.request = request\n        self.headers = self.default_response_headers  # deprecate?\n\n        try:\n            # 这里需要注意\n            self.initial(request, *args, **kwargs)\n\n            # Get the appropriate handler method\n            if request.method.lower() in self.http_method_names:\n                handler = getattr(self, request.method.lower(),\n                                  self.http_method_not_allowed)\n            else:\n                handler = self.http_method_not_allowed\n\n            response = handler(request, *args, **kwargs)\n\n        except Exception as exc:\n            response = self.handle_exception(exc)\n\n        self.response = self.finalize_response(request, response, *args, **kwargs)\n        return self.response\n```\n\n可以看出，当请求到达 dispatch 的时候，DRF 添加了一些钩子函数，用于开始 / 结束 / 错误控制。\n\n1. 在 initialize_request 的时候，对 request 进行封装，添加上 parser / auth / negoriator / parser context\n2. 接着在 initial 方法里面校验了版本，进行了认证和鉴权，检查了限流\n\n一看，其实与我们之前想封装 APIView 的想法不谋而合，而我们只是想想，DRF 是详细实现。\n\n## 0x02 DjangorestFramework 的使用案例\n\n### 如何开 WebAPI 接口\n\n回到我们的 yadjangoblog 上面来。这个时候我们想开一个博文列表 API:\n\n```python\n# 1. 定义序列器，用于序列化查询的每一条。\nclass BlogPostListSerializer(serializers.ModelSerializer):\n    category = BlogCategorySerializer(read_only=True)\n    tags = BlogTagSerializer(many=True, read_only=True)\n    title = serializers.CharField()\n    id = serializers.IntegerField()\n\n    class Meta:\n        model = BlogPost\n        fields = ('id', 'title', 'char_num', 'vote_num', 'category', 'tags', 'publish_date')\n\n# 2. 定义过滤器，可以通过过滤器进行查询\nclass BlogPostFilter(filters.FilterSet):\n    title = filters.CharFilter(lookup_expr='contains')\n    having_tags = filters.Filter(name=\"tags\", lookup_expr='in')\n\n    class Meta:\n        model = BlogPost\n        fields = ('title', 'char_num', 'category', 'tags')\n\n# 3. 指定其他设置，具体大家看源码就好了。\nclass BlogPostListAPIView(generics.ListAPIView):\n    \"\"\"\n    依照 category , tags , 时间 （年 / 月 / 日  年 / 月 年）\n    \"\"\"\n    queryset = BlogPost.objects.all()\n    serializer_class = BlogPostListSerializer\n    filter_backends = (filters.DjangoFilterBackend, OrderingFilter,)\n    filter_class = BlogPostFilter\n    ordering_fields = ('publish_date',)\n    ordering = ('publish_date',)\n    permission_classes = (permissions.AllowAny,)\n    pagination_class = SmallResultsSetPagination\n```\n\n在指定上面的操作之后，一个接口就快速的开出来了。\n\n: TODO 插入一张图\n\n当然，DRF 认认真真通读一遍的话，还是可以给自己节省不少时间的。\n\n这是开接口，似乎，还少了什么，比如 Restful API.\n\n### 前端如何使用 WebAPI 接口\n\n什么是 CORS 可以参考阮一峰的文章 http://www.ruanyifeng.com/blog/2016/04/cors.html\n\n在调试的时候，我们肯定是使用 ajax / fetch 方式请求。这就会遇到一个问题：\n\n- 跨域\n\n解决方式也很简单，服务端只要服务器实现了 CORS 接口，就可以跨源通信。\n\n安装 django-cors-headers, 并在 settings 中开启 CORS_ORIGIN_ALLOW_ALL = True 即可。\n\n这里参考了临书的解决方案，要感谢 @临书 , 附上参考地址 https://zhuanlan.zhihu.com/p/24893786\n\n对于本项目而言，使用了 axios 请求库，直接 get 即可。详细看前端代码即可。\n\n## 0x03 RESTFUL API 设计\n\n开发过程中，尽量靠近 RESTFUL API 的设计，而不是照搬。\n\n举个其他领域的例子，有的人表述美就只有：\n\n- 已撸\n\n但是不同的美各有各的模样：\n\n- 手如柔荑，肤如凝脂，领如蝤蛴，齿如瓠犀，螓首蛾眉，巧笑倩兮，美目盼兮。\n\n同样，放在 RESFUL 的时候确实也出现了这种情况：\n\n几乎所有的业务逻辑最后会落实到数据表的 CURDE, 但是所有业务逻辑并不能完全使用 CRUDE 描述。\n\n我们看下面的例子\n\n### 关于请求\n\n举个例子，RESTFUL 适合纯粹 CURDE 的设计风格。\n\n比如，新增博客，更新博客，查询博客，删除博客，查看是否含有博客\n\n但语义在某些场景下表述不足， 比如，设计订单的时候，\n\n```bash\nURL: /api/v1/user/some_user/orders\n你查看订单集合，这个好理解。get 方法\n你新增订单，这个好理解。put 方法\nURL: /api/v1/user/some_user/order/xxxxxxx\n你删除订单，这个好理解。delete 方法\n你获取订单，这个好理解。get 方法\n你修改订单，这个好理解。post 方法\n\n但修改订单，有的时候可能会比较复杂，有可能是取消订单，有可能是评价订单，有可能是其他。而 RESTFUL 表达这种情况就有些语义不足了。\n```\n\n当然，个人经验是，字段越多，越难靠近 RESTFUL 规范\n\n这个时候，就需要设计者做好 RESTFULAPI 的设计与语义化的平衡了。\n\n### 关于响应\n\n关于响应设计，主要有两点需要注意：\n\n- 状态码 (HTTP 状态码，也业务逻辑通用状态码）\n- 响应内容 包含 业务逻辑通用状态码，剩下的视具体情况而定。\n\nHTTP 状态码用于标记资源情况，比如：\n\n```\n200 表示获取资源\n404 表示 NOT FOUND\n```\n\n但有时候也存在语义表达不足问题，一般前后端也会约定一个通用的状态码\n\n```\n通用状态码 错误信息 含义 HTTP 状态码\n999\t    unknow_v2_error\t未知错误\t400\n1000\tneed_permission\t需要权限\t403\n1001\turi_not_found\t资源不存在\t404\n1002\tmissing_args\t参数不全\t400\n1003\timage_too_large\t上传的图片太大\t400\n....\n```\n\n至于响应内容，一般都是见招拆招的。建议查看文章末尾的 Douban 的相关 API 规范来提升姿势。\n\n## 0x04 Django 的处理请求流程代码解读\n\n这小节属于一时兴起写的番外篇。和本文主体内容没啥必要的关联。不感兴趣的可以直接跳转到文章末尾点赞哈。\n\nWSGI 全称叫做 web 服务器网关接口，通常情况下，gunicorn 或者 uwsgi 接收来自 nginx 转发来的请求之后，向 web app 提供了环境信息（叫请求上下文会不会好些）以及一个 callback. 这样的话，web app 就可以接收这个环境信息，处理完毕，通过回调函数处理请求，并返回响应。一个极简的 webapp 如下：\n\n```python\ndef app(environ, start_response):\n    \"\"\"Simplest possible application object\"\"\"\n    data = 'Hello, World!\\n'\n    status = '200 OK'\n    response_headers = [\n        ('Content-type','text/plain'),\n        ('Content-Length', str(len(data)))\n    ]\n    start_response(status, response_headers)\n    return iter([data])\n```\n\n现在我们看看 django 中是如何处理请求的。首先查看相关的 wsgi.py\n\n```python\n# wsgi.py\nimport os\nfrom django.core.wsgi import get_wsgi_application\nos.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"config.settings\")\napplication = get_wsgi_application()\n\n# 接着查看 get_wsgi_application\nimport django\nfrom django.core.handlers.wsgi import WSGIHandler\n\ndef get_wsgi_application():\n    \"\"\"\n    The public interface to Django's WSGI support. Return a WSGI callable.\n\n    Avoids making django.core.handlers.WSGIHandler a public API, in case the\n    internal WSGI implementation changes or moves in the future.\n    \"\"\"\n    django.setup(set_prefix=False)\n    return WSGIHandler()\n\n# 于是自然而言的看到了 WSGIHandler\nclass WSGIHandler(base.BaseHandler):\n    request_class = WSGIRequest\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.load_middleware()\n\n    def __call__(self, environ, start_response):\n        # 有木有看到 environ 和 start_response ?? 这就是极简 web app 中的 webapp 核心方法。\n        set_script_prefix(get_script_name(environ))\n        signals.request_started.send(sender=self.__class__, environ=environ)\n        request = self.request_class(environ)\n        # 注意这一行，有请求处理逻辑 具体要见下面代码\n        response = self.get_response(request)\n        # ......\n        return response\n```\n\n嗯，看到了子类，就要看看基类\n\n```python\nclass BaseHandler:\n    _request_middleware = None\n    _view_middleware = None\n    _template_response_middleware = None\n    _response_middleware = None\n    _exception_middleware = None\n    _middleware_chain = None\n\n    def load_middleware(self):\n        \"\"\"\n        注册 MiddleWare, 并赋值 _middleware_chain 方法，使之调用的时候可以先按照顺序从 setting 的 middleware 里面处理 requests\n        并在处理 request 的最后调用 私有方法 _get_response\n        \"\"\"\n        self._request_middleware = []\n        self._view_middleware = []\n        self._template_response_middleware = []\n        self._response_middleware = []\n        self._exception_middleware = []\n\n        handler = convert_exception_to_response(self._get_response)\n        # 注意，这里面是倒着来的 代码中越在前面，实际运行的时候处理就越在后面\n        for middleware_path in reversed(settings.MIDDLEWARE):\n            # 依次添加 view middleware / template middleware / exception middleware\n            middleware = import_string(middleware_path)\n            mw_instance = middleware(handler)\n            handler = convert_exception_to_response(mw_instance)\n\n        # We only assign to this when initialization is complete as it is used\n        # as a flag for initialization being complete.\n        self._middleware_chain = handler\n\n    .....\n\n    def get_response(self, request):\n        \"\"\"Return an HttpResponse object for the given HttpRequest.\"\"\"\n        # Setup default url resolver for this thread\n        set_urlconf(settings.ROOT_URLCONF)\n\n        response = self._middleware_chain(request)\n        # ......\n        return response\n\n    def _get_response(self, request):\n        \"\"\"\n        Resolve and call the view, then apply view, exception, and\n        template_response middleware. This method is everything that happens\n        inside the request/response middleware.\n        \"\"\"\n        response = None\n\n        # 1. 接着判断 urlconf （默认为 ROOT_URLCONF), 可以通过 middleware 进行设置\n        if hasattr(request, 'urlconf'):\n            urlconf = request.urlconf\n            set_urlconf(urlconf)\n            resolver = get_resolver(urlconf)\n        else:\n            resolver = get_resolver()\n\n        resolver_match = resolver.resolve(request.path_info)\n        callback, callback_args, callback_kwargs = resolver_match\n        request.resolver_match = resolver_match\n\n        # Apply view middleware....\n        # 注意，这个就是 view 函数\n        wrapped_callback = self.make_view_atomic(callback)\n        response = wrapped_callback(request, *callback_args, **callback_kwargs)\n        # Complain if the view returned None (a common error).\n        return response\n\n    def process_exception_by_middleware(self, exception, request):\n        # ......\n```\n\n上面代码比较表达的意思比较简单，值得注意的地方我都加了注释。\n\n需要特别注意的就是 middleware_chain 这个属性（实际上是一个方法）, 正是这个方法使得注册的 middleware （在 load_middleware 方法里）可以在 fbv 或者 cbv 处理 request 之前，通过对 request 进行处理。\n\n## 0xEE. 参考链接\n\n还犹豫啥，Django 前后端分离最佳实践，点赞后，快上车吧\n\n- 前端代码 https://github.com/twocucao/YaVueBlog\n- 后端代码 https://github.com/twocucao/YaDjangoBlog\n- 扩展阅读之 douban restful api 设计 https://developers.douban.com/wiki/?title=api_v2\n\n---\n\nChangeLog:\n\n- **2018-02-22** 开启本文\n- **2018-03-04** 重修文字\n"},{"tags":["Python","Django","YaDjangoBlog"],"path":"20180222_YaDjangoBlog开发环境配置.md","title":"YaDjangoBlog 开发环境配置","slug":"YaDjangoBlog 开发环境配置","date":"2018-02-22","category":"Django","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n本文是 Django 全栈开发教程的第一篇，上一篇是第零篇，目录会随时更新，地址在这里 2018 年不容错过的 Django 全栈项目 https://zhuanlan.zhihu.com/p/33903527\n\n\u003e 为什么是第零篇，因为程序员从零计数呀。笑~~\n\n本文需要完成两件事情：\n\n- 配置基本的开发环境\n- 让代码先运行一下\n\n如果你使用的 macOS, 那么可以跟着下文一步一步走。如果是 linux/window 用户，可能稍微需要在配置环境上多花点时间。\n\n\u003e 本文默认你至少会在 iTerm2 下面使用基本的 bash 命令与 git , 如果使用的 ohmyzsh 就更好了。 建议先参考请查看我之前的文章里面的配置环境 如何优雅地使用 macOS https://zhuanlan.zhihu.com/p/29892969\n\n## 0x01 Python 开发环境配置\n\n本小节的目的就是配置好基本的 python 开发环境\n\n使用了神器 pyenv\n\n\u003e BTW: 为什么不直接用 pipenv ? 因为网络不通畅，如若不然，pipenv 比 pyenv 更适合用来做 python 依赖包管理。\n\n```python\n# 新开终端\ngit clone https://github.com/yyuu/pyenv.git ~/.pyenv\ngit clone https://github.com/yyuu/pyenv-virtualenv.git ~/.pyenv/plugins/pyenv-virtualenv\necho 'export PYENV_ROOT=\"$HOME/.pyenv\"' \u003e\u003e ~/.zshrc\necho 'export PATH=\"$PYENV_ROOT/bin:$PATH\"' \u003e\u003e ~/.zshrc\necho 'eval \"$(pyenv init -)\"' \u003e\u003e ~/.zshrc\necho 'eval \"$(pyenv virtualenv-init -)\"' \u003e\u003e ~/.zshrc\n\n# 接着另开终端\n# 不喜写兼容代码，所有代码均向 3.5+ 靠拢\nv=3.5.2|wget http://mirrors.sohu.com/python/$v/Python-$v.tar.xz -P ~/.pyenv/cache/;pyenv install $v\nv=3.6.0|wget http://mirrors.sohu.com/python/$v/Python-$v.tar.xz -P ~/.pyenv/cache/;pyenv install $v\nv=2.7.11|wget http://mirrors.sohu.com/python/$v/Python-$v.tar.xz -P ~/.pyenv/cache/;pyenv install $v\n\n# 设置 Global Python 为 2.7.11, 备注：尽量不要把 Py3 设置为全局，否则由于 Homebrew 本身有一些依赖是依赖于 Py2 的，这样容易出现一些奇怪的问题。\npyenv global 2.7.11\npip install -i https://pypi.doubanio.com/simple requests\n# 下面这个是用于安装基本的代码补全功能\npip install -i https://pypi.doubanio.com/simple --upgrade \"jedi\u003e=0.9.0\" \"json-rpc\u003e=1.8.1\" \"service_factory\u003e=0.1.5\" flake8 pytest autoflake hy\n\n# 创建最常用 Py3 虚拟环境\npyenv virtualenv 3.5.2 py3-daily\npyenv activate py3-daily\npip install -i https://pypi.doubanio.com/simple requests\npip install -i https://pypi.doubanio.com/simple beatutifulsoup4\npip install -i https://pypi.doubanio.com/simple ipython[notebook]\npip install -i https://pypi.doubanio.com/simple jupyter\n# 下面这个是用于安装基本的代码补全功能\npip install -i https://pypi.doubanio.com/simple --upgrade \"jedi\u003e=0.9.0\" \"json-rpc\u003e=1.8.1\" \"service_factory\u003e=0.1.5\" flake8 pytest autoflake hy\n```\n\n好，Python 环境就安装完毕了。\n\n## 0x02 JavaScript 开发环境配置\n\n\u003e 本小节的目的就是配置好基本的 JS 开发环境，但估计 JSer 看了本小节依旧可以在配置上少一些麻烦。\n\nJS 可以前后端通吃，社区生态很丰富。ES6 之后从 python 和 ruby 里面借鉴了不少语法糖。现在写起来还是比较愉悦的。\n\nJavaScript 不管开发前端应用还是后端应用，都需要安装 node 环境。\n\n```bash\n# 先安装 nvm\ncurl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash\n# 新开终端\nnvm install 8\nnvm use 8\nnvm alias default 8\n\nnpm install cnpm\ncnpm install yarn -g\n# 设置镜像\nyarn config set registry https://registry.npm.taobao.org\n```\n\n编辑 ~/.npmrc 配置文件，输入下文再配置各种奇奇怪怪的镜像地址。\n\n```bash\nregistry=https://registry.npm.taobao.org/\nchromedriver_cdnurl=http://cdn.npm.taobao.org/dist/chromedriver\ndisturl=https://npm.taobao.org/dist\noperadriver_cdnurl=http://cdn.npm.taobao.org/dist/operadriver\nphantomjs_cdnurl=http://cdn.npm.taobao.org/dist/phantomjs\nfse_binary_host_mirror=https://npm.taobao.org/mirrors/fsevents\nsass_binary_site=http://cdn.npm.taobao.org/dist/node-sass\nelectron_mirror=http://cdn.npm.taobao.org/dist/electron/\n```\n\n配置完毕\n\n## 0x03 Docker 安装与配置\n\n\u003e 本小节主要解决一个最蛋疼的问题，就是网络问题\n\n下载并安装 docker for mac 地址如下 https://docs.docker.com/docker-for-mac/install/\n\n```bash\n# 安装成功后运行命令\ndocker run hello-world\n```\n\n如果一切正常，则会显示如下\n\n```bash\n$ docker run hello-world\nUnable to find image 'hello-world:latest' locally\nlatest: Pulling from library/hello-world\nca4f61b1923c: Pull complete\nDigest: sha256:083de497cff944f969d8499ab94f07134c50bcf5e6b9559b27182d3fa80ce3f7\nStatus: Downloaded newer image for hello-world:latest\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n\nTo generate this message, Docker took the following steps:\n 1. The Docker client contacted the Docker daemon.\n 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.\n    (amd64)\n 3. The Docker daemon created a new container from that image which runs the\n    executable that produces the output you are currently reading.\n 4. The Docker daemon streamed that output to the Docker client, which sent it\n    to your terminal.\n\nTo try something more ambitious, you can run an Ubuntu container with:\n $ docker run -it ubuntu bash\n\nShare images, automate workflows, and more with a free Docker ID:\n https://cloud.docker.com/\n\nFor more examples and ideas, visit:\n https://docs.docker.com/engine/userguide/\n```\n\n好，配置到这里。\n\n你以为你已经配置好了，还先别激动，网络问题还没解决呢。小的镜像可以直接从 Docker 上直接拖下来，几百兆的镜像可就没这么容易了。\n\n这里我们使用了阿里云的 Docker 容器镜像。\n\n登录阿里云，到控制台，找到容器镜像服务，镜像加速器，\n\n如下图：\n\n右键点击桌面顶栏的 docker 图标，选择 Preferences ，在 Daemon 标签（Docker 17.03 之前版本为 Advanced 标签）下的 Registry mirrors 列表中将 https://your-url.mirror.aliyuncs.com 加到\"registry-mirrors\"的数组里，点击 Apply \u0026 Restart 按钮，等待 Docker 重启并应用配置的镜像加速器。\n\nDocker 配置完毕。\n\n## 0x04 项目试运行\n\n运行项目之前，保持你我的工作环境基本一致\n\n- 创建一些必须的目录\n- clone 项目\n\n```bash\nmkdir -p ~/Codes/YaBlog/DockerVolume/YaDjangoBlog/PostgreSQL/data\nmkdir -p ~/Codes/YaBlog/DockerVolume/YaDjangoBlog/Redis/data\nmkdir -p ~/Codes/YaBlog/DockerVolume/YaDjangoBlog/Backups\ncd ~/Codes/YaBlog/\ngit clone git@github.com:twocucao/YaVueBlog.git\ngit clone git@github.com:twocucao/YaDjangoBlog.git\n```\n\n克隆下来项目之后还需要稍微折腾一下（没办法，CURD 开发 = 折腾折腾折腾 + 搬砖搬砖搬砖）\n\n- 运行 Vue 开发环境\n- 运行 Docker 化的 django 环境\n\n```bash\n# 新开一个终端 用于运行 Vue 应用\n# 前端环境不放在 Docker 环境中。（因为开发环境没必要，生产环境才需要）\ncd ~/Codes/YaBlog/YaVueBlog/ \u0026\u0026 yarn \u0026\u0026 cd -\ncd ~/Codes/YaBlog/YaVueBlog/packages/theme-future/ \u0026\u0026 yarn \u0026\u0026 cd -\ncd ~/Codes/YaBlog/YaVueBlog/\nnpm run build:theme\nnpm run dev\n```\n\n```bash\n# 新开一个终端\ncd ~/Codes/YaBlog/YaDjangoBlog/\nmake\n```\n\n看到下图，包含所有的命令。\n\n这是我用 Makefile 编写的一系列命令，方便我在开发过程将主要的精力花在业务逻辑上而不是花时间在强记大量的琐碎的命令。\n\n```bash\ncd ~/Codes/YaBlog/YaDjangoBlog/\nmake build-all\n# 等待运行后端所有组件\n```\n\n然后，读者可以先去泡杯咖啡点个外卖吃个饭之类的。等待构建完毕。\n\n需要注意的是，务必配置好 docker 镜像加速地址，否则根据国内情况，你可能需要多去泡几杯咖啡，多吃几顿饭。\n\n好，接下来我们运行后端程序，首次运行需要花费不少时间\n\n```bash\ncd ~/Codes/YaBlog/YaDjangoBlog/\nmake django-just-up\n```\n\n运行之后，终端结果如下：\n\n可以发现，服务已经都开始启动了。\n\n但不要冲动，先等等，因为一次开了如下的服务：\n\n- postgres\n- redis\n- elasticsearch\n- mailhog\n- django\n- celerybeat\n- celeryworker\n- celeryflower\n\n需要多等会儿时间到各个服务运行正常。直到出现下图：\n\n这意味着基本上所有的程序都运行正常了。如果有服务挂掉，欢迎到 github 的 issue 上提一下。\n\n```bash\n# 接着再新开一个终端 用于导入基础数据\ncd ~/Codes/YaBlog/YaDjangoBlog/\nmake django-import-articles\n```\n\n好，那么，我们来验证一下如下几个地址：\n\n- 接口地址 http://localhost:8000/api/v1/archive\n- Vue 地址 http://localhost:8080/\n- 在搜索框内输入 elasticsearch 查看接口是否正常返回数据\n- 查看 celery 的 task 是否正确\n\n如果一切正常，则所有的截图应该如下\n\n## 0x05 Tmux 和 Tmuxinator\n\n我们在上文中可以发现有个极其蛋疼菊紧的问题。\n\n当我们运行 make django-just-up 这个命令的时候，所有服务运行的同时，所有的标准输入都打印到一个终端。\n\n这个和我们日常开发不太相同\n\n1. 在 django 开发的时候，我们运行 runserver, 肯定是只想在那个终端里看到 runserver 的运行情况。而不是 Redis,Elasticsearch,PGsql 之类的 log。\n2. 并且，django 的热加载会有些小问题，有些错误只能 ctrl+c 关掉 runserver, 然后重启。但当我们想 ctrl+c 关掉 runserver 的时候，却把所有的的服务都关掉了。\n\n解决方式也简单：\n\n对于暂时不想在开发时看到日志的服务，干脆直接放后台运行，执行我封装的命令 make django-before-up 把部分服务直接放在后台里，然后再开四个终端，运行下面的命令。\n\n- make django-runserver # 运行 runserver , 并只把该容器的 log 打印出来。下面三者同上。\n- make django-celerybeat\n- make django-celeryworker\n- make django-celeryflower\n\n显然还是很麻烦，我这种懒人可是能少写几行代码就少些几行代码的。\n\n那么我们还可以更省事（懒一些）么？\n\n我之前写了一篇简单的 tmux 与 Tmuxinator 教程 https://zhuanlan.zhihu.com/p/33369297 , 具体配置步骤参考文中即可。\n\n配置好 Tmuxinator 之后\n\n```bash\n# 先软连接一下\nln -svf ~/Codes/YaBlog/YaDjangoBlog/yadjangoblog.yml ~/.tmuxinator/yadjangoblog.yml\n```\n\n当我需要运行的所有服务的时候，我只需要\n\n```bash\ntmuxinator start yadjangoblog\n```\n\n就可以开启所有命令。\n\nyadjangoblog.yml 的内容如下\n\n```\nwindows:\n  - \"前端-页面开发\":\n      root: ~/Codes/YaBlog/YaVueBlog/\n      layout: main-vertical\n      panes:\n        - \"前端页面 DEV\":\n          - \"npm run dev\"\n  - \"前端-CSS 与字体文件\":\n      root: ~/Codes/YaBlog/YaVueBlog/\n      layout: main-vertical\n      panes:\n        - \"npm run dev:theme\"\n        - \"npm run dev:iconfont\"\n  - \"后端-Django 及其服务\":\n      root: ~/Codes/YaBlog/YaDjangoBlog/\n      layout: main-vertical\n      panes:\n        - \"make django-before-up \u0026\u0026 make django-runserver\"\n  - \"后端-数据库相关\":\n      layout: main-vertical\n      root: ~/Codes/YaBlog/YaDjangoBlog/\n      panes:\n        - \"sleep 20 \u0026\u0026 make dbshell\"\n        - \"sleep 20 \u0026\u0026 make shell\"\n  - \"后端-Celery\":\n      layout: main-vertical\n      root: ~/Codes/YaBlog/YaDjangoBlog/\n      panes:\n        - \"sleep 20 \u0026\u0026 make django-celerybeat\"\n        - \"sleep 20 \u0026\u0026 make django-celeryworker\"\n```\n\n## 0x06 PyCharm 基本设置\n\n\u003e 大家应该都用 PyCharm 进行开发了吧。 如果是的话，不看本小节可能会让你栽个跟头\n\n```bash\n# 这步是给 pycharm 打开代码做准备\npyenv activate py3-daily\npip install -i https://pypi.doubanio.com/simple -r requirements/local.txt\n```\n\n务必完成下面两个步骤\n\n1. 在 Preferences -\u003e project -\u003e interpreter 选择对应的 py3-daily 虚拟环境。\n2. 在侧边栏把 yadjangoblog , 注意小写的。右键标记为 sources root\n\n这样的标记相当于告诉 PyCharm , 这个项目的 PYTHONPATH 是 yadjangoblog/ , 否则使用 PyCharm 导入 AModel 会自动导入 from yadjangoblog.yaadmin.models from AModel 而不是 from yaadmin.models import AModel , 这会导致程序运行错误。\n\n\u003e PS: 包括后面跑单元测试的时候，均手动设置了 PYTHONPATH 变量。\n\n## 0x07 开发流程\n\n本小节，从笔者开机开始，回顾一下环境配置好之后，笔者是如何进入开发状态的：\n\n1. 开机。输入密码进入桌面。\n2. 打开 Iterm, 运行 tmuxinator start yadjangoblog 开启项目。打开 PyCharm 和 WebStorm\n3. 开发\n\n- 在 WebStorm 中写写前端代码，在 http://localhost:8080 和 tmux 里的第一个 window 查看状态\n- 在 PyCharm 中写写后端代码，在第三个 window 查看 runserver 状态，在第四个 window 的两个 Panel 运行 python manage.py 相关命令。\n- 在 Chrome Elasticsearch Head 扩展里调试 Elasticsearch 语法\n- 在 http://localhost:8000/api/your-api-path 里调试前后端 API\n- 在 http://localhost:5555 通过 flower 查看相关\n- .....\n- 当然，你也可以新开一个终端里面，执行 make 查看相关还可以执行哪些命令。\n\n那么，具体执行这些命令背后究竟发生了什么？\n\n- 数十服务为何突然启动\n- 数百个任务为何半夜消失\n- 正常运行的服务为何屡屡崩溃\n- 这一切的背后！是工程师的人性扭曲还是码畜的道德沦丧？是内存的爆发还是处理器的无奈？\n- 敬请关注本专栏 『MG 的编程小屋』或者 Github 频道，让我们跟随教程走进全干工程师的代码世界。\n\n\u003e 不好意思，顺手打了个硬广，防止别人把我的文章砍头去尾直接扒过去。\n\n## 0xEE. 参考链接\n\n还犹豫啥，点赞后，快上车吧\n\n- 前端代码 https://github.com/twocucao/YaVueBlog\n- 后端代码 https://github.com/twocucao/YaDjangoBlog\n\n---\n\nChangeLog:\n\n- **2018-02-22** 重修文字\n"},{"tags":["Python","Django","YaDjangoBlog"],"path":"20180221_FullStackDjangoDevOps.md","title":"2018 年不容错过的 Django 全栈项目","slug":"2018 年不容错过的 Django 全栈项目","date":"2018-02-21","category":"Django","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n\u003e 写在前面的话：不好意思，标题难以免俗，起了个很俗气的名字。\n\n这是我的一个全栈类型 Django 开源项目的系列讲解教程的目录。\n\n为什么写这系列的文章呢？目的总的来说有两个：\n\n1. 一是希望更多的人通过本系列的教程更好的认识 Django 开发技术栈或者说是 Web 开发技术栈，让更多的 Pythonist 更顺畅的进入 Django 开发的世界。\n2. 二是希望借由这个持续更新的过程让自己更加深入理解 Django 技术栈 Django / DjangoRestFramework / Docker / Vue.JS / Celery / PostgreSQL / Redis / RabbitMQ\n\n为什么说这个项目你不容错过？\n\n- 新！新！新！保持最新的软件开发版本，E.G: Django 2.0 + Vue.JS 2.5 + PostgreSQL 10 + Celery 4.1.0\n- Django 框架：Django 及其 强大的生态圈\n- 后端组件：PostgreSQL RabbitMQ Redis Ngnix\n- 前端技术：单页应用 前后端分离 (VueJS+Webpack+DjangoRestFramework), 自动化部署\n- Django 社区最佳实践：从配置 / 开发 / 测试 / 部署 **全干**工程师 (Full Stuff Engineer) 的最新的 DevOps 思考成果。\n- 基本覆盖了进阶 Django 开发所需要的各种组件与操作。\n- 只需要适当的调整，本项目就可以成为你新开项目的最佳脚手架。\n\n本系列文章的面向读者：\n\n- 目标是 DevOps 的 Pythonist\n- 爱瞎几把折腾的 Pythonist\n- 前后端分离的实践者\n\n\u003e 生命苦短，赶快上车\n\n\u003e Life is Short , I Use Python\n\n## 0x01 项目介绍\n\nYaDjangoBlog 是另一个关于博客的轮子，但是其野心并不在于仅仅多造一个博客系统，还有通过本项目做 Django 全栈开发的最佳实践。\n\n### 1.1 项目地址\n\n- 前端代码 https://github.com/twocucao/YaVueBlog\n- 后端代码 https://github.com/twocucao/YaDjangoBlog\n\n### 1.2 项目技术栈\n\n- 开发与部署环境为 Docker\n- Python 3.5.2\n- 前端 Vue + Webpack + ES2015 + axios\n- 后端 [Django 2.0](https://github.com/django/django) + [DjangoRestFramework](https://github.com/tomchristie/django-rest-framework/) + Celery\n- 自动化部署选用工具 Ansible 以及 Docker\n- 后端组件\n  - ElasticSearch 用于搜索和推荐\n  - PostgreSQL 用于数据持久化\n  - Redis 用于 Session / 和缓存\n  - RabbitMQ 分布式队列 / 定时任务\n  - Nginx 用于反向代理\n\n### 1.3 特别感谢\n\n- ansible django stack: https://github.com/jcalazan/ansible-django-stack\n- cookiecutter-django: https://github.com/pydanny/cookiecutter-django\n- djangopackages: https://github.com/djangopackages/djangopackages\n- 董伟明 关于 ElasticSearch 的几篇文章 http://www.dongwm.com/archives/%E7%9F%A5%E4%B9%8ELive%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E4%B9%8B%E4%BD%BF%E7%94%A8Elasticsearch%E6%90%9C%E7%B4%A2/\n- 各个组件的开发者们\n  - ElasticSearch\n  - PostgreSQL\n  - Redis\n  - RabbitMQ\n  - Nginx\n  - Docker\n\n### 1.4 项目截图\n\n好，讲了半天有的没的，还是贴点图吧，毕竟我不是 Markdown 程序员\n\n\u003e 我们先看看能看得见的前端页面\n\n主页\n\n![](https://user-gold-cdn.xitu.io/2018/2/21/161b6ba50ddaa85f?w=3344\u0026h=1822\u0026f=png\u0026s=1504757)\n\n博客详情\n\n![](https://user-gold-cdn.xitu.io/2018/2/21/161b6c3e3a0b8dd4?w=3342\u0026h=1846\u0026f=png\u0026s=1021166)\n![](https://user-gold-cdn.xitu.io/2018/2/21/161b6c31db9c8d5c?w=3350\u0026h=1804\u0026f=png\u0026s=1016132)\n\n这是一个很普通的 Archive 页面\n\n![](https://user-gold-cdn.xitu.io/2018/2/21/161b6bfa8c121ed4?w=3312\u0026h=1818\u0026f=png\u0026s=425859)\n\n这是以 Elasticsearch 为支持的 搜索功能\n\n![](https://user-gold-cdn.xitu.io/2018/2/21/161b6bc0a967a3e1?w=3348\u0026h=1840\u0026f=png\u0026s=1582839)\n\nDjango 自带后台\n\n![](https://user-gold-cdn.xitu.io/2018/2/21/161b6c47b50b6827?w=3356\u0026h=1768\u0026f=png\u0026s=365303)\n\n前后端分离怎么能少的了 rest api 的实现与便捷的前端调试？\n\n![](https://user-gold-cdn.xitu.io/2018/2/21/161b6c5522e83368?w=3346\u0026h=1840\u0026f=png\u0026s=486772)\n![](https://user-gold-cdn.xitu.io/2018/2/21/161b6c7ad6641b0a)\n\nDjango Debug Tools 帮你迅速调优接口\n\n![](https://user-gold-cdn.xitu.io/2018/2/21/161b6c782bf2a593?w=3348\u0026h=1838\u0026f=png\u0026s=735083)\n\n\u003e 我们再先看看能看得见的开发界面\n\n在终端执行 tmuxinator start yavueblog 就可以自动运行所有任务\n\n前端运行状态\n\n![](https://user-gold-cdn.xitu.io/2018/2/21/161b6d2d904bb3aa?w=3360\u0026h=2054\u0026f=png\u0026s=539522)\n![](https://user-gold-cdn.xitu.io/2018/2/21/161b6d7172d15be3?w=3360\u0026h=2054\u0026f=png\u0026s=2446065)\n\n后端运行状态\n![](https://user-gold-cdn.xitu.io/2018/2/21/161b6d5933c52727?w=3360\u0026h=2054\u0026f=png\u0026s=3296514)\n![](https://user-gold-cdn.xitu.io/2018/2/21/161b6d8ce415395c?w=3360\u0026h=2054\u0026f=png\u0026s=2720324)\n![](https://user-gold-cdn.xitu.io/2018/2/21/161b6d9ff1f2efb1?w=3360\u0026h=2054\u0026f=png\u0026s=3932296)\n\n当然，你可以直接用客户端连接到对应的服务商检查组件的运行状态\n\n![](https://user-gold-cdn.xitu.io/2018/2/21/161b6db1754b4e8b?w=3352\u0026h=1430\u0026f=png\u0026s=640103)\n![](https://user-gold-cdn.xitu.io/2018/2/21/161b6d949bd83c81?w=3352\u0026h=1126\u0026f=png\u0026s=532337)\n\n## 0x02 系列教程目录\n\n### 2.1 教程注意项\n\n1. 本文的开发环境配置仅仅限于 macOS 上，如果读者使用的是 Windows / 可能需要自己搞定环境的配置。不过笔者使用了 Docker 进行环境配置，应该配置环境会省事很多。\n2. 在阅读本教程，请读者至少跟着 Django 官方的教程跟着走一遍。不要零基础一通瞎搞。\n3. 如果在使用过程中出现问题，请在 ISSUE 提供尽可能多的信息，将问题描述清楚。\n\n本系列教程并不按照一步一步增加代码的方式写教程。\n\n我先带着大家搭建好整个项目框架，然后从不同的视角开介绍这个项目，比如：\n\n1. 某个模块的 models 是如何设计的？有哪些卧槽居然可以这么用的写代码方式。\n2. Django User 如何做扩展？同样在 Django 的生态圈里面，哪些场景有哪些值得围观的包，比如 guardian\n3. Restful API 应该如何写，Django 里面的 Rest API 应该如何写？会有哪些生产效率 guangguangguang 提升上去的使用方法？权限怎么做？限流怎么搞？\n4. Py.test TDD 测试驱动开发了解一下？\n5. 使用 Tmux 等合理工具的优雅的单终端多开。\n\n### 2.2 教程目录\n\n- Django 全栈开发教程 - 2018 年不容错过的 Django 全栈项目 -- 目录篇\n- Django 全栈开发教程 - YaDjangoBlog 的开发环境配置\n- Django 全栈开发教程 - YaDjangoBlog 的后端组件配置\n- Django 全栈开发教程 - YaDjangoBlog 的前后端初步设计\n- Django 全栈开发教程 - YaDjangoBlog 的后端初步实现\n- Django 全栈开发教程 - YaDjangoBlog 的前端实现 YaVueBlog\n- Django 全栈开发教程 - YaDjangoBlog 的后端组件之 Redis\n- Django 全栈开发教程 - YaDjangoBlog 的后端组件之 PostgreSQL\n- Django 全栈开发教程 - YaDjangoBlog 的后端组件之 Elasticsearch\n- Django 全栈开发教程 - YaDjangoBlog 的后端组件之 RabbitMQ\n- Django 全栈开发教程 - YaDjangoBlog 的生产环境部署\n\n## 0xEE. 参考链接\n\n还犹豫啥，快上车吧\n\n- 前端代码 https://github.com/twocucao/YaVueBlog\n- 后端代码 https://github.com/twocucao/YaDjangoBlog\n\n---\n\nChangeLog:\n\n- **2018-02-21** 重修文字\n"},{"tags":["Python","Django","YaDjangoBlog"],"path":"20180220_UnKnownCheatSheet.md","title":"Unknown Cheatsheet","slug":"Unknown Cheatsheet","date":"2018-02-20","category":"Django","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n\u003e 写在前面的话：不好意思，标题难以免俗，起了个很俗气的名字。\n\n这是我的一个全栈类型 Django 开源项目的系列讲解教程的目录。目的总的来说有两个：\n\n1. 一是希望更多的人通过本系列的教程更好的认识 Django 开发技术栈或者说是 Web 开发技术栈，让更多的 Pythonist 更顺畅的进入 Django 开发的世界。\n2. 二是希望借由这个持续更新的过程让自己更加深入理解 Django 技术栈 Django / DjangoRestFramework / Docker / Vue.JS / Celery / PostgreSQL / Redis / RabbitMQ\n\n\u003e 生命苦短，我用 Python\n\n为什么说这个项目你不容错过？\n\n- 新！新！新！保持最新的软件开发版本，E.G: Django 2.0 + Vue.JS 2.5 + PostgreSQL 10 + Celery 4.1.0\n- Django 框架：Django 及其 强大的生态圈\n- 后端组件：PostgreSQL RabbitMQ Redis Ngnix\n- 前端技术：单页应用 前后端分离 (VueJS+Webpack+DjangoRestFramework), 自动化部署\n- Django 社区最佳实践：从配置 / 开发 / 测试 / 部署 **全干**工程师 (Full Stuff Engineer) 的最新的 DevOps 思考成果。\n- 基本覆盖了进阶 Django 开发所需要的各种组件与操作。\n- 只需要适当的调整，本项目就可以成为你新开项目的最佳脚手架。\n\n本系列文章的面向读者：\n\n- 目标是 DevOps 的 Pythonist\n- 爱瞎几把折腾的 Pythonist\n- 前后端分离的实践者\n\n\u003e 生命苦短，赶快上车\n\n## 0x01 项目介绍\n\nYaDjangoBlog 是另一个关于博客的轮子，但是其野心并不在于仅仅多造一个博客系统，还有通过本项目做 Django 全栈开发的最佳实践。\n\n### 1.1 项目地址\n\n- 前端代码 https://github.com/twocucao/YaVueBlog\n- 后端代码 https://github.com/twocucao/YaDjangoBlog\n\n### 1.2 项目技术栈\n\n- 开发与部署环境为 Docker\n- Python 3.5.2\n- 前端 Vue + Webpack + ES2015 + axios\n- 后端 [Django 2.0](https://github.com/django/django) + [DjangoRestFramework](https://github.com/tomchristie/django-rest-framework/) + Celery\n- 自动化部署选用工具 Ansible 以及 Docker\n- 后端组件\n  - ElasticSearch 用于搜索和推荐\n  - PostgreSQL 用于数据持久化\n  - Redis 用于 Session / 和缓存\n  - RabbitMQ 分布式队列 / 定时任务\n  - Nginx 用于反向代理\n\n### 1.3 特别感谢\n\n- ansible django stack: https://github.com/jcalazan/ansible-django-stack\n- cookiecutter-django: https://github.com/pydanny/cookiecutter-django\n- djangopackages: https://github.com/djangopackages/djangopackages\n- 董伟明 关于 ElasticSearch 的几篇文章 http://www.dongwm.com/archives/%E7%9F%A5%E4%B9%8ELive%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E4%B9%8B%E4%BD%BF%E7%94%A8Elasticsearch%E6%90%9C%E7%B4%A2/\n- 各个组件的开发者们\n  - ElasticSearch\n  - PostgreSQL\n  - Redis\n  - RabbitMQ\n  - Nginx\n  - Docker\n\n## 0x02 系列教程目录\n\n### 2.1 教程注意项\n\n1. 本文的开发环境配置仅仅限于 macOS 上，如果读者使用的是 Windows / 可能需要自己搞定环境的配置。不过笔者使用了 Docker 进行环境配置，应该配置环境会省事很多。\n2. 在阅读本教程，请读者至少跟着 Django 官方的教程跟着走一遍。不要零基础一通瞎搞。\n3. 如果在使用过程中出现问题，请在 ISSUE 提供尽可能多的信息，将问题描述清楚。\n\n\u003e 本系列教程并不按照一步一步增加代码的方式写教程。我先带着大家搭建好整个项目框架，然后从不同的视角开介绍这个项目，比如：\n\n1. 某个模块的 models 是如何设计的？有哪些卧槽居然可以这么用的方式。\n2. Django User 如何做扩展？同样在 Django 的生态圈里面，哪些场景有哪些值得围观的包，比如 guardian\n3. Rest API 应该如何写，Django 里面的 Rest API 应该如何写？会有哪些生产效率 guangguangguang 提升上去的使用方法？权限怎么做？限流怎么搞？\n4. Py.test TDD 测试驱动开发了解一下？\n\n### 2.2 教程目录\n\n- Django 全栈开发教程 - Python 和 Docker 环境配置\n- Django 全栈开发教程 - YaDjangoBlog 博客的后端组件配置\n- Django 全栈开发教程 - YaDjangoBlog 博客的前后端初步设计\n- Django 全栈开发教程 - YaDjangoBlog 博客的后端初步实现\n- Django 全栈开发教程 - YaDjangoBlog 博客的前端实现 YaVueBlog\n- Django 全栈开发教程 - YaDjangoBlog 博客的后端组件之 Redis\n- Django 全栈开发教程 - YaDjangoBlog 博客的后端组件之 PostgreSQL\n- Django 全栈开发教程 - YaDjangoBlog 博客的后端组件之 Elasticsearch\n- Django 全栈开发教程 - YaDjangoBlog 博客的后端组件之 RabbitMQ\n- Django 全栈开发教程 - YaDjangoBlog 博客的部署\n\n于是，本文的内容就如下：\n\n- 前后端分离\n- 自动化部署\n- 数据库相关\n- 其他踩坑经历\n\n\u003c!-- more --\u003e\n\n## 0x01 前后端分离\n\n前后端分离是提高团队开发的一个重要的开发策略，前后端分离之后，后端和前端交流好 JSON 格式，并行开发，局域网中放置一台服务器，后端写好一个功能，推送代码，由 gitlab 触发 Runner 自动交付到局域网的服务器上。这样的话，前后端可以并行开发，从而摆脱每一次开发过程不可避免，前端编写模板，然后由后端套用模板，出了问题，前端修改模板，后端接着修改模板... 循环往复，不曾更改的问题，在这种职责分明的情况下也不会出现背锅侠的问题。\n\n在往常的开发过程中，而如果 Ajax 比较多或者前端写的代码质量稍微低一些，那么倒霉的事情就发生了，后端和前端的沟通成本那是相当的高。推锅的事情也会发生。\n\n而新的开发过程中，如果上级有界面上的需求，基本上只需要前端更新一下代码，推送，就可以立即看到效果。\n同样的，后端也是如此。\n\n\u003e 这就是我选择前后端分离的初衷 -- 将主要的精力放在开发上面。而不是套用模板和编辑 Ajax 过程中带来的沟通问题。\n\n在前后端配合上：\n\n- 后端选择 Django,Restful 框架选择了 DjangoRestFramework, DRF 的优点在于可以自动生成 API 界面，让前端对照着表单进行请求接口的测试。于是局域网的那一台可以配置为 Debug 模式，生产机器就可以关闭 DEBUG 模式。\n- 前端选择 VueJS, 选择这个小而精美的框架一方面是基于团队的开发水平考虑，如果使用太激进的框架 React, 可能遇到问题无法在短时间内解决。由于选用了 VueJS, 也就选用了 Vue 全家桶，通过 Webpack2 进行配置完成基本的打包任务，通过 config 读取环境变量进行生产环境和发布环境的 apiurl 的分离\n- 代码提交选择 Coding.NET 用于提交代码，在局域网中选择 Gitlab 用于提交代码，配上 Gitlab CI 进行持续集成，每次提交代码直接直接构建本地发布。前后端合作亲密无间。\n\n前后端分离有什么缺点呢？\n\n1. 必须强行升级 Https\n2. 开发时候需要关掉 Django 的同源策略\n3. IE8-- 不兼容\n\n### 1.1 Django 和 他的小伙伴们\n\nDjango 适用于快速开发，对于创业公司来说，是不错的快速开发语言。\n\n不仅仅是因为 Python 表达力比较强，更重要的是 Django 有很多高质量的包可以使用。\n\n- Django Debug Toolbar\n- DjangoRestFramework\n- Django Extensions\n\n### 1.4 Django 的奇技淫巧\n\n#### Django Model\n\n- [Save If Changed](http://stackoverflow.com/questions/1355150/django-when-saving-how-can-you-check-if-a-field-has-changed)\n\n## 0x02 自动化部署\n\n写程序 一般就是开发测试部署。\n\n话虽然这么时候，但是在具体的实践过程中，还是有很多很多坑需要注意的。\n\n比如，仅仅就开发环节来说，团队协作怎么搞？你说可以用 GIT 作为版本管理工具，代码托管。那我问你，这个 Web 开发过程中前端开发模板，后端套用模板怎么搞？你说，前后端分离，那前后端分离后 Http 请求被劫持怎么办，跨站攻击怎么搞......\n甚至如果是一个人开发的话，直接拉一台服务器做做部署，定期更新到网站上就行了。但如果是团队协作呢？前端提交了代码，产品经理过来说，你更新一下服务器，后端提交了代码，前端过来说，你更新一下服务器，过程琐碎而耗时。大量的时间就浪费在了这种枯燥的事情上了。两个后端，一个前端的情况下，每天本地发布（交付）的次数就已经是相当惊人（大概是前后端每天提交 5 次左右），如果以后是 3 个后端，三个前端，那我作为主程，每天就写不了代码了，这种情况是断不能忍的。\n\n这个时候，就需要想着把团队协作开发流程优化好：\n\n在我刚开始进行开发的时候，使用 bash 配合 Ansible 在本地和上线的 Ubuntu 16.04 上面自动化能够自动化的大部分工作，程序员在本地开发的时候，只需要进行开发，然后推送代码到 repo, 剩下的诸如自动化测试集成到系统中，则全部自动化。\n\n### 2.1 使用场景\n\n经过研究，我确定了理想中的使用场景：\n\n\u003e 前端与后端提交代码到代码托管上面的时候，直接集成，构建，Stage 到服务器。\n\n\u003e 到上线的时候，由我执行 Ansible 进行上线。\n\n### 2.2 实施方案\n\n在这个流程中，我需要安装如下的软件：\n\n- Gitlab Gitlab-CI-Runner : 用于解决代码托管，项目的基本成长，以及持续化集成\n- PostgreSQL\n- MongoDB\n- Redis\n- RabbitMQ\n- Nginx\n- Python 以及 Python 扩展的依赖包\n- 其他\n\n配置文件为 3 类：\n\n- test\n- stage\n- production\n\n硬件设备 3 台：\n\n1. 第一台为 Gitlab 部署的软件\n2. 第二台为 Stage 环境 （本地局域网持续交付）的机器\n3. 第三台为 Server （阿里云） 机器\n\n\u003e 注：最初使用 Ubuntu 机器，最终确定使用 Docker 镜像进行构建\n\n### 2.3. 持续交付\n\n当前端工程师 Push Master 分支到 Repo 上的时候，执行 Job 更新网站\n当后端工程师 Push Master 分支到 Repo 上的时候，执行 Job 更新网站\n\nPush Master 分支，这个自然无需多说，问题是怎么执行 Job 呢？\n\n\u003e **Gitlab CI Multi Runner**\n\n在一台 stage 的机器上安装 gitlab ci multi runner , 并且在该机器上注册 runner 为 shell , 这意味着 runner 会以 gitlab-runner 用户的权限进行测试 , 你需要 uninstall\n然后 install --user=root 一下，然后重启，即可在 gitlab-ci.yml 上。\n\n修改文件\n\n```bash\n\ngitlab-runner register # 然后填入相关信息\nvim /etc/gitlab-runner/config.toml # 接着进行修改\n```\n\n```bash\nconcurrent = 1\ncheck_interval = 0\n\n[[runners]]\n  name = \"yadjangoweb\"\n  url = \"http://192.168.1.139/ci\"\n  token = \"325asd65f4e7xa9faasda8da\"\n  executor = \"shell\"\n  [runners.cache]\n```\n\n### 2.4. Dockerize Application\n\nDocker 以其轻量级和类似于版本管理的软件方式吸引了我。于是，准备将所有的 Service 都 Docker 化。\n\n拿 Django 程序来说，首先 Django 程序依赖三个组件 redis / postgresql / rabbitmq , 完成这些组件的安装之后才能进行下一步的操作。\n\n## 0x03 数据库相关\n\n### 1. 数据库设计\n\nPostgreSQL Array 在爬虫方面可以用来标记一个 Record 的处理状态\nPostgreSQL Range 用来判断范围也是一个比较高效的选择（用空间 gist 索引取代两个索引）\n\nGeoDjango 和 PostGIS 非常配\n\n### 2. 数据迁移\n\n#### 1.1. 第一次数据迁移之 MySQL 转 PostgreSQL\n\n第一次数据迁移的时候基于 PostgreSQL 社区里面有个大杀器，叫做 PostGIS, 通过 PostGIS, 可以很方便的拥有和国内一些地图公司匹敌的算法。抛开算法实现的效率问题，基本上可以满足日常的开发需求，当时数据量不算大，使用 mysqldump 下来也就 500M 左右，而且行数大约 700W 条，于是使用了一个很笨的方法，就是将数据库使用 Django 命令 dump 成 json, 接着修改配置重新导入新数据库。\n\n这种方式的缺点就是效率低而且太吃内存了，当时 16G 的服务器满内存，满交换内存地搞了一个上午。\n\n#### 1.2. 第二次数据迁移之重新 makemigrations\n\n为什么要重新 makemigrations 呢，因为糟糕的事情发生了。\n\n有个需求，需要重新定制用户登录认证系统。用户登录认证系统是最最应该在项目开始的时候编写的，这就是项目的基石，这个需求就恰似在房子盖到第三层的时候突然要把地基给加固。\n\nDjango 中如果使用了 auth 模块，则 auth.user 是最先被迁移到数据库中的，而如果你经过权衡继承 AbstractUser 并且 makemigrations 生成个迁移文件 0001_initial.py 后，在正常的情况下不容易将 migration 修改应用到数据库中。\n\n\u003e 如果我偏要勉强呢？\n\n当然是可以勉强的，删掉数据库中已经记录下来的 auth.user migration 的相关记录即可。\n\n那我为什么还是需要重新编写 migration 呢？\n\n1. 因为之前对数据库的结构调整比较频繁，多达 138 次，而在 138 次调整数据结构之后，再去撤销第一次数据表的迁移操作的时候，则无异于厨子做菜要把牛排做 8 分熟，但是厨子做到 7 分熟的时候，突然顾客说，我要 5 分熟的牛排。那只能重新来了。\n2. 顺手精简掉 138 个文件。\n\n如何做呢？\n\n1. 数据的迁移在没有表与表之间的关联的时候是很好办的，CSV, 标准 SQL 文件。\n2. 有表关联的情况下则需要权衡数据量来进行迁移，假如数据量在 10 来个 G 的时候，读到内存中，按照数据表的依赖关系，自下而上逐层迁移即可。\n3. 数据量大的时候，则需要去约束，去索引，然后转 CSV/SQL, 迁移到数据表中。如果表依赖不复杂的话，直接 psql 命令重定向数据也可以。\n\n但是呢，由于使用了 Django, 在数据量不大的时候，完全可以使用 Django 的 ORM 来做迁移。\n\n我在 Google 了一下，发现下面一个脚本，于是设置数据库为新数据库 default 和 depressed\n\n```python\ndef batch_migrate(model):\n    # remove data from destination db before copying\n    # to avoid primary key conflicts or mismatches\n    if model.objects.using('default').exists():\n        model.objects.using('default').all().delete()\n\n    # get data form the source database\n    items = model.objects.using('depressed').order_by(\"pk\").all()\n    count = len(items)\n    # process in chunks, to handle models with lots of data\n    for i in range(0, count, 10000):\n        chunk_items = items[i:i + 10000]\n        print(\"已经迁移数据\", i)\n        model.objects.using('default').bulk_create(chunk_items)\n\n    # many-to-many fields are NOT handled by bulk create; check for\n    # them and use the existing implicit through models to copy them\n    for m2mfield in model._meta.many_to_many:\n        m2m_model = getattr(model, m2mfield.name).through\n        batch_migrate(m2m_model)\n```\n\n按照表与表之间的依赖关系，逐个迁移到数据库中搞定。\n\n### 1.3 sequence 问题\n\n在写 Django 的时候发现的时候无论如何都无法保存新的 item.\n\n原来的代码为：\n\n```python\nitem = Item.objects.get_or_create()\nitem.foo = 1\nitem.save()\n```\n\n报错信息是 Integrety, 报 duplicated 错误（下面的代码当然是打了马赛克了）\n\n```python\ndjango.db.utils.IntegrityError: duplicate key value violates unique constraint \"foo_item_pkey\"\nDETAIL:  Key (id)=(111111) already exists.\n```\n\n那么，问题来了：\n\n\u003e ~~挖掘技术哪家强？~~\n\n啊，不是\n\n\u003e How To Solve This?\n\n经过猜测，而 get 到已有的 item 设置并且保存的话，并不会出现这个问题。问题主要出在 create 上面。\n\n于是编写代码验证一下是不是猜想正确\n\n```python\ntry:\n    item = Item.objects.get()\nexcept Exception:\n    item = Item.objects.create()\n\n# do something\n\nitem.save()\n```\n\nduplicate 的问题肯定是多次存同样的不能重复的字段。\n\n**但尼玛，我之前做测试的时候考虑过这个逻辑呀？**换而言之，这种问题不应该出现，如果出现了问题，八成是 ORM 用的不对。\n\n印象中这种问题 Google 一下 Integrety Duplicate Django PostgreSQL 一般就能出来了。\n\n最后找到解决方案：http://centoshowtos.org/web-services/django-and-postgres-duplicate-key/\n\n在终端进入 psql 查询 sequence 最新值\n\n```sql\nselect start_value, last_value, max_value from dt_crawler_item_item_id_seq;\n\n start_value | last_value |      max_value\n-------------|------------|---------------------\n           1 |    111110 | 9223372036854775807\n```\n\n而我们查看一下 item_id 的最大值\n\n```\nselect max(item_id) from app_model_item;\n\n   max\n---------\n 111111\n```\n\n重置 sequence last_value 值到最新即可。\n\n```\nalter sequence app_model_item_item_id_seq restart with 111111;\n```\n\n\u003e 当数据库每次插入一条非指定主键的记录，则获取 last_value(111110), 加 1 得到当前的主键接着插入。但这个过程无异于数据库中已经有了一个 pk 为 111111 的记录，再插入一条。于是报错。\n\n回顾这个问题，该问题是由于 PostGres 的 sequence 造成 pkey 相等，换而言之，postgres 应该在有一个 pk 值为 111111 的时候，插入一个无主键的记录，PostgreSQL 获取 sequence+1(111110 + 1) 得到它认为当前的主键值，接着再一次插入了主键为 111111 的这个值。\n\n这个过程相当于依次插入两个条 ID 相同的记录。\n\n```sql\nINSERT INTO table(id, column2, …) VALUES (111111, value2, …);\nINSERT INTO table(id, column2, …) VALUES (111111, value2, …);\n```\n\n\u003e sequence 避免了每一次 max 查找带来的性能损失，一方面带来了方便，也带来了隐藏的坑。\n\n如果以后这个问题比较多的话，参考下面的源码对文本进行修改。\n\nhttps://github.com/ASKBOT/django-postgresql-fix-sequences/blob/master/postgresql_sequence_utils/utils.py\n\n## 0x04 WebServer\n\n目前使用的 WebServer 是用 Nginx 做反向代理，将请求通过 unix socket 转发到 gunicorn，gunicorn 作为 django 实际上的 webserver。\n\n### unix socket 和 gunicorn 的 REMOTE_ADDR 问题\n\nDjango Admin 模块在访问 某个页面的时候特别特别慢，而在我的机器上一切正常，我怀疑的是数据库的问题，于是，那么首先要知道数据库的查询语句，于是想借用 django debug toolbar 来 profiling, 于是问题来了，我在局域网模拟真机环境，结果无论如何都无法呈现 Django Debug Toolbar,\n\n问题八成出现在 Django 配置环境 或者 Nginx 上面（当然，最后发现是 Gunicorn 的锅）. 在\n\n经过一段时间的排查，认为是 Nginx 的问题，在相关配置添加下面设置 Header,\n\n```python\nproxy_set_header X-Forwarded-For $remote_addr;\n```\n\n结果依旧无法获取 request.Meta[\"REMOTE-ADDR\"]\n\n经过搜索发现不止我一个人的问题：https://github.com/benoitc/gunicorn/issues/797\n\n最后发现是 Http 请求从 nginx 这儿经过 unix socket 转发到 gunicorn.sock 下默认是没有赋值 REMOTE-ADDR 的，\n\n那么，这个在 HTTP Header 层次的东西，没有在 gunicorn 层次解决，那就只能在 django 层次解决。\n\n给 Django 添加中间件如下，放在 djangodebugtools 的前面。\n\n```python\nclass XForwardedForMiddleware(MiddlewareMixin):\n    def process_request(self, request):\n        if request.META.get(\"HTTP_X_FORWARDED_FOR\", False):\n            request.META[\"HTTP_X_PROXY_REMOTE_ADDR\"] = request.META[\"REMOTE_ADDR\"]\n            parts = request.META[\"HTTP_X_FORWARDED_FOR\"].split(\",\", 1)\n            request.META[\"REMOTE_ADDR\"] = parts[0]\n```\n\n解决。\n\n### Nginx Gzip 压缩\n\n当 json 数据量比较大的时候，则必须要考虑开启压缩。一般情况下，虽然这个可以在 Django 层次完成，但是这么做还不如在 nginx 层次完成。\n\n```python\n    gzip on;\n    gzip_disable \"msie6\";\n    gzip_vary on;\n    gzip_proxied any;\n    gzip_comp_level 6;\n    gzip_buffers 16 8k;\n    gzip_http_version 1.1;\n    gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;\n```\n\n开启之后，我这边的 一个 220k 的数据缩减到 54k\n\n## 0x04. 其他踩坑相关\n\n### 4.1 奇怪的文件问题\n\n在某一天遇到了一个问题 往常的时候，当文件上传到 Django 中的时候，都可以正常的解析，但是这两天居然不能用了。\n\n```python\n# 问题代码出现在\ndf = pd.read_excel(file_obj)\n# 报这个问题 google 几乎没有什么解决方案\nInvalid file path or buffer object type\n\u003cclass 'django.core.files.uploadedfile.InMemoryUploadedFile'\u003e\n```\n\n更加糟糕的问题出现了，我本人的开发环境和服务器的开发环境基本一致，但，但，但为什么不能用呢？\n\n分别回滚代码，Nginx 设置，在线上打 Log, 最终确定了是 Pandas 从 0.19 升级到了 0.20 之后出现的一个小问题。最终还原线上 python 安装环境，搞定。\n\n## 0xEE. 参考链接\n\n---\n\nChangeLog:\n\n- **2018-02-21** 重修文字\n"},{"tags":["CheatSheet"],"path":"20180210_DockerCheatSheet.md","title":"Docker CheatSheet","slug":"Docker CheatSheet","date":"2018-02-10","category":"DevOps","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n本文为 Cheatsheet 类型文章，用于记录我在日常编程中经常使用的 Docker 相关和命令。\n\n- Docker 相关概念\n- Docker 配套工具\n- Django PostgreSQL RabbitMQ Redis ElasticSearch Sentry 集群 Docker 化\n- Docker 踩坑记录\n\n不定期更新。\n\n\u003c!-- more --\u003e\n\n## 0x01 Docker 相关概念\n\n### 1.1 Docker 是什么？\n\n在认知 Docker 这种相对而言比较新概念的时候，只要从以往的经验中拿出一个词语来概括新词汇即可。\n\n于是，我们便可以这么理解：\n\n\u003e Docker 是一种比虚拟机轻量的用来存放职责比较单一的应用的容器。\n\n也就是三点：\n\n- 比虚拟机轻量\n- 用来存放职责单一的应用\n- 容器\n\n显然这是一种理解，而不是一种定义。\n\n### 1.2 Docker 是用来做什么的？\n\n新技术本质是什么？工具也。\n每一个新的技术都是为了提升效率才被创造出来，那么，究竟 Docker 可以从哪些方面提升我们的效率呢？\n\n我们知道开发一个有些规模的网站的话，需要严格遵守如下的开发流程：\n\n- 编码\n- 测试\n- 集成到系统中\n- 部署\n\n但如果人员比较多，则会出现问题，有的人喜欢用 MacOS, 有的人喜欢用 Ubuntu, 开发测试环境怎么统一呢？如果开发人员明明使用的是某个版本的 PostgreSQL, 用了最新的功能，但是测试和运维用的就是老版本的功能怎么办？\n\n部署环境也会有问题，比如，开发部突然想使用更高版本的软件，比如突然需要更多的 Django 应用来负担海量请求的怎么办？Hadoop 不够用怎么办？\n\n当然，思路很简单，开发的时候使用虚拟机，拷贝给大家一起用，部署的时候多创建一些机器，然后上 Ansible 远程操控。即可。\n\n并不是不行，但是 Docker 由于更加轻量，操作粒度更加细腻，我可以销毁镜像，上传镜像，定制镜像，很轻松调整镜像包并且安装挂载文件。\n\n## 0x02 Docker 初始配置\n\n```\ndocker-machine create --driver=virtualbox default\ndocker-machine ls\neval \"$(docker-machine env default)\"\n```\n\n## 0x03 Django 技术栈 Docker 化\n\n为了理解这个过程，下面我将我 Docker 化 django 应用的流程按照一定步骤演示出来。我将我使用 Django 的部分经验搞出来，做成了一个 django-bpc ，即 django best practice。如果诸位有兴趣研究的话，拿来看看源码倒是倒是非常好。\n\n```bash\n# 演示环境为 MAC, 在此之前，务必安装好 docker for mac 以及 virualbox\n# xxxxxx 为 阿里云分配的容器 registry\ndocker-machine create --engine-registry-mirror=https://xxxxxx.mirror.aliyuncs.com -d virtualbox default\n\n```\n\n```bash\n├── AUTHORS.md\n├── HISTORY.md\n├── LICENSE\n├── MANIFEST.in\n├── Makefile\n├── README.md\n├── assets\n├── compose\n│   ├── django\n│   ├── elasticsearch\n│   ├── nginx\n│   ├── postgres\n│   ├── rabbitmq\n│   └── redis\n├── config\n│   ├── __init__.py\n│   ├── settings\n│   ├── urls.py\n│   └── wsgi.py\n├── dev.yml\n├── docker-compose.yml\n├── docs\n│   ├── Makefile\n│   ├── exts\n│   ├── make.bat\n│   ├── make_pdf.sh\n│   └── source\n├── manage.py\n├── pytest.ini\n├── requirements\n│   ├── base.txt\n│   ├── local.txt\n│   ├── production.txt\n│   └── test.txt\n├── scripts\n├── setup.cfg\n├── tests\n│   ├── __init__.py\n│   ├── conftest.py\n│   └── test_basics.py\n└── yadjangoblog\n    ├── __init__.py\n    ├── contrib\n    ├── static\n    ├── templates\n    ├── yaaccounts\n    ├── yaadmin\n    ├── yaapi\n    ├── yablog\n    ├── yacommon\n    └── yataskapp\n```\n\n### 3.1 开发时\n\n#### 1. 运行所需组件\n\n在开发时候需要使用几个后台的组件\n\n- PostgreSQL 用于做数据存储\n- Redis 用于做缓存 和 Session 等等\n- RedditMQ 用于消息队列\n- ElasticSearch 用于做搜索与推荐\n\n目录中的组件基本上都在这儿了。\n\n```\n├── compose\n│   ├── django\n│   ├── elasticsearch\n│   ├── nginx\n│   ├── postgres\n│   ├── rabbitmq\n│   └── redis\n```\n\n进行初步的封装和添加脚本，不直接采用官网的配置需要是因为添加一些的定制版本。\n\n#### 2. Vue.JS 运行环境\n\nVue.JS 使用 Vue-Cli 搭建的脚手架还是挺方便的，这个就无需 Docker 化了，需要注意的是，建议配置一下开发时候请求的 API 地址。\n\n我本人用于请求本地地址的 8080 端口，并且 8080 端口映射到 Docker 容器里面的 Django App\n\n#### 3. Django App\n\n配置 Django, 我使用的是 ubuntu 16.04 基础镜像，然后安装必备的依赖。\n\n接着指定 workdir 为当前目录\n\n需要注意的是，Django App 里面需要等待 PostgreSQL 初始化完毕才能进行正常的运行接下来需要运行的命令，比如 runserver 之类的命令。\n\nentrypoint 的左右即是放在命令执行之前，这样的话，重写掉 entrypoint 文件，就可以实现上面的功能了\n\n```python\n# 本段代码来自 cookiecutter Django\nfunction postgres_ready(){\npython \u003c\u003c END\nimport sys\nimport psycopg2\ntry:\n    conn = psycopg2.connect(dbname=\"$POSTGRES_USER\", user=\"$POSTGRES_USER\", password=\"$POSTGRES_PASSWORD\", host=\"postgres\")\nexcept psycopg2.OperationalError:\n    sys.exit(-1)\nsys.exit(0)\nEND\n}\n\nuntil postgres_ready; do\n  \u003e\u00262 echo \"Postgres is unavailable - sleeping\"\n  sleep 1\ndone\n```\n\n最后封装一些命令到，比如启动 Celery 之类的。\n\n#### 4. Celery 运行环境\n\n#### 5. 其他零散的重要配置\n\n### 3.2 具体开发\n\n我编写了一整套 makefile 的命令，我会先进入项目 YaDjangoBlog , 然后执行 make ; 执行 make 之后，显示了我编写的一些便于开发测试的命令如下：\n\n```\nsep--sep-a           ========== 开发时命令 ==============\ndjango-build-up      build and compose up\nforce_djnago_build-up django / pg / es\ndjango-before-up     e.g pg / es / redis\ndjango-runserver     runserver\ndjango-celerybeat    celerybeat\ndjango-celeryworker  celeryworker\ndjango-just-up       build and up\ndjango-manager       Enter python manage.py\ndjango-console       Enter Django Console\nshell                Enter Shell\ndbshell              Enter psql as yadjangoweb\nsep--sep-b           ========== 测试与代码质量 ==============\nlint                 check style with flake8\ntest                 run tests quickly with the default Python\ncoverage             check code coverage quickly with the default Python\nsep--sep-c           ========== 文档生成相关 ==============\ndocs                 generate Sphinx HTML documentation, including API docs\nservedocs            compile the docs watching for changes\nsep--sep-d           ========== 程序发布相关 ==============\nrelease              package and upload a release\ndist                 builds source and wheel package\ninstall              install the package to the active Python's site-packages\nsep--sep-e           ========== Docker 镜像相关 ==============\nbuild-postgres       \u003e Postgres\nforce-build-postgres \u003e Postgres\nbuild-ubuntu         \u003e base ubuntu\nforce_build-ubuntu   \u003e base ubuntu\nbuild-django         \u003e base django\nforce_build-django   \u003e base django\nsep--sep-f           ========== 文件清理相关 ==============\nclean                remove all build, test, coverage and Python artifacts\nclean-build          remove build artifacts\nclean-pyc            remove Python file artifacts\nclean-test           remove test and coverage artifacts\n```\n\n#### 1. 构建镜像\n\n执行 build 命令即可。\n\n#### 2. 使用 Tmuxinator 批量运行命令\n\n现在，我有这么一个需求，就是在 iterm 中开启如下的终端：\n\n- 第 1 个终端，运行的命令是 Vue.JS 的启动命令 npm run dev。\n- 第 2 个终端，有两个分屏，其一用于构建 iconfont 字体文件的命令，其二用于 Gulp 动态编译 SCSS 文件的命令。\n- 第 3 个终端，运行的命令是 Django 的 runserver 的命令。\n- 第 4 个终端，有两个分屏，一个是 Django 容器的 bash 环境，另一个是 PostgreSQL 的 命令行环境。\n- 第 5 个终端，有两个分屏，一者运行 Celery Beat，另一者则是运行 Celery Worker.\n\n\u003e 当然，目前没有添加 redis 和 RabbitMQ 的命令行环境\n\n#### 3. 使用 PyCharm 进行开发\n\n### 3.3 部署时\n\nDocker 部署需要解决的问题，是裸机部署的 Docker 化。\n\n\u003e TODO: 目前 Docker 部署的脚本还在编写中，这部分的文字可能后期会调整\n\n#### 0. Django 生产环境和开发环境之间的区别\n\n生产环境和开发环境除了一些文字配置上的不同，还有一些不同，比如：\n\n1. 新增了 uwsgi / gunicorn 作为新的 web 容器\n2. 新增了 Ngnix 作为反向代理\n3. Celery Worker 数量的变化\n4. Supervisor 进程守护\n\n首先说第一点带来的区别，我们使用 Django 内置的 runserver 的时候，其实这个命令可以用于做生产环境的 Web 服务器。\n\n比如，只需如此 python manage.py runserver 0.0.0.0:8888\n\n可以用，但不推荐用。没什么负载量。这时候就需要 gunicorn 了。你可以理解 Gunicorn 是进阶的 runserver,\n\n可以参考：https://docs.djangoproject.com/en/2.0/howto/deployment/wsgi/gunicorn/\n\n同时，Gunicorn 可以进行颗粒度更细致的操作，但负载量不如 uwsgi, 毕竟前者 python 写的，后者是 C 写的。\n\n一般 Gunicorn 也会配上 NGNIX,\n\n简单来说，Nginx 至少可以解决下面的问题：\n\n- 匹配域名\n- 转发请求\n  - 设置请求头\n  - 转发本地的静态文件 (static / media）\n  - 映射部分请求到 gunicorn , 然后 gunicorn 开启一个线程到 Django\n  - 负载均衡\n\n需要注意的是 gunicorn 这种关键性的进程，一定要用 Supervisor 进行守护，否则挂掉了就完蛋了，\n\n#### 1. 裸机部署 Django 程序\n\n#### 2. Docker 部署\n\n## 0x04 Docker 踩坑记录\n\n### 4.1 PostgreSQL 的初始化\n\n当 Docker 化 PostgreSQL 的时候，必须要把一些初始化脚本放在 docker-entrypoint-initdb.d 中，才能初始化，笔者在进行测试的时候多次发现无法进行初始化，究其原因，经过查找，如果没有及时删除 Volume 的话，则无论怎么初始化，或者 Build, 每一次都会挂载原来的文件夹。\n\n```bash\nADD init_django_db.sh /docker-entrypoint-initdb.d/init_django_db.sh\n```\n\n### 4.2 清空所有 Image\n\n```bash\n# Delete all containers\ndocker rm $(docker ps -a -q)\n# Delete all images\ndocker rmi $(docker images -q)\n# Force delete\ndocker rmi $(docker images -q) -f\n# Delete Unused Volume\ndocker volume prune\n```\n\n### 4.3 时区\n\n```\n# Alpine\nRUN apk --no-cache add tzdata \u0026\u0026 ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \u0026\u0026 echo \"Asia/Shanghai\" \u003e /etc/timezone\n# Ubuntu\nRUN echo \"Asia/Shanghai\" \u003e /etc/timezone \u0026\u0026 dpkg-reconfigure -f noninteractive tzdata\n# Centos\nRUN echo \"Asia/shanghai\" \u003e /etc/timezone\n```\n\n# 0xEE 参考链接\n\n- https://github.com/wsargent/docker-cheat-sheet\n\n---\n\nChangeLog:\n\n- **2017-01-20** 初始化本文\n"},{"tags":["Pandas","Numpy","CheatSheet"],"path":"20180210_ElasticSearchCheatSheet.md","title":"ElasticSearch CheatSheet","slug":"ElasticSearch CheatSheet","date":"2018-02-10","category":"DevOps","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n本文为 Cheatsheet 类型文章，用于记录我在日常编程中经常使用的 ElasticSearch 相关和命令。\n\n\u003e 最早使用 ElasticSearch 是两年前了。最近准备用 Django 写一个全栈式的应用，借用强大的 ES 来做搜索。\n\n这是我在写程序之余写这篇笔记的原因。最近因为换工作的事情耽误了教程更新，就把这篇笔记放出来吧。不定期更新。\n\n官网介绍 ElasticSearch 不仅仅是全文搜索，也可以结构化搜索（这里用结构化查询会更准确一些），处理人类语言，地理位置，以及关系。\n\n然而，我在项目使用过程中还是主要用到了全文搜索以及推荐。\n\n不用其他的主要原因是因为 ES 尺有所短寸有所长：\n\n1. geo 处理方面 postgis 完全就是神一般的存在。为什么还要用 ES 呢？\n2. 关系型数据库的核心不就是处理关系？复杂的关系肯定还是放在关系数据库里面。\n\n- highlighted search\n- search-as-you-type\n- did-you-mean suggestions\n\n我对 ElasticSearch 在后台组件里的作用在于搜索与推荐：\n\n1. 整站的搜索功能\n\n- 全文搜索\n\n2. 推荐\n\n- 依据某几个维度的数据进行排序\n\n知乎的文章居然不支持 toc, 实在是太蛋疼了。\n\n文章目录如下\n\n```\n  ▼ 0x00 前言 : section\n  ▼ 0x01 安装，配置，基本 shell 命令 : section\n      1. 安装 : section\n      2. 配置 : section\n      3. 插件 : section\n    0x02 ElasticSearch 配套工具 : section\n  ▼ 0x03 ElasticSearch 基础概念 : section\n    ▼ 3.1 Elasticsearch CRUDE 以及基本操作 : section\n        CURDE : section\n        普通搜索 : section\n        聚集搜索 : section\n  ▼ 0x04 全文搜索的基本概念 : section\n      4.1 全文搜索遇到的挑战 : section\n    ▼ 4.2 全文搜索的索引时与查询时 : section\n        1. 索引时 ES 做了什么？ : section\n        2. 查询时 ES 做了什么？ : section\n        3. 全文搜索调优之中文分词 : section\n        4. 全文搜索调优之停止词 : section\n        5. 全文搜索调优之同义词 : section\n        6. 全文搜索调优之拼写错误 : section\n      ▼ 7. 全文搜索调优之相关性 : section\n          索引时三因素 : section\n          查询时 : section\n          计算公式 : section\n    0x05 搜索语法 : section\n    0x06 Python SDK : section\n    0x07 踩坑集 : section\n    0xEE 参考链接 : section\n```\n\n\u003c!-- more --\u003e\n\n## 0x01 安装，配置，基本 shell 命令\n\n### 1. 安装\n\n具体在项目中的配置建议看一下我写的配置文章 https://zhuanlan.zhihu.com/p/33920401 和并且参考现有代码 https://github.com/twocucao/YaDjangoBlog\n\n```\n# 执行如下的命令\ncurl 'http://localhost:9200/?pretty'\n# 输出结果\n{\n  \"name\" : \"XOGvo8a\",\n  \"cluster_name\" : \"docker-cluster\",\n  \"cluster_uuid\" : \"fAwp341bQzalzBxRFyD1YA\",\n  \"version\" : {\n    \"number\" : \"6.2.1\",\n    \"build_hash\" : \"7299dc3\",\n    \"build_date\" : \"2018-02-07T19:34:26.990113Z\",\n    \"build_snapshot\" : false,\n    \"lucene_version\" : \"7.2.1\",\n    \"minimum_wire_compatibility_version\" : \"5.6.0\",\n    \"minimum_index_compatibility_version\" : \"5.0.0\"\n  },\n  \"tagline\" : \"You Know, for Search\"\n}\n```\n\n### 2. 配置\n\n配置略\n\n### 3. 插件\n\nES 的插件有很多，截止笔者写这篇文章的时候，ES 最新的版本是 6.2.1 版本。\n\n\u003e PS: 两年前我用的还是 2.3.3 版本。新版本有很多插件配置起来已经有所不同了。比如说 head 现在已经被独立出来作为一个单纯的网页，chrome 商店可以直接下载。\n\n需要配 ik-analyser. 如果你在 YaDjangoBlog 中起了这个命令，则已经配置完毕。\n\n## 0x02 ElasticSearch 配套工具\n\n建议使用 Head 插件来进行简单的查询与调试。\n\n## 0x03 ElasticSearch 基础概念\n\n### 3.1 Elasticsearch CRUDE 以及基本操作\n\n详细的搜索见 Python SDK\n\n#### CURDE\n\nES 使用的是 RESTFUL API 接口\n\n这也就意味着：\n\n- PUT 创建记录\n- GET 获取记录\n- POST 更新记录\n- DELETE 删除记录\n- HEAD 是否存在\n\n#### 结构化搜索\n\nES 写复杂查询的时候，语法乱，这个过程需要多翻看 guide 和手册。\n\nhttps://www.elastic.co/guide/en/elasticsearch/guide/current/structured-search.html\n\n#### 全文搜索\n\n全文搜索包含两个重要方面：\n\n- 相关性：通过 TF/IDF , 距离 , 模糊相似度，以及其他算法\n- 分析：大文本 token 化，用于形成倒排索引。这个过程见 4.2\n\nhttps://www.elastic.co/guide/en/elasticsearch/guide/current/full-text-search.html\n\n#### 聚集搜索\n\nhttps://www.elastic.co/guide/en/elasticsearch/guide/current/aggregations.html\n\n## 0x04 全文搜索的基本概念\n\n### 4.1 全文搜索遇到的挑战\n\n在最初开源搜索引擎技术还不是很成熟的时候，我们一般都会使用 RDBMS 进行简单搜索。\n\n简单搜索，也就是我们常常使用的 like 查询（当然，有的数据库可以使用正则表达式）\n\n这种方式是简单暴力的查询方式，优点是实现起来简单暴力。缺点是在这个场景下性能和准确度很差。\n\n举例：\n\n- 假如站点里文章数量比较大，并且文章内容比较长，则进行一次全表查询，效率可想而知。当然，做好分库分表读写分离也是能用的。\n- 如果我要对搜索到的词语进行高亮，则实现方式就只能是把查询到的文章放在应用层里面进行批量替换。\n- RDBMS 似乎完全不懂语言与语言之间的区别。比如说：\n  - 『停止词 / 常用词』有的字我是不需要的，比如南京的狗，其实我想搜的是南京狗，这里的『的』就不是我需要的。\n  - 『同义词』有的字我需要的是他的同义词，比如日本黄狗，其实我想搜的是柴犬。\n  - 『附加符号』假如说我们搜索一个声调 [nǐ], 总不能让用户打出 [nǐ] 进行搜索吧？总归要转为 ni 才能方便搜索\n  - 『词根形式』对于一个单词，假如是动词可能有时态上的区分，如果是名词，可能有单复数的区分。假如我搜 mice, 其实同样的 mouse 也应该被搜索出来。但有事用这种方式也会矫枉过正，比如 organizations 的 原型其实并不是 organization 而是，organ. （当然，overstemming 和 understemming 也是两个不可忽视的问题）\n    - Number: fox, foxes\n    - Tense: pay, paid, paying\n    - Gender: waiter, waitress\n    - Person: hear, hears\n    - Case: I, me, my\n    - Aspect: ate, eaten\n    - Mood: so be it, were it so\n    - PS: 万幸的是，中文处理中木词根这个概念。我也就不深入这块了。\n  - 『拼写问题』 周杰棍与周杰伦\n  - 『分词 / 识别词』中文不像英文，词和词之间是完全没有空格的，也就是说，中文天然要比英文多一个关于分词的步骤。\n\n是的，我们需要一种新的姿势，来进行搜索。也就是本文所说的全文搜索。\n\n### 4.2 全文搜索的索引时与查询时\n\n本小节先搞清楚两个点，\n\n1. 索引时 ES 做了什么？\n2. 查询时 ES 做了什么？\n\n- 索引时，指的是 ElasticSearch 在存储文档的阶段。\n- 查询时，指的是 ElasticSearch 在查询文档的阶段。\n\n#### 1. 索引时 ES 做了什么？\n\n\u003e 这里我们略过定义 index,type,document 仅仅指某个 field 被赋值 document 被保存的时候针对这个被赋值的 text 类型 field 的处理。\n\n- 第一步：**文本经过 analyzer 处理**\n- 第二步：**形成倒排索引**\n\n先看第一步：\n\n通常在定义 field 的时候显式指定 analyzer（分析器）.\n\n这个 analyzer 一般的作用如下：\n\n- STEP 1: 令牌化文本为独立的词\n- STEP 2: 词语转小写\n- STEP 3: 去除常见的停止词\n- STEP 4: 获取词的词根的原型\n\n不同的 analyzer 作用大同小异，拿我们常用的 https://github.com/medcl/elasticsearch-analysis-ik 的话，则也是类似的步骤（下面步骤是我猜测的，没看源码）\n\n1. 令牌化文本为独立的词语 - 分词，并且令牌化文本为独立的词汇\n2. 除去常见的停止词\n3. 匹配同义词\n4. ....\n\n可以定义字段的时候可以指定 analyzer（索引时） 与 search_analyzer（查询时）\n\n先看经过第一步之后，就可以进入第二步形成倒排索引了，此时，倒排索引之于 ElasticSearch 可以类比于 btree 之于 MySQL 或者 Gist 之于 PostgreSQL.\n\n那么，倒排索引包含哪些东西呢？\n\n- **Terms dictionary**\n  - 已排序完毕的 terms, 以及包含这些 terms 的 documents 的数量。\n- **Postings List**\n  - 哪些 document 包含这些词\n- **Terms frequency**\n  - 每个 term 在这些文章的频率\n- **Position**\n  - 每个 term 在每个 document 的位置，这是为了便于 phrase query 和 proximity query\n  - 高频词的 phrase query 可能导致 上 G 的数据被读取。虽然有 cache, 但是远远不够。\n- **Offsets**\n  - 每个 term 在每个 document 的开始和结束，便于高亮\n- **Norms**\n  - 用于给短 field 更多权重的因素.(TODO: 啥玩意）\n\n减少停止词仅仅可以减少少部分 terms dictionary 和 postings list , 但是 positions 和 offsets data 对 index 的影响则是非常大的。\n\n#### 2. 查询时 ES 做了什么？\n\n- 第一步：**文本经过 analyzer 处理**\n- 第二步：**查询倒排索引**\n\n其实搜索的就是这个玩意。\n\n- **Terms dictionary**\n- **Postings List**\n- **Terms frequency**\n- **Position**\n- **Offsets**\n- **Norms**\n\n于是，我们就必须关注如何更好的查询文档了。下面几个小节，你就知道全文搜索是比较难调优的了。好，一个一个来。\n\n#### 3. 全文搜索调优之中文分词\n\n中文分词以前是个难点，现在基本有成熟的解决方案，在没有更加牛逼的分词技术解决方案之前，现在分词效果主要是拼词典。\n\n\u003e TODO: 这个话题可能比较大，先挖坑，以后填\n\n#### 4. 全文搜索调优之停止词\n\n使用停止词是减少索引大小的一种方式（减小索引效果不明显），那么，哪些词语可以呗当做停止词呢？\n\n- 低频词语：低频词语具备高权重\n- 高频词语：高频词语具备低权重\n\n当然，是否是高频词语依据个人经验主要依据两点来判断：\n\n- 具体场景：比如在英文中，and/the 之类的会比较多，但是中文会比较少。同样的，中文里面其他语言的东西会少一些。正文八经的文章出现不正经的词汇的概率会低。在技术问里面，『数据库』属于高频词汇，但是在比如简书之类的，可能梦想 / 鸡汤 / 超级 / 震惊会多一些。掘金的『前端』两个字绝壁是高频词。\n- 抽样跑新词发现的程序。社区里多的是新词发现的脚本。对文章内容或者从搜索框记录下来的搜索词跑一下新词发现的程序，然后人工筛选，应该可以发现更多的高频和低频的词汇。\n\n是不是用上停止词就好了呢？并不是。\n\n比如：\n\n- 假如停止词里面包含了 not , 那么 happy 和 not happy 搜索出来的结果则一致。\n- 假如停止词里面包含了或，那么，如果有个乐队名字叫做『或或』, 则搜索不出来。\n- 假如停止词里面包含了 to / be / not / or , 则莎士比亚的名言 『To be, or not to be』 则搜索不出来。\n\n#### 5. 全文搜索调优之同义词\n\n同义词也有很多种：\n\n1. 平级关系：插、戳、刺、扎\n2. 包含关系：成人包含男人和女人\n3. 不容易分清楚关系：\n\n- 炒，煎，贴，烹，炸，溜\n  　- 汆，涮，煮，炖，煨，焐\n  　- 蒸，鲊\n  　- 卤，酱，熏，烤，炝，腌，拌，焗\n\n随着场景的不同，上面有些同义词也是不能轻而易举同义的。\n\n| -        | 索引时                                                                           | 查询时                                 |\n| -------- | -------------------------------------------------------------------------------- | -------------------------------------- |\n| 索引大小 | 耗时变多，同义词被索引，大小更大                                                 | 耗时几乎不变                           |\n| 相关性   | 准确度下降，所有同义词相同 IDF, 则在所有文档的索引记录中，常用词和冷门词权重相同 | 准确度提升，每个同义词的 IDF 将被校正  |\n| 性能     | 性能下降，查询需要涨到                                                           | 性能下降，查询被重写，用于查找同义词   |\n| 灵活性   | 变差，同义词法则不改变已存在记录，需重新索引                                     | 不变，同义词法则可被更新，无需重新索引 |\n\n由此可见，大部分场景下的索引时如果没有特别的需求，**谨慎使用同义词**。\n\n\u003e 同义词使用自定义 filter , 并且在新建 analyzer 并指定 filter 即可。\n\n#### 6. 全文搜索调优之拼写错误\n\n有的时候，用户也会输入错误：\n\n- 手误，把『周杰伦』拼成『周杰棍』\n\n这个时候，搜索引擎应该提示一下，您搜索的是不是『周杰伦』呢？\n\n这里面就遇到了一个问题，我们显然知道周杰棍和周杰伦是是相似的，为什么呢？或者说，直观上感知的详细，能用数学方式表达出来吗？\n\n有人说，正则匹配 / 通配符匹配呗。这是一个思路。\n\nVladimir Levenshtein 和 frederic damerau 给出了一种相似度算法 https://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance\n\n一个词组通过转换到另一个词的步数就是其距离：\n\n- 替换：『周杰伦』到『周杰棍』\n- 插入：『周杰』到『周杰棍』\n- 删除：『周杰伦』到『周杰』\n- 相邻字符转换：『周伦杰』和『周杰伦』 , 但是『周杰棍的双节伦』到『周杰伦的双节棍』 并不是相邻字符转换\n\n用法：\n\n\u003e 指定 \"fuzziness\": step 即可\n\n当 step \u003e=2 的时候，ES 进行查询的时候，每次查询都会遍历 terms 字典，所以，如果 fuzziness 大于 2 的时候遍历 terms 的数量则非常惊人了。\n\n- 方法一：设置 prefix_length, 单词的前面一定长度不进行 fuzzy 匹配。一般设置为 3 （估计这是属于英文的匹配，中文环境做不了参考）;\n- 方法二：设置 max_expansins, 类似于 RDBMS 的 limit, 查询到一定记录之后停止查询。\n\nfuzzy match query 也是支持的，比如说，假如你指定 \"fuzziness\" 为 1, 搜索周杰棍，则将周杰伦，周杰全搜索出来了。似乎搜索的很全面呀，但是问题来了：\n\n\u003e 依据 TF/IDF 的高频低权重，低频高权重的计算方式，**周杰棍由于出现次数极少，反而获得了极高的权重。**\n\n跑个题，这种因为『出现次数少，查询的时候反而显得权重较高』的情况。并不仅仅出现在 TF/IDF 算法上。\n\n这方面搜索引擎和人是一样一样的\n\n- 小孩子听腻了家长们所说的『带着脑子去学习』, 反而觉得以前没出现的新词叫『刻意学习』牛逼到爆。\n- 美女听腻了直男癌说的『漂亮』, 反而觉得夸她『品质 / 品味』的话语词词入心。\n\n回到正题\n\n所以，一般情况下还是建议拼写错误主要还是用于：\n\n- Search as you type : completion suggester\n- Did you mean : phrase suggester\n\n#### 7. 全文搜索调优之相关性\n\n我们在接触 RDBMS 的时候系统是没有相关性的说法的，比如说，2017 年 12 月份 xxx 用户的订单，就是直接 select 出来这些订单。因为 where 语句后面包含了界限明确的条件，而全文搜索则不然。\n\n这个时候一个人拍着桌子站起来，说：不对呀，我要搜索包含周杰伦的所有文章。这咋没有条件边界。\n\n嗯，稍等，『选出所有包含周杰伦的文章』条件很清晰。但问题是，排序怎么做？按照日期排？按照点击率排？这篇文章上周已经在在搜索靠前了，已经『长江后浪推前浪了』上了，这周是不是该差不多『前浪死在沙滩上』了？\n\nElasticsearch 中使用的计算 score 的公式叫做 practical scoring function, 这个公式借鉴于 TF/TDF 以及 矢量空间模型，但有更多的特征比如，条件因素，字段长度正态化，term / query clause boosting\n\n全文搜索不仅仅找到匹配的 documents, 并且按照相关性进行排序（其实就是打分 score)。\n\n为什么需要打分呢？从相亲角度来说，上海内环有房肯定是个超级大加分项。同样是录入信息，在上海内环有房的权重值可是设置的高一些。\n\n嗯，其实相关性的调优是最难的部分。\n\n##### 索引时三因素\n\n先看前两个因素 TF/IDF\n\n- tf(t in d) = sqrt(frequency)\n- idf(t) = 1 + log (numDocs / (docFreq + 1))\n\n再看后一个因素 Field-Length norm\n\n标题越短，这个词对这个 field 的代表性越强\n\n- norm(d) = 1 / sqrt(numTerms)\n\n##### 查询时\n\n几个词 -\u003e 几维度 -\u003e 寻求最佳匹配以及近似匹配\n\n- 最佳匹配应该是通过计算长度（应该是，但不确定）\n- 近似匹配，计算距离最近的 cos 值。\n\n##### 计算公式\n\n这个公式调优的时候需要用到\n\n```bash\nscore(q,d)  = queryNorm(q)\n                ·coord(q,d)\n                ·∑(tf(t in d)·idf(t)²·t.getBoost()·norm(t,d)) (t in q)\n```\n\n## 0x05 搜索语法\n\nSingle document APIs\n\n- Index API\n- Get API\n- Delete API\n- Update API\n- Multi-document APIs\n\nMulti Get API\n\n- Bulk API\n- Delete By Query API\n- Update By Query API\n- Reindex API\n\n## 0x06 Python SDK\n\n官方提供了两个 SDK 方便我们进行日常的开发：\n\n- elasticsearch\n- elasticsearch_dsl\n\n我更喜欢 elasticsearch , 而不是 elasticsearch_dsl, 因为写起来更容易结合 elasticsearch-head 进行 profile\n\n前者偏底层一些，后者偏高层一些，高底层关系的有点类似于 sql 和 sqlalchemy core 之间的关系。\n\n## 0x07 踩坑集\n\n## 0xEE 参考链接\n\n- https://www.zhihu.com/question/19645541\n\n---\n\nChangeLog:\n\n- **2018-02-15** 重修文字\n"},{"tags":["CheatSheet"],"path":"20180203_NumpyCheatSheet.md","title":"NumPy CheatSheet","slug":"NumPy CheatSheet","date":"2018-02-03","category":"Python","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n# Numpy 库\n\n## 0x00 前言\n\n本文为 Cheatsheet 类型文章，用于记录我在日常编程中经常使用的 Numpy 相关语句。\n\n对于数据分析应用而言，最应该关注：\n\n- 用于数据整理和清理、子集构造和过滤、转换等快速的矢量化数组运算。\n- 常用的数组算法，如排序、唯一化、集合运算等。\n- 高效的描述统计和数据聚合 / 摘要运算。\n- 用于异构数据集的合并 / 连接运算的数据对齐和关系型数据运算。\n- 将条件逻辑表述为数组表达式（而不是带有 if-else-if 分支的循环）\n- 数据的分组运算（聚合、转换、函数应用等）。\n\n\u003e 学习 Numpy 本质上是为了更好的使用 Pandas\n\n## 0x01 ndarray\n\n### 1.1 数据类型\n\n### 1.2 创建 ndarray\n\n### 1.3 数组和标量之间的运算\n\n当我们把数组当做矢量的时候。\n\n1. 两个大小相同的矢量将运算到元素级\n2. 矢量和标量将作用与每一个元素\n3. 不同大小的矢量之间的运算叫做广播\n\n### 1.4 索引和切片\n\n### 1.4.1 一般索引和一般切片\n\n对于一维数组的话，如果没有显式 copy 则会修改原来的值。\n\n切片语法与 Python 相近\n\n### 1.4.2 切片型索引\n\n```python\na[:2,1:]\na[2,1:]\n```\n\n### 1.4.3 布尔型索引\n\n参考 pandas 语法\n\n## 0xEE 参考链接\n\n---\n\nChangeLog:\n\n- **2017-06-03** 初始化本文\n- **2018-02-03** 重修文字\n"},{"tags":["Celery","消息队列"],"path":"20180220_CeleryCheatSheet.md","title":"Celery 快速入门指北","slug":"Celery 快速入门指北","date":"2018-02-02","category":"Python","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n本文编写于 2018 年初，于 2019 四月进行修订，也是笔者对 Celery 的系统梳理。\n\n在我的文章如何保证 Django 项目的数据一致性中，提到了这么一个解决超卖的方案。\n\n1. 在 Redis 里面直接生成 200 个订单号\n2. 然后用户来一个取走一个订单号码\n3. 通过 Celery 削峰 排队走异步任务\n4. 最后通过数据表的 uniq 约束来防止下单超过 200 个。\n\nhttps://zhuanlan.zhihu.com/p/57668068\n\n有朋友和我讲，你这个方法是有问题的，走异步任务容易并发量太大，容易把数据库打爆。\n\n其实是可以的，Celery 可以对 Worker 的 Task 限流 (ratelimit)。\n\n## 0x01 Celery\n\n### 为什么需要 Celery\n\n在日常开发的时候，常常有一些『任务』需要处理。\n\n1. 为了提升系统的响应速度，比如发送短信 / 发送邮箱，这类的『任务』可以走异步。\n2. 为了在某个时间执行耗时操作，比如统计用户的文章 / 点赞 / 活跃度。\n3. 为了削减峰值，比如秒杀系统的削峰走异步\n4. 为了业务代码解耦，比如当我在知乎上更新文章，可能就会触发『推荐系统』,『文章管理系统』,『用户通知系统』\n\n不用 Celery 的话，其实上面的业务也是能做的。 比如 1 中，可以直接启一个线程来做。比如 2 完全可以 Crontab 做一个定时任务。\n\n那为什么要用 Celery 呢？\n\n1. 把目光聚焦在 Task 的分发上面。而非线程，Deamon 之类细节的处理。\n2. 方便，简单，易维护，高可用。\n3. 便于监控。\n4. 扩展性好。\n\n基本上满足了你九成的需求。\n\n## 0x02 Celery 快速开始\n\n本文的讨论基于 Broker 为 RabbitMQ, Result Backend 为 Redis, Django 的 Web 应用，叫做 djoo\n\n```\nsudo rabbitmqctl add_user djoo djoo\nsudo rabbitmqctl add_vhost djoo\nsudo rabbitmqctl set_user_tags djoo djoo\nsudo rabbitmqctl set_permissions -p djoo djoo \".*\" \".*\" \".*\"\n```\n\n```\nCELERY_BROKER_URL = 'amqp://djoo:djoo@localhost:5672/djoo'\n\nCELERY_RESULT_BACKEND = \"redis://{host}:{port}/1\".format(\n    host=os.getenv(\"REDIS_HOST\", \"localhost\"), port=os.getenv(\"REDIS_PORT\", \"6379\")\n)\n\n```\n\n泛读文档之后，需要搞清楚几个概念。\n\n- Broker: 携带 Task 的消息中间件，是发送消息和接收消息的解决方案，比如 RabbitMQ\n- Result Backend: Task 执行结果。\n- Application: Celery 的实例\n- Worker: 执行任务者\n- Beat: 或叫做 Schedule, 一般用于执行定时任务。\n- Task: 任务\n\n## 0x03 Celery Guide\n\n### Application\n\nApplication 可以针对整个 Celery 实例进行配置，比如配置时区，重写 Application 里的基类\n\n### Tasks\n\nTask 是一个 Class, 并且可以从任意 Callable 的对象创建。\n\nTask Message 除非被 Acked, 否则不会从队列中移除。\n\n\u003e NOTE: 那什么时候算是 Acked?\n\n```\n@app.task(name=\"xsum\")\ndef xsum(numbers):\n    return sum(numbers)\n```\n\n- Tasks\n- Calling Tasks\n- Canvas: Designing Work-flows\n- Workers Guide\n- Daemonization\n- Periodic Tasks\n- Routing Tasks\n- Monitoring and Management Guide\n- Security\n- Optimizing\n- Debugging\n- Concurrency\n- Signals\n- Testing with Celery\n- Extensions and Bootsteps\n- Configuration and defaults\n\n### Application\n\n### Tasks\n\n### Calling Tasks\n\n### Canvas: Designing Work-flows\n\n### Workers Guide\n\n### Daemonization\n\n### Periodic Tasks\n\n### Routing Tasks\n\n### Monitoring and Management Guide\n\n### Security\n\n### Optimizing\n\n### Debugging\n\n### Concurrency\n\n### Signals\n\n### Testing with Celery\n\n### Extensions and Bootsteps\n\n### Configuration and defaults\n\n## 0x03 RabbitMQ\n\n发布者的消息经过交换机，分发到不同的队列，最后由接收方进行处理。\n\n那么问题来了，交换机都是用来干嘛的\n\n- Direct 单播路由：扔一条消息到一个队列中，依照 routingkey 投递\n- Topic 多播路由：发给某几类队列（通知）.\n- Fanout 广播路由：发给全部绑定在该路由上面的队列。\n- Headers\n\n1. 应用解耦。（平台无关，语言无关）\n\n比如说，但项目足够大的时候，更新一个活动，可能需要更新用户的一些状态，可能要更新一波统计数据，可能要记录一批日志。这个时候原来的代码可能这么写：\n\n```bash\nupdate_activity()\nupdate_user()\nupdate_user_cache()\nupdate_stats()\nrecord_user_log()\n```\n\n现在代码就可能这么写：\n\n```\nsend_task_update_activity()\nsend_task_update_user()\nsend_task_update_user_cache()\nsend_task_update_stats()\nsend_task_record_user_log()\n```\n\n2. 异步通信。（减轻请求峰值）\n\n原本一个 webapp 不做异步的话，也能搞定，但做了异步之后，可以大幅度提升吞吐量和响应时间。\n\n3. 数据持久化。（不丢失消息）\n4. 送达保证。(ack late)\n\n### 简单步骤\n\n1. 定义 app, 指定 broker 和 backend\n2. 定义 tasks\n3. 指定 worker\n4. 调用 Task , 调用后返回 AsyncResult 实例，\n\n```python\nadd.delay(2, 2)\nadd.apply_async((2, 2))\nadd.apply_async((2, 2), queue='lopri', countdown=10)\nadd.signature((2, 2), countdown=10)\n\nres = add.delay(2, 2)\nres.get(timeout=1)\n\n```\n\n#### Groups\n\n```\n# 并行\ngroup(add.s(i, i) for i in xrange(10))().get()\n# [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]\n# partial group\ng = group(add.s(i) for i in xrange(10))\ng(10).get()\n```\n\n#### Chains\n\n```\nchain(add.s(4, 4) | mul.s(8))().get()\n(add.s(4, 4) | mul.s(8))().get()\n# partial chain\ng = chain(add.s(4) | mul.s(8))\ng(4).get()\n```\n\n#### Chords\n\n```python\nchord((add.s(i, i) for i in xrange(10)), xsum.s())().get()\n(group(add.s(i, i) for i in xrange(10)) | xsum.s())().get()\n# eg : upload_document.s(file) | group(apply_filter.s() for filter in filters)\n```\n\n## 0x07 踩坑集\n\n- 序列问题\n\n## 0xEE 参考链接\n\n---\n\nChangeLog:\n\n- **2018-02-20** 初始化\n- **2019-04-04** 重修文字\n"}],"total":10},{"name":"2018-01","posts":[{"tags":["Tmux"],"path":"20180128_TmuxWithTmuxinatorWorkflow.md","title":"用 tmux 与 tmuxinator 打造开发工作流","slug":"用 tmux 与 tmuxinator 打造开发工作流","date":"2018-01-28","category":"善用佳软","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00. 前言\n\n本文就我最近开发的一个前后端的项目（名字叫做 yavueblog) 来简单介绍两个神器\n\n- 一个是 tmux\n- 一个是 tmuxinator\n\n我在开发这个前后端的项目的时候要开启要通过不少的命令来启动服务：\n\n- （前端开发）运行 npm run dev 进行开发前端页面\n- （前端开发）运行 npm run dev:theme , 当主题的 SCSS 发生变化的同时，编译 SCSS\n- （前端开发）运行 npm run dev:iconfont, 当移入了新的 svg 图标的时候，自动构建出新的字体文件与 iconfont.css 。\n- （后端开发）运行 make dockerup 中开启 Django 应用。启动 Django 服务，PostgreSQL 数据库，Redis 等等，\n\n我的需求如下：\n\n- 一键启动这些脚本，前两个任务，放在第一个终端。\n- 后面两个任务放在第二、三个终端里。\n\n以前的做法都是新建三个终端选项卡，然后第一个终端分两屏，然后分别到各个终端 cd 或者 autojump 到对应的目录，然后手动运行命令。\n\n加上运行 npm run dev:theme 的时候，我是通过 Python 的 watchdog 来实现对指定目录和指定类型文件的变化进行监听的，所以还要切换 PyEnv 自定义的 Python 的环境中。\n\n这些命令反反复复输入还是挺麻烦的事情，为何不用工具来解决呢？\n\n## 0x01 tmux + tmuxinator\n\n先安装\n\n```\nbrew install tmux\nbrew install ruby\ngem install tmuxinator\n```\n\n什么是 tmux? 简单而言，就是一个终端复用软件。\n什么是 tmuxinator? 简单而言，就是为了简化 tmux 操作的软件。只需要编写 yaml 即快速开启一个比较适合你的终端窗口布局。\n\n关于 tmux 的配置，推荐这个 repo\n\nhttps://github.com/gpakosz/.tmux\n\n## 0x02 编写 Tmuxinator 配置文件\n\n输入 tmuxinator new yavueblog\n\n修改文件如下\n\n```\n# ~/.tmuxinator/yavueblog.yml\n\nname: yavueblog\nroot: ~/Codes/PublicRepos/YaBlogSystem/\n\n# Optional tmux socket\n# socket_name: foo\n\n# Runs before everything. Use it to start daemons etc.\n# pre: sudo /etc/rc.d/mysqld start\n\n# Runs in each window and pane before window/pane specific commands. Useful for setting up interpreter versions.\npre_window: pyenv activate 3.5.2/envs/py3-daily\n\nwindows:\n  - \"网站开发\":\n      layout: main-vertical\n      # Synchronize all panes of this window, can be enabled before or after the pane commands run.\n      # 'before' represents legacy functionality and will be deprecated in a future release, in favour of 'after'\n      # synchronize: after\n      panes:\n        - \"cd ./YaVueBlog/ \u0026\u0026 npm run dev\"\n        - \"cd ./YaVueBlog/ \u0026\u0026 npm run dev:theme\"\n  - \"iconfont 构建\": \"cd ./YaVueBlog/ \u0026\u0026 npm run dev:iconfont\"\n  - \"DockerizedDjango\": \"cd ./YaDjangoBlog/ \u0026\u0026 make docker-compose-build-up\"\n\n```\n\n这样的话，每次开发就只需要运行 tmuxinator start yavueblog，并且打开 IDE 直接捋起袖子就是干就好了。\n\n## 0x03 玩 tmux 首先要掌握的三个小技巧\n\n如果你刚用 tmux 的话，火速掌握下面三个小技巧。要不然会抓狂的。\n\n1. 切换终端\n\n- c-b + 数字\n- c-b + n\n\n2. 滚屏\n\nhttps://superuser.com/questions/209437/how-do-i-scroll-in-tmux\n\n3. 复制文字\n\nhttps://superuser.com/questions/196060/selecting-text-in-tmux-copy-mode\n\n## 0xEE 参考链接\n\n- [我的 Github](https://github.com/twocucao)\n\nChangeLog:\n\n- **2017-03-08 09:33:37** 重新润饰文字，弃用 Rails 开发一年。现在主 DjangoRestFrameWork+VueJS\n- **2018-01-28 11:44:00** 重修文字，适配本文\n"},{"tags":["Python"],"path":"20180123_PythonCompression.md","title":"Python 中的数据压缩和存档","slug":"Python 中的数据压缩和存档","date":"2018-01-23","category":"Python","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n在一次数据分析过程中，对方扔过来 40GB 的数据 -- data.tar.gz .\n\n我想着能不能直接用 pandas 直接读取这个文件呢？查找了一些资料，于是有了本文。\n\nPython 中支持如下：\n\n- 数据压缩算法：zlib, gzip, bzip2 and lzma\n- 存档格式：zip 以及 tar\n\n## 0x01 压缩是怎么回事？\n\n## 0x02 zlib 与 gzip\n\ngzip 依赖于 zlib\n\n```\n# 读取压缩文件\nimport gzip\nwith gzip.open('/home/joe/file.txt.gz', 'rb') as f:\n    file_content = f.read()\n\n# 写入压缩文件\nimport gzip\ncontent = b\"Lots of content here\"\nwith gzip.open('/home/joe/file.txt.gz', 'wb') as f:\n    f.write(content)\n\n# 拷贝压缩文件\nimport gzip\nimport shutil\nwith open('/home/joe/file.txt', 'rb') as f_in:\n    with gzip.open('/home/joe/file.txt.gz', 'wb') as f_out:\n        shutil.copyfileobj(f_in, f_out)\n\n# 压缩二进制字符串\nimport gzip\ns_in = b\"Lots of content here\"\ns_out = gzip.compress(s_in)\n```\n\n---\n\nChangeLog:\n\n- **2017-12-20** 初始化本文\n"}],"total":2},{"name":"2017-12","posts":[{"tags":["Frontend"],"path":"20171228_AllStuffAboutCSS.md","title":"关于 CSS 你应该知道的一切","slug":"关于 CSS 你应该知道的一切","date":"2017-12-28","category":"前端开发","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n本笔记诞生于很久前零零散散记录的笔记，拿出来发布一下。\n\n## 0x01 CSS 是如何工作的？\n\nHTML 是元素的标记语言。\n\nCSS 被用来 样式和网页布局的。\n\n样式和布局都有哪些呢？\n\n- 字体\n- 颜色\n- 大小\n- 内容间距\n- 多列\n- 动画\n\n通过 DOM 树的节点和样式节点结合，生成渲染树，然后交给浏览器进行渲染从而使得外观发生变化。\n\n## 0x02 CSS 基本语法\n\nCSS 基本语法有三个组成部分：\n\n1. 规则\n2. 选择器\n3. 属性\n\n### 2.1 CSS 规则\n\n```css\nh1 {\n  colour: blue;\n  background-color: yellow;\n  border: 1px solid black;\n}\n\n// @规则\n\n@import @charset @media @font-face\n  /* in shorthand like padding and margin, the values are applied\nin the order top, right, bottom, left (the same order as an analog clock). There are also other\nshorthand types, for example two values, which set for example\nthe padding for top/bottom, then left/right */ padding: 10px 15px 15px 5px;\n```\n\n### 2.2 选择器\n\n```\n// Simple selectors: Match one or more elements based on element type, class, or id.\n/* All div elements are blue */\ndiv {\n    color: blue;\n}\n\nh1 {\n    color: red;\n    text-shadow: 1px 1px 1px black;\n    background: linear-gradient(to bottom, rgba(0,0,0,0.25), rgba(0,0,0,0.1));\n    padding: 3px;\n    text-align: center;\n    box-shadow: inset 2px 2px 5px rgba(0,0,0,0.5), inset -2px -2px 5px rgba(255,255,255,0.5);\n}\n\n// Attribute selectors: Match one or more elements based on their attributes/attribute values.\n/* All elements with the attribute \"data-vegetable\"\nare given green text */\n\n[data-vegetable] {\n    color: green;\n}\n\n/* All elements with the attribute \"data-vegetable\"\nwith the exact value \"liquid\" are given a golden\nbackground color */\n\n[data-vegetable=\"liquid\"] {\n    background-color: goldenrod;\n}\n\n/* All elements with the attribute \"data-vegetable\",\ncontaining the value \"spicy\", even among others,\nare given a red text color */\n\n[data-vegetable~=\"spicy\"] {\n    color: red;\n}\n\n// Pseudo-classes: Match one or more elements that exist in a certain state, such as an element that is being hovered over by the mouse pointer, or a checkbox that is currently disabled or checked, or an element that is the first child of its parent in the DOM tree.\n// Pseudo-elements: Match one or more parts of content that are in a certain position in relation to an element, for example the first word of each paragraph, or generated content appearing just before an element.\n\n:active\n:any\n:checked\n:default\n:dir()\n:disabled\n:empty\n:enabled\n:first\n:first-child\n:first-of-type\n:fullscreen\n:focus\n:focus-within\n:hover\n:indeterminate\n:in-range\n:invalid\n:lang()\n:last-child\n:last-of-type\n:left\n:link\n:not()\n:nth-child()\n:nth-last-child()\n:nth-last-of-type()\n:nth-of-type()\n:only-child\n:only-of-type\n:optional\n:out-of-range\n:read-only\n:read-write\n:required\n:right\n:root\n:scope\n:target\n:valid\n:visited\n\n// Combinators: These are not exactly selectors themselves, but ways of combining two or more selectors in useful ways for very specific selections. So for example, you could select only paragraphs that are direct descendants of divs, or paragraphs that come directly after headings.\n\nA, B\t匹配 A 或 B\nA B\t    匹配 A 里面的 B\nA \u003e B\t匹配 A 里面的直属 B\nA + B\t匹配 A 下一个兄弟节点 B\nA ~ B\t匹配 A 的下一群兄弟节点 B\n\n// Multiple selectors: Again, these are not separate selectors; the idea is that you can put multiple selectors on the same CSS rule, separated by commas, to apply a single set of declarations to all the elements selected by those selectors.\n```\n\n### 2.3 属性\n\n#### Position\n\nhttp://cssreference.io/positioning/\n\n#### Display\n\n#### Box Model\n\n块级元素 (Block)\n新开始一行并且尽可能撑满容器，p,form,header,footer,section\n设置块级元素的 width 可以防止它从左到右撑满整个容器\n行内元素 (inline)\n包裹一些文字，而不会打乱段落的布局，a,span\nnone\nscript 默认 display:none,visibility:hidden 是占据空间\n\n盒模型\n\n属性\n\n三，层叠与继承\n\n既然是层叠，就要有层叠的规律\n\n## 0x03 CSS 新语法\n\n### 3.1 Flex Layout\n\n- https://github.com/philipwalton/solved-by-flexbox\n\n### 3.2 Grid Layout\n\n## 0x04 SCSS\n\n这是一种兼容 CSS 语法的新语言。主要用于提升代码的可维护性。\n\n至于其他 less 之类大同小异。只选取了功能最强大的部分进行间接。\n\n### 4.1 OOCSS / BEM / 我的实践\n\n### 4.1 如何组织 SCSS 代码 --- 布局篇\n\n### 4.2 如何组织 SCSS 代码 --- 组件篇\n\n#### 4.2 BEM\n\n## 0x05 CSS 规范\n\n- https://github.com/airbnb/css\n\n- Use soft tabs (2 spaces) for indentation\n- Prefer dashes over camelCasing in class names.\n  - Underscores and PascalCasing are okay if you are using BEM (see OOCSS and BEM below).\n- Do not use ID selectors\n- When using multiple selectors in a rule declaration, give each selector its own line.\n- Put a space before the opening brace { in rule declarations\n- In properties, put a space after, but not before, the : character.\n- Put closing braces } of rule declarations on a new line\n- Put blank lines between rule declarations\n\nOOCSS 与 BEM 混用\n\n\u003e 只要是可维护的好代码，并不需要拘泥于用什么风格\n\n### 5.1 圣杯\n\n## 0xEE 参考链接\n\n- https://github.com/picturepan2/spectre\n\n---\n\nChangeLog:\n\n- **2017-12-20** 初始化本文\n"},{"tags":["macOS"],"path":"20171223_macOSInDepth.md","title":"macOS 的系统与软件","slug":"macOS 的系统与软件","date":"2017-12-23","category":"善用佳软","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n折腾了 Windows 很多年，后来出于个人开发需求转投 Mac，使用起来一直很顺手。现在也开始从顺手开始到了解更深一点的东西。\n\n## 0x01 系统安全架构\n\n### 1.1 系统架构概述\n\n非开发人员分层：\n\n- User Experience\n  - Aqua\n  - Dashboard\n  - Spotlight\n  - Dock\n  - 输入法\n  - 屏保\n  - 辅助功能\n  - 语音\n  - 位置与地图\n  - 搜索\n  - etc\n- Application Framework\n  - Cocoa\n- Graphics and Media\n  - 核心框架，OpenAL,Quartz,SceneKit,SpriteKit\n- Darwin\n  - 系统内核与 Shell 环境\n\n开发人员分层：\n\n- Cocoa Layer: Cocoa 框架层 包括了用于开发界面程序的框架集合。\n- Foundation Layer: 提供了程序开发室使用到的基础数据类型、数值处理、网络、IO 和 日期等\n- Media Layer: 提供了图像、声音、视频、动画及游戏开发需要的接口\n- Core Service Layer: 系统安全、底层内部数据访问以及存储接口。比如 AddressBook,CoreData,QuickLook 用于快速浏览插件开发。CoreFoundation 框架也属于这一层。\n- Core OS Layer: 加速器，蓝牙，异常处理，网络扩展，系统配置\n- Kernel \u0026 Driver Layer: 内核与驱动层。包括开发设备驱动程序与内核扩展所需的一些框架。\n\n应用程序是一个 bundle 文件，一般为 xxx.app 文件夹，\n\n### 1.1 一些常用软件\n\nClang\nLLVM\n\nHT Editor\n\n```\nbrew install ht\n```\n\n## 0x02 前言\n\n## 0x03 前言\n\n## 0xEE 参考链接\n\n- macOS 软件安全和逆向分析\n\n---\n\nChangeLog:\n\n- **2017-12-20** 初始化本文\n- **2018-02-10** 添加笔记\n"},{"tags":["数据分析"],"path":"20171207_ANoteWithSmallMachineAndBigData.md","title":"记一次小机器的 Python 大数据分析","slug":"记一次小机器的 Python 大数据分析","date":"2017-12-07","category":"Python","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n机缘巧合，最近公司突然要搞一波大量数据的分析。属于客流类的分析。\n\n数据量级也还算不错，经过 gzip 压缩，接近 400 个 点位的 SQL 文件 (MySQL innoDB)，大小接近 100GB 左右，原始记录数据估测在 180 亿左右。\n\n解压后...... 差不多一个 T 吧。\n\n如果是人民币玩家，自然是直接购置几十台高配置机器，做个 mysql shard 或者直接上大数据全家桶比如 hadoop 和 hive 之类，让程序员去往死里折腾吧。\n\n\u003e 嗯，然而对于我这种非人民币玩家，就要用单机硬扛。\n\n那就硬扛呗。\n\n我手上的机器配置如下：\n\n- 局域网服务器 （ Ubuntu 16.04 LTS ）\n\n  - Xeon(R) CPU E3-1225 v5 @ 3.30GHz\n  - 16G 内存\n  - 1T 硬盘\n\n- 苹果电脑 2016 年 15 寸 最高配\n  - 1T 硬盘\n  - i7 四核\n\n## 0x01 准备数据阶段\n\n用低配机器分析大数据的**首要原则**，就是**不要分析大数据**。\n\n何也？\n\n\u003e 就是**尽可能的抽取所得结论所需分析数据的最小超集**\n\n小机器是无法完成海量计算的，但通过一定的过滤和筛选可以将数据筛选出到一台机器能扛得住的计算量。从而达到可以可以分析海量数据的目的。\n\n### 1.1 将数据导入 MySQL 中\n\n我们先不管三七二十一，既然给了 SQL 文件，肯定要入库的，那么问题来了：\n\n\u003e ~~将大象关进冰箱要几个步骤~~\n\n将数据导入数据库中需要几个步骤\n\n或者说，如何更快的导入 400 张不同表的数据。\n\n大致步骤如下：\n\n- 新增硬盘，并初始化\n- 配置 MySQL 的 datadir 到新增硬盘上\n- 导入数据 (PV \u0026 MySQL)\n\n#### 新增硬盘，并初始化\n\n首先，**购买并插入硬盘**\n\n使用 lshw 查看硬盘信息\n\n```bash\nroot@ubuntu:~# lshw -C disk\n  *-disk\n       description: SCSI Disk\n       product: My Passport 25E2\n       vendor: WD\n       physical id: 0.0.0\n       bus info: scsi@7:0.0.0\n       logical name: /dev/sdb\n       version: 4004\n       serial: WX888888HALK\n       size: 3725GiB (4TB)\n       capabilities: gpt-1.00 partitioned partitioned:gpt\n       configuration: ansiversion=6 guid=88e88888-422d-49f0-9ba9-221db75fe4b4 logicalsectorsize=512 sectorsize=4096\n  *-disk\n       description: ATA Disk\n       product: WDC WD10EZEX-08W\n       vendor: Western Digital\n       physical id: 0.0.0\n       bus info: scsi@0:0.0.0\n       logical name: /dev/sda\n       version: 1A01\n       serial: WD-WC888888888U\n       size: 931GiB (1TB)\n       capabilities: partitioned partitioned:dos\n       configuration: ansiversion=5 logicalsectorsize=512 sectorsize=4096 signature=f1b42036\n  *-cdrom\n       description: DVD reader\n       product: DVDROM DH1XXX8SH\n       vendor: PLDS\n       physical id: 0.0.0\n       bus info: scsi@5:0.0.0\n       logical name: /dev/cdrom\n       logical name: /dev/dvd\n       logical name: /dev/sr0\n       version: ML31\n       capabilities: removable audio dvd\n       configuration: ansiversion=5 status=nodisc\n```\n\n使用 fdisk 格式化硬盘，并且分区\n\n```bash\nfdisk /dev/sdb\n#输入 n\n#输入 p\n#输入 1\n#输入 w\nsudo mkfs -t ext4 /dev/sdb1\nmkdir -p /media/mynewdrive\nvim /etc/fstab\n# /dev/sdb1    /media/mynewdrive   ext4    defaults     0        2\n# 直接挂载所有，或者 reboot\nmount -a\n```\n\n至此为止，硬盘就格式化完成了。\n\n\u003e 关于安装硬盘，可以参考 https://help.ubuntu.com/community/InstallingANewHardDrive\n\n#### 配置 MySQL\n\n篇幅有限，只简介具体在 Ubuntu 16.04 上面 配置 MySQL 的 DataDIR ，省去安装和基本登录认证的配置。\n\nmysql 在 ubuntu 下面默认的路径如下：\n\n```bash\n/var/lib/mysql/\n```\n\n我们开始配置 DataDIR\n\n```bash\nsystemctl stop mysql\nrsync -av /var/lib/mysql /mnt/volume-nyc1-01\nmv /var/lib/mysql /var/lib/mysql.bak\nvim /etc/mysql/mysql.conf.d/mysqld.cnf\n# 修改至 datadir=/mnt/volume-nyc1-01/mysql\nvim /etc/apparmor.d/tunables/alias\n# alias /var/lib/mysql/ -\u003e /mnt/volume-nyc1-01/mysql/\nsudo systemctl restart apparmor\nvim /usr/share/mysql/mysql-systemd-start\n# 修改成\nif [ ! -d /var/lib/mysql ] \u0026\u0026 [ ! -L /var/lib/mysql ]; then\n echo \"MySQL data dir not found at /var/lib/mysql. Please create one.\"\n exit 1\nfi\n\nif [ ! -d /var/lib/mysql/mysql ] \u0026\u0026 [ ! -L /var/lib/mysql/mysql ]; then\n echo \"MySQL system database not found. Please run mysql_install_db tool.\"\n exit 1\nfi\n\n# 接下来\nsudo mkdir /var/lib/mysql/mysql -p\nsudo systemctl restart mysql\n\n# 最后 my.conf 修改相关文件路径\n```\n\n\u003e 详细请参考这篇文章 https://www.digitalocean.com/community/tutorials/how-to-move-a-mysql-data-directory-to-a-new-location-on-ubuntu-16-04\n\n将 DataDIR 配置完成之后，就可以导入数据了。嗯，经过这么麻烦的事情之后，我决定下次遇到这种情况首选 Docker 而不是在 Ubuntu Server 上面搞这个。\n\n\u003e 站在现在看，如果重来的话，我肯定会用 Docker 然后把数据盘挂载到新硬盘到。\n\n比如直接 Docker 命令执行\n\n```bash\ndocker run --name some-mysql -v /my/own/datadir:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag\n```\n\n#### 导入数据 之 MySQL + PV\n\n我们使用 mysql 导入脚本的时候，有几种导入方式\n\n- source 命令，然而这个命令容易在数据量很大的时候直接卡掉。（印象中是直接把 sql 文件加载到内存中，然后执行，然而，只要涉及到大量文本打印出来并且执行，速度一定会变慢很多）\n- mysql 命令\n\n```bash\n# mysql 命令的典型导入场景就是这样\nmysql -uadmin -p123456 some_db \u003c tb.sql\n```\n\n加上 PV 命令的话，比较神奇了。有进度条了！!\n\n```bash\n# 附加进度条的导入场景\npv -i 1 -p -t -e ./xxxx_probe.sql | mysql -uadmin -p123456 some_db\n```\n\n然后，可以查看一下磁盘 CPU 内存的占用情况。如果负载（着重注意 IO，内存）还不够满，使用 tmux 多开几个进程导入数据。\n\n因为每个 SQL 文件对应的表不一样，所以多开几个进程批量 insert 的话并不会锁表，这样可以显著提升导入速度。\n\n### 1.2 导出数据\n\n既然已经导入了数据，为什么需要导出数据呢？\n\n因为数据量比较大，需要进行初步清洗。而我们最后肯定使用 Pandas 进行分析，从局域网数据库中读取大量的数据的时候，pandas 速度会非常的慢（具体是因为网络传输速度？)。所以，为了后面分析省事，我批量导出了数据，然后按照我的习惯进行了归类。\n\n在这个过程中，我还进行了一小部分的数据过滤，比如：\n\n- 只选取对自己有用的行与列。\n- 化整为零，拆分数据为最小单元的 CSV 文件\n\n#### 只选取对自己有用的行与列\n\n```sql\nselect col_a , col_b from some_table where Acondition and bcondition and col_c in ('xx','yy','zz');\n```\n\n这里面有一些值得注意的地方\n\n- 尽量把简单的判断写在左边。\n- 如果不是反复查询，则没有必要建立索引。直接走全表，筛选出必要的数据存 CSV 即可。\n\n#### 尽量拆分数据为最小单元的 CSV 文件\n\n如果按照某类，某段时间进行拆分可以在分析的时候随时取随时分析那就进行拆分。\n\n比如，某个大的 CSV 包含琼瑶里面各种人物情节地点的位置就可以拆分为：\n\n```bash\n201712_大明湖畔_夏雨荷_还珠格格_你还记得吗.csv\n201711_老街_可云_情深深雨蒙蒙_谁来救我.csv\n201710_屋子里_云帆_又见一帘幽梦_你的腿不及紫菱的爱情.csv\n```\n\n当我们需要取这坨数据的时候，可以直接 glob 一下，然后 sort, 接着二分查找。就可以快速读取这块数据了。\n\n### 1.3 校验数据完备性\n\n第三方给的数据多多少少会有这些或者那些的问题，一般情况下，可以通过检查数据完备性来尽可能的减少数据的不靠谱性。\n\n我习惯性在这样的表里面详细记录数据完备性的各种参数与进度。\n\n比如：\n\n- 数据的提供情况和实际情况\n- 阶段性的记录条数和点位的统计值\n- max，min，mean，median 用来避免异常值\n- 如果是分年份，则必须要统计每一天的情况，否则也不知道数据的缺失程度。\n\n## 0x02 分析阶段\n\n经过上一步处理，数据的文件总大小大约从 1000GB (uncompressed) -\u003e 30GB 左右 （拆分成若干个文件 compressed) 。每个文件大约是几百兆。\n\n### 2.1 性能要点 1：文件系统\n\n如果统计逻辑很简单，但是数量多，首选使用读取文件。读取文件进行统计速度是非常快的。（人民币玩家走开）\n\n像 linux 里面的 wc,grep,sort,uniq 在这种场景有时候也能用到。\n\n\u003e 注意，如果文件特别大，一定要迭代器一个一个读取。\n\n对于超大文件，比如说，上百 G 文件，可以先分成小片的文件，然后多进程批量读取并且处理。\n\n### 2.2 性能要点 2：化整为零，map reduce filter\n\n化整为零这个已经在上面的 1.2 节讲过了。\n\nmap/reduce/filter 可以极大的减少代码。\n\n\u003e collection 中有个 Counter , 在进行简单代码统计的时候用起来可以极大的减少代码。\n\n### 2.3 性能要点 3：进程池的两种作用\n\n我们都知道，当 用 Python 执行计算密集的任务时，可以考虑使用多进程来加速：\n\n即**为了加速计算**，此为作用一。如下：\n\n```python\ndef per_item_calc(item):\n    df = pd.read.....\n    # complex calc\n    return result\n\nwith ProcessPoolExecutor(3) as pool:\n    result_items = pool.map(per_item_calc,all_tobe_calc_items)\n\nreduce_results = ....\n```\n\n其实进程的销毁本身就可以给我带来第二个作用**管理内存**。\n\n具体会在 2.6 中的 DataFrame 里面解释。\n\n### 2.4 性能要点 4：List 和 Set , itertools\n\n有 400 组 UUID 集合，每个列表数量在 1000000 左右，列表和列表之间重复部分并不是很大。我想拿到去重之后的所有 UUID，应该怎么处理\n\n在去重的时候，自然而然想到了使用集合来处理。\n\n最初的做法是\n\n```python\nlist_of_uuid_set = [ set1 , set2 ... set400 ]\nall_uuid_set = reduce(lambda x: x | y, list_of_uuid_set)\n```\n\n1 小时过去了。 突然之间，四下里万籁无声。公司内外聚集数百之众，竟不约而同的谁都没有出声，便有人想说话的，也为这寂静的气氛所慑，话到嘴边都缩了回去。似乎硬盘的指示灯也熄灭了，发出轻柔异常的声音。我心中忽想：\n\n\u003e ~~小师妹这时候不知在干甚么？~~ 卧槽，程序是不是又卡死了？\n\nSSH 上去 htop 一下机器。发现实存和内存都满了。直觉告诉我，CPython 的集合运算应该是挺耗内存的。\n\n嗯，这怎么行，试试用列表吧。列表占用内存应该是比较小的。\n\n```python\ndef merge(list1,list2):\n    list1.append(list2)\n    return list1\n\nlist_of_uuid_list = [ list1 , list2 ... list400 ]\nall_uuid_set = set(reduce(merge, list_of_uuid_list))\n```\n\n1 小时过去了。 我一拍大腿，道：\n\n\u003e ~~小师妹这时候不知在干甚么？~~ 卧槽，程序是不是又卡死了？\n\n最后在 StackOverFlow 上找到了更好的解决方案。\n\n```python\nlist_of_uuid_list = [ list1 , list2 ... list400 ]\nall_uuid_set = set(list(itertools.chain(*list_of_uuid_list)))\n```\n\n运行一下，5s 不到出了结果（注意，包含了 Set 去重）。\n\nitertools 里还有很多有趣的函数可以使用。\n\nhttps://docs.python.org/3/library/itertools.html\n\n### 2.5 性能要点 5：IPython 给性能带来的影响\n\n当我们在分析数据的时候，往往使用的是 IPython, 或者 Jupyter Notebook\n\n但是，方便的同时，如果不加以注意的话，就会带来一点点小问题。\n\n比如下划线和双下划线分别存储上一个 CELL 的返回值，和上上个 CELL 的返回值。\n\n### 2.6 性能要点 6：DataFrame 带来的 GC 问题\n\nDataFrame 是我用 Pandas 的原因，在这次使用 DataFrame 的过程中，还是出现一些头疼的问题的。比如莫名的内存泄露。\n\n```python\ndef per_item_calc(item):\n    df = pd.read.....\n    # complex calc\n    return result\n\nresult_items = []\nfor item in all_tobe_calc_items:\n    result_items.append(per_item_calc(item))\n\nreduce_results = ....\n```\n\n我在 For 循环中读取 DataFrame 赋值给 df, 然后统计出一个结果。按理来说，每次只要一个简单的 result, 每次读取的文件大小一致，同样的会占用接近 2G 内存，而，当我赋值 df 的时候，**按理来说，应该是把原先 df 的引用数应该为 0, 会被 gc 掉，又释放了 2G 内存**，所以，是不太可能出现内存不够用的。\n\n运行程序，内存 biubiubiubiu 的增长，当进行到约第 1000 次的循坏的时候，直到 16G 内存占满。\n\n那么显式的 del 一下会不会好一点呢？代码如下：\n\n```python\ndef per_item_calc(item):\n    df = pd.read.....\n    # complex calc\n    del df\n    return result\n```\n\n似乎好了一点点，但是其实并没有好到哪里去。\n\n然而，和前一次一样，内存 biubiubiubiu 的增长，当进行到约第 1000 次的循坏的时候，直到 16G 内存占满。\n\n只是在读取文件的时候，预先减少了上次循环没有 del 掉的 df. 和上一个想法没有太大区别。除了比上一个方法每次读取文件的提前减少了一个多 G 的内存。\n\n查找相关资料，涉及到 Python 里面的 Pandas GC 的资料并不多，稍微整理一下，如下：\n\n\u003e Python 程序 在 Linux 或者 Mac 中，哪怕是 del 这个对象，Python 依旧 ~~站着茅坑不拉屎~~ 就是不把内存还给系统，自己先占着，~~有本事你打死我啊~~ 直到进程销毁。\n\n嗯？这个和我要的东西不一样嘛？具体怎么管理 pandas 里面的 object 的，到底是哪里 GC 不到位呢？还是没有说呀。\n\n参考：\n\n- https://stackoverflow.com/questions/23183958/python-memory-management-dictionary\n- http://effbot.org/pyfaq/why-doesnt-python-release-the-memory-when-i-delete-a-large-object.htm\n\n不过有一点启示了我。\n\n\u003e 直到进程销毁。\n\nPython 里面不是有个 ProcessPoolExecutor 模块么。\n\n那么问题来了，ProcessPoolExecutor 是动态创建进程并且分配任务的呢，为每一个 item 分配一个进程来运算？还是创建完三个进程之后把 item 分配给空闲进程的进行运算呢？\n\n- 如果是前者，则是正经的进程池。似乎 map 过去，除非任务执行完毕或者异常退出，否则进程不销毁。并不能给我们解决 内存泄露 的问题。\n- 如果是后者，则是并不是线程池。\n\n你说，进程池肯定是前者咯。可是你在验证之前，这是进程池只是你的从其他语言带来的想法，这是不是一个线程池，是一个什么样子的进程池，如果进程执行过程中挂掉了，这个时候就少了一个线程，会不会再补充一个进程呢？？\n\n怎么看验证呢？\n\n1. 运行程序，进入 Htop 看进程 PID\n2. 看源码\n\n```python\n# https://github.com/python/cpython/blob/3.6/Lib/concurrent/futures/process.py#L440\ndef _adjust_process_count(self):\n    for _ in range(len(self._processes), self._max_workers):\n        p = multiprocessing.Process(\n                target=_process_worker,\n                args=(self._call_queue,\n                        self._result_queue))\n        p.start()\n        self._processes[p.pid] = p\n```\n\n从源码得出在主线程创建了管理进程的线程，管理进程的线程创建了 max_workers 个进程（在我的例子里面就只有 3 个 worker).\n\n\u003e 是个进程池。\n\n好，如果是进程池，似乎 map 过去，除非任务执行完毕或者异常退出，否则进程不销毁。并不能给我们解决 内存泄露 的问题。\n\n\u003e 等等，如果用多进程池不就好咯？\n\n```python\ndef per_item_calc(item):\n    df = pd.read.....\n    # complex calc\n    return result\n\nresult_items = []\nstep = 300\nfor idx in range(0,len(all_tobe_calc_items),step):\n    pieces_tobe_calc_items = all_tobe_calc_items[idx:idx+step]\n    with ProcessPoolExecutor(3) as pool:\n        pieces_result_items = pool.map(per_item_calc,pieces_tobe_calc_items)\n        result_items.append(pieces_result_items)\n\nreduce_results = list(itertools.chain(*result_items))\n```\n\n\u003e 当然，这是一种让操作系统帮我 GC 的方法。**即 Python 不能帮我 GC 的，操作系统帮我 GC**\n\n\u003e PS: 其实用 multiprocessing 模块也行，只是线程池可以稍微控制一下进程创建的数量。\n\n总结一下，对于大量的 DataFrame 处理：\n\n1. 多个进程池是一种处理的方式。\n2. 尽量减少 DataFrame 的数量\n3. 尽量减少赋值导致的 COPY, 修改时带上 inplace=True\n4. 读取 CSV 的时候指定相关列的类型 {‘col_a’: np.float64, ‘col_b’: np.int32}，否则 pandas 会产生大量的 object\n\n## 0xDD 番外篇\n\n在分析这次的数据过程中，自己的 Mac 主板也坏掉了，幸好还在保修期，送到苹果店维修了一下。给苹果的售后点个赞。\n\n## 0xEE 更新\n\n- **2017-12-07** 初始化本文\n- **2017-12-16** 增加分析阶段的文字\n- **2017-12-26** 去掉一些 TODO, 发布到我的小站\n- **2017-12-31** 正式发布\n"},{"tags":["Python"],"path":"20150309_图片爬虫.md","title":"Python 图片爬虫","slug":"Python 图片爬虫","date":"2017-12-01","category":"Python","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n# Python 图片爬虫\n\n## 0x00 前言\n\n在平时抓取部分自己喜欢的资源的时候，我们常常会去下载一些比较有用的资源，比如，我比较喜欢 GEM 的照片，但是，这个东西，总不能总是去找别人要吧，那么，怎么办？\n\n很简单，我们只需要通过 Python 写一个小小的爬虫就可以解决这些问题。\n\n什么是爬虫？自己可以百度去。\n\n我这里指的爬虫是那些可以模拟浏览器的行为的小程序。\n\n比如，我要抓取 G.E.M 的相片，那么，我就想个办法。把图片的地址解析出来。然后写一个小功能下载不就好了么。\n\n\u003c!--more--\u003e\n\n虽然，话是这么说，\n\n但，怎么下手？\n\n这在写这篇文章，并且写到这里的时候，刚刚决定了抓取几个站点\n\n（刚刚百度了 邓紫棋壁纸 得到这个网站 http://www.6188.com/show/12788_1.html)\n\n## 0x01 准备工作以及爬取思路\n\nPython3,Chrome 浏览器或者 Firefox,\nPython3 基本依赖库 beautifulsoup4 lxml\n\n任务如下：\n\n1. 第一个简单案例 http://www.6188.com/show/12788_1.html\n\n2. 百度 API 解析\n\n3. 虾米照片爬取\n\n4.instagram 墙外下载 Gem 照片\n\n5. 发烧级别的 GEM 粉丝 - 虾米网 down! down! down!\n\n涉及到的知识点：\n\n1. 爬虫的最最基本思路\n2. 几个解析方法 正则解析，bs4 解析，lxml 解析\n3. 多线程使用\n\n## 0x02 6188.com 壁纸抓取 -- 关键词爬虫\n\n先说一下思路，首先，你要会点击下载按钮.(#-#)\n\n1. 访问 http://www.6188.com/show/12788_1.html\n\n2. 点击下载大图\n\n3. 看大图，手动另存为\n\n这是普通人下载图片的方式。\n\n让我们用程序员的眼光来看。\n\n浏览器呈现的具体的过程可以看我的 PyDjango 中关于计算机 Http 协议的部分。\n\n经过抓包 (http 包）分析 (chrome 的 F12), 知道，要想获取图片原始链接，有这么一个流程\n\n从 http://www.6188.com/show/12788_1.html 解析出下面链接\n\n从 http://www.6188.com/show.php?pic=/flashAll/20140211/1392111065nvjKS7.jpg 解析下面链接\n\n从 http://pic.6188.com/upload_6188s/flashAll/20140211/1392111065nvjKS7.jpg 下载图片。\n\n这样一看，非常简单明了。这就是下载一张图片的链接。\n\n同样道理，把下面的程序写成一个 for 循环，就可以直接下载 35 张图片。\n\n```html\nhttp://www.6188.com/show/12788_1.html http://www.6188.com/show/12788_2.html\nhttp://www.6188.com/show/12788_3.html ... http://www.6188.com/show/12788_35.html\n```\n\n写的应该比较容易认出\n\n```python\nimport os\nimport re\nimport requests\n\n__author__ = 'micheal'\n\nr = requests.get(\"http://www.6188.com/show/12788_1.html\")\nm = re.search(\"(/show\\.php.+jpg)\\\"\", r.text)\n\npic_url = \"http://www.6188.com\" + m.group(0)\nprint(m.group(0))\ndata = requests.get(pic_url)\nprint(data.text)\n\nm = re.search(\"src='(http://.+\\.jpg)\", data.text)\nreal_url = m.group(1)\n\ntry:\n    print(\"real_url-- 正在下载 --\"+real_url)\n    r = requests.get(real_url,stream=True)\n    fileName = \"GEM.jpg\"\n    fileFullPath = os.path.join('/home/micheal/Pictures/', fileName)\n    print(\"正在下载\" + str(data.status_code))\n    with open(fileFullPath, 'wb') as f:\n        for chunk in r.iter_content(chunk_size=1024 * 2):\n            if chunk: # filter out keep-alive new chunks\n                f.write(chunk)\n                f.flush()\n    pass\nexcept Exception:\n    print(\"出错\")\n    raise\n\nprint(\"任务完成\")\n\n```\n\n添加 For 循环，优化一下\n\n```python\nimport os\nimport re\nimport requests\n\n__author__ = 'micheal'\n\ns = requests.session() # 仿真 browser 使用一个会话\n\nfor i in range(1,30):\n    html_url = \"http://www.6188.com/show/12788_\"+str(i)+\".html\"\n    r = s.get(html_url)\n    print(\"downloading\" + html_url)\n    m = re.search(\"(/show\\.php.+jpg)\\\"\", r.text)\n\n    pic_url = \"http://www.6188.com\" + m.group(0)\n    print(m.group(0))\n    data = s.get(pic_url)\n    print(data.text)\n\n    m = re.search(\"src='(http://.+\\.jpg)\", data.text)\n    real_url = m.group(1)\n\n    try:\n        img_store_dir = \"/home/micheal/Pictures/GEM/6188\"\n        print(\"real_url-- 正在下载 --\"+real_url)\n        r = s.get(real_url,stream=True)\n        fileName = \"GEM\"+str(i)+\".jpg\"\n        if not os.path.exists(img_store_dir):\n            os.makedirs(img_store_dir)\n        fileFullPath = os.path.join(img_store_dir, fileName)\n        print(\"正在下载\" + str(data.status_code))\n        with open(fileFullPath, 'wb') as f:\n            for chunk in r.iter_content(chunk_size=1024 * 2):\n                if chunk: # filter out keep-alive new chunks\n                    f.write(chunk)\n                    f.flush()\n        pass\n    except Exception:\n        print(\"出错\")\n        continue\n    finally:\n        pass\n\nprint(\"任务完成\")\n\n```\n\n###评价\n\n第一个小程序应该是非常容易看懂的。\n\n那么，这个程序有什么缺点呢？\n\n- 下载速度太慢，需要使用多线程，\n- 解析方法不具有通用性，这张网页中只有一个地址需要解析，所以正则表达式还是可以胜任。但是，复杂的网页肯定不行\n- 下载的图片太少了。\n\n## 0x03 百度 API 的解析 -- 关键词多线程\n\n主要就是增加了一个多线程的任务，原理什么的基本上和上面那个的相似\n\n```python\nimport json\nimport os\nfrom queue import Queue\nimport re\nimport threading\nimport requests\n\n__author__ = 'micheal'\n\nq = Queue(maxsize=0)\n# http://image.baidu.com/i?tn=resultjsonavatarnew\u0026ie=utf-8\u0026word=%E9%82%93%E7%B4%AB%E6%A3%8B\u0026cg=star\u0026pn=0\u0026rn=60\n\ns = requests.session()\n\ndef worker():\n    while True:\n        try:\n            real_url = q.get()\n            print(\"正在下载\" + real_url)\n\n            img_store_dir = \"/home/micheal/Pictures/GEM/baidu\"\n            print(\"real_url-- 正在下载 --\"+real_url)\n            r = s.get(real_url,stream=True)\n            fileName = real_url.split(\"/\")[-1]\n            if not os.path.exists(img_store_dir):\n                os.makedirs(img_store_dir)\n            fileFullPath = os.path.join(img_store_dir, fileName)\n            print(\"正在下载\" + str(r.status_code))\n            with open(fileFullPath, 'wb') as f:\n                for chunk in r.iter_content(chunk_size=1024 * 2):\n                    if chunk: # filter out keep-alive new chunks\n                        f.write(chunk)\n                        f.flush()\n            pass\n        except Exception as e:\n            print(\"出错\")\n            raise e\n            continue\n\n        finally:\n            pass\n\n        q.task_done()\n\n    pass\n\nif __name__ == \"__main__\":\n\n    for i in range(100):\n        fr = i * 60\n        to = i * 60 + 60\n        r = requests.get(\"http://image.baidu.com/i?tn=resultjsonavatarnew\u0026ie=utf-8\u0026word=%E9%82%93%E7%B4%AB%E6%A3%8B\u0026cg=star\u0026pn=\"+str(fr)+\"\u0026rn=\"+str(to)+\"\u0026itg=1\u0026z=3\u0026fr=\u0026width=0\u0026height=0\u0026lm=-1\u0026ic=0\u0026s=0\u0026st=-1\")\n        data = json.loads(r.text)\n\n        for j in range(60):\n            real_url = data['imgs'][j]['objURL']\n            print(real_url)\n            q.put(real_url)\n\n        for j in range(20):\n            t = threading.Thread(target=worker)\n            t.daemon = True\n            t.start()\n\nq.join()\n\nprint(\"任务完成\")\n\n```\n\n引入了多线程，但是抓取效果并不好，大概有 10% 左右的照片可能是有点问题的，把线程数目从 20 条调整小一些。\n\n先写到这里，明天接着写剩下来的代码。\n\n## 0x04 抓取虾米的相册 -- 反反爬虫\n\n好吧，我们将魔手伸向了虾米音乐的图片板块\n\nhttp://www.xiami.com/artist/pic-55712\n\n我们尝试使用昨天的方法获取页面。\n\n```python\nss = requests.session()\nr = ss.get(“http://www.xiami.com/artist/pic-55712?spm=0.0.0.0.IaKt5o\u0026page=3”)\nprint(r.text)\n\n```\n\n但是出现问题了，\n\n```html\n\u003c!DOCTYPE HTML PUBLIC “-//IETF//DTD HTML 2.0//EN”\u003e\n\u003chtml\u003e\n\u003chead\u003e\u003ctitle\u003e400 Bad Request\u003c/title\u003e\u003c/head\u003e\n\u003cbody bgcolor=”white”\u003e\u003cscript\u003e\nwith(document)with(body)with(insertBefore(createElement(“script”),firstChild))setAttribute(“exparams”,”category=\u0026userid=\u0026aplus\u0026yunid=\u0026\u0026asid=AABI4v5USkJh1pUp01o=”,id=”tb-beacon-aplus”,src=(location\u003e”https”?”//s”:”//a”)+”.tbcdn.cn/s/aplus_v2.js”)\n\u003c/script\u003e\n\n\u003ch1\u003e400 Bad Request\u003c/h1\u003e\n\u003cp\u003eYour browser sent a request that this server could not understand. Sorry for the inconvenience.\u003cbr/\u003e\nPlease report this message and include the following information to us.\u003cbr/\u003e\nThank you very much!\u003c/p\u003e\n\u003ctable\u003e\n\u003ctr\u003e\n\u003ctd\u003eURL:\u003c/td\u003e\n\u003ctd\u003ehttp://www.xiami.com/artist/pic-55712?spm=0.0.0.0.IaKt5o\u0026amp;page=3\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eServer:\u003c/td\u003e\n\u003ctd\u003eweb-xiami-main-030.cm10\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eDate:\u003c/td\u003e\n\u003ctd\u003e2015/03/10 20:23:36\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/table\u003e\n\u003chr/\u003ePowered by Tengine\u003c/body\u003e\n\u003c/html\u003e\n\nProcess finished with exit code 0\n\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/table\u003e\u003c/p\u003e\u003c/h\u003e\n\u003c/script\u003e\u003c/title\u003e\u003c/head\u003e\n\u003c/html\u003e\n```\n\n我们前面使用的代码都是爬取一些没有做太多防止爬虫的网站，但是，我们今天准备爬取的是一个有防护措施的网站。\n\n没办法，修改一下 headers, 然后继续访问即可。\n\n## 0xEE 更新\n\n---\n\nChangeLog:\n\n- **2017-12-19** 重修文字\n"},{"tags":["Python"],"path":"20150317_扇贝背单词小助手.md","title":"背单词小助手","slug":"背单词小助手","date":"2017-12-01","category":"Python","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n# 背单词小助手\n\n## 0x01 本文内容\n\n### 思路\n\n- 英文单词的处理\n- shanbay 单词本的提交\n\n### 英文单词的处理\n\n正则表达式进行提取，然后通过 Python 的自然语言处理工具 ntlk 进行单词原型的转换\n\n### shanbay 单词的处理\n\n由于使用了传说中的 requests，使得代码简洁程度大大提升。\n\n\u003c!--more--\u003e\n\n### 代码如下\n\n英文单词处理模块\n\nshanbay 登录以及单词的提交\n\n这是 v0.1 版本，有不少细节需要调整。有时间我会继续更新\n代码 9 逻辑比较简单，自己阅读代码吧\n\n[请来 github 这里](https://github.com/twocucao/PyTools)\n\n```python\nimport os\nimport re\n\n__author__ = 'micheal'\n\nfrom nltk.stem import WordNetLemmatizer\n\nlemmatizer = WordNetLemmatizer()\n\n## 常量设置\n\nBOOKS_FOLDER = \"Books/\"\n\nOUTPUTS_FOLDER = \"OutPuts/\"\n\nCOVER_FILE = \"cover.jpg\"\n\nEXCLUDED_LIB_FILE = \"excluded_libs.txt\"\n\nSUMMARY_FILE = \"SUMMARY.json\"\n\nALL_LIB_FILE = \"all.txt\"\n\n### 初始化数据，\n# 创建 ALLFile\ndef createMergeFile():\n    fo = open(ALL_LIB_FILE, 'w')\n    for name in os.listdir(BOOKS_FOLDER):\n        fi = open(BOOKS_FOLDER + name, \"r\")\n        while True:\n            s = fi.read(16 * 1024)\n            if not s:\n                break\n            fo.write(s)\n        fi.close()\n    fo.close()\n\n    pass\n\ndef get_sorted_words_list_from(txt_path):\n    with open(txt_path, \"r\") as f:\n        strs = f.read()\n        s = re.findall(\"\\w+\", str.lower(strs), flags=re.ASCII)\n\n    ss = []\n    for item in s:\n        ss.append(lemmatizer.lemmatize(item))\n\n    l = sorted(list(set(ss)))\n    ll = []\n\n    for i in l:\n        m = re.search(\"\\d+\", i)\n        n = re.search(\"\\W+\", i, flags=re.ASCII)\n        if not m and not n and len(i) \u003e 4:\n            ll.append(i)\n            # 不属于数字也不属于非（英文 + 数字）并且字母长度大于 4 的集合\n\n    return ll\n\ndef WordCountInit():\n    createMergeFile()\n\n    excluded_words = get_sorted_words_list_from(\"excluded_libs.txt\")\n\n    file = {}\n\n    folder_list = os.listdir(BOOKS_FOLDER)\n\n    for item in folder_list:\n        file[item] = get_sorted_words_list_from(BOOKS_FOLDER + item)\n\n        words = file[item]\n\n        real_words = []\n\n        for word in words:\n            if word not in excluded_words:\n                real_words.append(word)\n\n        # print(\"excluded_words\\n\"+str(excluded_words))\n\n        print(\"real_words\\n\" + str(real_words))\n\n        excluded_words.extend(file[item])\n        with open(OUTPUTS_FOLDER + item, \"w\") as f:\n            f.write(str(sorted(list(real_words))))\n\n    return True\n\n    # print(file)\n\n```\n\n```python\nfrom datetime import datetime\nimport json\nimport os\nimport requests\nfrom WordsCount import get_sorted_words_list_from, WordCountInit\n\n__author__ = 'micheal'\n\nword_book_url = \"http://www.shanbay.com/wordbook/99004/\"\n\nfrom nltk.stem import WordNetLemmatizer\n\nlemmatizer = WordNetLemmatizer()\n\nclass ShanBay:\n    # 初始化 shanbay 的基本信息\n    # 1. 登录，\n\n    # 2，创建 wordbook\n    # 3，创建 wordlist，\n    # 4，用集合填充 wordlist\n    # 5，填充策略\n    #\n\n    def __init__(self):\n        print(\"基本数据正在初始化\")\n        WordCountInit()\n        print(\"初始化完毕\")\n\n        self.headers = {\n            \"User-Agent\": \"Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.93 Safari/537.36\",\n            \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\",\n            \"Content-Type\": \"application/x-www-form-urlencoded; charset=UTF-8\",\n            \"Accept-Language\": \"en-US,en;q=0.5\",\n            \"Accept-Encoding\": \"gzip, deflate\",\n            \"Connection\": \"keep-alive\",\n            \"Cache-Control\": \"max-age=0\",\n        }\n\n        self.index_url = \"http://www.shanbay.com/\"\n\n        self.login_url = \"http://www.shanbay.com/accounts/login/\"\n\n        self.sb_session = requests.Session()\n        self.sb_session.headers.update(self.headers)\n        self.sb_session.get(self.login_url)\n        # 开始登录\n        # 初始化登录\n\n        print(\"正在登录中\")\n        self.doLogin(\"test\", \"test\")\n\n        print(\"单词书  情况如下 \\n\")\n        with open(\"SUMMARY.json\", \"r\") as f:\n            decodejson = json.loads(f.read())\n            self.book_info_title = decodejson[\"title\"]\n            self.book_info_category = decodejson[\"category\"]\n            self.book_info_description = decodejson[\"description\"]\n            self.book_info_price = decodejson[\"price\"]\n            print(\n                \"标题：\" + self.book_info_title + \"\\n 类型：\" + self.book_info_category + \"\\n 描述：\" + self.book_info_description + \"\\n 价格：\" + self.book_info_price)\n\n        self.createWordBook()\n\n        ## 判断有多少个路进然后接着进行一系列的操作\n        word_list_list = os.listdir(\"Books/\")\n        for word_list in word_list_list:\n            print(\"正在创建\" + word_list)\n\n            dt = datetime.now()\n\n            list_id = self.createWordList(self.word_book_id, \"List\" + dt.strftime('%Y%m%d%H%M%S'),\n                                          \"这仅仅是一个比较简单的描述\" + dt.strftime('%Y%m%d%H%M%S'))\n\n            self.fillWordListById(list_id, get_sorted_words_list_from(\"OutPuts/\" + word_list))\n\n            # print(self.sb_session.get(self.index_url).text)\n\n    def doLogin(self, username, password):\n        self.login_form = {\n            \"csrfmiddlewaretoken\": self.sb_session.cookies[\"csrftoken\"],\n            \"username\": username,\n            \"password\": password,\n        }\n\n        self.sb_session.post(self.login_url, self.login_form)\n\n        return True\n\n    def fillWordListById(self, _id, words):\n        # \"172981\"\n        for word in words:\n            post_data = {\n                \"id\": _id,\n                \"word\": word,\n            }\n            self.sb_session.post(\"http://www.shanbay.com/api/v1/wordlist/vocabulary/\", post_data)\n\n        return 0\n\n    def createWordBook(self):\n        # http://www.shanbay.com/wordbook/create/basicinfo/\n\n        createWordBookForm = {\n            \"csrfmiddlewaretoken\": self.sb_session.cookies[\"csrftoken\"],\n            \"title\": self.book_info_title,\n            \"category\": self.book_info_category,\n            \"description\": self.book_info_description,\n            \"price\": self.book_info_price,\n        }\n\n        t = self.sb_session.post(\"http://www.shanbay.com/wordbook/create/basicinfo/\", createWordBookForm)\n        self.word_book_id = str(t.url).split(\"/\")[-3]\n\n        # 封面没有办法提交...... 以后再说\n        coverFiles = {\n            \"csrfmiddlewaretoken\": self.sb_session.cookies[\"csrftoken\"],\n            \"cover\": ('cover.jpg', open('cover.jpg', 'rb'), 'image/jpeg', {'Expires': '0'}),\n            \"wordbook_id\": self.word_book_id,\n            \"description\": self.book_info_description,\n        }\n        # files = {'file': ('report.xls', open('report.xls', 'rb'), 'application/vnd.ms-excel', {'Expires': '0'})}\n\n        self.sb_session.post(\"http://www.shanbay.com/wordbook/create/\" + self.word_book_id + \"/uploadcover/\",\n                             files=coverFiles)\n\n        return True\n\n    def doMenu(self):\n        # while True:\n        #\n        # print(\"\"\"\\\n        #\n        # 请输入相关操作：\n        # 1.createWordBook\n        # 2.createWordList\n        #\n        #\n        #     \"\"\")\n        #     self.word_book_id = input(\"word_book_id\")\n        #\n        #\n        #\n\n        pass\n\n    def createWordList(self, _id, name, desc):\n        createWordListFrom = {\n            \"name\": name,\n            \"description\": desc,\n            \"wordbook_id\": _id,\n\n        }\n        r = self.sb_session.post(\"http://www.shanbay.com/api/v1/wordbook/wordlist/\", createWordListFrom)\n        return (json.loads(r.text)[\"data\"][\"wordlist\"][\"id\"])\n\n        pass\n\nsss = ShanBay()\n\n```\n\n这个程序还是比较简单的。\n\n---\n\nChangeLog:\n\n- **2020-11-30** 重修文字\n"},{"tags":["Shell"],"path":"20150418_ShellCheatSheet.md","title":"Shell CheatSheet","slug":"Shell CheatSheet","date":"2017-12-01","category":"善用佳软","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n# Shell CheatSheet\n\n## 0x00 前言\n\n本文为 Cheatsheet 类型文章，用于记录我在日常编程中经常使用的 Shell 单行命令。\n\n## 0x01 快捷键\n\n```\n- 「c-c」 : 中断当前命令。\n- 「c-z」 : 当前程序暂停，bg 切换后台运行，使用 fg 可以调回\n- 「tab」 : 补全\n- 「tabx2」 : 补全提示\n- 「c-r」 : 搜索命令行\n- 「c-w」 : 同 vim\n- 「c-u」 : 删除整行\n- 「a-b/a-f」 : 移动一个词\n- 「c-a」 : 移动至行首\n- 「c-e」 : 移动至行尾\n- 「c-k」 : 删除光标到行尾\n- 「c-l」 : 清屏\n- 「c-x,c-e」 : 用默认编辑器编辑当前命令（这样就可以把其他文本移动扔掉了。)\n```\n\n## 0x02 帮助\n\n查找帮助\n\n```\n- man\n- whatis / which / where\n- tldr\n```\n\n值得一提的就是 tldr, 直接可以在上面查看命令的常规使用。实在是碉堡了。\n\n```\n\u003e tldr ssh\nLocal data is older than two weeks, use --update to update it.\n\nssh\n\nSecure Shell is a protocol used to securely log onto remote systems.\nIt can be used for logging or executing commands on a remote server.\n\n- Connect to a remote server:\n    ssh username@remote_host\n\n- Connect to a remote server with a specific identity (private key):\n    ssh -i path/to/key_file username@remote_host\n\n- Connect to a remote server using a specific port:\n    ssh username@remote_host -p 2222\n\n- Run a command on a remote server:\n    ssh remote_host command -with -flags\n\n- SSH tunneling: Dynamic port forwarding (SOCKS proxy on localhost:9999):\n    ssh -D 9999 -C username@remote_host\n\n- SSH tunneling: Forward a specific port (localhost:9999 to slashdot.org:80) along with disabling pseudo-[t]ty allocation and executio[n] of remote commands:\n    ssh -L 9999:slashdot.org:80 -N -T username@remote_host\n\n- SSH jumping: Connect through a jumphost to a remote server (Multiple jump hops may be specified separated by comma characters):\n    ssh -J username@jump_host username@remote_host\n\n- Agent forwarding: Forward the authentication information to the remote machine (see `man ssh_config` for available options):\n    ssh -A username@remote_host\n```\n\n## 0x03 macOS 用户\n\n如果你和我一样使用的是 mac 系统\n\n可以考虑将部分 FreeBSD 的工具换成 gnu\n\n```\nbrew install autoconf bash binutils coreutils diffutils ed findutils flex gawk \\\n    gnu-indent gnu-sed gnu-tar gnu-which gpatch grep gzip less m4 make nano \\\n    screen watch wdiff wget\n```\n\nbashrc/zshrc 加上如下命令\n\n```\nif type brew \u0026\u003e/dev/null; then\n  HOMEBREW_PREFIX=$(brew --prefix)\n  # gnubin; gnuman\n  for d in ${HOMEBREW_PREFIX}/opt/*/libexec/gnubin; do export PATH=$d:$PATH; done\n  # I actually like that man grep gives the BSD grep man page\n  #for d in ${HOMEBREW_PREFIX}/opt/*/libexec/gnuman; do export MANPATH=$d:$MANPATH; done\nfi\n```\n\n经过上面一步，则基本上 find sed tar which 这些命令使用的 gnu 版本 (linux 版本）, 而非系统自带的 unix 版本了。\n\n## 0x04 基本命令 - old fashion\n\n```bash\n文件 / 目录 mkdir / rm\n查找文件 cd / cp / pwd / find\n查看文件 more / less / tail / diff / cat / grep\n用户权限 chown / chmod\n复制 / 粘贴 / 同步 / 链接 cp / rsync / ln\n挂载 mount\n```\n\n```bash\n# 创建和删除\nmkdir\nmkdir -p a/b/c\n\nrm\nrm -rf dir/file/regex\nrm *log# 等价 find ./ -name \"*log\" -exec rm {};\n\nmv\ncp\ncp -r source_dir dest_dir\nrsync --progress -a source_dir dest_dir\nrsync -vr --progress you_folder_here twocucao@192.168.2.151:/Users/twocucao/Codes/# 目录切换 ls -lrt\nfind ./ -name \"*.o\" -exec rm {} \\;\nmore\nhead\ntail\ntail -f filename\ndiff\nchown\nchmod\nchown -R tuxapp source/chmod a+x myscript\nln cc ccA\nln -s cc ccTo\ncat -v record.log | grep AAA | grep -v BBB | wc -l\nfind ./ | wc -l\n```\n\n```bash\n查找文件之 find (gfind)\n## Find\nfind . \\( -name \"*.txt\" -o -name \"*.pdf\" \\) -print\n# 正则方式查找 txt 和 pdf\nfind . -regex  \".*\\(\\.txt|\\.pdf\\)$\"\nfind . ! -name \"*.txt\" -print\nfind . -maxdepth 1 -type f\n# 定制搜索\n## 按照类型搜索\nfind . -type f -print  #只列出所有文件\nfind . -type d -print  #只列出所有目录\nfind . -type l -print  #只列出所有符号链接\n## 按照时间搜索\nfind . -atime 7 -type f -print\n# 最近第 7 天被访问过的所有文件：\nfind . -atime -7 -type f -print\n# 最近 7 天内被访问过的所有文件：\nfind . -atime +7 type f -print\n# 查询 7 天前被访问过的所有文件：\n# w,k,M,Gfind . -type f -size +2kfind . -type f -perm 644 -print \n# 找具有可执行权限的所有文件 find . -type f -user weber -print\n# 找用户 weber 所拥有的文件\n# 后续动作\n## 删除 find . -type f -name \"*.swp\" -delete\n## 执行动作\nfind . -type f -name \"*.swp\" | xargs rmfind . -type f -user root -exec chown weber {} \\;\n## eg: copy 到另一个目录\nfind . -type f -mtime +10 -name \"*.txt\" -exec cp {} OLD \\;\n##  -exec ./commands.sh {} \\;\n# 2. 删除内部为空的文件夹# 递归删除 a/b/c\nfind . -type d -empty -delete\n# 使用.gitkeep 进行填充\nfind . -type d -empty -exec touch {}/.gitkeep \\;\nfind . -type d -empty -not -path '*/\\.*' -exec touch {}/.gitkeep \\;\n# 不初始化.git/\n# 3. 寻找 TOP 10\nfind . -type f -printf '%s %p\\n'| sort -nr | head -10 | awk '{$1/=1024*1024;printf \"%.2fMB - %s\\n\",$1,$2}'\n# 4. 寻找文件夹 TOP 10\n{}: A placeholder token that will be replaced with the path of the search result (documents/images/party.jpg).{.}: Like {}, but without the file extension (documents/images/party).{/}: A placeholder that will be replaced by the basename of the search result (party.jpg).{//}: Uses the parent of the discovered path (documents/images).{/.}: Uses the basename, with the extension removed (party).# Convert all jpg files to png files:fd -e jpg -x convert {} {.}.png# Unpack all zip files (if no placeholder is given, the path is appended):fd -e zip -x unzip# Convert all flac files into opus files:fd -e flac -x ffmpeg -i {} -c:a libopus {.}.opus# Count the number of lines in Rust files (the command template can be terminated with ';'):fd -x wc -l \\; -e rs\n```\n\n```bash\n# 压缩 / 解压缩\n7z / 7za /7zr\ntar / gzip / unzip/ unrar\n# 打包\ntar -cvf\n# 解包\ntar -xvf\n# 压缩\ngzip\n# 解压缩\ngunzip\nbzip\ntar 是将多个文件放在一起变成一个 tar 文件 (Tape Archiver)\ngzip 是讲一个文件变成一个压缩文件\n则 foo.tar.gz 指的是 先把文件转为 tar 文件，然后 gzip 之\n```\n\n### 文本篇\n\n```bash\ngrep match_pattern file\n\n\t-o 只输出匹配的文本行\n\t-v 只输出没有匹配的文本行\n\t-c 统计文件中包含文本的次数\n\t-n 打印匹配行号\n\t-i 搜索时符合大小写\n\t-l 之打印文件名\n\ngrep \"class\" . -R -n # 多级目录中对文本递归搜索\ngrep -e \"class\" -e \"vitural\" file # 匹配多个模式\ngrep \"test\" file* -lZ| xargs -0 rm # grep 输出以、0 作为结尾符的文件名：（-z）-d 定义定界符-n 输出为多行-l {} 指定替换字符串 cat file.txt | xargs # 打印多行 cat file.txt | xargs -n 3 # 分割多行\ncat file.txt | xargs -I {} ./command.sh -p {} -1-0 指定、0 为输入定界符\nfind source_dir/ -type f -name \"*.cpp\" -print0 |xargs -0 wc -l\n\n# sort 排序\n\n-n 按数字进行排序\n-d 按字典序进行排序\n-r 逆序排序\n-k N 指定按照第 N 列排序\nsort -nrk 1 data.txtsort -bd data // 忽略像空格之类的前导空白字符\nsort unsort.txt | uniq \u003e sorted.txt # 消除重复行\nsort unsort.txt | uniq -c # 统计各行在文件中出现的次数\nsort unsort.txt | uniq -d # 找出重复行# 用 tr 进行转换\n\n# cut 按列切分文本 cut -f2,4 filename\n# 截取文件的第 2 列和第 4 列 cut -f3 --complement filename #去文件除第 3 列的所有列 cut -f2 -d\";\" filename -d #指定定界符 cut -c1-5 file\n# 打印第一到 5 个字符 cut -c-2 file \n# 打印前 2 个字符# paste 按列拼接文本 paste file1 file2 -d \",\"\n\n# wc 统计行和字符的工具 wc -l file # 统计行数 wc -w file # 统计单词数 wc -c file # 统计字符数\n\n# sed 文本替换利器 sed 's/text/replace_text/' file \n# 首处替换 sed 's/text/replace_text/g' file \n# 全局替换 sed -i 's/text/repalce_text/g' file # 替换文件 sed '/^$/d' file \n# 移除空白行 sed -i 's/twocucao/micheal/g' xx.dump.sqlsed -n 634428,887831p insert_doc_ids_new.sql \u003e uninserted_sql.sql\n```\n\n### 用户篇\n\n```bash\n# 添加 yaweb 为 sudo 用户\nusermod -aG sudo yaweb\n所有用户和用户组信息保存在：/etc/passwd , /etc/group\n用户\nuseradd -m yaweb # 创建相关账号，和用户目录 /home/yawebpasswd yawebuserdel -r yaweb # 删除\n用户组\nusermod -g groupName username # 变更组 usermod -G groupName username # 添加到组 usermod -aG sudo yaweb # 添加 yaweb 到 sudo 组\n用户权限\nchown userMark(+|-)PermissionsMark\nuserMark 取值： - u：用户 - g：组 - o：其它用户 - a：所有用户\nPermissionsMark 取值： - r: 读 - w：写 - x：执行\nchmod a+x main         对所有用户给文件 main 增加可执行权限 chmod g+w blogs        对组用户给文件 blogs 增加可写权限 chown -R weber server/\n远程登录\nssh -l root 192.168.2.253\nssh-copy-id root@192.168.2.253\n```\n\n### 网络篇\n\n```bash\n/etc/hostname\n/etc/hosts\nnetstat -a\n```\n\n### 磁盘篇\n\n```bash\n# 查看当前目录大小\ndu -sh\ndu -sh `ls` | sort\n# 查看当前目录的下一级文件和子目录的磁盘容量\ndu -lh --max-depth=1\n```\n\n### 进程管理\n\n```bash\nps -ef | grep twocucao ps -lu twocucao # 完整显示\nps -ajx\nps au | grep phantomjs | awk '{ print $2 }' | xargs kill -9 \ntop htop \nlsof -i:3306\nlsof -u twocucao \nkill -9 pidnum \n# 将用户 colin115 下的所有进程名以 av_开头的进程终止\nps -u colin115 |  awk '/av_/ {print \"kill -9 \" $1}' | sh\n# 将用户 colin115 下所有进程名中包含 HOST 的进程终止：\nps -fe | grep colin115 | grep HOST | awk '{print $2}' | xargs kill -9;\n```\n\nSystemd\n创建一个 Systemd 服务\n\n```\n# /etc/systemd/system/gunicorn.service: \n\n[Unit]\nDescription=gunicorn daemon\nRequires=gunicorn.socket\nAfter=network.target \n\n[Service]\nPIDFile=/run/gunicorn/pid\nUser=someuser\nGroup=someuser\nRuntimeDirectory=gunicorn\nWorkingDirectory=/home/someuser/applicationroot\nExecStart=/usr/bin/gunicorn --pid /run/gunicorn/pid  \n\\\\           --bind unix:/run/gunicorn/socket applicationname.wsgi\nExecReload=/bin/kill -s HUP $MAINPID\nExecStop=/bin/kill -s TERM $MAINPID PrivateTmp=true \n\n[Install]\nWantedBy=multi-user.target\n```\n\n### 性能监控\n\n### 内存瓶颈\n\n```\nhtop\nfree # 从 /proc/meminfo 读取数据\nIO 瓶颈\n# ubuntu 下 可以 mac 下不可以 iostat -d -x -k 1 1\n如果 %iowait 的值过高，表示硬盘存在 I/O 瓶颈。\n如果 %util 接近 100%，说明产生的 I/O 请求太多，I/O 系统已经满负荷，该磁盘可能存在瓶颈。\n如果 svctm 比较接近 await，说明 I/O 几乎没有等待时间；\n如果 await 远大于 svctm，说明 I/O 队列太长，io 响应太慢，则需要进行必要优化。\n如果 avgqu-sz 比较大，也表示有大量 io 在等待。\n```\n\n## 0x06 资料推荐\n\n- 一个关于 Linux 命令的各种奇技的网站 http://www.commandlinefu.com/commands/browse\n- Linux 工具快速教程 http://linuxtools-rst.readthedocs.org/zh_CN/latest/index.html\n- 一个 Awesome List, https://github.com/jaywcjlove/linux-command\n- 命令行的艺术 https://github.com/jlevy/the-art-of-command-line\n- man command 需要好好研读，特别是 man bash 至少要研读几遍\n\n---\n\nChangeLog:\n\n- **2015-04-18** 初始化本文\n- **2018-08-28** 重修文字\n- **2020-10-24** 重修文字\n"}],"total":6},{"name":"2017-11","posts":[{"tags":["Python"],"path":"20171120_PythonClosureAndScopes.md","title":"Python 中的作用域准则","slug":"Python 中的作用域准则","date":"2017-11-20","category":"Python","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n因为最早用的是 Java 和 C#，写 Python 的时候自然也把 Python 作用域的想的和原有的一致。\n\nPython 的作用域变量遵循在大部分情况下是一致的，但也有例外的情况。\n\n本文着通过遇到的一个作用域的小问题来说说 Python 的作用域\n\n\u003c!-- more --\u003e\n\n## 0x01 作用域的几个实例\n\nPython 的作用域变量遵循在大部分情况下与其他语言一致，但也有例外的情况。比如：\n\n### 1.1 第一个例子\n\n作用域第一版代码如下\n\n```python\na = 1\nprint(a, id(a)) # 打印 1 4465620064\ndef func1():\n    print(a, id(a))\nfunc1()  # 打印 1 4465620064\n```\n\n作用域第一版对应字节码如下\n\n```\n  4           0 LOAD_GLOBAL              0 (print)\n              3 LOAD_GLOBAL              1 (a)\n              6 LOAD_GLOBAL              2 (id)\n              9 LOAD_GLOBAL              1 (a)\n             12 CALL_FUNCTION            1 (1 positional, 0 keyword pair)\n             15 CALL_FUNCTION            2 (2 positional, 0 keyword pair)\n             18 POP_TOP\n             19 LOAD_CONST               0 (None)\n             22 RETURN_VALUE\n```\n\n\u003e PS: 行 4 表示 代码行数 0 / 3 / 9 ... 不知道是啥，我就先管他叫做**条**吧 是 load global\n\u003e PPS: 注意条 3/6 LOAD_GLOBAL 为从全局变量中加载\n\n顺手附上本文需要着重理解的几个指令\n\n    LOAD_GLOBA          : Loads the global named co_names[namei] onto the stack.\n    LOAD_FAST(var_num)  : Pushes a reference to the local co_varnames[var_num] onto the stack.\n    STORE_FAST(var_num) : Stores TOS into the local co_varnames[var_num].\n\n这点似乎挺符合我们认知的，那么，再深一点呢？既然这个变量是可以 Load 进来的就可以修改咯？\n\n### 1.2 第二个例子\n\n然而并不是，我们看作用域第二版对应代码如下\n\n```python\na = 1\nprint(a, id(a)) # 打印 1 4465620064\ndef func2():\n    a = 2\n    print(a, id(a))\nfunc2() # 打印 2 4465620096\n```\n\n一看，WTF, 两个 a 内存值不一样。证明这两个变量是完全两个变量。\n\n作用域第二版对应字节码如下\n\n```\n  4           0 LOAD_CONST               1 (2)\n              3 STORE_FAST               0 (a)\n\n  5           6 LOAD_GLOBAL              0 (print)\n              9 LOAD_FAST                0 (a)\n             12 LOAD_GLOBAL              1 (id)\n             15 LOAD_FAST                0 (a)\n             18 CALL_FUNCTION            1 (1 positional, 0 keyword pair)\n             21 CALL_FUNCTION            2 (2 positional, 0 keyword pair)\n             24 POP_TOP\n             25 LOAD_CONST               0 (None)\n             28 RETURN_VALUE\n```\n\n\u003e 注意行 4 条 3 (STORE_FAST) 以及行 5 条 9/15 (LOAD_FAST)\n\n这说明了这里的 a 并不是 LOAD_GLOBAL 而来，而是从该函数的作用域 LOAD_FAST 而来。\n\n### 1.3 第三个例子\n\n那我们在函数体重修改一下 a 值看看。\n\n```python\na = 1\ndef func3():\n    print(a, id(a)) # 注释掉此行不影响结论\n    a += 1\n    print(a, id(a))\nfunc3() # 当调用到这里的时候 local variable 'a' referenced before assignment\n# 即 a += 1 =\u003e a = a + 1 这里的第二个 a 报错鸟\n```\n\n```\n  3           0 LOAD_GLOBAL              0 (print)\n              3 LOAD_FAST                0 (a)\n              6 CALL_FUNCTION            1 (1 positional, 0 keyword pair)\n              9 POP_TOP\n\n  4          10 LOAD_FAST                0 (a)\n             13 LOAD_CONST               1 (1)\n             16 BINARY_ADD\n             17 STORE_FAST               0 (a)\n\n  5          20 LOAD_GLOBAL              0 (print)\n             23 LOAD_FAST                0 (a)\n             26 CALL_FUNCTION            1 (1 positional, 0 keyword pair)\n             29 POP_TOP\n             30 LOAD_CONST               0 (None)\n             33 RETURN_VALUE\n```\n\n那么，func3 也就自然而言由于没有无法 LOAD_FAST 对应的 a 变量，则报了引用错误。\n\n然后问题来了，a 为基本类型的时候是这样的。如果引用类型呢？我们直接仿照 func3 的实例把 a 改成 list 类型。如下\n\n### 1.4 第四个例子\n\n```python\na = [1]\ndef func4():\n    print(a, id(a)) # 这条注不注释掉都一样\n    a += 1 # 这里我故意写错 按理来说应该是 a.append(1)\n    print(a, id(a))\nfunc4()\n\n# 当调用到这里的时候 local variable 'a' referenced before assignment\n```\n\n╮(╯▽╰)╭ 看来事情那么简单，结果变量 a 依旧是无法修改。\n\n可按理来说跟应该报下面的错误呀\n\n```\n'int' object is not iterable\n```\n\n### 1.5 第五个例子\n\n```python\na = [1]\ndef func5():\n    print(a, id(a))\n    a.append(1)\n    print(a, id(a))\nfunc5()\n# [1] 4500243208\n# [1, 1] 4500243208\n```\n\n这下可以修改了。看一下字节码。\n\n```\n  3           0 LOAD_GLOBAL              0 (print)\n              3 LOAD_GLOBAL              1 (a)\n              6 LOAD_GLOBAL              2 (id)\n              9 LOAD_GLOBAL              1 (a)\n             12 CALL_FUNCTION            1 (1 positional, 0 keyword pair)\n             15 CALL_FUNCTION            2 (2 positional, 0 keyword pair)\n             18 POP_TOP\n\n  4          19 LOAD_GLOBAL              1 (a)\n             22 LOAD_ATTR                3 (append)\n             25 LOAD_CONST               1 (1)\n             28 CALL_FUNCTION            1 (1 positional, 0 keyword pair)\n             31 POP_TOP\n\n  5          32 LOAD_GLOBAL              0 (print)\n             35 LOAD_GLOBAL              1 (a)\n             38 LOAD_GLOBAL              2 (id)\n             41 LOAD_GLOBAL              1 (a)\n             44 CALL_FUNCTION            1 (1 positional, 0 keyword pair)\n             47 CALL_FUNCTION            2 (2 positional, 0 keyword pair)\n             50 POP_TOP\n             51 LOAD_CONST               0 (None)\n             54 RETURN_VALUE\n```\n\n从全局拿来 a 变量，执行 append 方法。\n\n## 0x02 作用域准则以及本地赋值准则\n\n### 2.1 作用域准则\n\n看来这是解释器遵循了某种变量查找的法则，似乎就只能从原理上而不是在 CPython 的实现上解释这个问题了。\n\n查找了一些资料，发现 Python 解释器在依据 基于 LEGB 准则 （顺手吐槽一下不是 LGBT）\n\nLEGB 指的变量查找遵循\n\n- Local\n- Enclosing-function locals\n- Global\n- Built-In\n\nStackOverFlow 上 martineau 提供了一个不错的例子用来说明\n\n```python\nx = 100\nprint(\"1. Global x:\", x)\nclass Test(object):\n    y = x\n    print(\"2. Enclosed y:\", y)\n    x = x + 1\n    print(\"3. Enclosed x:\", x)\n\n    def method(self):\n        print(\"4. Enclosed self.x\", self.x)\n        print(\"5. Global x\", x)\n        try:\n            print(y)\n        except NameError as e:\n            print(\"6.\", e)\n\n    def method_local_ref(self):\n        try:\n            print(x)\n        except UnboundLocalError as e:\n            print(\"7.\", e)\n        x = 200 # causing 7 because has same name\n        print(\"8. Local x\", x)\n\ninst = Test()\ninst.method()\ninst.method_local_ref()\n```\n\n我们试着用变量查找准则去解释 **第一个例子** 的时候，是解释的通的。\n\n第二个例子，发现函数体内的 a 变量已经不是那个 a 变量了。要是按照这个查找原则的话，似乎有点说不通了。\n\n但当解释第三个例子的时候，就完全说不通了。\n\n```python\na = 1\ndef func3():\n    print(a, id(a)) # 注释掉此行不影响结论\n    a += 1\n    print(a, id(a))\nfunc3() # 当调用到这里的时候 local variable 'a' referenced before assignment\n# 即 a += 1 =\u003e a = a + 1 这里的第二个 a 报错鸟\n```\n\n按照我的猜想，这里的代码执行可能有两种情况：\n\n- 当代码执行到第三行的时候可能是向从 local 找 a, 发现没有，再找 Enclosing-function 发现没有，最后应该在 Global 里面找到才是。注释掉第三行的时候也是同理。\n- 当代码执行到第三行的时候可能是向下从 local 找 a, 发现有，然后代码执行，结束。\n\n但如果真的和我的想法接近的话，这两种情况都可以执行，除了变量作用域之外还是有一些其他的考量。我把这个叫做**本地赋值准则** （拍脑袋起的名称）\n\n一般我们管这种考量叫做 ~~Python 作者就是觉得这种编码方式好你爱写不写~~ Python 作者对于变量作用域的权衡。\n\n事实上，当解释器编译函数体为字节码的时候，如果是一个赋值操作 (list.append 之流不是赋值操作），则会被限定这个变量认为是一个 local 变量。如果在 local 中找不到，并不向上查找，就报引用错误。\n\n    这不是 BUG\n    这不是 BUG\n    这不是 BUG\n\n这是一种设计权衡 Python 认为 虽然不强求强制声明类型，但假定被赋值的变量是一个 Local 变量。这样减少避免动态语言比如 JavaScript 动不动就修改掉了全局变量的坑。\n\n这也就解释了第四个例子中赋值操作报错，以及第五个例子 append 为什么可以正常执行。\n\n如果我偏要勉强呢？ 可以通过 global 和 nonlocal 来 引入模块级变量 or 上一级变量。\n\n\u003e PS: JS 也开始使用 let 进行声明，小箭头函数内部赋值查找变量也是向上查找。\n\n## 0xEE 参考链接\n\n- [Martineau 的例子](https://stackoverflow.com/questions/291978/short-description-of-the-scoping-rules)\n\n---\n\nChangeLog:\n\n- **2017-11-20** 从原有笔记中抽取本文整理而成\n"}],"total":1},{"name":"2017-10","posts":[{"tags":["macOS"],"path":"20171007_ElegantMac.md","title":"如何优雅地使用 macOS","slug":"如何优雅地使用 macOS","date":"2017-10-07","category":"善用佳软","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n# 如何优雅的使用 macOS\n\n## 0x01 macOS 系统操作\n\n### 快捷键\n\n```bash\n- cmd 为 command 按键，通常情况下为所有桌面程序通用性的快捷键。\n- ctrl ，通常情况下是针对程序的功能进行加强，并且此功能往往是非 cmd 类（窗口操作，选择，复制粘贴等等）操作。\n- shift 按键通常用于加强操作。一般会让操作更进一步 or 相反操作。\n\n- cmd+tab =~ alt+tab 程序之间的切换\n- cmd+\\` 应用内窗口切换\n\n- cmd+h 窗口 hide\n- cmd+m 窗口 minimize\n- cmd+n 新建窗口\n- cmd+o 打开\n- cmd+s 保存\n- cmd+shift+s 另存为\n- cmd+p 打印 print\n- cmd+w 关闭\n- cmd+q quit\n\n- cmd+a select all\n- cmd+i show info\n- cmd+n create a new folder\n- cmd+f search\n- cmd+c copy\n- cmd+v paste\n- cmd+delete  删除选中文件\n- cmd+shift+delete 清空回收站\n\n- cmd+= 放大\n- cmd+- 缩小\n- cmd+t 新建选项卡\n- cmd+r 刷新\n\n- cmd+shift+3 截取整个屏幕\n- cmd+shift+4 截取选择区域\n- cmd+shift+4+SPACE 截取选择窗口\n- cmd+ 鼠标点击 -\u003e 选中不连续文件\n- control+ 鼠标点击 -\u003e 相当于 win 中右键点击\n\n- fn+left home\n- fn+right end\n- fn+up pageup\n- fn+down pagedown\n```\n\n### 触摸板\n\n```bash\n- 单指点击 - 单击\n- 单指滑动 - 滑动鼠标光标\n- 双指点击 - 相当于 Windows 的鼠标右键\n- 三指点击 - 划词查找\n\n- 双指上下滑动 - 滚动\n- 双指缩放 - 与 Android 上图片缩放一致\n- 双指双击 - 只能缩放\n- 双指旋转 - 旋转\n- 双指左右滑动 - 应用内切换网页\n- 双指头从右往左\n- 三指头左右滑动 - 全屏幕 App 切换\n- 大拇指和食中无名缩放 - launchpad\n```\n\n## 0x02 日常软件\n\n- iTunes\n- iPhoto\n- SpotLight -\u003e Alfred 3\n\n- Google Chrome\n- Safari\n\n- QQ\n- WeXin\n\n- Adobe PhotoShop CC\n- Adobe PhotoShop LightRoom\n- Adobe After Effect\n- Final Cut Pro X\n- Pollar Photo Editor\n- Sketch\n- ScreenFlow\n- QuickTime\n- iQiyi\n- Snip Pro\n- NeteaseMusic\n- IINA\n- Axure\n- HandBrake\n\n- 欧陆词典\n- Calibre\n- Margin Note 3\n- PDF Expect\n- Microsoft Office\n- iWork 套件：包括 pages, numbers, keynote\n- XMind\n- Spark\n- TeamViewer 远程管理\n- OmniFocus\n\n- AppCleaner\n- CleanMyMac\n- VMWare\n- BetterZip\n- Amphetamine\n- PopClip\n- Paste\n\n### 0x03 开发者工具\n\n### 图形界面\n\n```bash\n- iTerm2\n\n- PyCharm\n- Intellij IDEA\n- WebStorm\n- Datagrip\n- VSCode\n- Vim/NeoVim\n\n- SS QT\n- Charles\n- Wireshark\n- Github Desktop\n- QGIS\n\n- Dash\n```\n\n### 命令行\n\n    #!/bin/bash\n\n    if test ! $(which brew); then\n        echo \"Installing homebrew...\"\n        ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n    fi\n\n    # Shell Support\n    brew install bash\n    brew install bash-completion2\n    echo \"Adding the newly installed shell to the list of allowed shells\"\n    sudo bash -c 'echo /usr/local/bin/bash \u003e\u003e /etc/shells'\n    # chsh -s /usr/local/bin/bash\n    brew install zsh\n    sudo bash -c 'echo /usr/local/bin/zsh \u003e\u003e /etc/shells'\n    chsh -s /usr/local/bin/zsh\n    brew install fish\n    sudo bash -c 'echo /usr/local/bin/fish \u003e\u003e /etc/shells'\n    # chsh -s /usr/local/bin/fish\n\n\u003e 注意：MAC 中存在一些独占的命令\n\n```\nopen\npbcopy\npbpaste\nscreencapture\nlaunchctl\nmdfind（还是 linux 的 find 好用）\nsip （还是比较推荐 imagemagic)\n```\n\n\u003e 注意：MAC 使用的大多命令来自于 FreeBSD , 并不是来自 GNU , 所以很多命令会与常规的 linux 命令不太一样。 所以，Shell 命令请在安装完 Gnu 的工具集之后，可以到我的文章 Shell CheatSheat 查看语法。\n\n```bash\nbrew install diffutils\nbrew install binutils\nbrew install moreutils\nbrew install findutils\nbrew install gnu-sed\nbrew install ed\nbrew install findutils\nbrew install gnu-indent\nbrew install gnu-sed\nbrew install gnu-tar\nbrew install gnu-which\nbrew install grep\n\n# aerial 屏保\n# https://github.com/JohnCoates/Aerial\nbrew cask install aerial\n# https://github.com/sindresorhus/quick-look-plugins\nbrew cask install qlcolorcode qlstephen qlmarkdown quicklook-json qlprettypatch quicklook-csv betterzipql qlimagesize webpquicklook suspicious-package quicklookase qlvideo\nbrew cask install keycastr\n```\n\n另起终端\n\n有时候 /usr/local 的可能会存在权限问题，建议如果可能出现问题，则需要执行下面的命令修复权限。\n\n```bash\nsudo chown -R $(whoami):admin /usr/local/\n```\n\n## 0x03 编程环境\n\n---\n\n### Python\n\n    brew install python@2 python\n\n### NodeJS\n\n```bash\n# ~/.npmrc\nchromedriver_cdnurl=http://cdn.npm.taobao.org/dist/chromedriver\noperadriver_cdnurl=http://cdn.npm.taobao.org/dist/operadriver\nphantomjs_cdnurl=http://cdn.npm.taobao.org/dist/phantomjs\nfse_binary_host_mirror=https://npm.taobao.org/mirrors/fsevents\nsass_binary_site=http://cdn.npm.taobao.org/dist/node-sass\nelectron_mirror=http://cdn.npm.taobao.org/dist/electron/\n\nregistry=https://registry.npm.taobao.org\ndisturl=https://npm.taobao.org/dist\nchromedriver-cdnurl=https://npm.taobao.org/mirrors/chromedriver\ncouchbase-binary-host-mirror=https://npm.taobao.org/mirrors/couchbase/v{version}\ndebug-binary-host-mirror=https://npm.taobao.org/mirrors/node-inspector\nelectron-mirror=https://npm.taobao.org/mirrors/electron/\nflow-bin-binary-host-mirror=https://npm.taobao.org/mirrors/flow/v\nfse-binary-host-mirror=https://npm.taobao.org/mirrors/fsevents\nfuse-bindings-binary-host-mirror=https://npm.taobao.org/mirrors/fuse-bindings/v{version}\ngit4win-mirror=https://npm.taobao.org/mirrors/git-for-windows\ngl-binary-host-mirror=https://npm.taobao.org/mirrors/gl/v{version}\ngrpc-node-binary-host-mirror=https://npm.taobao.org/mirrors\nhackrf-binary-host-mirror=https://npm.taobao.org/mirrors/hackrf/v{version}\nleveldown-binary-host-mirror=https://npm.taobao.org/mirrors/leveldown/v{version}\nleveldown-hyper-binary-host-mirror=https://npm.taobao.org/mirrors/leveldown-hyper/v{version}\nmknod-binary-host-mirror=https://npm.taobao.org/mirrors/mknod/v{version}\nnode-sqlite3-binary-host-mirror=https://npm.taobao.org/mirrors\nnode-tk5-binary-host-mirror=https://npm.taobao.org/mirrors/node-tk5/v{version}\nnodegit-binary-host-mirror=https://npm.taobao.org/mirrors/nodegit/v{version}/\noperadriver-cdnurl=https://npm.taobao.org/mirrors/operadriver\nphantomjs-cdnurl=https://npm.taobao.org/mirrors/phantomjs\nprofiler-binary-host-mirror=https://npm.taobao.org/mirrors/node-inspector/\npuppeteer-download-host=https://npm.taobao.org/mirrors\npython-mirror=https://npm.taobao.org/mirrors/python\nrabin-binary-host-mirror=https://npm.taobao.org/mirrors/rabin/v{version}\nsass-binary-site=https://npm.taobao.org/mirrors/node-sass\nsodium-prebuilt-binary-host-mirror=https://npm.taobao.org/mirrors/sodium-prebuilt/v{version}\nsqlite3-binary-site=https://npm.taobao.org/mirrors/sqlite3\nutf-8-validate-binary-host-mirror=https://npm.taobao.org/mirrors/utf-8-validate/v{version}\nutp-native-binary-host-mirror=https://npm.taobao.org/mirrors/utp-native/v{version}\nzmq-prebuilt-binary-host-mirror=https://npm.taobao.org/mirrors/zmq-prebuilt/v{version}\ncypress_download_mirror=https://npm.taobao.org/mirrors/cypress{version}\n\n```\n\n## 0x04 剪辑环境\n\n---\n\n## 0xDD mac 系统踩坑集\n\n---\n\n这里记录 mac homebrew 之类的工具的踩坑集合\n\n### 本地 Socket 异常\n\n在 Python 中执行下面的代码的时候总是报错：\n\n```python\nip = socket.gethostbyname(socket.gethostname())\n# socket.gaierror:\n# [Errno 8] nodename nor servname provided, or not known\n\n```\n\n最后发现是因为设置主机名没有设置好\n\n```bash\nsudo scutil --set ComputerName \"macOS\"\nsudo scutil --set LocalHostName \"macOS\"\nsudo scutil --set HostName \"macOS\"\ndscacheutil -flushcache\n```\n\n### 常见编译问题解决思路\n\n```\n# 确保 xcode command line 是最新\nsoftwareupdate --all --install --force\n\n# 重新安装 xcode command line\nsudo rm -rf /Library/Developer/CommandLineTools\nsudo xcode-select --install\n\n# 如果还不能安装，建议到下面地址下载\nhttps://developer.apple.com/download/more/?=command%20line%20tools\n```\n\n## 0xEE. 扩展阅读\n\n---\n\n- [关于 Mac 我的回答](https://www.zhihu.com/question/30816866/answer/59415036)\n- [关于 Ubuntu 我的回答](https://www.zhihu.com/question/30816866/answer/59415036)\n- [关于 Win10 我的回答](https://www.zhihu.com/question/32129337/answer/59379401)\n\n---\n\nChangeLog:\n\n- **2020-10-31** 重修文字\n"}],"total":1},{"name":"2017-09","posts":[{"tags":["VueJS"],"path":"20170915_ReadingVueDocuments.md","title":"VueJS 文档阅读笔记","slug":"VueJS 文档阅读笔记","date":"2017-09-15","category":"前端开发","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x01 Essential\n\n### 1.1 The Vue Instance\n\n当 Vue 实例被创建时，添加所有在 Data 对象中的属性到 Reactivity System 中。\n\n\u003e 而创建之后添加赋值新属性，则不 Reactive\n\n而实例被创建之时，会自带前缀为 $ 的一系列属性和方法\n\n#### 1.1.1 内置方法和属性\n\n##### Instance Properties\n\nvm.$data\nvm.$props\nvm.$el\nvm.$options\nvm.$parent\nvm.$root\nvm.$children\nvm.$slots\nvm.$scopedSlots\nvm.$refs\nvm.$isServer\nvm.$attrs\nvm.$listeners\n\n\u003c!-- more --\u003e\n\n##### Instance Methods / Data\n\nvm.$watch\nvm.$set\nvm.$delete\n\n##### Instance Methods / Events\n\nvm.$on\nvm.$once\nvm.$off\nvm.$emit\n\n##### Instance Methods / Lifecycle\n\nvm.$mount\nvm.$forceUpdate\nvm.$nextTick\nvm.$destroy\n\n#### 1.1.2 生命周期\n\n![生命周期](https://vuejs.org/images/lifecycle.png)\n\n### 1.2 Template Syntax\n\nVueJS 编译 模板为 VirtualDOM render 函数，如果对 VirtualDom 非常熟悉的话，则可以使用\n\n#### 1.2.1 插值\n\n```\n# text\n{{ msg }}\n\u003cspan v-once\u003e {{ msg }} \u003cspan\u003e\n# raw html\n\u003cdiv v-html=\"rawHTML\"\u003e\u003c/div\u003e\n# attributes\n\u003cdiv v-bind:id=\"dynamicID\"\u003e\u003c/div\u003e\n# JS Expressions\n{{ number + 1 }}\n{{ ok ? 'YES' : 'NO' }}\n{{ message.split('').reverse().join('') }}\n\u003cdiv v-bind:id=\"'list-' + id\"\u003e\u003c/div\u003e\n```\n\n#### 1.2.2 指令\n\n- v-bind -\u003e :\n- v-on -\u003e @\n- v-on:submit.prevent=\"onSubmit\"\n\n### 1.3 Computed Properties and Watchers\n\n- 当使用 Computed 的时候，一旦其依赖的 reactive 的 data 发生变化之后，则其值发生变化。\n- 其实，可以在模板中调用方法，但只能在项目中。\n\n### 1.4 Class and Style Bindings\n\n#### 1.4.1 Object 语法\n\n```\n\u003cdiv class=\"static\"\n     :class=\"{ active: isActive, 'text-danger': hasError }\"\u003e\n\u003c/div\u003e\n```\n\n#### 1.4.2 Array 语法\n\n```\n\u003cdiv v-bind:class=\"[isActive ? activeClass : '', errorClass]\"\u003e\u003c/div\u003e\n```\n\n#### 1.4.3 组件\n\n```\n\u003cmy-component class=\"baz boo\"\u003e\u003c/my-component\u003e\n\n\u003cp  class=\"origin baz boo\"\u003e\n```\n\n### 1.5 Conditional Rendering\n\n```\n\u003ch1 v-if=\"ok\"\u003eYes\u003c/h1\u003e\n\n\u003ch1 v-if=\"ok\"\u003eYes\u003c/h1\u003e\n\u003ch1 v-else\u003eNo\u003c/h1\u003e\n\n\u003cdiv v-if=\"type === 'A'\"\u003e\n  A\n\u003c/div\u003e\n\u003cdiv v-else-if=\"type === 'B'\"\u003e\n  B\n\u003c/div\u003e\n\u003cdiv v-else-if=\"type === 'C'\"\u003e\n  C\n\u003c/div\u003e\n\u003cdiv v-else\u003e\n  Not A/B/C\n\u003c/div\u003e\n```\n\n- v-if 是否\n- v-for 优先级高于 v-if\n\n### 1.6 List Rendering\n\n对于数组\n\n```\n\u003cul id=\"example-2\"\u003e\n  \u003cli v-for=\"(item, index) in items\"\u003e\n    {{ parentMessage }} - {{ index }} - {{ item.message }}\n  \u003c/li\u003e\n\u003c/ul\u003e\n```\n\n对于对象\n\n```\n\u003cul id=\"example-2\"\u003e\n  \u003cli v-for=\"(item, index) in items\"\u003e\n    {{ parentMessage }} - {{ index }} - {{ item.message }}\n  \u003c/li\u003e\n\u003c/ul\u003e\n```\n\n#### 1.6.1 ARRAY 修改检测\n\n##### 方法\n\n- push()\n- pop()\n- shift()\n- unshift()\n- splice()\n- sort()\n- reverse()\n\n##### 取代数组\n\nfilter\n\n##### 警告\n\n```html\n直接通过 index 对数组进行修改 不应该 vm.items[indexOfItem] = newValue 应该 //\nVue.set Vue.set(example1.items, indexOfItem, newValue) // Array.prototype.splice\nexample1.items.splice(indexOfItem, 1, newValue) 修改 length 不该 vm.items.length\n= newLength 应该 example1.items.splice(newLength)\n```\n\n\u003e 猜测背后可能是因为这种方式是无法监测设置\n\n#### 1.6.2 Object 修改检测警告\n\n```javascript\njs 无法直接提供对\n\nthis.$set(this.userProfile, 'age', 27)\n```\n\n### 1.7 Event Handling\n\n#### 1.7.1 Listening to Events\n\n```html\n\u003cdiv id=\"example-1\"\u003e\n  \u003cbutton v-on:click=\"counter += 1\"\u003eAdd 1\u003c/button\u003e\n  \u003cp\u003eThe button above has been clicked {{ counter }} times.\u003c/p\u003e\n\u003c/div\u003e\n```\n\nPS: 注意，前面 v-on v-bind 所有的绑定可以绑在方法上，也可以直接填单行表达式。可以提高可阅读性\n\n#### 1.7.2 Method Event Handlers\n\n可以绑定方法\n\n#### 1.7.3 Methods in Inline Handlers\n\n可以绑定方法加参数，配合 for / if\n\n#### 1.7.4 Event Modifiers\n\n事件修饰符\n\n```javascript\n.stop\n.prevent\n.capture\n.self\n.once\n```\n\n```html\n\u003c!-- the click event's propagation will be stopped --\u003e\n\u003ca v-on:click.stop=\"doThis\"\u003e\u003c/a\u003e\n\u003c!-- the submit event will no longer reload the page --\u003e\n\u003cform v-on:submit.prevent=\"onSubmit\"\u003e\u003c/form\u003e\n\u003c!-- modifiers can be chained --\u003e\n\u003ca v-on:click.stop.prevent=\"doThat\"\u003e\u003c/a\u003e\n\u003c!-- just the modifier --\u003e\n\u003cform v-on:submit.prevent\u003e\u003c/form\u003e\n\u003c!-- use capture mode when adding the event listener --\u003e\n\u003c!-- i.e. an event targeting an inner element is handled here before being handled by that element --\u003e\n\u003cdiv v-on:click.capture=\"doThis\"\u003e...\u003c/div\u003e\n\u003c!-- only trigger handler if event.target is the element itself --\u003e\n\u003c!-- i.e. not from a child element --\u003e\n\u003cdiv v-on:click.self=\"doThat\"\u003e...\u003c/div\u003e\n```\n\n#### 1.7.5 Key Modifiers\n\n```javascript\n.enter\n.tab\n.delete (captures both “Delete” and “Backspace” keys)\n.esc\n.space\n.up\n.down\n.left\n.right\n```\n\n```html\n\u003c!-- same as above --\u003e\n\u003cinput v-on:keyup.enter=\"submit\" /\u003e\n\u003c!-- also works for shorthand --\u003e\n\u003cinput @keyup.enter=\"submit\" /\u003e\n```\n\n#### 1.7.6 System Modifier Keys\n\n键盘\n\n```\n.ctrl\n.alt\n.shift\n.meta\n```\n\n```\n\u003c!-- Alt + C --\u003e\n\u003cinput @keyup.alt.67=\"clear\"\u003e\n\u003c!-- Ctrl + Click --\u003e\n\u003cdiv @click.ctrl=\"doSomething\"\u003eDo something\u003c/div\u003e\n```\n\n鼠标\n\n```\n.left\n.right\n.middle\n```\n\n#### 1.7.7 Why Listeners in HTML?\n\n在以往的开发中，直接写在 html 的 onclick 是很糟糕的方式，因为这违反了局部变量准则。将 onclick 变量提升为整个页面很容易导致，页面内部组织混乱。\n\n而 v-on 则仅执行 viewmodel 的方法，不会绑定到其他方法里。\n\n### 1.8 Form Input Bindings\n\nhttps://vuejs.org/v2/guide/forms.html\n\n对于每个 Form 空间，可以进行一定的封装。\n\n比如拖拽上传啦，比如 RadioGroup 啦等等。通过封装，可以进行相关的分析。\n\n### 1.9 Components\n\nUsing Components\nGlobal Registration\nLocal Registration\nDOM Template Parsing Caveats\ndata Must Be a Function\nComposing Components\nProps\nPassing Data with Props\ncamelCase vs. kebab-case\nDynamic Props\nLiteral vs. Dynamic\nOne-Way Data Flow\nProp Validation\nNon-Prop Attributes\nReplacing/Merging with Existing Attributes\nCustom Events\nUsing v-on with Custom Events\nBinding Native Events to Components\n.sync Modifier\nForm Input Components using Custom Events\nCustomizing Component v-model\nNon Parent-Child Communication\nContent Distribution with Slots\nCompilation Scope\nSingle Slot\nNamed Slots\nScoped Slots\nDynamic Components\nkeep-alive\nMisc\nAuthoring Reusable Components\nChild Component Refs\nAsync Components\nAdvanced Async Components\nComponent Naming Conventions\nRecursive Components\nCircular References Between Components\nInline Templates\nX-Templates\nCheap Static Components with v-once\n\n### 总结\n\n组件化是 Vue 模块化组织前端网页的方式。\n\nVue 的组件化，将模板，JavaScript 与样式放在一起。出于代码的复用性：\n\n组件化可以给组件子组件们组织起来，起一个阅读性更好的名称，从而使得编写 Vue 组件更加语义化。\n\n- 如果模板是常用的组件，比如手风琴控件，Menu 控件，sidebar 控件\n\nVue 通过组件来组织代码，但糟糕的是并不是一切都可以被组件化\n\n## 0x02 Transitions \u0026 Animation\n\n### 2.1 Event Handling\n\n### 2.2 Event Handling\n\n## 0x03 Reusability \u0026 Composition\n\n## 0x04 Tooling\n\n## 0x05 Scaling Up\n\n## 0x06 Internals\n\n## 0x07 Vue 番外篇\n\n下面的内容从 Vue 作者的知乎 Live 上取来。\n\n### 阅读源码的建议\n\nhttp://hcysun.me/2017/03/03/Vue 源码学习 /\n\n### 框架背后的要解决的原理\n\n组件为基本单元\n\n页面 -\u003e应用（模块，组件树（偏展示））\n\n- 接入型 container\n- 展示型\n- 交互型 比如各类加强版的表单组件，通常强调复用\n- 功能型 比如 `\u003crouter-view\u003e`，`\u003ctransition\u003e`，作为一种扩展、抽象机制存在。\n\nview = render(state)\n\n- 命令式 (jquery)\n- 声明式\n\n### Virtual Dom\n\n### 变化侦测和渲染机制\n\npush pull\n\nvue 混合式\n\n### 状态管理\n\n## 0xEE TODO TO LIST\n\n---\n\nChangeLog:\n\n- **2017-09-15** 初始化本文\n"}],"total":1},{"name":"2017-08","posts":[{"tags":["Python"],"path":"20170804_RethinkingInPython.md","title":"ReThinking In Python","slug":"ReThinking In Python","date":"2017-08-04","category":"Python","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n本文诞生于利用 Topic Reading 方法读 Python 和 JavaScript 若干本技术书籍这个过程中结合自己的开发常见场景记录下来的一些笔记。\n\n## 0x01 Python 胡论\n\n### Why Python\n\n是要用一门编程语言无非是两种原因：\n\n- 这门技术很火，能挣钱\n- 写起来很舒服，开发效率高\n\n这也是我在涉猎了很多编程语言为什么选择了 Python 和 TypeScript 作为自己的主要技能树。\n\nPython 具备这两点，TS （更加准确的说是 JavaScript）具备前一点。\n\nPython 写起来真的特别舒服，语法简洁，第三方库丰富，而且也比较火。\n\n有什么东西比，写代码效率高、生态圈好还重要了。\n\n生态圈好，比如\n\n- Web 开发用 Django/Flask\n- 数据抓取用 Requests\n- 数据分析清洗用 Pandas\n- 机器学习 Tensorflow SCIPY\n\n\u003c!-- more --\u003e\n\n### 工具链\n\n[Pythonista 的工具集](./ch04/s03_Pythonista_的工具集.md)\n\n### 文档\n\n### 社区\n\n### 书籍\n\n## 0x02 基础概念\n\n### 2.1 数据类型\n\n#### 常量\n\n```\nFalse\nTrue\nNone\nNotImplemented\nElilipsis ...\n```\n\n##### 布尔\n\n布尔常量\n\n```\nNone\nFalse\n0 0.0 0j\n'' () []\n{}\n一个对象 __bool__() = False , 如果上一个为 True 则__len__()\n```\n\n布尔运算符\n\n```\nx or y\nx and y\nnot x\n```\n\n布尔比较值\n\n```\n# 可以定制\n\u003c \u003c= \u003e= \u003e == !=\n# 无法定制\nis / is not\n```\n\n##### 字符串\n\n五种 format 方式\n\n1. 古代 %\n2. 近代 format\n3. 现代 f 字符串\n4. 内置的 template\n5. jinja2 的模板\n\n#### 数字类型\n\n- int\n- float\n- complex\n\n##### 操作符\n\n```\n+ - * / // % -n +n abs() int() float()\ncomplex(re,im)\nc.conjugate()\ndivmod(x,y)\npow(x,y) x ** y\nmath.trunc(x)\nmath.round(x[,n])\nmath.floor(x) \u003c=x\nmath.ceil(x)  \u003e=x\n| ^ \u0026 \u003c\u003c \u003e\u003e ~x\n```\n\n注意\n\n```\n(-1) / 2 # -1\n1 / (-2) # -1\n```\n\n##### 数值哈希\n\n// TODO : 麻蛋居然没看懂 4.4.4. Hashing of numeric types\n\n#### 迭代器类型\n\n迭代器类型\n\n#### 序列类型\n\nC 实现的按照 item 是否为同一类型分为：\n\n- **Container sequences**: list, tuple, and collections.deque can hold items of different types.\n- **Flat sequences**: str, bytes, bytearray, memoryview, and array.array hold items of one type.\n\nC 实现按照 item 是否可修改分为：\n\n- **Mutable sequences**: list, bytearray, array.array, collections.deque, and memoryview\n- **Immutable sequences**: tuple, str, and bytes\n\n##### 通用序列操作\n\n```bash\nx in s\nx not in s\ns + t\ns * n 或者 n * s\ns[i]\ns[i:j]\ns[i:j:s]\nlen(s)\nmin(s)\nmax(s)\ns.index(x,i,j)\ns.count(x)\n// TODO 封装 deepEqual\n```\n\n切片\n\n为何 Slice 和 Range 会排除 最后一个 Item?\n\n书中讲的太复杂，其实这个和尺子是一个作用，尺子从 0 刻度开始，这样方便丈量。\n\n比如说：\n\n- items[0:10] 为 10 厘米\n- items[10] 为 10 刻度后一个单位，即 items[10:11]\n- items[2:] 为 2 刻度后面若干个单位\n- items[::3] 以三为单位，从 0 刻度开始，最后为结尾，每三个\n\n```python\na[i, j] # 调用 a.__getitem__((i, j))\n```\n\n##### 不可变序列\n\n- 解包赋值\n- 不要手贱加逗号\n- 下划线可以用作临时变量 （但是 django 中下划线用于中英文）\n\n```python\na, b, *rest = range(5) # (0, 1, [2, 3, 4])\na, b, *rest = range(3) # (0, 1, [2])\na, b, *rest = range(2) # (0, 1, [])\n\na, *body, c, d = range(5) # (0, [1, 2], 3, 4)\n*head, b, c, d = range(5) # ([0, 1], 2, 3, 4)\n```\n\n- namedtuple\n\n```python\nCity = namedtuple('City', 'name country population coordinates')\ntokyo = City('Tokyo', 'JP', 36.933, (35.689722, 139.691667))\ntokyo.population\ntokyo.coordinates\ntokyo[1]\nCity._fields # tuple\n```\n\n##### 可变序列\n\n```\ns[i] = x\ns[i:j] = t\ndel s[i:j]\ns[i:j:k] = t\ndel s[i:j:k]\ns.append(x)\ns.clear()\ns.copy()\ns.extend(t) 或者 s += t\n\n```\n\n##### List Comprehensions and Generator Expressions\n\n```python\nnew_items = [func(a) for item in items]\nnew_items = [ str(x) for x in range(100) if x % 2 == 0]\nnew_items = list(map(str,list(filter(lambda x: x % 2 == 0 , list(range(100))))))\n# 可写成\nnew_items = list(map(str,filter(lambda x: x % 2 == 0 , range(100))))\n```\n\nlist 往往和 map filter 以及 listcomp 用于创建简单的序列\n\n##### 序列赋值\n\n```python\n对于不可变类型 赋值 l *= 2 在内存中则是创建了新的两个长度的元祖，然后赋值\n而由于字符串则需要注意，str_a += \"str b\" , 虽然为不可变变量，但并不需要拷贝整个字符串（特殊情况）, 但字符串的拼接建议还是\"\".join()\n\nt = (1, 2, [30, 40])\nt[2] += [50, 60]\n# 结果为既赋值成功，又报错\n# 但 t[2].extend([50, 60]) 可以赋值成功\nimport dis\ndis.dis('s[a] += b') # 可以查看字节码\n```\n\n1. 尽量不要在不可变变量内保存可变变量\n2. t[2] += [50,60] 并不是原子操作，因为，当做了一半的时候，抛出的错误。\n\n##### objs.sort 与 sorted()\n\n对于 sort 和 sorted 来说，reverse 代表 desc,key 为单参数用于计算每一个值的结果的函数。\nlist.sort 直接针对列表排序，并且返回 None（出于编程习惯的问题，直接返回 None 的函数大多是对程序有一定的修改）\n\n##### 二分搜索\n\n```python\nimport bisect\nbisect -\u003e bisect_right\nbisect_left\ninsort -\u003e insort_left\ninsort_right\n# 搜索可以用来划分档次\ndef grade(score, breakpoints=[60, 70, 80, 90], grades='FDCBA'):\n    i = bisect.bisect(breakpoints, score)\n    return grades[i]\n\n[grade(score) for score in [33, 99, 77, 70, 89, 90, 100]] # ['F', 'A', 'C', 'C', 'B', 'A', 'A']\n```\n\n##### 列表\n\nlist 是一种 mix-typed 的数据结构，即可以存放不同种类型的数据结构，由此带来的问题自然是性能问题：\n\n- list 第一是 mix-typed 的数据结构\n- 动态数组，并非数组\n\n当考虑性能的时候，则需要考虑是不是要换一个更好的数据结构：\n\n- 适用于类型单一的 array\n- 增删比较多，或者需要使用 FIFO,LIFO, 则使用 deque (double-ended queue)\n\n```python\n# Arrays\nfloats = array('d', (random() for i in range(10**7)))\n# NumPy and SciPy\n\n# Deques and Other Queue\n```\n\n##### Queue 与 Deque\n\n- Deque\n- queue 线程安全 Queue, LifoQueue, and PriorityQueue\n- multiprocessing Queue 和 JoinableQueue\n- asyncio Queue, LifoQueue, PriorityQueue, and JoinableQueue\n\n### 2.2 语句\n\n语句\n\n### 2.3 函数\n\n#### 参数\n\n#### 闭包与作用域\n\n本部分具备一定文字量，故单独抽取出来到文章，请参考 Python 中的闭包和作用域。\n\n#### 高阶函数\n\n- map\n- reduce\n- filter\n\n#### 特殊方法\n\n```python\nobj.__len__()\nlen()\n\nobj.__\n```\n\n对于内置类型 (list, str , bytearray) 解释器在调用特殊方法的时候调用 C 库，比如 CPython 实现的 len 方法一般直接会调用 PyVarObject C Struct ob_size\n\n特殊方法往往并不是显示调用，而是被隐式调用。比如 init 在 new 中的作用，比如 for item in items 世界上会调用 iter(items), 这也会隐式调用 items.**iter**() .\n\n一般当大量使用特殊方法的时候，都是在进行元编程。\n\n```python\nbool(x) 先调用 x.__bool__() , 如果 x.__bool__() 没有实现，则调用 x.__len__(), 如果为 0 则返回 False\nsorted(arr) 可以直接返回 arr，arr.sort() 是排序内部。\n```\n\n特殊方法名 （有操作符）\n\n| 种类                            | 方法名                                             |\n| ------------------------------- | -------------------------------------------------- |\n| String/Bytes                    | repr , str , format , bytes                        |\n| Conversion to number            | abs , bool , complex , init , float , hash , index |\n| Emulating collections           | len , getitem , setitem , delitem , contains       |\n| Iteration                       | iter, reversed , next                              |\n| Emulating callables             | call                                               |\n| Context management              | enter, exit                                        |\n| Instance creation \u0026 destruction | new , init , del                                   |\n| Attribute management            | getattr , getattribute , setattr , delattr, dir    |\n| Attribute descriptors           | get , set ,delete                                  |\n| Class service                   | prepare , instancecheck , subclasscheck            |\n\n特殊方法名 （无操作符）\n\n| 种类                           | 方法名                                                              |\n| ------------------------------ | ------------------------------------------------------------------- |\n| Unary numeric operators        | neg , pos , abs                                                     |\n| Rich comparison operators      | lt , le , eq , ne , gt , ge                                         |\n| Arithmetic operators           | add ,sub , mul ,truediv ,floordiv ,mod , divmod , pow , round round |\n| Reversed arithmetic operators  | radd , rsub , rmul , rtruediv, rfloordiv , rmod , rdivmod, rpow     |\n| Augmented assignment mathmatic | iadd , isub , imul , itruediv, ifloordiv                            |\n| Bitwise operators              | invert , lshift , rshift , and , or                                 |\n| Reversed bitwise operators     | rlshift , rrshift , rand , rxor , ror                               |\n| Augmented assignment bitwise   | ilshift , irshift , iand , ixor , ior                               |\n\nWhy len Is Not a Method\n\n```python\n因为对 不同类型并不是一定调用 __len__ , 对于基本类型查看 c struct 中长度，对于其他类型直接调用 __len__ , 这种区分对待\n```\n\n### 2.4 生成器\n\n```python\ndef gen():\n    yield 1\n    yield 2\n    yield 3\n    # 这里为了省事，标记 123, 但是一般会有个循环，或者多个循环\n\ngen # \u003cfunction __main__.gen\u003e\n# 显式调用，返回方法对象\ng = gen() # \u003cgenerator object gen at 0x10ec23dc0\u003e\nnext(g)\nnext(g)\nnext(g)\nnext(g) # 执行到结尾部分或者其他报错 StopIteration\n\nfor i in gen():\n    print(i)\n```\n\n生成器的作用就在于将遍历 lazy 化。嗯？其实编写代码的时候完全不中写生成器也可以 lazy 化很多操作。\n\n需要注意的是，generator 后面支持了一个方法叫做 send(), 是 next() 的升级版本。将原来的数据的单向流通变成了双向流通。\n\n见 [协程](#423-协程)\n\n## 0x03 中级概念\n\n### 类和对象\n\n包含元编程\n\n### 模块与包\n\n#### 单下划线与双下划线\n\n```\n前缀单下划线 _var # 在类中被认为是私有变量，在模块中可以通过 amodule._func() 来使用，但是没有办法 from xx.amodule import * 然后调用。\n后缀单下划线 var_ # 一般用于表示被占用的关键字 比如 default_ int_ class_ object_\n前缀双下划线 __var # 放在类中的话，实例化的时候会被转成'_A__size', 这个解释器进行的操作叫做 name mangling\n\nIn [13]: class A:\n    ...:     def __init__(self):\n    ...:         self.__eq__ = 2\n    ...:         self.__size = 34\n    ...:         self.__size__ = 44\n\n前后双下划线 __var__\n单下划线 _\n```\n\n### 错误 / 调试测试\n\n### IO 编程\n\n### 正则表达式\n\n```python\n. ^ $ * + ? { } [ ] \\ | ( )\n\nRegular String\n\n\"ab*\"\n\"\\\\\\\\section\"\n\"\\\\w+\\\\s+\\\\1\"\n\nRaw string\n\nr\"ab*\"\nr\"\\\\section\"\nr\"\\w+\\s+\\1\"\n```\n\n## 0x04 高级概念\n\n### 元编程\n\n#### 装饰器\n\n```\nenforcing access control and authentication\ninstrumentation and timing functions\nrate-limiting\ncaching, and more”\n```\n\n#### Dynamic Attributes and Properties\n\n```python\nobj.attr\n\n重写__getattr__\n\n// TODO: 什么时候完成 python 的 DICT 以及 JSON 的相等？\n\naccessor?\n__new__ 是一个 class method, 但是并没有 xxx\n\nx = Foo('a')\n\ndef object_maker(the_class, some_arg):\n    new_object = the_class.__new__(some_arg)\n    if isinstance(new_object, the_class):\n        the_class.__init__(new_object, some_arg)\n    return new_object\n\nx = object_maker(Foo,'a')\n```\n\n#### Attributes Descriptors\n\n```python\n@property\n\n__class__ # 接近 type()\n__dict__\n__slot__\n\ndir(obj) # 与__dict__接近\ngetattr\nsetattr\nhasattr\n\n```\n\n#### Class MetaProgramming\n\n### 并发编程\n\n#### GIL - Global Interpreter Lock\n\n并不是所有的解释器语言都有 GIL （尽管 Python 和 Ruby 里面都有）, 也并不是没有尝试过去除 GIL, 但是每次去除都会导致单线程性能的下降。所以暂时保留。\n\nGIL 对程序中的影响：\n\n\u003e 一个线程运行 Python , 而其他 N 个睡眠或者等待 I/O - **同一时刻只有一个线程对共享资源进行存取** , Python 线程也可以等待 threading.Lock 或者线程模块中的其他同步对象；\n\n##### 协同式多任务处理\n\n如果有两个线程，同时进行 IO 请求，当其中一个线程连接之后，立即会**主动让出 GIL**, 其他线程就可以运行。\n\n\u003e 当 N 个线程在网络 I/O 堵塞，或等待重新获取 GIL，而一个线程运行 Python。\n\n让出之后还要执行代码呀，所以要有个收回 GIL 的动作。\n\n##### 抢占式多任务处理\n\nPython 2 GIL , 尝试收回 GIL 为 执行 1000 字节码。\nPython 3 GIL , 尝试收回 GIL 检测间隔为 15ms\n\n##### 线程安全\n\n原子操作：sort 之类不需要\n非原子操作：n=n+2 的字节码分为 加载 n , 加载 2 , 相加，存储 n, 四个步骤，由于不是原子性，很可能被由于 15 ms 而被打断。\n\n当然，懒人一向是 : **优先级不决加括号，线程不决加 lock**\n\n对于 Java, 程序员努力在尽可能短的时间内加锁存取共享数据，减轻线程的争夺，实现最大并行。但 Python 中，线程无法并行运行，细粒度的锁就没有了优势。\n\n#### 多线程\n\n\u003e Python 多线程约等于并发。\n\n#### 多进程\n\n#### 协程\n\nPython 中，协程在语法上接近于生成器（函数内包含 yield 关键字）.\n\n```python\n# 生成器\ndef g():\n    yield a\n    pass\n```\n\n```python\n# 协程\ndef c():\n    # b = yield a\n    b = yield\n    pass\n```\n\n协程在\n\n## 0x05 标准库与第三方库\n\n### 数据结构与算法\n\n### 字符串与文本\n\n### 数字日期与时间\n\n### 迭代器与生成器\n\n1. Introduction\n2. Built-in Functions\n3. Built-in Constants\n4. Built-in Types\n5. Built-in Exceptions\n6. Text Processing Services\n7. Binary Data Services\n8. Data Types\n9. Numeric and Mathematical Modules\n10. Functional Programming Modules\n11. File and Directory Access\n12. Data Persistence\n13. Data Compression and Archiving\n14. File Formats\n15. Cryptographic Services\n16. Generic Operating System Services\n17. Concurrent Execution\n18. Interprocess Communication and Networking\n19. Internet Data Handling\n20. Structured Markup Processing Tools\n21. Internet Protocols and Support\n22. Multimedia Services\n23. Internationalization\n24. Program Frameworks\n25. Graphical User Interfaces with Tk\n26. Development Tools\n27. Debugging and Profiling\n28. Software Packaging and Distribution\n29. Python Runtime Services\n30. Custom Python Interpreters\n31. Importing Modules\n32. Python Language Services\n33. Miscellaneous Services\n34. MS Windows Specific Services\n35. Unix Specific Services\n36. Superseded Modules\n37. Undocumented Modules\n\n## 0xAA 测试\n\n### 单元测试\n\n单元测试我只用 pytest\n\n1. 给对象打补丁\n2. 测试异常情况\n3. 测试输出到日志文件\n\n```\npytest --pdb\npytest --tb=long    # exhaustive, informative traceback formatting\n```\n\n## 0xBB 调试技巧\n\n### IPython\n\n### IPdb\n\n## 0xCC 优化技巧\n\n```\ncProfile\n```\n\n### 统计型优化\n\nhttps://github.com/what-studio/profiling\n\n## 0xDD 代码质量\n\n### 社区推崇的代码风格 Pythonic\n\n```\n    The Zen of Python, by Tim Peters\n\n    Beautiful is better than ugly.\n    Explicit is better than implicit.\n    Simple is better than complex.\n    Complex is better than complicated.\n    Flat is better than nested.\n    Sparse is better than dense.\n    Readability counts.\n    Special cases aren't special enough to break the rules.\n    Although practicality beats purity.\n    Errors should never pass silently.\n    Unless explicitly silenced.\n    In the face of ambiguity, refuse the temptation to guess.\n    There should be one-- and preferably only one --obvious way to do it.\n    Although that way may not be obvious at first unless you're Dutch.\n    Now is better than never.\n    Although never is often better than *right* now.\n    If the implementation is hard to explain, it's a bad idea.\n    If the implementation is easy to explain, it may be a good idea.\n    Namespaces are one honking great idea -- let's do more of those!\n```\n\n### Python 代码质量\n\n```\nhttps://github.com/ambv/black\n```\n\n#### 正确性\n\n- 外部**不该**引用 protected member （单下划线）\n- lambda 为一次使用，最好不要赋值。\n- 不要给 buildin 函数赋值\n- py3 直接 super()\n- for in else 如果不内置 break 则出会在最后 for in 为 empty 的时候再执行 else 中的语句\n- context exit 如果不 catch 掉异常让其自然向上一级抛出错误的话，必须为 (self, exception_type, exception_value, traceback):\n- 不要在 init 里面 return 数据\n- 不要混用 tab 和 space\n- 4 个 space 缩进\n- staticmethod 直接是 参数，classmethod 第一个参数为 cls\n- 可变的 default value 是不能作为 参数的。（可能是解释器在确定函数的定义的时候完成赋值？)\n- 遵循 exception hierachy https://docs.python.org/3/library/exceptions.html#exception-hierarchy\n- defaultdict defaultdict(lambda : 6) , 必须 callable\n- 尽量 unpack 赋值\n- 字典用获取用 get(\"myk\",None) , 赋值用 dictionary.setdefault(\"list\", []).append(\"list_item\")\n\n#### 可维护性\n\n- 避免使用 import \\* , 我觉得这点值得商榷 , 如果是某个模块下，完全可以先把模块拆分成多个，最后 import 进来，接着使用 all.\n- getxxx 获取实际值，如果不为实际值，返回 None 显然不如 try catch 来的实在。\n- 避免使用 global\n- 命名要注意\n- 动态创建方法 , 我觉得这点值得商榷。\n\n#### 可读性\n\n- 不要检查，如果可能有异常，尽量抛出异常来 trycatch 解决。\n- a is None , if flag\n- isinstance , not type(r) is types.ListType\n- \"{name}{city}\".format(\\*\\*info_dict)\n- for k , v in infodict.items()\n- 使用 poiinfo = namedtuple(\"poiinfo\",[\"name\",\"lng\",\"lat\"]) 返回 poiinfo['上海',121.00,23] 最后返回值打印 poi.name , poi.lng , poi lat\n- for numbers_value, letters_value in zip(numbers, letters):\n- enumerate\n- 如果能用 listcomp 则不使用 map 和 filter\n\n#### 性能\n\n- 用 set\n- d.iteritems() 比 items() 省内存\n\n## 0xEE 文章更新\n\n- **2017-05-11 19:43:00** : 增加代码质量模块\n- **2017-08-04 19:43:00** : 增加部分 Fluent Python 的笔记\n"}],"total":1},{"name":"2017-07","posts":[{"tags":["React"],"path":"20170726_ReactCheatSheet.md","title":"React CheatSheet","slug":"React CheatSheet","date":"2017-07-26","category":"前端开发","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00. 前言\n\n\u003e 备注：由于目前没有上 React 的打算，本文暂时太监\n\n之前一直使用 VueJS 进行开发，心血来潮想换换口味，于是就借着自己的一个开源的项目尝试一下 ReactJS , 代码分为两部分，如下：\n\n- 前台系统（支持 SSR) [YaReactBlog](https://github.com/twocucao/YaReactBlog)\n- 后台系统 [YaReactAdmin](https://github.com/twocucao/YaReactAdmin)\n\n```bash\n\nTODO:\n\n```\n\n\u003c!-- more --\u003e\n\n本文目录\n\n- 前端、单页与 React 开发\n- 官网的 Tutorial / Guide 要点\n- Dva 下使用 React JS 的要点\n\n## 0x00. 前端、单页与 React 开发\n\n### 0.1. 前端\n\n前端开发，是最近几年才出现的独立工种。\n\n在我的印象中，以前的人很少会区分前端和后端，现在的前端的职责往往是由后端的人顺手做掉的。当然，这种界面一般情况下都比较丑。\n\n后来，随着浏览器的功能越来越强大，性能越来越好，用户对于界面要求也就越来越高。甚至到后来，对于用户界面的操作的复杂程度要求也越来越高。 传统的后端渲染 Template + 简单的 Ajax 不能满足要求了。\n\n\u003e 要界面，要交互，要复杂\n\n于是便出现了单页应用。\n\n### 0.2. 单页\n\n单页完全可以当做一个性能不是很强的，运行在浏览器中的，使用 HTML CSS JS 来编写的小型客户端。\n\n写单页和写客户端基本一致的情况下，于是在这种情况下，前端开发在使用单页后，直接可以 Mock 数据，接着编写界面，接着调通页面的状态和操作，最后发布。\n\n### 0.3. ReactJS\n\n为什么选用 ReactJS 呢？\n\n个人认为，框架是用于改善代码组织的一种约束。\n\n不管是 Web 应用开发的早期的 HTML in PHP OR PHP in HTML, 还是中期的 MVC MTV, 还是后来的 富 AJAX 操作，还是现在的 SPA, 出现的各种框架无非就是为了解决代码组织的问题。\n\n对后端而言，后端 WEB 框架的设计，都是为了单个模块职责过重而出现的一种解决方案：\n\n- HTML IN PHP 拼接代码简单暴力，可是如果拼接太多，每个文件就很职责重，代码阅读性差，不方便调试，就显得很杂乱。\n- PHP in HTML 相比上一个解决方案好很多。可是，嵌入过多 PHP 代码，代码阅读性差，不方便调试，则会显得比较混乱。\n- MVC 与 MTV 把渲染的变量独立出来放到 Controller 中，然后把需要渲染的 HTML 模板放到 Template 中，并且在 Template 中来完成模板的拼接。最后调用 Render 进行渲染。是不是这样问题就解决了呢？不是，如果把业务逻辑放在 Model 层，则 Model 职责过重。那就必须要添加一个 Serivce 层来封装业务逻辑。是不是封装了一个\n\n如果业务逻辑简单到令人发指，HTML IN PHP 可以给人最大的灵活性。\n\n1. 尝试一下新技术。保持对技术的敏感性。\n2. React 是 FB 出的一套前端框架。大厂支持，不会轻易太监掉。\n3. 写了一段时间 VueJS 换换口味。\n\n当我们讨论一个框架的时候，除了基本的框架之外还必须要有大量的社区资源，那么对 React 而言，除了 ReactJS 之外，还有什么？\n\n```bash\n\n后台系统\n\n - ant.design\n\n打包构建\n\n - webpack\n\n路由和状态管理\n\n - react-router\n - react-router-redux\n - redux\n - redux-saga\n\n为了更好的管理路由和状态，还是使用 dva 来管理比较好。\n\n - [dva](https://github.com/dvajs/dva)\n - [dva-cli](https://github.com/dvajs/dva-cli)\n\n开发构建工具\n\n - [roadhog](https://github.com/sorrycc/roadhog)\n\n```\n\n## 0x01. 官网的 Tutorial / Guide\n\n官网的要点\n\n## 0x02. 在 dva 下，编写 React 组件的正确姿势\n\n编写 React 的时候，我选用了 dva 框架配合 ReactJS 来编写单页。\n\n参考 FB 的这篇教程后，梳理了我编写组件的步骤 https://facebook.github.io/react/docs/thinking-in-react.html :\n\n1. 先构思出原型 （或者拿到 UI 图）\n2. Mock 出假数据\n3. 分解页面 OR 组件为 组件树\n4. 编写静态组件树\n5. 确定最小表达 UI （加上满足要求的样式）\n6. 确定什么时候需要什么状态（网络请求，键盘输入，位置变化等等）\n7. 收尾美化\n8. 在发现问题的时候进行优化\n\n## 0x03. 在 dva 下，编写 React 组件的正确姿势\n\n---\n\nChangeLog:\n\n- **2017-07-17** 重修文字\n"},{"tags":["Python"],"path":"20170717_数据科学的常识笔记.md","title":"数据科学的常识笔记","slug":"数据科学的常识笔记","date":"2017-07-17","category":"数据分析","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n2017 年 07 月，为了解统计学和机器学习的基本常识，开了这篇文章。\n\n当然，仅仅是为了了解，所以也就写的随性（不严谨）一些，排版什么的也都详细推敲。想到哪里就记录到哪里。\n\n\u003c!-- more --\u003e\n\n## 0x01 数据科学的含义与内容\n\n### 0.1 WHAT?\n\n\u003e To gain insights into data through computation, statistics , and visualization.\n\nJosh Blumenstock 认为 数据科学家就是比计算机科学家多点统计技术，比统计学家多点计算机技术。\n\nShlomo Aragmon 认为 数据科学家 = 统计学家 + 程序员 + 教练 + 讲故事者 + 艺术家\n\n#### 一些准则\n\n- 多数据源\n- 懂得数据如何被采集\n- 对数据进行权重\n- 使用统计模型\n- 理解相关性\n- 像 Bayesian 一样思考，像 frequentist 一样检验\n- 良好的沟通能力（代表什么，如何可视化，检验，理解结论）\n\n#### 一些挑战\n\n- 数据量大\n- 高维诅咒\n- 数据缺失\n- 需要避免过度拟合 (test data vs. training data)\n\n#### Data Science 涉及到哪些领域呢？\n\n- Data Management\n- Data Mining\n- Machine Learning\n- Business Intelligence\n- Statistics\n- Decision Making Theory\n- Story Telling\n- Perception\n- Human Cognition\n\n### 0.2 WHY?\n\n海量数据的时代\n\n### 0.3 HOW?\n\n- **ASK** an interesting question. 目标是什么？如果拿到数据可以预测或者估计什么？\n- **GET** the data. 数据如何抽样？那些数据是相关的？\n- **EXPLORE** the data. 可视化数据，有异常吗？有模式吗？\n- **MODEL** the data. 构建模型，拟合模型，检验模型。\n- **COMMUNICATE** and **VISUALIZE** the results 我们学到了什么？结果有意义吗？\n\n### 0.4 本文目录\n\n- 统计学与数据分析\n\n  - 信息可视化\n  - 集中趋势的量度\n  - 分散性与变异的量度\n  - 概率计算\n  - 离散概率分布\n  - 排列与组合\n  - 几何分布、二项分布、泊松分布\n  - 正态分布\n  - 统计抽样\n  - 总体和样本的估计\n  - 置信区间\n  - 假设检验的运用\n  - x2 分布\n  - 相关与回归\n\n- 数据挖掘基本扫盲\n\n  - 推荐系统入门\n  - 隐式评价和基于物品的过滤算法\n  - 分类与分类进阶\n  - 朴素贝叶斯\n  - 朴素贝叶斯算法和非结构化文本\n  - 聚类\n\n- 机器学习\n\n  - 分类与回归\n  - 交差校验\n  - 降维\n  - 支持向量机\n  - 决策树 \u0026 随机森林\n  - Bagging \u0026 Boosting\n  - 聚类与文本\n  - 贝叶斯思维 \u0026 Naive Bayes\n  - 文本分析：LDA\u0026Topic Modeling\n  - 聚类\n\n- 深度学习\n\n- 自然语言 NLP\n  - 中文分词\n  - 新词发现\n\n## 0x02 统计学与数据分析\n\n### 2.1 信息可视化\n\n建议直接阅读 AntV 的可视化基础 https://antv.alipay.com/vis/doc/chart/index.html\n\n### 2.2 集中趋势的量度\n\n\u003e 目的：找出能够反映集中趋势的一个数值\n\nPS: 可以用分布图看它的均值和平均数是否落在集中趋势，数据向右偏斜，均值位于中位数右侧\n\n- 均值 （均值对于抽样数据更加稳定，但是如果村里一个杨千万九个穷光蛋，则个个都是杨百万）\n- 中位数\n- 众数\n\n### 2.3 分散性与变异的量度\n\n\u003e 目的：仅有均值，中位数，众数是不够的，还需要距和差\n\n- 全距：MAX（上界） - MIN（下界）\n- 按照四分位书的切分方式： 下界 - 下四分位数目 (Q1) - 中位数 - 上四分位数 - 上界\n- 四分位距：上四分位数 - 下四分位数 （当然，可以使用箱线图进行绘制，从而判断出数据集中的地方）\n- 百分位距：在统计的时候，往往需要避免极值对数据的影响\n- 方差：量度数据分散性\n- 标准差：典型值与均值的距离，体现了数值的变异程度。即加入有一批数据的标准差为 3cm, 代表着平均而言，这些数值与均值的距离为 3cm\n\n## 0x03 数据挖掘\n\n本节是『面向程序员的挖掘指南』的笔记。\n\n数据挖掘是深一步的分析统计。\n\n本书所讲内容就是一个核心：\n\n\u003e 给用户推荐物品\n\n内容就是：\n\n- 第一章和第二章均为依据用户对物品的评价（显示评价以及隐式评价）来做出相关推荐。\n- 第三章为物品本身的特点进行**分类**\n- 第四章直到最后一章则是分类的详细讨论以及聚类分析。\n\n### 基于用户的协同过滤算法\n\n用户与用户之间相似\n\n#### 基本的距离算法\n\n\u003e 擦擦擦，LaTeX 公式 居然不能用...\n\n- 曼哈顿距离 如果在 n 维坐标上，即绝对值。\n- 欧几里得距离 就是其实就是 n 维勾股定理。\n\n曼哈顿距离和欧几里得距离在判断 同样是 n 维的数据是完全 OK 的。即总量为 m 部电影的情况下，k 个人同样评价了 n 部电影，比较容易算出距离。\n\n但，n 纬和比他更小的纬度算出的距离，似乎并不应该相等。 如何处理这些缺失的数据呢？如果是我的话，会设定一个默认值吧。（半值，均值）\n\n- 闵科夫斯基距离\n\n```\nTODO: 以后补上公式\n```\n\n\u003e r 值越大，单个维度的差值大小会对整体距离有更大的影响。\n\n- 皮尔森相关系数\n\n用户也分为好几种，比如说：\n\n用户 1: 好的打分 5, 差的打分 3\n用户 2: 好的打分 5, 差的打分 1\n用户 3: 要么 5, 要么 1\n\n- 余弦相似度\n\n如果数据存在“分数膨胀”问题，就使用皮尔逊相关系数。\n如果数据比较“密集”，变量之间基本都存在公有值，且这些距离数据是非常重要的，那就使用欧几里得或曼哈顿距离。\n如果数据是稀疏的，则使用余弦相似度。\n\n- K 最邻近算法\n\n### 隐式评价和基于物品的过滤算法\n\n显式评价：豆瓣的五星，用户的评论\n\n显式评价可能存在下面几个问题：\n\n1. 懒得评价\n2. 会出于面子，合群，偏见撒谎。\n3. 懒得追加评价一般数量少，假如买的东西一个月后坏掉了，则不用。\n4. 账号共享带来的问题。\n5. 买东西就是有问题才调出来判断，其他的情况下懒得评价。\n\n隐式评价：通过观察可得。通常需要工程师针对客户端和浏览器端进行埋点。比如，买过，还买过，点击情趣用品多次。\n\n1. 网页方面：页面点击、停留时间、重复访问次数、引用率、观看视频的次数； 音乐播放器：播放的曲目、跳过的曲目、播放次数；\n\n\u003e 然而，越精准的判断越消耗性能。\n\n- 扩展性：当用户数量大幅度上升的时候，计算量就上来了。千万用户其中一个用户和其他用户进行有一次运算的话，计算量就相当大了。\n- 稀疏性：物品数量远大于用户数量，而千万级用户仅仅对百万本书中几十本评价，\n\n\u003e 书中说，可以考虑基于物品的协同过滤，其实可以考虑，先给用户和书划分类型，从而使得计算量下来。 计算标签和标签之间的相似度，这样可以使得成本大幅度下降。\n\n### 基于物品的协同过滤算法\n\n- **修正的余弦相似度** 是一种基于模型的协同过滤算法。我们前面提过，这种算法的优势之一是扩展性好，对于大数据量而言，运算速度快、占用内存少。 用户的评价标准是不同的，比如喜欢一个歌手时有些人会打 4 分，有些打 5 分；不喜欢时有人会打 3 分，有些则会只给 1 分。修正的余弦相似度计算时会将用户对物品的评分减去用户所有评分的均值，从而解决这个问题。\n- **Slope One 算法**\n\n### 训练集和测试集\n\n十折交叉验证\n\n将数据集随机分割成十个等份，每次用 9 份数据做训练集，1 份数据做测试集，如此迭代 10 次。\n\nn 折交叉验证\n\n### 评估分类器\n\n- 混淆矩阵 （其实就是交叉表的统计学说法）\n- Kappa 指标\n\n- 优化邻近算法\n  - kNN 算法\n\n### 分类方法\n\n## 0x03 机器学习\n\n## 0x04 深度学习\n\n## 0x05 自然语言 NLP\n\n## 0xEE 链接\n\n- [面向程序员的数据挖掘指南](https://dataminingguide.books.yourtion.com/)\n\n---\n\nChangeLog:\n\n- **2017-07-17** 重修文字\n- **2017-10-12** 增加数据挖掘模块\n"},{"tags":["Python"],"path":"20170711_GeoProcessingWithPython.md","title":"GeoProcessing In Python","slug":"GeoProcessing In Python","date":"2017-07-11","category":"数据分析","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00. 前言\n\n16 年 12 月研究 GIS 相关资料用于处理 GIS 相关问题，完成基本 GIS 功能。\n最新需要进阶相关内容用于更好的处理相关数据。\n\n- 书籍：\n  - Geoprocessing With Python\n  - PostGIS In Action 2rd\n- 框架：\n  - 前端 Leaflets D3\n  - 后端 GeoDjango\n- 其他零零碎碎的资料\n\n特此记录。\n\n\u003c!-- more --\u003e\n\n本文目录\n\n- 基本概念\n- Vertor VS Raster\n- Vertor 相关类型与坐标系\n- Raster 相关类型\n- 其他类型\n- GIS 开发的生态圈以及常用技术栈\n- Vertor 分析\n- Raster 分析\n- Vertor 与 Raster\n\n## 0x01 基本概念\n\n### 1.1. Vertor VS Raster\n\n- Vector : 基本单元为 Point : points, lines, and polygons 以及其组合，适用于矢量图，地形边界，路线等。\n- Raster : 基本单元为 Pixel : 2d/3d 包含数值的数组，适用于连续性数据，不仅仅适用于图片。\n\n### 1.2. Vertor 相关类型与坐标系\n\n#### 1.2.1. 国内常见的几种坐标系\n\n国内由于特殊的国情，国际标准也要向国家标准靠齐。比如各个不同的坐标系上坐标的换算。\n\n我们都知道一个坐标 (x,y) 可以表示为经纬度，甚至放在坐标系上，我们可以这么运算两点 (x1,y1) , (x2,y2) 之间的距离\n\n```python\n# z 表示比例系数\ndistance = math.sqrt((x1-x2) ** 2 + (y1-y2) ** 2) * z\n```\n\n在近距离的时候的确是可以这么做的比如计算村里小芳和隔壁老王家的距离。当距离过大的时候，比如计算上海 A 区和 B 区的两个写字楼的距离的时候，则有相当大的误差。\n\n那么问题来了：\n\n~~挖掘技术哪家强~~\n\n啊不是，是**国内有哪些常用坐标标准呢？又是如何计算的呢？**\n\n- 1.  GPS WGS-84 国际标准（原始）\n- 2.  GCJ-02 国内标准（原始数据混淆）\n- 3.  其他坐标比如 BD-09（原始数据混淆再混淆）\n\n对于小公司而言，我们是没有任何方法来通过 BD-09 以及 GCJ-02 这种坐标系进行运算的：\n\n因为坐标点非线性偏移核心计算方法掌握在 GCJ-02 / BD-09 的公司里面，比如 Google 中国，高德地图，百度地图，腾讯地图。所以，为了研究，则必须要有**能够对坐标进行运算的算法**, 那这个东西有没有呢？答案是肯定的，因为国外使用的 WGS-84 标准，并且，计算坐标的算法早就开源。\n\n那么，我们的思路就确定下来了。\n\n1. 各种地图的经纬度坐标比如 BD-09 或 GCJ-02 标转换成 WGS-84 坐标。\n2. 使用开源 GIS 软件进行对 WGS-84 进行运算。\n\n感谢诸多在 GIS 运算上开源的中国先辈，我们轻而易举的获取到了坐标之间相互转化的方法：\n\nhttps://github.com/wandergis/coordTransform_py\n\n#### 1.2.2. 形状\n\n坐标系，我们可以简单的理解为一个笛卡尔坐标系（虽然这么说很不准确，但已经足够形象了）\n\n于是对于二维的数据，GIS 的分析就可以理解为对于点，线段，多边形自身以及他们之间的关系的分析。\n\n### 1.3. Raster 相关类型\n\nraster 的 digital elevation model(DEM), 即每一个像素值包含一个 elevation value\n\nGDAL/OGR\n\n\u003c!-- more --\u003e\n\n## 0x02. Vertor 分析\n\n## 0x03. Raster 分析\n\n### 3.1. 教程\n\n### 3.2. 教程\n\n### 3.3. 教程笔记\n\n## 0x04. Vertor 与 Raster\n\n### 基础版本\n\n- Point\n- LineString\n- Polygon\n\n- MultiPoint\n- MultiLineString\n- MultiPolygon\n\n### 中级概念\n\n- Raster / Tile (Bands 是什么鬼）\n\n### PostGIS MetaTable\n\n- spatial_ref_sys\n- geography_columns\n- geometry_columns\n- raster_columns\n- raster_overviews\n\n### PostGIS 常用函数\n\n```sql\nST_AsText(geom) 用于查看 WKT\nST_GeometryType(geometry) returns the type of the geometry\nST_NDims(geometry) returns the number of dimensions of the geometry\nST_SRID(geometry) returns the spatial reference identifier number of the geometry\nST_X(geometry) returns the X ordinate , 如果作用在 Point 上，则返回经度\nST_Y(geometry) returns the Y ordinate , 如果作用在 Point 上，则返回纬度\n\nST_Length(geometry) returns the length of the linestring\nST_StartPoint(geometry) returns the first coordinate as a point\nST_EndPoint(geometry) returns the last coordinate as a point\nST_NPoints(geometry) returns the number of coordinates in the linestring\n\nST_Area(geometry) returns the area of the polygons\nST_NRings(geometry) returns the number of rings (usually 1, more of there are holes)\nST_ExteriorRing(geometry) returns the outer ring as a linestring\nST_InteriorRingN(geometry,n) returns a specified interior ring as a linestring\nST_Perimeter(geometry) returns the length of all the rings\n\nST_NumGeometries(geometry) returns the number of parts in the collection\nST_GeometryN(geometry,n) returns the specified part\nST_Area(geometry) returns the total area of all polygonal parts\nST_Length(geometry) returns the total length of all linear parts\n```\n\n### Snippets\n\n```\n-- 合并多个区域并返回 multipoly\nUPDATE areas as A\nSET \"Boundary\" = ST_Multi(st_union(ARRAY(SELECT geom FROM county_boundary_region WHERE gid in ( 'foo_id','bar_id)')\n)))\nWHERE A.\"ID\" = 'xxxxxx'\n```\n\n## 0xEE 参考链接\n\n1. http://gis.stackexchange.com/questions/6681/what-are-the-pros-and-cons-of-postgis-geography-and-geometry-types\n2. Geo Processing with Python\n\n---\n\nChangeLog:\n\n- **2017-07-11** 重修文字\n"},{"tags":["JavaScript"],"path":"20170704_RethinkingInJavaScript.md","title":"Rethinking In JavaScript","slug":"Rethinking In JavaScript","date":"2017-07-04","category":"前端开发","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00. 前言\n\nJavaScript 这门语言已经不容小觑了，在项目中的前端部分基于 VueJS 和 ElementUI 之后，我也就顺应历史潮流深入了解了一下这门不容小觑的语言。\n\n\u003c!-- more --\u003e\n\n### 1. 为什么是 JavaScript\n\n为什么是 JavaScript 呢？\n\n因为太火，不得不认真学习一下。\n\n我本人对 JavaScript 这种语言是有偏见的，这点我不会掩饰，我始终记得在正常的语言 Python / Java / C# 中实现一个休眠的简单功能和在 JS 中实现一个休眠功能的差别。\n\n在 Python 中有很多语法糖，内置数据结构丰富，而 JS 则并不是如此，数据类型相对少，Bool 判断混乱，而今天，这门混乱的语言在流行程度上几乎接近于 Java 这门语言，即便是存在这样或者那样的问题，JavaScript 依然是一种奇葩的王者。\n\n在服务端，有多少功能是 Python 完不成而 JavaScript（即 NodeJS) 可以胜任的呢？而且，NodeJS 写起来的感觉比起 Python 来说，还是差了很多，所以，我比较倾向于把计算类和 IO 类的操作用 Python 来写，至于浏览器端就交给 JavaScript 好了。\n\n那么，对 JS 的这种定位，也使得我对 JS 生态圈的掌握程度不会超过 Vue/React 系。\n\n### 2. 工具链\n\n#### 2.1. 浏览器端\n\n#### 2.2. 桌面端\n\n#### 2.3. 客户端\n\n### 4. 文档\n\n### 5. 社区\n\n### 6. 书籍\n\n## 0x01 基本概念\n\n### 1. 数据类型\n\n- Number （没有 INT 值，只有 double-precision 64-bit format IEEE 754 ）\n- String\n- Boolean\n- Symbol (new in ES2015)\n- Object\n  - Function\n  - Array\n  - Date\n  - RegExp\n- null\n- undefined\n\n### 2. 操作\n\n#### 操作\n\n#### 操作\n\n### 3. 语句\n\n## 0x02 中级概念\n\n### 函数\n\n#### 作用域\n\n### 模块\n\n### 面向对象\n\n### 错误 / 调试测试\n\n### IO 编程\n\n### 进程和线程\n\n#### 多线程\n\n#### 多进程\n\n#### GIL\n\n##### 协同式多任务处理\n\n##### 抢占式多任务处理\n\n##### 线程安全\n\n### 正则表达式\n\n## 0x03 高级技巧\n\n## 0x04 标准库\n\n### 常用内建模块\n\n### 系统化模块\n\n### 安全性\n\n### 性能\n\n## 0x05 NPM \u0026\u0026 Yarn\n\n## 0xEE 文章更新\n\n- **2017-07-05 19:43:00** : 初始化本文\n"}],"total":4},{"name":"2017-06","posts":[{"tags":["Git"],"path":"20170615_GitCheatSheet.md","title":"Git CheatSheet","slug":"Git CheatSheet","date":"2017-06-15","category":"善用佳软","lastMod":"2020-10-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\nGit 是一种分布式版本管理工具。\n\n## 0x01 Git 命令范论\n\n1.  基础命令 （本地修改类）\n2.  合作命令 （本地与仓库类）\n3.  综合命令\n4.  管理命令\n\n### 基础命令\n\n- git-init(1) to create a new repository.\n- git-log(1) to see what happened.\n- git-checkout(1) and git-branch(1) to switch branches.\n- git-add(1) to manage the index file.\n- git-diff(1) and git-status(1) to see what you are in the middle of doing.\n- git-commit(1) to advance the current branch.\n- git-reset(1) and git-checkout(1) (with pathname parameters) to undo changes.\n- git-merge(1) to merge between local branches.\n- git-rebase(1) to maintain topic branches.\n- git-tag(1) to mark a known point.\n\n```bash\n$ tar zxf frotz.tar.gz\n$ cd frotz\n$ git init\n$ git add . (1)\n$ git commit -m \"import of frotz source tree.\"\n$ git tag v2.43 (2)\n\n$ git checkout -b alsa-audio (1)\n$ edit/compile/test\n$ git checkout -- curses/ux_audio_oss.c (2) # 恢复文件\n$ git add curses/ux_audio_alsa.c (3)\n$ edit/compile/test\n$ git diff HEAD (4) # 查看提交了哪些修改\n$ git commit -a -s (5) # 提交所有\n$ edit/compile/test\n$ git diff HEAD^ (6) # 查看所有变化，包含之前的 commit\n$ git commit -a --amend (7) # 修订前一个 commit, 把所有的新变化提交到\n$ git checkout master (8)\n$ git merge alsa-audio (9)\n$ git log --since='3 days ago' (10)\n$ git log v2.43.. curses/ (11)\n```\n\n### 合作命令\n\n- git-clone(1) from the upstream to prime your local repository.\n- git-pull(1) and git-fetch(1) from \"origin\" to keep up-to-date with the upstream.\n- git-push(1) to shared repository, if you adopt CVS style shared repository workflow.\n- git-format-patch(1) to prepare e-mail submission, if you adopt Linux kernel-style public forum workflow.\n- git-send-email(1) to send your e-mail submission without corruption by your MUA.\n- git-request-pull(1) to create a summary of changes for your upstream to pull.\n\n```bash\n## clone 修改 提交\n$ git clone git://git.kernel.org/pub/scm/.../torvalds/linux-2.6 my2.6\n$ cd my2.6\n$ git checkout -b mine master (1)\n$ edit/compile/test; git commit -a -s (2)\n$ git format-patch master (3)\n$ git send-email --to=\"person \u003cemail@example.com\u003e\" 00*.patch (4)\n$ git checkout master (5)\n$ git pull (6)\n$ git log -p ORIG_HEAD.. arch/i386 include/asm-i386 (7) # 查看感兴趣的部分\n$ git ls-remote --heads http://git.kernel.org/.../jgarzik/libata-dev.git (8) # 查看分支\n$ git pull git://git.kernel.org/pub/.../jgarzik/libata-dev.git ALL (9) # 从一个特地\n$ git reset --hard ORIG_HEAD (10) # 撤销 pull\n$ git gc (11) # garbage collect leftover objects from reverted pull\n# 推送到其他 repo\n\nsatellite$ git clone mothership:frotz frotz (1)\nsatellite$ cd frotz\nsatellite$ git config --get-regexp '^(remote|branch)\\.' (2)\nremote.origin.url mothership:frotz\nremote.origin.fetch refs/heads/*:refs/remotes/origin/*\nbranch.master.remote origin\nbranch.master.merge refs/heads/master\nsatellite$ git config remote.origin.push \\\n            +refs/heads/*:refs/remotes/satellite/* (3)\nsatellite$ edit/compile/test/commit\nsatellite$ git push origin (4)\n\nmothership$ cd frotz\nmothership$ git checkout master\nmothership$ git merge satellite/master (5)\n\n           1. mothership machine has a frotz repository under your home directory; clone from it to start a repository on the satellite machine.\n           2. clone sets these configuration variables by default. It arranges git pull to fetch and store the branches of mothership machine to local remotes/origin/* remote-tracking\n           branches.\n           3. arrange git push to push all local branches to their corresponding branch of the mothership machine.\n           4. push will stash all our work away on remotes/satellite/* remote-tracking branches on the mothership machine. You could use this as a back-up method. Likewise, you can\n           pretend that mothership \"fetched\" from you (useful when access is one sided).\n           5. on mothership machine, merge the work done on the satellite machine into the master branch.\n\n       Branch off of a specific tag.\n\n               $ git checkout -b private2.6.14 v2.6.14 (1)\n               $ edit/compile/test; git commit -a\n               $ git checkout master\n               $ git cherry-pick v2.6.14..private2.6.14 (2)\n\n           1. create a private branch based on a well known (but somewhat behind) tag.\n           2. forward port all changes in private2.6.14 branch to master branch without a formal \"merging\". Or longhand git format-patch -k -m --stdout v2.6.14..private2.6.14 | git am -3\n           -k\n\n```\n\n### 综合个体\n\n### 仓库管理\n\n安装完毕之后，cmd-s-p shell command install\n\n## 0x02 常见操作\n\n```bash\n# 搜索代码的变化\ngit log -S'\u003ca term in the source\u003e'\n# 放弃本地修改，与远程同步\ngit fetch origin \u0026\u0026 git reset --hard origin/master \u0026\u0026 git clean -f -d\n# 列出所有冲突文件\ngit diff --name-only --diff-filter=U\n\n# 手贱错误提交，但是没有 push\ngit commit -m \"Something terribly misguided\"              (1)\ngit reset HEAD~                                           (2)\n# edit needing changed files\ngit add needing changed files                             (4)\ngit commit -c ORIG_HEAD                                   (5)\n\n# Delete all changes in the Git repository, but leave unstaged things\ngit checkout .\n# Delete all changes in the Git repository, including untracked files\ngit clean -f\n```\n\n## 0x03 常见问题\n\n```\n\n```\n\n## 0x04 Hub\n\n## 0x05 Workflow\n\n## 0xEE 扩展阅读\n\n---\n\nChangeLog:\n\n- **2020-12-15** 重修文字\n"},{"tags":["数据分析"],"path":"20170603_PandasCheatSheet.md","title":"Pandas CheatSheet","slug":"Pandas CheatSheet","date":"2017-06-03","category":"Python","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n本文为 Cheatsheet 类型文章，用于记录我在日常编程中经常使用的 Pandas 相关语句。\n\n主要包含：\n\n- Pandas 中 Series 的一些常见操作和技巧\n- Pandas 中 Dateframe 的一些常见操作和技巧\n- Python 里的可视化技巧\n- Pandas 使用过程中的一些细节\n\n不定期更新。\n\n\u003c!-- more --\u003e\n\n\u003e SQL 是一种面向集合的处理工具 / 语言\n\u003e Pandas 是一种面向数组的处理工具\n\n\u003e **而一般处理 pandas 的数据往往以二维表的形式存在。所以，可以类比为更加强大的 SQL 语言。**\n\n而依据 Pandas 的作者之言，牛逼的 Pandas 使用者必须要精通 numpy; 当然，关于 Numpy, 留待之后开一篇文章做笔记好了。\n\n## 0x01 Series 相关\n\nSeries 接近于 ndarray 的用法，区别仅仅在于会带上 label 而已\n\n\u003e 关于 ndarray, 请参考 我的另一篇文章 Numpy Cheatsheet\n\n## 0x02 DataFrame 相关\n\n### 2.1 对象创建\n\n```python\n\n# 1. 内存变量转 Dataframe\n## 1.1. 通过二位矩阵 , index , columns\ndates = pd.date_range('20130101', periods=6)\npd = pd.DataFrame(np.random.randn(6,4), index=dates, columns=list('ABCD'))\n## 1.2. 通过字典 Key 为 Column , Value 为 list,timestamp,np.array,value\ndf2 = pd.DataFrame({ 'A' : 1.,\n                     'B' : pd.Timestamp('20130102'),\n                     'C' : pd.Series(1,index=list(range(4)),dtype='float32'),\n                     'D' : np.array([3] * 4,dtype='int32'),\n                     'E' : pd.Categorical([\"test\",\"train\",\"test\",\"train\"]),\n                     'F' : 'foo' })\n# 长度无需统一，会自动填充\n\n# 2. 从文件中读取\npd.read_excel(\"./data_set.xlsx\",index_col=False) # 关掉 Index\n\n# 3. 合并多个同样的 DataFrame\ndf_items = [df_item1,df_item2,...]\ndf = pd.concat(df_items).drop_duplicates()\ndf.merge(data_set_df, left_on=\"lno\", right_on=\"rno\", how=\"outer\")\n\n# 4.series to dataframe\ndf = s.to_frame()\n\n```\n\n选择数据\nGetting\nSelection by Label\nSelection by Position\nBoolean Indexing\nSetting\n缺失数据\n数据操作\nOperations\nStats\nApply\nHistogramming\nString Methods\n数据合并\nConcat\nJoin\nAppend\nGrouping\nReshaping\nStack\nPivot Tables\nTime Series\nCategoricals\nPlotting\n\n### 2.2 浏览数据\n\n```python\n# 1. 查看表结构\n\ndf.head()\ndf.tail(3)\ndf.index\n# df.index = ['日期','小时']\ndf.columns\ndf.columns = map(str.lower, df.columns)\n\ndf.values\n\ndf['col'] = df['col'].astype(str).convert_objects(convert_numeric=True)\n\n# 2. 删除 col_name\n\ndf.drop(['col_name_1','col_name_2',...,'col_name_N'],inplace=True,axis=1,errors='ignore')\n\ndel df['cola']\n\n# 3. 修改元数据\ndf.rename(columns=lambda x: x.split('.')[-1], inplace=True)\ndf.rename(columns={'oldName1': 'newName1', 'oldName2': 'newName2'}, inplace=True)\ndf.rename(columns = {0: 'cola', 1: 'colb', 2: 'colc'}, inplace=True)\n\n# 2.\n## 2. 遍历\nfor index, row in df.iterrows():\n    print row[\"c1\"], row[\"c2\"]\nfor row in df.itertuples(index=True, name='Pandas'):\n    print getattr(row, \"c1\"), getattr(row, \"c2\")\n= IF([@price] \u003c 1, \"未知\",IF([@price] \u003c 30000, \"三万以下\", IF([@price] \u003c= 50000, \"三万到五万\", IF([@price] \u003c= 100000, \"五万到十万\", IF([@price] \u003c= 10000000, \"十万以上\", \"其他\")))))\n```\n\n### 2.3 修改表内容\n\n```python\ndf.drop_duplicates(['col_a','col_b'])\n```\n\n### 2.4 查看表内容\n\n```python\n# 选择\ndf['A'] # 列选\ndf[0:30] # 行选\ndf['20130102':'20130104'] # 行选\ndf.loc['20130102':'20130104',['A','B']] # by label\ndf.loc[condition,['cola','colb']]\ndf.loc[['ri01','ri02'] , [\"cola\",\"colb\",\"colc\"]]\n\ndf.iloc[1:5, 2:4] # by position\ndf.iloc[: , 0:7] # 全部列，0-7 索引\n\ndf.ix[['ri02', 'ri09']] # 选取行\n\ntotal_rows=len(df.axes[0])\ntotal_cols=len(df.axes[1])\n\ndf.sample(3000) # 随机抽取 3000 行，可以用于快速验证算法\n\ncriterion = df2['a'].map(lambda x: x.startswith('t'))\ndf2[criterion]\n\ndf2[[x.startswith('t') for x in df2['a']]]\n# select * from df limit 5\ndf.head()\n# select a,b,c from df\ndf[['a','b','c']].head()\n# select a,b,c from df where a = 11 and b = 'xx'\ndf[ ( df['a'] == 11) \u0026 ( df['b'] == 'xx') ][['a','b','c']]\ndf['a'].value_counts()\n\n# SELECT * FROM df ORDER BY a DESC LIMIT 10 OFFSET 5;\ndf.nlargest(10+5, columns='a').tail(10)\n\ndf.column.str[0:2]\ndf.column_name.str.len()\ntwo_groups = '(?P\u003cletter\u003e[a-z])(?P\u003cdigit\u003e[0-9])'\ns.str.extract(two_groups, expand=True)\n\n# 排序\n\ndf.sort_index(axis=1, ascending=False)\ndf.sort_values(by='B')\ndf = df.sort(['col1','col2','col3'],ascending=[1,1,0])\n#\n\n# window function\n# SELECT a, b, c, rank() OVER (PARTITION BY a ORDER BY b DESC) as rn FROM df;\n# 如果没有这个 window function 的话，可以 groupby 一下，然后生成表和原有表进行 JOIN\ntips.assign(rn=tips.sort_values(['b'], ascending=False).groupby(['a']).cumcount() + 1)\n\n# Top N rows per group\n# rank 代表等级 如果两人并列第一名，则不存在第二名，直接是第三名 , row_number 代表排名，即即便两个人分数一样，也无法并列第一名\n\n# PostGRESQL's ROW_NUMBER() analytic function\nSELECT * FROM (\n  SELECT\n    t.*,\n    ROW_NUMBER() OVER(PARTITION BY day ORDER BY total_bill DESC) AS rn\n  FROM tips t\n) tt\nWHERE rn \u003c 3\nORDER BY day, rn;\n\n(tips.assign(rn=tips.sort_values(['total_bill'], ascending=False)\n                    .groupby(['day'])\n                    .cumcount() + 1)\n     .query('rn \u003c 3')\n     .sort_values(['day','rn'])\n)\n\n(tips.assign(rnk=tips.groupby(['day'])['total_bill']\n                     .rank(method='first', ascending=False))\n     .query('rnk \u003c 3')\n     .sort_values(['day','rnk'])\n)\n\n# PostGRESQL's RANK() analytic function\nSELECT * FROM (\n  SELECT\n    t.*,\n    RANK() OVER(PARTITION BY sex ORDER BY tip) AS rnk\n  FROM tips t\n  WHERE tip \u003c 2\n)\nWHERE rnk \u003c 3\nORDER BY sex, rnk;\n\n(tips[tips['tip'] \u003c 2]\n     .assign(rnk_min=tips.groupby(['sex'])['tip']\n                         .rank(method='min'))\n     .query('rnk_min \u003c 3')\n     .sort_values(['sex','rnk_min'])\n)\n\n# where 语句\ndf['a'].isnull()\ndf['a'].isin(arr)\n\n# groupby\ndf.groupby('a').size() # 计算 a\ndf.groupby('a')['b'].count() # 同上计算 a\ndf.groupby('a').count() # 计算所有 cols\nagg_fun_dict = {'tip': np.mean, 'day': np.size}\nagg_fun_dict_new = {'tip': [np.mean, np.size]}\ndf.groupby('a')[['b','c']].agg(agg_fun_dict)\ndf.groupby('a')['b'].describe()\ndf.age.agg(['min', 'max'])\ndf.applymap(multiply_10_for_every_int) #\n\ncalc_groups = df.groupby([date])\ncalc_groups['id_aa'].nunique().reset_index().to_excel(\"123.xlsx\")\n\n# pivot\npd.pivot_table(data=df,values='value_col', index='A_FROM', columns='B_TO', aggfunc=lambda x: len(x.unique()),margins=True)\n\n# CONCAT\nappend\n# JOIN\npd.merge(df1, df2, on='key', how='outer')\n\n# UPDATE tips SET tip = tip*2 WHERE tip \u003c 2;\ntips.loc[tips['tip'] \u003c 2, 'tip'] *= 2\n\n# TODO:\n```\n\n### 2.5 表变换\n\n```python\n# apply , apply map\nDataFrame.apply operates on entire rows or columns at a time.\nDataFrame.applymap, Series.apply, and Series.map operate on one element at time.\n```\n\n### 2.6 表遍历\n\n```python\ndf.iterrows()\ndf.itertuples()\n```\n\n## 数据导入导出\n\n### SQL\n\n```python\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.engine.url import URL\nDATABASE = {\n    'drivername': 'postgres',\n    'host': 'localhost',\n    'port': '5432',\n    'username': 'yourusername',\n    'password': 'yourpass',\n    'database': 'yourdb'\n}\n# 这里并不建议直接写数据库连接字符串，而是使用 URL 函数，这样可以避免转义字符带来的坑，比如 @ 在数据库连接字符串是 %40\nengine = create_engine(URL(**DATABASE))\n\n# 读一整张表\nwith engine.connect() as conn, conn.begin():\n    data = pd.read_sql_table('yourtablehere', conn)\n    processyourdata(data)\n\n# 按照 SQL 语句来读\nwith engine.connect() as conn, conn.begin():\n    data = pd.read_sql(\"\"\"\n    yoursqlquery\n    \"\"\", conn)\n    processyourdata(data)\n```\n\n### CSV\n\n日常数据处理用 CSV 的比较多，因为这种格式语法简洁，类二维表，读写速度快，而且配合 gzip 压缩解压。\n\npandas 在 windows 上好像不能读取中文路径？\n\n而且，pandas 读取的时候要注意指定编码。因为在日常导出 CSV 的时往往使用的是 utf-8, 而 windows 默认打开文本文件时候使用的是 gbk\n\nread_csv 有几十个参数，挑几个说一下：\n\n- sep 可以指定分隔符，默认为',', 但有的人导出的数据以 tab 为空格。\n- dtype 可以指定某些列的值类型为 int,float 的类型从而减少 object 的创建 , 但是对 str/object 没有什么暖用\n- parse_dates 可以指定 date 列\n- header 如果 CSV 没有 Header, 可以指定为 None\n- usecols 可以指定几列，相当于数据库中的 SELECT a_col,b_col\n\n其中还有一些比较有趣的东西，比如说，iterator=True\n值得注意的是，通过\n\n### Excel\n\nGotchas\n\n## 0x02 可视化技术\n\n```python\n# 绘制\ndf.plot(kind='bar')\n\nplt.xlabel('xlable')\nplt.ylabel('ylable')\nplt.title('title name')\n\nplt.show()\n\ndf['数量'].plot(kind='bar')\n\n# 批量创建图\ng = sns.FacetGrid(customers, col=\"cola\")\ng.map(plt.scatter, \"数量\", \"单位\", alpha=1)\ng.add_legend();\n\nttbill = sns.distplot(tips[\"总价格\"]);\nttbill.set(xlabel = '价值', ylabel = '频率', title = \"标题名\")\nsns.despine()\n\nsns.jointplot(x =\"total_bill\", y =\"tip\", data = tips)\n# https://github.com/guipsamora/pandas_exercises/blob/master/07_Visualization/Tips/Exercises_with_code_and_solutions.ipynb\n\nplt.pie(\n    [100,300],\n    labels = ['男', '女'],\n    shadow = False,\n    colors = ['blue','red'],\n    explode = (0.15 , 0),\n    startangle = 90,\n    autopct = '%1.1f%%'\n    )\nplt.axis('equal')\nplt.title(\"男女比例\")\nplt.tight_layout()\nplt.show()\n```\n\n## 0x03 asd1\n\n## 0x07 Performance Tips\n\n最近遇到了数据量比较大的数据处理，数据条数差不多在 3 千万条。加载到内存中大约 1GB.\n\n### 7.1 精简行列\n\n1. 读入 dataframe 的时候就排除多余的行列。\n2. Merge 时候需要精简行列。\n\n```python\ndf1.merge(df2[list('xab')])\npandas.merge(dataframe1, dataframe2.iloc[:, [0:5]], how='left', on='key')\n```\n\n### 7.2 大文件的处理\n\n\u003e 参考我的文章 记一次小机器的 Python 大数据分析\n\n## 0x 踩坑集合\n\n## 0x08 踩坑集合\n\n### 8.1 IO 类\n\n####\n\n### 8.2 IO 类\n\n## 0xEE 参考链接\n\n---\n\nChangeLog:\n\n- **2017-06-03** 初始化本文\n- **2018-02-03** 重修文字\n"},{"tags":["编辑器","Vim"],"path":"20170623_VimCheatSheet.md","title":"CVim","slug":"CVim","date":"2017-06-03","category":"善用佳软","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 什么是 CVim 呢？\n\nCVim 基于 NeoVim 0.5+ , 整理 cvim 的配置，将大部分从 vimscript 迁移到 lua 中\n\n\u003e only tested on neovim 0.5\n\n### 优势\n\n- Vim, Not Vim like\n- 更现代的编辑界面\n  - 开始页面 via. vim-startify\n  - 菜单栏 via. QuickUI\n  - 上下文菜单 via. QuickUI Context Menu\n  - 文件栏 via. LuaTree\n  - Tag 栏 via. Vista\n  - 更好的 Finder via. telescope\n    - ctrl + p 文件搜索\n  - 侧边栏 via\n    - vim-signature\n    - vim-signify\n- 全文搜索\n  - Enhenced Basic Keys\n    - j/k via accelerated\n    - f/F/t/T via sneak\n  - Enhenced Select\n    - 缩进选择\n- 更现代化的编辑，如\n- For TypeScript/Python/Golang FullStack Engineer\n  - Python\n  - Golang\n  - TypeScript\n\n### 劣势\n\n\u003e self used, use it with your own caution\n\n## 0x01 安装与配置\n\n```\nbrew install --HEAD neovim\n```\n\n## 0x02 从 VimL 到 Lua\n\n## 0x03 基础操作\n\n### 文件定位\n\n- c-p\n- m-p + words\n- gf\n\n### 文本定位\n\n- `h/j/k/l`\n- `ctrl+f/b/u/d`\n- `gg` `G`\n- w/W e/E\n- `;` 重复上次查找操作\n- `gi` 返回上次修改地\n- `[[` 跳转到上一个 class or funciton\n- `]]` 跳转到上一个 class or function\n- `c-o`\n- `c-i`\n- `10g` 跳转到第十行\n- `u` 撤销\n\n- 高亮版 f/F t/T\n  - f{char} F{char}\n  - t{char} T{char}\n- /\n- ?\n\n- . 重复上次文本操作\n- u 撤销上次文本操作\n- ; 重复上次查找操作\n\n### 文本选择\n\n```python\nvib- 选框内\nvi\"- \"\" 内部\nvi'- '' 内部\nggVG\ngv 选中上次的 visual 选中区\n```\n\n行选择，块选择，扩展块选择\n\n多光标选择\n\n### 插入模式\n\n- c-w 向后删除 word\n- c-h 向后删除 char\n\n### 未分类\n\n```\nU 恢复单个句子\n在命令状态下按 c-d 可以查看所有命令，相当于 bash 下面的 tabtab\nEasyMotion 使用这个就可以代替乱七八糟的快速移动了。这是一个可以给当前的文字立即用打上 tag, 这样的话在 normal 情况下输入，,w 然后就可以看到很多 tag, 输入其中的 tag 就可以立即跳转到相应的 tag.\ninsert 状态进行编辑 c-h c-w 删除一个字，删除一个词。\nnormal 状态下进行删除 x dd —— 删除一个字，剪切一行。\n\nc-b c-f back forth\nc-n c-p 代码补全，tips, 建议标点符号全部半角花，这样就会吧每段连起来的汉字当成一个单词，这样就可以减少输入代码。\nindent\n\n\u003c outdent\ndo it (\u003e)\n```\n\n## 0x06 文本处理技能\n\n### 文本对齐\n\n```viml\n\" Using predefined alignment rules\n\"   :EasyAlign[!] [N-th] DELIMITER_KEY [OPTIONS]\n:EasyAlign :\n:EasyAlign =\n:EasyAlign *=\n:EasyAlign 3\\\n\n\" Using arbitrary regular expressions\n\"   :EasyAlign[!] [N-th] /REGEXP/ [OPTIONS]\n:EasyAlign /[:;]\\+/\n:EasyAlign 2/[:;]\\+/\n:EasyAlign */[:;]\\+/\n:EasyAlign **/[:;]\\+/\n```\n\n### 行处理\n\n行排序\n\n```bash\nsort r /【.\\+】/\nsort u\nsort n\nsort\nsort!\ng/start/+1,/end/-1 sort n\n:%!column -t\n:%!sort -k2nr\n```\n\n```bash\n# 行删除\n# 删除 html 标签\n\n:%s/\u003c\\_.\\{-1,\\}\u003e//g\n\n# 移除每行第一个空格之后的字符\n:%s/ .*//\n```\n\n```\n# 删除空行\n:g/^$/d\n:g/^\\s*$/d\n:%s/\\n\\{3,}/\\r\\r/e\n:g/^[ \\t\\u3000]*$/d\n:g/pattern/d\n:g!/pattern/d\n:g/pattern/t$\n:g/pattern/m$\n:s/ \\{2,}/ /g\n\n```\n\n## 0x07 代码补全与 Snippet\n\n### 常规补全\n\n- \u003cC-X\u003e\u003cC-F\u003e : insert name of a file in current directory\n- \u003cC-N\u003e\u003cC-P\u003e : word completion in insert mode\n- \u003cC-X\u003e\u003cC-L\u003e : Line complete SUPER USEFUL\n\n### UltiSnips\n\n## 0x07 Tags\n\n```\nbrew tap universal-ctags/universal-ctags\nbrew install --with-jansson --HEAD universal-ctags/universal-ctags/universal-ctags\n```\n\n## 0x08 编程语言\n\n### 8.1 Python / Django / Flask\n\n### 8.2 JavaScript / Vue / React\n\n### 8.3 Bash / Ngnix / SQL\n\n### 8.4 Markdown\n\n### 8.5 Go\n\n## 0x09 tips\n\n### profiling startuptime\n\n```bash\nvim --startuptime /tmp/startup.log +q \u0026\u0026 vim /tmp/startup.log\n```\n\n## 0xEE 感谢\n\n- skywind3000/vim-init\n- SpaceVim\n- skywind3000/vim\n- rafi/vim-config\n\n## 0xEE 扩展阅读\n\n- [c-vim](https://github.com/twocucao/c-vim)\n\n---\n\nChangeLog:\n\n- **2020-08-08** 重修文字\n"}],"total":3},{"name":"2017-05","posts":[{"tags":["Python"],"path":"20170529_一个基于TensorFlow的分类器.md","title":"一个基于 TensorFlow 的图片分类器","slug":"一个基于 TensorFlow 的图片分类器","date":"2017-05-29","category":"数据分析","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n\u003e 备注：本文训练效果太差，所以直接太监了。\n\n这年头，不会写爬虫不会写网站，那基本上不能算是一个 Python 程序员，但是 2017 年的 Google IO 之后，作为一个 Pythonist 你不会点数据分析和机器学习，也不好见人了。\n所以，本文教你在什么机器学习概念都不懂的情况下，做出一个基于 TensorFlow 的图片分类功能，入个门。仅此而已。\n本文的代码和文章内容主要源于我在 Github 上无意间翻到的一个 Repo, 链接地址，我所做的功夫就是在这基础上将代码改为了 Python 3 / TensorFlow 1.1.0 的环境，将这个流程梳理一下，不算是代码的生产者最多搬运工，仅此而已。\n\n本文的目的是：\n\n\u003e 通过 TensorFlow 训练一个小型的分类器，用这个分类器通过照片识别出明星的姓名。\n\n即我们要训练一个小 AI, 这个小 AI 能分辨欢乐颂里面的五美：\n\n- 乔欣\n- 刘涛\n- 王子文\n- 杨紫\n- 蒋欣\n\n\u003c!-- more --\u003e\n\n注意：本文主要在 MacOS 上进行测试。\n本文的目录结构如下：\n\n- 准备训练数据和测试数据\n- TensorFlow 环境配置\n- 开始训练图片\n- 对图片进行分类\n- 文章回顾\n- 参考链接\n\n首先克隆我的 Repo,（我的 Repo 在这里）[https://github.com/twocucao/the-machine] .\n\n仓库结构大致如下\n\n```bash\n├── README.md\n├── compose\n│   └── tensorflow\n│       ├── Dockerfile\n│       └── Dockerfile-dev\n├── config\n├── doc\n├── image_classifier\n│   ├── __init__.py\n│   ├── label_dir.py\n│   ├── label_image.py\n│   ├── retrain.py\n│   └── train.sh\n└── bootstrap.sh\n```\n\n## 0x01 准备训练数据和测试数据\n\n准备训练数据，数据从哪里来呢？从百度来。我们从百度抓取大约 5 组图片，每组图片大约 1000 张图片，并且从每组里面留下 900 组作为训练数据，抽出 100 作为测试数据。\n\n### 1.1 抓取图片\n\n抓取代码放在代码仓库中，比较简单，下载即可用。\n\n在 crawl_baidu_images.py 中填入五美的姓名，运行脚本即可。\n脚本会请求百度图片的图片，然后下载下来，程序跑完会有如下的图片数据。\n好，抓取图片我们就完成了。\n\n### 1.2 归类训练数据\n\n归类训练数据，其实就是把刚刚下载下来的图片，分类为五美，也就是把刘涛的照片放到刘涛文件夹中。看一下现在的文件夹，似乎已经分类完毕了，是不是这样呢？显然不是，因为：\n\n- 下载下来的图片貌似 JPG 结尾的图片，但是文件内容是不是 JPEG 的格式就不好说了，也可 GIF 也可能是 PNG.\n- 当你搜索刘涛的时候，百度图片给出的不仅仅是刘涛。也可能有胡歌《琅琊榜》, 也可能有胡军《天龙八部》\n\n所以下面需要做的是：\n\n1. 移除非 JPG 的文件格式\n2. 人工确 (jian) 定 (huang) 文件夹中的图片。\n\n在做上面这两步之前，我们先新建文件夹 image_classifier_train ( 笔者放在 /Users/twocucao/Codes/Repos/image_classifier_train ), 注意，这个文件夹不要放在代码下面，把五美的文件夹放到这个文件夹下面的 data 文件夹下。并且用拼音命名。\n\n如下：\n\n![](http://oriw7hkjj.bkt.clouddn.com/WX20170529-160220@2x.png)\n\n我们先移除非 JPEG 的图片。如果是 mac 系统需要先安装 jpeginfo , brew install jpeginfo 即可。\n进入 /Users/twocucao/Codes/Repos/image_classifier_train 执行下面脚本 **去除非 JPG 的图片**\n\n```\nfind . -iname \"*.jpg\" -exec jpeginfo -c {} \\; | grep -E \"WARNING|ERROR\" \u003e need_delete.sh\ncat need_delete.sh | awk '{print $1}' | xargs rm\nrm need_delete.sh\n```\n\n好了接下来，我们需要到每一个文件夹下进行人工~~鉴黄~~检验图片是不是五美，比如，到 liutao 文件夹下检查，删除图片基本上没有清晰面容的照片。\n为了速度，我们把图片转成缩略图大致看一下，去除明显不是五美的照片，我们进行下一步的筛选。\n\n### 1.3 \b 找出对应的头像\n\n我们需要从图片库中选出五美的头像来\n\n```bash\npyenv global system\n\nbrew reinstall boost-python --with-python3 --without-python\nconda install -c menpo dlib=19.4\n```\n\n## 0x02 TensorFlow 环境配置\n\n### 2.1 Docker 的安装和镜像加速\n\n本文需要使用 Docker 作为环境配置，也正是因为如此，我们可以在很快的时间内搭建起来 tensorflow 的运行环境。目测，Docker 也是未来几年内搭建环境分发环境的首选。\nDocker 下载不必多说，需要补充一句的是，我们可以在阿里云账户上使用一个 registry 对 Docker 镜像进行加速。\n在阿里云的容器界面获取加速链接填到 docker 里面即可。如图。\n\n![](http://oriw7hkjj.bkt.clouddn.com/WX20170529-162953@2x.png)\n\n### 2.2 构建镜像文件并且构建镜像\n\n建议在执行构建镜像之前，务必先完成本文的第二小节的图片准备。然后执行下面的命令，将镜像文件构建成镜像。\n\n```bash\ncd /Users/twocucao/Codes/Repos/the-machine\ndocker build -f compose/tensorflow/Dockerfile-dev -t twocucao/tensorflow .\n```\n\n该行命令使用 compose/tensorflow/Dockerfile-dev 作为 Dockerfile 文件，构建镜像名称为 twocucao/tensorflow , 传入的 context 为 当前路径。\n\n### 2.3 测试 Tensorflow 容器\n\n```bash\ndocker run -it twocucao/tensorflow /bin/bash\necho 'hello tensorflow'\n```\n\n如果运行正常，则一切正常。可以进行下一步骤了。\n\n## 0x03 开始训练\n\n执行命令开始训练。\n\n```bash\n./train.sh /Users/twocucao/Codes/Repos/image_classifier_train\n```\n\n我设置的训练次数为 20000, 在我的本子上基本两个小时，可能时间有些长，没有耐心的童鞋可以吧训练次数调整低一些。然后重新构建镜像。\n\n\u003e 那么，当 TensorFlow 在训练的时候，我们要谈些什么？\n\nGoogle 开源了 Inception 模型，这个模型从 ImageNet 的上千个分类的图片训练而来，而我们所做的工作，便是在此基础上做最后的增量训练。然而，我们只用来区分女明星，似乎这个 Inception 的模型有点大材小用？好，训练结束之后我们查看一下文件夹 /Users/twocucao/Codes/Repos/image_classifier_train 下，\n\n```bash\n├── bottlenecks\n│   ├── jiangxin\n│   ├── liutao\n│   ├── qiaoxin\n│   ├── wangziwen\n│   └── yangzi\n├── data\n│   ├── jiangxin\n│   ├── liutao\n│   ├── qiaoxin\n│   ├── wangziwen\n│   └── yangzi\n├── inception\n│   ├── LICENSE\n│   ├── classify_image_graph_def.pb\n│   ├── cropped_panda.jpg\n│   ├── imagenet_2012_challenge_label_map_proto.pbtxt\n│   ├── imagenet_synset_to_human_label_map.txt\n│   └── inception-2015-12-05.tgz\n├── retrained_graph.pb\n├── retrained_labels.txt\n└── test_data\n    ├── src\n    └── target\n```\n\nBottlenecks 文件夹为我们将每一张 JPG 转成矩阵的文本\nInception 为 Google 开源的模型文件。\nretrained_graph.pb 为训练出来的图的模型文件。\nretrained_labels.txt 为标签。\n\n如下图不断刷出的一坨坨的文字是什么呢？\n\n- 时间 , 无需多说\n- 当前训练次数\n- Train accuracy = 87.0%\n- Cross entropy = 0.499145\n- Validation accuracy = 52.0% (N=100)\n\n看到 Train accuracy \u003e\u003e Validation accuracy 估计是模型过度拟合了，嗯，看来这个模型还是有点问题的。\n\n## 0x04 对图片进行分类\n\n### 4.1 开始分类\n\n### 4.2 对分类结果进行评估\n\n## 0x05 文章回顾\n\n## 0x06 参考链接\n\n- https://codelabs.developers.google.com/codelabs/tensorflow-for-poets/index.html\n"},{"tags":["编辑器"],"path":"20170527_VSCodeCheatSheet.md","title":"VSCode CheatSheet","slug":"VSCode CheatSheet","date":"2017-05-27","category":"善用佳软","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n本文为 Cheatsheet 类型文章，用于记录我使用 VSCode 的一些开发小技巧。\n\n不定期更新。\n\n\u003c!-- more --\u003e\n\nVSCode 是一种编辑器，这显然是一句废话。\n\n这个问题应该是，我为什么要使用 VSCode 作为主力编辑器。有人说：微软出品一定是精品。这个理由很软粉，但是不能打动我更换编辑器的欲望。\n\n使用编辑器自然是求其轻量，高效的文字处理，以及编程的相关环境的支持，以及跨平台和可扩展性。\n\n- **轻量**是求其打开速度快，编辑不卡顿。这一点，用 Vim , Emacs , Sublime Text 完全都可以。\n- **高效的文字处理**是因为满足日常编写文字和代码的需求。\n- **编程相关环境的支持**是因为作为一个学习东西很杂乱的人来说，最痛苦的事情就在于 IDE 常常来不及给一些新技术予以足够的支持，比如说 Docker, 比如说 ansible。\n- **跨平台和可扩展性** 跨平台是必须的，可扩展性则是从插件资源和编写插件的难度考虑。\n\n本文的目录结构如下：\n\n- VSCode 常用命令\n\n## 0x01 VSCode 相关配置\n\n安装完毕之后，cmd-s-p shell command install\n\n## 0x02 VSCode 常用命令\n\n- **Command Palette** : cmd-s-p\n- **cmd-p** : cmd-p\n- **显示状态** : cmd-s-m\n- **下一个错误** : F8 / shift-F8\n- \\*\\*\\*\\* : c-s-p\n- \\*\\*\\*\\* : c-s-p\n- \\*\\*\\*\\* : c-s-p\n- \\*\\*\\*\\* : c-s-p\n- \\*\\*\\*\\* : c-s-p\n- \\*\\*\\*\\* : c-s-p\n- \\*\\*\\*\\* : c-s-p\n\n## 0x03 VS 扩展相关\n\n## 0x04\n"},{"tags":["macOS"],"path":"20170501_OhMyNewMac.md","title":"MacBook Pro 15.4 Multi-Touch Bar","slug":"MacBook Pro 15.4 Multi-Touch Bar","date":"2017-05-01","category":"碎碎念","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 前言\n\n一个月前换了这台新电脑 MacBook Pro 15.4 Multi-Touch Bar (Core i7/16GB/512GB)，感觉每天打字都很舒服，也算是实现了一个梦寐以求的小目标吧。\n\n\u003c!-- more --\u003e\n\n在此之前，用我的**前任**有下面几款：\n\n- 大一时候从网吧买的 400 块钱的台式机\n- 大一时候从淘宝买的 700 块钱的笔记本\n- 大二上学期买的 1200 块钱的笔记本\n- 大三上学期买的 3200 块钱的笔记本，后来花了 2000 块升级了一下下\n- 大四上学期买的 5000 块的二手 MacBook Pro\n\n后来手贱买了降噪耳机，机械键盘，手机，pad , 花的都是自己的钱。\n\n能把一手烂牌打出不错的结果，这才是让人自豪的事情啊！\n\n晚安，以及劳动节快乐。\n\n## 更新\n\n2017-05-01: 初始化本文\n"}],"total":3},{"name":"2017-04","posts":[{"tags":["Python"],"path":"20170408_ThinkingInPython.md","title":"Thinking In Python Language","slug":"Thinking In Python Language","date":"2017-04-08","category":"Python","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x01 前言\n\n\u003e Python 简略笔记\n\n本文诞生于利用 Topic Reading 方法读 Python 和 JavaScript 若干本技术书籍这个过程中结合自己的开发常见场景记录下来的一些笔记。\n\n\u003c!-- more --\u003e\n\n## 0x00 简介\n\n### 1. 为什么是 Python\n\n选 Python, 很大程度上是因为 Python 的快速开发。\n\n当然，快速开发（这里的开发包含部署）这个词也往往会被误解。什么叫做快速？我用一个 CMS 框架快速搭建出一个网站这是否叫做快速？\n\n- 每一次部署的时候，如果使用 Java 或者是 Go, 部署的时候直接 maven 编译打包，接着把 War 包直接上传到 Tomcat 就结束了。而用 Python 则需要各种虚拟环境，各种稀里哗啦的配置。这种情况下是哪一种快速呢？\n\nPython 有什么好处呢？\n\n- 写代码效率高\n- 生态圈好\n\n写代码效率高，这指的是写 Python 代码，而不是运行时。\n\n生态圈好，Web 开发用 Django/Flask , 数据抓取用 Requests , 数据分析清洗用 Pandas, 机器学习。\n\n### 2. 工具链\n\n### 4. 文档\n\n### 5. 社区\n\n### 6. 书籍\n\n## 0x01 基本概念\n\n\u003e 程序 = 算法 + 数据结构\n\n这句话当然是不全面的，但并不影响这句话在计算机世界里面的地位。\n\n依我看来，对我的启发大致是：\n\n\u003e 我会把 API 的调用和数据结构以及算法想清楚，然后才动手把代码分解成伪代码。\n\n### 1. 数据类型\n\n数据类型按照不同的划分标准可以进行不同的划分：\n\n按照复杂性可以这么划分：\n\n- 简单类型\n- 复杂类型\n\n按照复杂性可以这么划分：\n\n- 基本类型\n- 引用类型\n\n按照数据结构可以这么划分：\n\n- 集合结构 : 串\n- 线性结构 : 线性表 （单链表，静态链表，循环链表，双向链表，**栈，队列**)\n- 树形结构 : 树（二叉树，B+ 树，红黑树）\n- 图形结构 : 图\n\n### 2. 操作\n\n#### 操作\n\n对于一些基本的数据类型，操作为 加减乘除取余数位运算等等\n\n对于复杂的一些数据类型，则需要对数据结构多一些了解。\n\n比如，对队列而言，增删改查在算法复杂度上意味着什么？对机器的性能会不会有很多影响呢？\n比如，对 hash 而言，增删改查在算法复杂度上意味着什么？对机器的性能会不会有很多影响呢？\n比如，对字典而言，增删改查在算法复杂度上意味着什么？对机器的性能会不会有很多影响呢？\n比如，对字符串而言，增删改查在算法复杂度上意味着什么？对机器的性能会不会有很多影响呢？\n\n那字符串来说，Java 推荐使用 StringBuilder 来合并多个字符串，Python 推荐 join 多个字符串等等。\n\n#### 操作\n\n### 3. 语句\n\n## 0x02 中级概念\n\n### 函数\n\n#### 作用域\n\n### 模块\n\n模块，这个概念，可大可小，大的时候，把一个程序说成是模块，小的时候，可以把一个文件，甚至你说这一个函数是一个模块，也行。\n\n这里的模块指的是一个包下的函数。\n\n### 面向对象\n\n面向对象有三大概念：\n\n- 封装\n- 继承\n- 多态\n\n### 错误 / 调试测试\n\n异常处理实际上可以考验一个程序员编写代码的健壮性。\n\n事实上来说，代码写的健壮是一个程序员必备的素养。但其实在开发过程中，出于对项目进行赶工上线，需要对程序的健壮性做出一定的取舍。并且，在编写客户端，服务端，网页前端的时候基本上都会遇到这个问题。什么时候选择健壮的程序，什么时候选择是还可以的程序。需要自己的经验。\n\n### IO 编程\n\n### 进程和线程\n\n#### 多线程\n\n\u003e Python 多线程约等于并发。\n\n#### 多进程\n\n#### GIL\n\nGlobal Interpreter Lock\n\n并不是所有的解释器语言都有 GIL （尽管 Python 和 Ruby 里面都有）, 也并不是没有尝试过去除 GIL, 但是每次去除都会导致单线程性能的下降。所以暂时保留。\n\nGIL 对程序中的影响：\n\n\u003e 一个线程运行 Python , 而其他 N 个睡眠或者等待 I/O - **同一时刻只有一个线程对共享资源进行存取** , Python 线程也可以等待 threading.Lock 或者线程模块中的其他同步对象；\n\n##### 协同式多任务处理\n\n如果有两个线程，同时进行 IO 请求，当其中一个线程连接之后，立即会**主动让出 GIL**, 其他线程就可以运行。\n\n\u003e 当 N 个线程在网络 I/O 堵塞，或等待重新获取 GIL，而一个线程运行 Python。\n\n让出之后还要执行代码呀，所以要有个收回 GIL 的动作。\n\n##### 抢占式多任务处理\n\nPython 2 GIL , 尝试收回 GIL 为 执行 1000 字节码。\nPython 3 GIL , 尝试收回 GIL 检测间隔为 15ms\n\n##### 线程安全\n\n原子操作：sort 之类不需要\n非原子操作：n=n+2 的字节码分为 加载 n , 加载 2 , 相加，存储 n, 四个步骤，由于不是原子性，很可能被由于 15 ms 而被打断。\n\n当然，懒人一向是 : **优先级不决加括号，线程不决加 lock**\n\n对于 Java, 程序员努力在尽可能短的时间内加锁存取共享数据，减轻线程的争夺，实现最大并行。但 Python 中，线程无法并行运行，细粒度的锁就没有了优势。\n\n### 正则表达式\n\n## 0x03 高级技巧\n\n## 0x04 标准库\n\n### 常用内建模块\n\n### 系统化模块\n\n1. Introduction\n2. Built-in Functions\n3. Built-in Constants\n4. Built-in Types\n5. Built-in Exceptions\n6. Text Processing Services\n7. Binary Data Services\n8. Data Types\n9. Numeric and Mathematical Modules\n10. Functional Programming Modules\n11. File and Directory Access\n12. Data Persistence\n13. Data Compression and Archiving\n14. File Formats\n15. Cryptographic Services\n16. Generic Operating System Services\n17. Concurrent Execution\n18. Interprocess Communication and Networking\n19. Internet Data Handling\n20. Structured Markup Processing Tools\n21. Internet Protocols and Support\n22. Multimedia Services\n23. Internationalization\n24. Program Frameworks\n25. Graphical User Interfaces with Tk\n26. Development Tools\n27. Debugging and Profiling\n28. Software Packaging and Distribution\n29. Python Runtime Services\n30. Custom Python Interpreters\n31. Importing Modules\n32. Python Language Services\n33. Miscellaneous Services\n34. MS Windows Specific Services\n35. Unix Specific Services\n36. Superseded Modules\n37. Undocumented Modules\n\n## 0x05 第三方库\n\n- Requests : API 人性化\n\n## 0x06 代码质量\n\n### 正确性\n\n- 外部**不该**引用 protected member （单下划线）\n- lambda 为一次使用，最好不要赋值。\n- 不要给 buildin 函数赋值\n- py3 直接 super()\n- for in else 如果不内置 break 则出会在最后 for in 为 empty 的时候再执行 else 中的语句\n- context exit 如果不 catch 掉异常让其自然向上一级抛出错误的话，必须为 (self, exception_type, exception_value, traceback):\n- 不要在 init 里面 return 数据\n- 不要混用 tab 和 space\n- 4 个 space 缩进\n- staticmethod 直接是 参数，classmethod 第一个参数为 cls\n- 可变的 default value 是不能作为 参数的。（可能是解释器在确定函数的定义的时候完成赋值？)\n- 遵循 exception hierachy https://docs.python.org/3/library/exceptions.html#exception-hierarchy\n- defaultdict defaultdict(lambda : 6) , 必须 callable\n- 尽量 unpack 赋值\n- 字典用获取用 get(\"myk\",None) , 赋值用 dictionary.setdefault(\"list\", []).append(\"list_item\")\n\n### 可维护性\n\n- 避免使用 import \\* , 我觉得这点值得商榷 , 如果是某个模块下，完全可以先把模块拆分成多个，最后 import 进来，接着使用 all.\n- getxxx 获取实际值，如果不为实际值，返回 None 显然不如 try catch 来的实在。\n- 避免使用 global\n- 命名要注意\n- 动态创建方法 , 我觉得这点值得商榷。\n\n### 可读性\n\n- 不要检查，如果可能有异常，尽量抛出异常来 trycatch 解决。\n- a is None , if flag\n- isinstance , not type(r) is types.ListType\n- \"{name}{city}\".format(\\*\\*info_dict)\n- for k , v in infodict.items()\n- 使用 poiinfo = namedtuple(\"poiinfo\",[\"name\",\"lng\",\"lat\"]) 返回 poiinfo['上海',121.00,23] 最后返回值打印 poi.name , poi.lng , poi lat\n- for numbers_value, letters_value in zip(numbers, letters):\n- enumerate\n- 如果能用 listcomp 则不使用 map 和 filter\n\n### 安全性\n\n### 性能\n\n- 用 set\n- d.iteritems() 比 items() 省内存\n\n## 0xEE 文章更新\n\n- **2017-05-11 19:43:00** : 增加代码质量模块\n"},{"tags":["Python"],"path":"20170417_读书笔记_FluentPython.md","title":"『Fluent Python』读书笔记","slug":"『Fluent Python』读书笔记","date":"2017-04-07","category":"读书笔记","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 前言\n\nFluent Python 适用于中级 Pythoner。\n\n\u003e 以 Python 作为主力编程语言已经 1 年多了，读这本书，希望写的代码可以更加的 Pythonic。\n\n\u003c!-- more --\u003e\n\n## 本文目录\n\n## 本书结构\n\n- P1. Prologue\n  - C01. The Python Data Model\n- P2. Data Structure\n  - C02. An Array of Sequences\n    - Overview of Built-in Sequences\n    - List Comprehensions and Generator Expressions\n    - Tuples Are Not Just Immutable Lists\n    - Slicing\n    - Using plus and star with Sequences\n    - Augmented Assignment with Sequences\n    - list.sort and the sorted Built-In Function\n    - Managing Ordered Sequences with bisect\n    - When a List Is Not the Answer\n    - Summary\n    - Further Reading\n  - C03. Dictionaries and Sets\n    - Generic Mapping Types\n    - Dict Comprehensions\n    - Common Mapping Methods\n    - Mappings with Flexiable Key Lookup\n    - Variations of Dict\n    - Subclassing UserDict\n    - Immutable Mappings\n    - Set Theory\n    - Dict and Set Under the Hood\n    - Summary\n    - Further Reading\n  - C04. Text VS Bytes\n    - Character Issues\n    - Byte Essentials\n    - Basic Encoders/Decoders\n    - Understanding Encode/Decode Problems\n    - Handling Text Files\n    - Normalizng Unicode for Saner Comparisons\n    - Sorting Unicode Text\n    - The Unicode Database\n    - Dual-Mode str and bytes APIs\n    - Summary\n    - Further Reading\n- P3. Function as Objects\n  - C05. First-Class Function\n    - Treating a Function Like an Object\n    - Higher-Order Functions\n    - Anonymous Functions\n    - The Seven Flavors of Callable Objects\n    - User-Defined Callable Types\n    - Function Introspection\n    - From Positional to Keyword-Only Parameters\n    - Function Annotations\n    - Packages for Functional Programming\n    - Summary\n    - Further Reading\n  - C06. Design Patterns with First-Class Functions\n    - Refactoring Strategy\n    - Command\n    - Summary\n    - Further Reading\n  - C07. Function Decorators and Closures\n    - Decorators 101\n    - When Python Executes Decorators\n    - Decorator-Enhanced Strategy Pattern\n    - Variable Scope Rules\n    - Closures\n    - The nonlocal Declaration\n    - Implementing a Simple Decorator\n    - Decorators In the Standard Library\n    - Stacked Decorators\n    - Parameterized Decorators\n    - Summary\n    - Further Reading\n- P4. Object-Oriented Idioms\n  - C08. Object References, Mutability, and Recycling\n    - Variables Are Not Boxes\n    - Identity, Equality , and Aliases\n    - Copies Are Shallow by Default\n    - Function Parameters as References\n    - del and Garbage Collection\n    - Weak References\n    - Tricts Python Plays with Immutables\n    - Summary\n    - Further Reading\n  - C09. A Pythonic Object\n    - Object Representations\n    - Vector Class Redux\n    - An Alternative Constructor\n    - classmethod VS staticmethod\n    - Formatted Displays\n    - A Hashable Vector2d\n    - Private and \"Protected\" Attributes in Python\n    - Saving Space with the slots Class Attribute\n    - Overriding Class Attributes\n    - Summary\n    - Further Reading\n  - C10. Sequence Hacking , Hashing , and Slicing\n    - Vector: A User-Defined Sequence Type\n    - Vector Take #1: Vector2d Compatible\n    - Protocols and Duck Typing\n    - Vector Take #2: A Sliceable Sequence\n    - Vector Take #3: Dynamic Attribute Access\n    - Vector Take #4: Hashing and a Faster ==\n    - Vector Take #5: Formatting\n    - Summary\n    - Further Reading\n  - C11. Interfaces: From Protocols to ABCs\n    - Interfaces and Protocols in Python Culture\n    - Python Digs Sequences\n    - Monkey-Patching to Implement a Protocol at Runtime\n    - Alex Martelli's Waterfowl\n    - Subclassing an ABC\n    - ABCs in the Standard Library\n    - Defining and Using an ABC\n    - How the Tombola Subclasses Were Tested\n    - Usage of register in Practice\n    - Geese Can Behave as Ducks\n    - Chapter Summary\n    - Further Reading\n  - C12. Inheritance: For Good or For Worse\n    - Subclassing Built-In Types Is Tricty\n    - Multiple Inheritance and Method Resolution Order\n    - Multiple Inheritance in the Real World\n    - Coping with Multiple Inheritance\n    - A Modern Example: Mixins in Django Generic Views\n    - Chapter Summary\n    - Further Reading\n  - C13. Operator Overloading: Doing It Right\n    - Operator Overloading 101\n    - Unary Operators\n    - Overloading plus for Verctor Addtion\n    - Overloading star for Scalar Multiplication\n    - Rich Comparison Operators\n    - Augmented Assignment Operator\n    - Chapter Summary\n    - Further Reading\n- P5. Control Flow\n  - C14. Iterables, Iterators , and Generators\n    - Sentence Take #1 : A Sequence of Words Iterables VS Iterators\n    - Iterables Versus Itertors\n    - Sentence Take #2 : A Classic Iterator\n    - Sentence Take #3 : A Generator Function\n    - Sentence Take #4 : A Lazy Implementation\n    - Sentence Take #5 : A Generator Expression\n    - Generator Expressions : When to Use Them\n    - Another Example : Arithmetic Progression Generator\n    - Generator Functions in the Standard Library\n    - New Syntax In Python 3.3 : yield from\n    - Iterable Reducing Functions\n    - A Closer Look at the iter Function\n    - Case Study : Generators in a Databse Conversion Utility\n    - Generators as Coroutines\n    - Chapter Summary\n    - Further Reading\n  - C15. Context Managers and else Blocks\n    - Do This , Then That: else Blocks Beyond if\n    - Context Managers and with Blocks\n    - The contextlib Utilities\n    - Using @contextmanager\n    - Chapter Summary\n    - Further Reading\n  - C16. Coroutines\n    - How Coroutines Evolved from Generators\n    - Basic Behavior of a Generator Used as a Coroutine\n    - Example: Coroutine to Compute a Running Average\n    - Decorators for Conroutine Priming\n    - Coroutine Termination and Exception Handing\n    - Returning a Value from a Coroutine\n    - Using Yield from\n    - The Meaning of yield from\n    - Use Case: Coroutines for Discrete Event Simulation\n    - Chapter Summary\n    - Further Reading\n  - C17. Concurrency with Futures\n    - e.g. Web Downloads in Three Styles\n    - Blocking I/O and the GIL\n    - Launching Processes with concurrent.futures\n    - Experimenting with Executor.map\n    - Downloads with Progress Display and Error Handling\n    - Chapter Summary\n    - Further Reading\n  - C18. Concurrency with asyncio\n    - Thread VS Coroutine : A Comparison\n    - Downloading with asyncio and aiohttp\n    - Running Circling Around Blocking Calls\n    - Enhancing the asyncio downloader Script\n    - From Callbacks to Futures and Coroutines\n    - Writing asyncio Servers\n    - Chapter Summary\n    - Further Reading\n- P6. Metaprogramming\n  - C19. Dynamic Attributes and Properties\n    - Data Wrangling with Dynamic Attributes\n    - Using a Property for Attribute Validation\n    - A Proper Look at Properties\n    - Coding a Property Factory\n    - Handling Attribute Deletion\n    - Essential Attributes and Functions For Attribute Handling\n    - Chapter Summary\n    - Further Reading\n  - C20. Attribute Descriptors\n    - Desciptor Example: Attribute Validation\n    - Overriding VS Nonoverriding Descriptors\n    - Methods Are Descriptors\n    - Descriptor Usage Tips\n    - Descriptor docstring and Overriding Deletion\n    - Chapter Summary\n    - Further Reading\n  - C21. Class Metaprogramming\n    - A Class Factory\n    - A Class Decorator for Customizing Descriptors\n    - What Happens When: Import Time VS Runtime\n    - Metaclasses 101\n    - A Metaclass for Customizing Descriptors\n    - The Metaclass prepare Special Method\n    - Classes as Objects\n    - Chapter Summary\n    - Further Reading\n\n## P1. Prologue\n\n序言部分讲了很重要的一点，Python 最优秀的地方就是其统一性。\n\nPythonic 体现在使用的 Python Data Model 来表述，其途径主要编写**特殊方法 (Special/Magic Method)**\n\n- Iteration\n- Collections\n- Attribute access\n- Operator overloading\n- Function and method invocation\n- Object creation and destruction\n- String representation and formatting\n- Managed contexts (i.e., with blocks)\n\n### C01. The Python Data Model\n\n扩展阅读：http://zopeinterface.readthedocs.io/en/latest/\n\n#### A Pythonic Card Deck\n\n```python\n#### 1. 案例一：纸牌 nametuple\nCard = collections.namedtuple('Card', ['rank', 'suit'])\n# Card 是一个类\n# 重载到 Cards(object) 的 __init__ , __len__ , __getitem__\n# 重载可以之后可以使用 [] 语法 ( [0] [-1] random.choice(cards) [:3] [12::13] for in sorted reversed,sorted(cards, key=calc_score) card in cards ),\n# 还可以重载 __setitem__, 之后就可以 shuffle\n# 重载 __repr__ , __abs__ , __bool__ , __add__ , __mul__ 可以 repr() abs() bool() + *\n```\n\n#### How Special Methods Are Used\n\n```python\nobj.__len__()\nlen()\n\nobj.__\n```\n\n#### Overview of Special Methods\n\n对于内置类型 (list, str , bytearray) 解释器在调用特殊方法的时候调用 C 库，比如 CPython 实现的 len 方法一般直接会调用 PyVarObject C Struct ob_size\n\n特殊方法往往并不是显示调用，而是被隐式调用。比如 init 在 new 中的作用，比如 for item in items 世界上会调用 iter(items), 这也会隐式调用 items.**iter**() .\n\n一般当大量使用特殊方法的时候，都是在进行元编程。\n\n```python\nbool(x) 先调用 x.__bool__() , 如果 x.__bool__() 没有实现，则调用 x.__len__(), 如果为 0 则返回 False\nsorted(arr) 可以直接返回 arr，arr.sort() 是排序内部。\n```\n\n特殊方法名 （有操作符）\n\n| 种类                            | 方法名                                             |\n| ------------------------------- | -------------------------------------------------- |\n| String/Bytes                    | repr , str , format , bytes                        |\n| Conversion to number            | abs , bool , complex , init , float , hash , index |\n| Emulating collections           | len , getitem , setitem , delitem , contains       |\n| Iteration                       | iter, reversed , next                              |\n| Emulating callables             | call                                               |\n| Context management              | enter, exit                                        |\n| Instance creation \u0026 destruction | new , init , del                                   |\n| Attribute management            | getattr , getattribute , setattr , delattr, dir    |\n| Attribute descriptors           | get , set ,delete                                  |\n| Class service                   | prepare , instancecheck , subclasscheck            |\n\n特殊方法名 （无操作符）\n\n| 种类                           | 方法名                                                              |\n| ------------------------------ | ------------------------------------------------------------------- |\n| Unary numeric operators        | neg , pos , abs                                                     |\n| Rich comparison operators      | lt , le , eq , ne , gt , ge                                         |\n| Arithmetic operators           | add ,sub , mul ,truediv ,floordiv ,mod , divmod , pow , round round |\n| Reversed arithmetic operators  | radd , rsub , rmul , rtruediv, rfloordiv , rmod , rdivmod, rpow     |\n| Augmented assignment mathmatic | iadd , isub , imul , itruediv, ifloordiv                            |\n| Bitwise operators              | invert , lshift , rshift , and , or                                 |\n| Reversed bitwise operators     | rlshift , rrshift , rand , rxor , ror                               |\n| Augmented assignment bitwise   | ilshift , irshift , iand , ixor , ior                               |\n\n#### Why len Is Not a Method\n\n```python\n因为对 不同类型并不是一定调用 __len__ , 对于基本类型查看 c struct 中长度，对于其他类型直接调用 __len__ , 这种区分对待\n```\n\n## P2. Data Structure\n\n### C02. An Array of Sequences\n\nStrings, lists, byte sequences, arrays, XML elements, and database results share a rich set of common operations including iteration, slicing, sorting, and concatenation.\n\n#### Overview of Built-in Sequences\n\nC 实现的按照 item 是否为同一类型分为：\n\n- **Container sequences**: list, tuple, and collections.deque can hold items of different types.\n- **Flat sequences**: str, bytes, bytearray, memoryview, and array.array hold items of one type.\n\nC 实现按照 item 是否可修改分为：\n\n- **Mutable sequences**: list, bytearray, array.array, collections.deque, and memoryview\n- **Immutable sequences**: tuple, str, and bytes\n\n#### List Comprehensions and Generator Expressions\n\n```python\nnew_items = [func(a) for item in items]\nnew_items = [ str(x) for x in range(100) if x % 2 == 0]\nnew_items = list(map(str,list(filter(lambda x: x % 2 == 0 , list(range(100))))))\n# 可写成\nnew_items = list(map(str,filter(lambda x: x % 2 == 0 , range(100))))\n```\n\nlist 往往和 map filter 以及 listcomp 用于创建简单的序列\n\n#### Tuples Are Not Just Immutable Lists\n\n- 解包赋值\n- 不要手贱加逗号\n- 下划线可以用作临时变量 （但是 django 中下划线用于中英文）\n\n```python\na, b, *rest = range(5) # (0, 1, [2, 3, 4])\na, b, *rest = range(3) # (0, 1, [2])\na, b, *rest = range(2) # (0, 1, [])\n\na, *body, c, d = range(5) # (0, [1, 2], 3, 4)\n*head, b, c, d = range(5) # ([0, 1], 2, 3, 4)\n```\n\n- namedtuple\n\n```python\nCity = namedtuple('City', 'name country population coordinates')\ntokyo = City('Tokyo', 'JP', 36.933, (35.689722, 139.691667))\ntokyo.population\ntokyo.coordinates\ntokyo[1]\nCity._fields # tuple\n```\n\n#### Slicing\n\n为何 Slice 和 Range 会排除 最后一个 Item?\n\n书中讲的太复杂，其实这个和尺子是一个作用，尺子从 0 刻度开始，这样方便丈量。\n\n比如说：\n\n- items[0:10] 为 10 厘米\n- items[10] 为 10 刻度后一个单位，即 items[10:11]\n- items[2:] 为 2 刻度后面若干个单位\n- items[::3] 以三为单位，从 0 刻度开始，最后为结尾，每三个\n\n```\na[i, j] # 调用 a.__getitem__((i, j))\n```\n\n#### Augmented Assignment with Sequences\n\n```python\n对于不可变类型 赋值 l *= 2 在内存中则是创建了新的两个长度的元祖，然后赋值\n而由于字符串则需要注意，str_a += \"str b\" , 虽然为不可变变量，但并不需要拷贝整个字符串（特殊情况）, 但字符串的拼接建议还是\"\".join()\n\nt = (1, 2, [30, 40])\nt[2] += [50, 60]\n# 结果为既赋值成功，又报错\n# 但 t[2].extend([50, 60]) 可以赋值成功\nimport dis\ndis.dis('s[a] += b') # 可以查看字节码\n```\n\n1. 尽量不要在不可变变量内保存可变变量\n2. t[2] += [50,60] 并不是原子操作，因为，当做了一半的时候，抛出的错误。\n\n#### list.sort and the sorted Built-In Function\n\n对于 sort 和 sorted 来说，reverse 代表 desc,key 为单参数用于计算每一个值的结果的函数。\nlist.sort 直接针对列表排序，并且返回 None（出于编程习惯的问题，直接返回 None 的函数大多是对程序有一定的修改）\n\n#### Managing Ordered Sequences with bisect\n\n```python\nimport bisect\nbisect -\u003e bisect_right\nbisect_left\ninsort -\u003e insort_left\ninsort_right\n# 搜索可以用来划分档次\ndef grade(score, breakpoints=[60, 70, 80, 90], grades='FDCBA'):\n    i = bisect.bisect(breakpoints, score)\n    return grades[i]\n\n[grade(score) for score in [33, 99, 77, 70, 89, 90, 100]] # ['F', 'A', 'C', 'C', 'B', 'A', 'A']\n```\n\n#### When a List Is Not the Answer\n\nlist 是一种 mix-typed 的数据结构，即可以存放不同种类型的数据结构，由此带来的问题自然是性能问题：\n\n- list 第一是 mix-typed 的数据结构\n- 动态数组，并非数组\n\n当考虑性能的时候，则需要考虑是不是要换一个更好的数据结构：\n\n- 适用于类型单一的 array\n- 增删比较多，或者需要使用 FIFO,LIFO, 则使用 deque (double-ended queue)\n\n```python\n# Arrays\nfloats = array('d', (random() for i in range(10**7)))\n# NumPy and SciPy\n\n# Deques and Other Queue\n```\n\n#### Deques and Other Queue\n\n- Deque\n- queue 线程安全 Queue, LifoQueue, and PriorityQueue\n- multiprocessing Queue 和 JoinableQueue\n- asyncio Queue, LifoQueue, PriorityQueue, and JoinableQueue\n\n### C03. Dictionaries and Sets\n\n本章内容：\n\n- Common dictionary methods\n- Special handling for missing keys\n- Variations of dict in the standard library\n- The set and frozenset types\n- How hash tables work\n- Implications of hash tables (key type limitations, unpredictable ordering, etc.)\n\n##### Generic Mapping Types\n\nHashable ? 一个 obj 的 hash value 在他生命周期内 hash value 是不变的。一个 frozen set 也是 hashable 的（包括每个子元素）.\n\n\u003e All of Python’s immutable built-in objects are hashable , except that tuple\n\u003e 如果一个 tuple 是每个子元素都是 hashable 的话，则该 tuple 也是 hashable 的。\n\n```bash\n# 直接在 dict 上面进行操作\nindex.setdefault(word, []).append(location)\n```\n\n##### missing 方法\n\nkeyerror 会触发 missing 方法\n\n##### Variations of Dict\n\nOrderedDict - 有序字典\nChainMap - 组装多个字典，按照次序搜索\nCounter - COUNTER\n\n##### Immutable Mappings\n\n##### Set Theory\n\n交差并补\n\n```python\n# 1. 交集\ns \u0026 z\nz \u0026 s\ns \u0026= z\n# 2. 差集\ns - z\nz - s\ns -= z\n# 3. 并集\ns | z\nz | s\ns |= z\n# 4. 补集\ns ^ z\nz ^ s\ns ^= z\n\n# 被包含\ne in z\n\n# 子集\ns \u003c= z\ns =\u003e z\n```\n\n##### Dict and Set Under the Hood\n\n### C04. Text VS Bytes\n\n     - Character Issues\n     - Byte Essentials\n     - Basic Encoders/Decoders\n     - Understanding Encode/Decode Problems\n     - Handling Text Files\n     - Normalizng Unicode for Saner Comparisons\n     - Sorting Unicode Text\n     - The Unicode Database\n     - Dual-Mode str and bytes APIs\n     - Summary\n     - Further Reading\n\n## P3. Function as Objects\n\nfunction is the first-class object\n\nHigher-Order Functions\n\n- 设计模式\n- 装饰器\n- callables\n- function attributes\n- introspection\n- parameter annotations\n- nonlocal declaration\n\n- references, mutability, 实例生命周期，定制自己集合类 collections and ABCs, 多继承，重载操作符。\n\n- 生成器\n- 上下文管理器\n- 协程 （包括 Yield)\n- concurrency\n- event-oriented IO asyncio\n\n- 动态创建类\n- descriptors\n- class decorators\n- metaclasses\n\n### C05. First-Class Function\n\n     - Treating a Function Like an Object\n     - Higher-Order Functions\n     - Anonymous Functions\n     - The Seven Flavors of Callable Objects\n     - User-Defined Callable Types\n     - Function Introspection\n     - From Positional to Keyword-Only Parameters\n     - Function Annotations\n     - Packages for Functional Programming\n     - Summary\n     - Further Reading\n\n### C06. Design Patterns with First-Class Functions\n\n     - Refactoring Strategy\n     - Command\n     - Summary\n     - Further Reading\n\n### C07. Function Decorators and Closures\n\n     - Decorators 101\n     - When Python Executes Decorators\n     - Decorator-Enhanced Strategy Pattern\n     - Variable Scope Rules\n     - Closures\n     - The nonlocal Declaration\n     - Implementing a Simple Decorator\n     - Decorators In the Standard Library\n     - Stacked Decorators\n     - Parameterized Decorators\n     - Summary\n     - Further Reading\n\n## P4. Object-Oriented Idioms\n\n### C08. Object References, Mutability, and Recycling\n\nreference variable : variable 不是盒子，贴在盒子上的标签。\n\n赋值并非创建 Copy\n赋值给一个值并非改变之前绑定的值，而仅仅是重新绑定 rebinding\n函数由于参数为 reference, 所以可以修改 mutable 的变量\n函数参数不应当初始化为可修改的值。\n\nid 与 == : 内存值 和 值相等\ncopy 默认是浅拷贝\n函数参数是引用\nGC 使用的引用计数，通过 weakref.finalize 可以增加 obj 被回收的回调函数\n强引用和弱引用，weakref 具体使用场景？ https://pymotw.com/3/weakref/\nOne example is a class that wants to keep track of all its current instances. This can be done with weak references, a low-level mechanism underlying the more useful collections WeakValueDictionary, WeakKey Dictionary, WeakSet, and the finalize function from the weakref module.\n公用字符串字面量和小的数的技巧叫做 interning\n\nPS:\n\n```\n在 IPython 中 _ 为某个表达式返回的值\n```\n\n     - Weak References\n     - Tricts Python Plays with Immutables\n     - Summary\n     - Further Reading\n\n### C09. A Pythonic Object\n\n     - Object Representations\n     - Vector Class Redux\n     - An Alternative Constructor\n     - classmethod VS staticmethod\n     - Formatted Displays\n     - A Hashable Vector2d\n     - Private and \"Protected\" Attributes in Python\n     - Saving Space with the slots Class Attribute\n     - Overriding Class Attributes\n     - Summary\n     - Further Reading\n\n### C10. Sequence Hacking , Hashing , and Slicing\n\n     - Vector: A User-Defined Sequence Type\n     - Vector Take #1: Vector2d Compatible\n     - Protocols and Duck Typing\n     - Vector Take #2: A Sliceable Sequence\n     - Vector Take #3: Dynamic Attribute Access\n     - Vector Take #4: Hashing and a Faster ==\n     - Vector Take #5: Formatting\n     - Summary\n     - Further Reading\n\n### C11. Interfaces: From Protocols to ABCs\n\n     - Interfaces and Protocols in Python Culture\n     - Python Digs Sequences\n     - Monkey-Patching to Implement a Protocol at Runtime\n     - Alex Martelli's Waterfowl\n     - Subclassing an ABC\n     - ABCs in the Standard Library\n     - Defining and Using an ABC\n     - How the Tombola Subclasses Were Tested\n     - Usage of register in Practice\n     - Geese Can Behave as Ducks\n     - Chapter Summary\n     - Further Reading\n\n### C12. Inheritance: For Good or For Worse\n\n     - Subclassing Built-In Types Is Tricty\n     - Multiple Inheritance and Method Resolution Order\n     - Multiple Inheritance in the Real World\n     - Coping with Multiple Inheritance\n     - A Modern Example: Mixins in Django Generic Views\n     - Chapter Summary\n     - Further Reading\n\n### C13. Operator Overloading: Doing It Right\n\n\u003e 依据我的经验。除非特别适合，比如说矩阵相加，否则不要进行操作符重载。 因为 加减乘除之类的操作符本身就容易有二义性。\n\n## P5. Control Flow\n\n### C14. Iterables, Iterators , and Generators\n\n     - Sentence Take #1 : A Sequence of Words Iterables VS Iterators\n     - Iterables Versus Itertors\n     - Sentence Take #2 : A Classic Iterator\n     - Sentence Take #3 : A Generator Function\n     - Sentence Take #4 : A Lazy Implementation\n     - Sentence Take #5 : A Generator Expression\n     - Generator Expressions : When to Use Them\n     - Another Example : Arithmetic Progression Generator\n     - Generator Functions in the Standard Library\n     - New Syntax In Python 3.3 : yield from\n     - Iterable Reducing Functions\n     - A Closer Look at the iter Function\n     - Case Study : Generators in a Databse Conversion Utility\n     - Generators as Coroutines\n     - Chapter Summary\n     - Further Reading\n\n### C15. Context Managers and else Blocks\n\n     - Do This , Then That: else Blocks Beyond if\n     - Context Managers and with Blocks\n     - The contextlib Utilities\n     - Using @contextmanager\n     - Chapter Summary\n     - Further Reading\n\n### C16. Coroutines\n\n     - How Coroutines Evolved from Generators\n     - Basic Behavior of a Generator Used as a Coroutine\n     - Example: Coroutine to Compute a Running Average\n     - Decorators for Conroutine Priming\n     - Coroutine Termination and Exception Handing\n     - Returning a Value from a Coroutine\n     - Using Yield from\n     - The Meaning of yield from\n     - Use Case: Coroutines for Discrete Event Simulation\n     - Chapter Summary\n     - Further Reading\n\n### C17. Concurrency with Futures\n\n     - e.g. Web Downloads in Three Styles\n     - Blocking I/O and the GIL\n     - Launching Processes with concurrent.futures\n     - Experimenting with Executor.map\n     - Downloads with Progress Display and Error Handling\n     - Chapter Summary\n     - Further Reading\n\n### C18. Concurrency with asyncio\n\n     - Thread VS Coroutine : A Comparison\n     - Downloading with asyncio and aiohttp\n     - Running Circling Around Blocking Calls\n     - Enhancing the asyncio downloader Script\n     - From Callbacks to Futures and Coroutines\n     - Writing asyncio Servers\n     - Chapter Summary\n     - Further Reading\n\n## P6. Metaprogramming\n\n### C19. Dynamic Attributes and Properties\n\n     - Data Wrangling with Dynamic Attributes\n     - Using a Property for Attribute Validation\n     - A Proper Look at Properties\n     - Coding a Property Factory\n     - Handling Attribute Deletion\n     - Essential Attributes and Functions For Attribute Handling\n     - Chapter Summary\n     - Further Reading\n\n### C20. Attribute Descriptors\n\n     - Desciptor Example: Attribute Validation\n     - Overriding VS Nonoverriding Descriptors\n     - Methods Are Descriptors\n     - Descriptor Usage Tips\n     - Descriptor docstring and Overriding Deletion\n     - Chapter Summary\n     - Further Reading\n\n### C21. Class Metaprogramming\n\n     - A Class Factory\n     - A Class Decorator for Customizing Descriptors\n     - What Happens When: Import Time VS Runtime\n     - Metaclasses 101\n     - A Metaclass for Customizing Descriptors\n     - The Metaclass prepare Special Method\n     - Classes as Objects\n     - Chapter Summary\n     - Further Reading\n\n## 相关链接\n\n- https://docs.python.org/3/reference/datamodel.html\n- Python Cookbook\n- Python Essential Reference, 4th Edition\n- The Art of the Metaobject Protocol\n\nUPDATE:\n\n| 日期           | 类型 | 详细操作           |\n| -------------- | ---- | ------------------ |\n| **2017-04-18** | 动笔 | 初始化本文结构     |\n| **2017-04-26** | 重构 | 添加目录和阅读笔记 |\n"}],"total":2},{"name":"2017-02","posts":[{"tags":["书单"],"path":"20170201_读书笔记_好好说话.md","title":"『好好说话』读书笔记","slug":"『好好说话』读书笔记","date":"2017-02-01","category":"读书笔记","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n#『好好说话』读书笔记\n\n## 说话是权利的游戏\n\n当时看到奇葩说这个节目就深深的喜欢上了这群打辩论的顶级高手们。\n\n于是，当这些奇葩的辩论王者们出了『好好说话』的语音教程的时候，就非常开心的入手了。现在出了纸质书，像我这种不是特别聪明的人自然是要好好的拿来研究一番，于是诞生了本文。本文是我的公开的笔记，私人的笔记就不分享了。\n\n好好说话有语音版和文字版。建议购买。很多技能都不重要，早一点学迟一点学基本上都没有问题，但是说话是为数不多的，不学就非常可惜的早学可以少走很多麻烦的。\n\n\u003e 真心建议买正版，为优秀的知识付费是追求上进的人的基本素质。\n\n世界上需要交智商税的东西真的特别多，但是说话这种东西一般情况下交的智商税的特别的高：\n\n\u003c!-- more --\u003e\n\n就像在书籍第一章开头所说，说话之伤都是暗伤。\n\n\u003e 能意识到你问题所在的，通常都不会告诉你。心大点的，察人之过笑而不言，但是私下里知道你这个人不靠谱，以后有重要的事不能指望你，就会疏远你；心稍微小点的，不跟你计较，但是客客气气找个别的由头举了你；等而下之的人的，甚至会一边给你穿小鞋一边装大度，让你死都没有四个明白。\n\n回想起我前 25 年的很多糟糕的言行，现在想想，当时总归是可以有更优解的。\n\n但仔细一想，似乎寻常人总会去踩这些坑，吃过很多教训，才能明白。\n\n## 说话是权利的游戏\n\n五维话术：演讲，沟通，说服，谈判，辩论。\n\n- 演讲 A -- 权力的形成（吸引，聚焦，引导）\n- 沟通 B -- 权力的流动（避免冲突与协调转向）\n- 说服 C -- 权力在对方（无权的一方要改变有权的一方）\n- 谈判 D -- 权力在双方（双方要合作，才能解决问题）\n- 辩论 E -- 权力在他方（双方无权决定胜负，通常由中立第三方裁决）\n\n这里面的纬度，并不是每一个场景下就对应某一纬度的，比如说，当你在沟通的时候，有的时候就也需要说服，有的时候又需要辩论，甚至谈判。\n\n所以，每一场复杂的说话场景实际上是在不断的变化当中，甚至可以用矢量 (A,B,C,D,E,T) 其中 T 表示的是 Times 次数。即以 A 为演讲值，MAX 为 10,MIN 为 0 的情况下，第 T 次演讲的说法应该为 (A,B,C,D,E), 比如 (2,3,4,9,0) 表示此次对话应该着重于谈判.P20 有一个非常有趣的说明叫做色有三原，光分七彩。\n\n温和的的沟通，可能蕴含着辩论的机锋和谈判的策略；\n娓娓道来的说服可能需要演讲的华彩的沟通的诀窍。\n\n而好好说话的工作流就是\n\nS1. 倾听 For 收集信息\nS2. 判断 For 权力棍术\nS3. 思考 For 应对之策 说话策略需要依据权力（大小）, 态度（反对 / 赞同）, 成本（低 / 高）, 方向（单向 / 双向）, 受众（多 / 少）\nS4. 表达 For 语言输出，然后转 S1\n"}],"total":1},{"name":"2017-01","posts":[{"tags":["书单"],"path":"20170127_读书笔记_与时间做朋友.md","title":"『把时间当做朋友』读书笔记","slug":"『把时间当做朋友』读书笔记","date":"2017-01-27","category":"读书笔记","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 前言\n\n我大一的时候看到的这本书的第一版。转眼大四毕业半年了。\n\n这本书对我有很大积极的作用，大一时候很庆幸读到这本书籍，当时一读这本书，就像一个溺水的人抓到了一个水面上的一根稻草，以为『明白一个道理，于是突然间就主角光环加深，从此走向人生巅峰』。当时可能是因为年轻气盛见识少，待我见识稍稍多了那么一点点之后，也就逐渐可以对成功学类的鸡汤脱敏。这里的脱敏指的是可以减少过度情绪化的理解，从句子中逐渐剥离感性的煽情的句子，慢慢的从稍稍理性的一些角度进行理解。\n\n这本书放在公网上，并不需要购买即可免费查看，但，值得一提的是，第三版在排版上下足了功夫。阅读体验很好。推荐购买纸质书。\n\n我是一个认为『术』重于『道』的人。『道』意味着对『术』进行抽象总结，并且艺术化的语言进行诠释，这个过程难保没有信息的损失。\n\n这本书在四年后看的今天，依然读出了很多不一样的味道，这种惊喜恰如第一次读到这本书的时候那般惊奇。\n\n\u003c!-- more --\u003e\n\n\u003e 四年前，我看了这本书，相信自己的积累终究会有一天有所回报。\n\n现在想想，很多李老师说的道理也有道理本身的局限性，道理一旦脱离于扎根这些道理的土壤，就显得很没有道理，李笑来提到：\n\n- 速成绝无可能\n- 交换才是硬道理\n- 完美永不存在\n- 未知永远存在\n- 现状永远无法摆脱\n\n这些话的正确性在于如何定义速成，如何定义交换，如何定义完美，如何定义未知，如何定义摆脱现状。放在李老师列举的几个例子来说是成立的，但是放在其他的例子里面则是不成立的。\n\n比如说，『速成绝无可能』：\n\n\u003e 拿我自己举例子，我本身已经学会了几门编程语言，再学另一门编程语言，那仅仅是多看几天编程手册的事情。几天学会一门编程语言这叫不叫速成呢？一两天学会另一个数据库这叫不叫速成呢？有的人可是要花好几周呢？你会说，这并不见得，你这是主场，你这是在同一个领域里面学习。这种情况不应该叫做速成。那，举个其他的例子，写代码这个过程涉及到大量的推导和不断的修正自己的方法，这让我学一门新的编程类技术或者非编程类技术的过程中有很强的 common sense, 这个过程也是事半功倍的，那这算不算速成呢？\n\n在本书中，对于『时间管理』, 这个词本来就不是管理时间的流动的，而是管理自己对于时间的开销。可，李老师反倒说：时间本来就不服从于每个人的管理，你只能选择和时间做朋友。\n\n\u003e 可，我只想对**我的时间开销**进行合理安排.**我没有控制时间的想法呀**!\n\n当然，瑕不掩瑜，我认为这本书除了重要的内容是那些『术』而非那些『道』. 没有人不懂道，也没有人不懂道理，只是道理本身具备相当大的局限性罢了。\n\n### 目录\n\n通常情况下，看一本『自我成长』类书籍，看他的目录就能了解这本书的讲解思路。\n\n困境 - 醒悟 - 现实 - 管理 - 学习 - 思考 - 交流 - 应用 - 积累\n\n几天读下来，私以为最有价值的部分为**管理 - 学习 - 思考 - 交流**这四个章节，这四个章节多看几遍，其他大略看看便好。\n\n以下便是我的一些零散的笔记。\n\n### 第 0 章：困境\n\n首先是发现时间不够用（问题）, 接着是尝试改变但却时间压力导致自己即勤奋又懒惰（慌乱）显得『用战术上的勤劳掩盖战略上的懒惰』, 我们尝试去管理时间，但是却无法管理好时间，于是李老师提出『我们无法管理时间，只能管理自己』，怎么管理自己？李老师给出的答案是『必须要看清楚、想明白『问题出在自己身上』, 而解决就只能靠积累』。\n\n\u003e 番外：为什么是第 0 章呢？因为程序员从零计数，而李笑来老师是一个 Geek 范十足的人。而且，概述放在第 0 章，我觉得也蛮有意义的。\n\n从第 0 章可以看出这本书围绕着：运用心智获得解放\n\n其实个人觉得这本书的这个副标题 -- 运用心智获得解放倒是非常适合作为本书的标题，因为论概括性比把时间当做朋友显得更加的契合本书的内容。当然，做销售出身的李老师肯定也知道，这个副标题没有多大吸引力，至少没有把时间当做朋友那么有吸引力。\n\n### 第 1 章：醒悟\n\n定义了孰主孰仆：不要跟着感觉走，翻身做大脑的主人\n\n\u003e 举了『一个锤子不能砸自身，钉子不能砸自身，但人脑可以修正自身的想法（元思考）来说明人脑的高级』的例子。放在一起总觉得怪怪的。举一个不恰当的例子：耳机可以通过不断的播放音乐来使得耳机音质得到大量的提升，这个过程叫做煲耳机，而超过一定使用期限之后，耳机的音质就会有所下降。我觉得耳机也是一个通过不同使用自身进行发声并且使得自己的发出的声音更加美妙的东西呢。\n\n定义了何为心智：一个人心智就是其过往获得的一切的知识与经验的总和。\n\n\u003e 举了一个聪明人办傻事，还振振有词，义正辞严，双目炯炯的例子。我甚至会怀疑是否本来人家能接受意见，反而因为当众揭露出来，因而在内心里抵触别人意见。当然，缺乏具体的场景，我也无从判断。只能假设，这个倒霉的聪明蛋说的是那种很大的自以为振振有词的话了。\n\n李老师举了自己学了计算机，盲打，统计，做销售，英语的例子来说明一些道理。PS: 不得不说，在 90 年代学到了这些先进的，time saving 的东西真的是让人非常的羡慕。\n\n\u003e 然后说了一个和乔布斯学习书法一样的道理，并且加以升华：『因为不知道那东西有什么用而决定去学』和『因为不知道那东西有什么用而决定不去学』, 前者在实践中越发相信技多不压身，后者只能感叹技到用时方恨少。（当然，与此同时，相信技多不压身的人往往也会陷入同时学习多个技能从而导致处处平庸的误区.)\n\n### 第 2 章：现实\n\n- 速成绝无可能\n- 交换才是硬道理\n- 完美永不存在\n- 未知永远存在\n- 现状无法马上摆脱\n\n关于速成，李老师这么说：人本质上就容易对那些在**短时间**内能让自己满足的事物产生依赖，并且全然不顾事实上对自己的影响是好是坏，比如：\n\n- 依赖打游戏来满足自己的成就感\n- 『今天那么累了就大吃一顿吧』\n\n然而，在很多领域，之所以相信有速成之法，多少因为之前的老师教的太烂。相信速成之法的聪明人，只是寻找一个更好的学习路径而已。相反，很多人看书不去看一下评论，不 Google 一下，不去征求一下该领域的牛人的意见，上来就一阵瞎折腾，这不也是一种『既勤劳又懒惰』的人么？\n\n第二章总结：\n\n- 你得有耐心接受现状有耐心，接受自己的不完美，有耐心接受未知。\n- 你得有所积累才能有资本。\n- 相信我，你并不孤独。\n\n其实整本书籍讲的都是不要急，慢慢来。\n\n### 第 3 章：管理\n\n第三章叫做管理，一本书终于进入了干货期，特别是打电话这个流程总结的相当不错，不是很清楚打电话这个是不是商务人士的常识，但的的确确让我也注意到了一些细节其实可以处理的更加完美。\n\n1. 凭什么确定现在就可以接电话？发条短信问问对方是否方便\n2. 想清楚，对照着清单进行沟通。防止漏掉关键信息。\n3. 工作电话，对方未接，显示的是工作总机。应该发消息到对方手机。\n4. 交代自己是谁！\n5. 对方没有纸和笔怎么办？善意提醒对方可以邮件发个备忘。\n\n\u003e 处处留心皆学问。\n\n至于记录时间的方法，曾经尝试过一段时间，没有坚持下来，个人觉得并不适用于我。\n\n至于制定计划的注意点，其实李老师说的其实就是 SMART 法则吧：\n\n1. 目标是具体的 (Specific)\n2. 可以衡量的 (Measurable)\n3. 可以达到的 (Attainable)\n4. 要与其他目标具有一定的相关性 (Relevant)\n5. 具有明确的截止期限 (Time-bound)\n\n### 第 4 章：学习\n\n- 1.  效率本质\n  - 1.2. 学习有效率的东西才是王道\n- 2.  基本途径\n  - 2.1. 体验 / 试错 / 观察 / 阅读\n- 3.  主要手段\n  - 3.1. 科学方法\n- 4.  经验局限\n  - 4.1. 个体经验有限\n  - 4.2. 群体经验有限\n  - 4.3. 与现有知识相悖的知识\n- 5.  自学能力\n  - 5.1. 基础阅读能力\n  - 5.2. 检索能力（基于阅读能力）\n  - 5.3. 写作能力（写出简洁，有效，准确，朴素，具体的文字记录自己的只是和经验）\n  - 5.4. 实践能力是自学能力最终转化为真正价值的根本。\n  - 5.5. 保持开放的心态 记录下不能苟同的言论，定期想想原因\n\n学习，就是为了提高效率。这与李老师主张的实用主义非常吻合。从四个基本途径（体验 / 试错 / 观察 / 阅读）入手，并介绍了主要手段即科学方法。接着介绍经验局限如何自学能力。\n\n有趣的东西在于科学方法。\n\n所谓科学方法，用于求索科学问题还是很有意义的，可是用于解决日常生活中的问题，多多少少显得过于书生气。\n\n\u003e 对于科学界已经确定的结论，经过严密的科学方法来验证，那些是值得相信的。比如进化论，现代医学，科学结论。\n\n能不能说科学探索出来的就一定是正确的呢？不见得，但是经过严密推导后或者是严谨的双盲测试的结论则是非常值得去相信的，如果错了，那就只能认了。如果严谨的科学探究都能出错，那也属于\"天亡我，我何辞为？\".\n\n\u003e 然而，遗憾的是，更多的问题则是没有足够的素材来验证这个道理是否属于真理，我们遵循**科学方法**估计得出的也就是假想。甚至来不及验证，机会就溜走了。\n\n### 第 5 章：思考\n\n第五章是最有意义的一章，这是李老师特别擅长的思考，所以每次读都可以发现有趣的东西，比如，李老师定义的勤于思考 -- **只不过是从别人那里知道一个结论的时候，自己动脑重新推演一遍，看看得出的结论的过程有没有漏洞和不合理的地方，衡量一下结论到底有没有道理的过程。**\n\n\u003e 至于勤于思考的原因却是，我们也处于一个信任成本极高的社会。\n\n接着李老师举出两个思维陷阱：\n\n- 概念不清\n- 拒绝接受不确定性\n\n概念不清的人往往分不清目标与计划、 科学科普与科普作者 \\ 历史与历史课 \\ 上学与学习\n\n拒绝接受不确定性的人就会往两个方向发展要么选择相信鬼神要么擅长使用二分法强行得出答案。\n\n很多人也分不清相关性和因果性：\n\n其实确立思考的方案也很简单，如果别人给了你一个**因为 A, 所以 B**：\n\n- A 不一定是 B 的理由\n- A 不一定是 B 唯一的理由\n- A 不一定是 B 最重要的理由\n- A 可能是促进了 B ,B 也反过来促进了 A, 两者相互促进，互为因果。\n\n举个例子：\n\n\u003e 有个人说：程序员只能去北京才能混得好。\n\n想清楚这句话有没有道理很简单：\n\nSTEP1. 确立他说的因果关系：因为程序员去北京混，所以混得好。\nSTEP2. 想想混的好的原因真的是因为去北京混吗？去上海就一定不行咯？北京的程序员就一定混得好咯？\nSTEP3. 想想混的好的原因的唯一理由是因为去北京混吗？不去北京就一定不行咯？\nSTEP4. 想想混的好的原因的最重要的理由是因为去北京混吗？如果不去北京还想混得好，还有什么方法呢？\n\n命题的四种概念：\n\n1. 因为 A, 所以 B\n2. 因为~A, 所以~B\n3. 因为~B, 所以~A\n4. 因为 B, 所以 A\n\n\u003e 很早接触这个概念，虽然至今用的还是不熟，但这四个概念真的是写段子的强行混淆概念的好概念啊。\n\n### 第 6 章 交流\n\n- 学会倾听\n- 说与不说\n- 交流守则\n- 正确复述\n- 勤于反思\n\n这一章也值得反复多看几遍，即便不能理解，一本正经的引用牛人的话也是提升谈资，满足自身小虚荣的重要手段。\n\n有趣的是交流守则：\n\n- 对话的目的是寻求真理，不是为了斗争。\n- 不做人身攻击。\n- 保持主题。\n- 辩论时要用证据。\n- 不要坚持错误不改。\n- 要分清对话与只准自己讲话的区别。\n- 对话要有记录。\n- 尽量理解对方。\n\n当然，有的时候别人会进行反驳，而注意双方的反驳层次也是很有用的（书中未提）:\n\nPaul Graham《How to Disagree》值得一看 http://www.zreading.cn/archives/4137.html\n\n引用李老师的话：\n\n\u003e 如果我们作为讨论的一方，发现对方已经不再“遵守理性讨论基本原则”，那么就马上停止讨论吧，因为我们已经失去了讨论的对象。就算对方不依不饶，我们也应该回避回避再回避，因为任何接下去的过程都已经不再是“讨论”，而更可能是仅仅为争而争的“争论”了。这种争论的害处很多，比如浪费时间，比如影响情绪，比如把对方变成敌人，比如失去更多朋友……\n\n## 总结\n\n读到这本书之后，确实让我不安宁了好一阵子，因为这让我真真确确的感受到了自己对时间的浪费，对自己精力的浪费。这些东西原本可以使我变得更好。\n\n四年后，重读这本书，依旧让我收获颇深，至于前面部分的挑刺，也仅仅是耍耍小聪明而已，挑刺很容易，建立体系并不那么简单。\n\n遇见有趣的书，就如同遇见一个有趣的人一样。\n\n所有的遇见，都是久别重逢，只叹相见恨晚。\n\n感谢毕业后的第一个春节假期的都让我不断补充新知识不停止学习的步伐的公司，让我在大年初二完成这篇读书笔记。\n"},{"tags":["书单"],"path":"20170201_读书笔记_如何阅读一本书.md","title":"『如何阅读一本书』读书笔记","slug":"『如何阅读一本书』读书笔记","date":"2017-01-27","category":"读书笔记","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 前言\n\n选择了这本书进行精读是有原因的：\n\n\u003e 在一个需要大量阅读的时代里，读东西更加有策略。\n\n记得大约是初三的考试比赛，监考老师发了卷子，我们这些人拿到卷子捋起袖子就是写，而监考老师说了一句话：\n\n\u003e 先看看卷子，然后再写，不要上来就做题。\n\n虽然那次考试并不算理想，最大的收获应该就是这句话。\n\n\u003e 通过'先预估，然后再做'的意识，我应该是少走了一些弯路的。至少工作效率稍微提升了一些。\n\n但，有了这个先预估一下，然后再做的意识可以减少很多问题，然而并不能更好解决的问题。因为意识这玩意，不是方法，不是策略。知道考虑火候，不懂得把握火候照样做不出好菜。\n\n\u003c!-- more --\u003e\n\n对应到我看这本书的目的，即是，当需要我能在捋起袖子干之前，找到一个更好的策略，对读书，有一个更好的方法。而不是仅仅是埋下头一通看。\n\n也是为了给自己更好的啃源码，看文档激发一些更好的灵感。\n\n这是从非专业领域里面找灵感的一种方式，即所谓：汝果欲学诗，工夫在诗外。\n\n## 本文目录\n\n\u003c!-- markdown-toc start - Don't edit this section. Run M-x markdown-toc-generate-toc again --\u003e\n\n**Table of Contents**\n\n- [-](#-)\n- [本文目录](#本文目录)\n- [《如何阅读一本书》目录简评](#如何阅读一本书目录简评)\n- [问与答](#问与答)\n  - [CQ1: 本书整体讲了什么？](#cq1- 本书整体讲了什么)\n  - [SQ1: 较好的阅读一本书的步骤](#sq1- 较好的阅读一本书的步骤)\n    - [确定要补充那些知识 / 技能体系](#确定要补充那些知识 -- 技能体系)\n    - [筛选书籍阶段 : 过滤不适合的书](#筛选书籍阶段 -- 过滤不适合的书)\n    - [检视阅读阶段 : 判断一本书的质量](#检视阅读阶段 -- 判断一本书的质量)\n      - [检视阅读阶段 STEP1 : 大体定位这本书。](#检视阅读阶段 -step1-- 大体定位这本书)\n      - [检视阅读阶段 STEP2 :](#检视阅读阶段 -step2-)\n      - [检视阅读的一些误区：](#检视阅读的一些误区：)\n      - [分析阅读阶段 : 全方位吃透这本书](#分析阅读阶段 -- 全方位吃透这本书)\n        - [分析阅读第一阶段：找出一本书在谈写什么的规则](#分析阅读第一阶段：找出一本书在谈写什么的规则)\n        - [分析阅读第二阶段：诠释一本书的内容的规则。](#分析阅读第二阶段：诠释一本书的内容的规则)\n        - [分析阅读第三阶段：评论一本书的规则](#分析阅读第三阶段：评论一本书的规则)\n      - [主题阅读阶段 : 纳入自己的知识体系](#主题阅读阶段 -- 纳入自己的知识体系)\n  - [SQ2: 上面关于阅读一本书的步骤是适用于所有书，即使通用的步骤吗？](#sq2- 上面关于阅读一本书的步骤是适用于所有书即使通用的步骤吗)\n    - [分析阅读之如何阅读实用型的书](#分析阅读之如何阅读实用型的书)\n    - [分析阅读之如何阅读历史书](#分析阅读之如何阅读历史书)\n  - [SQ3: 关于读书的有哪些误区](#sq3- 关于读书的有哪些误区)\n    - [速读](#速读)\n    - [随便翻翻](#随便翻翻)\n    - [陷入细枝末节](#陷入细枝末节)\n  - [EQ1: 为什么要**重新学习**如何阅读书籍的策略与方法](#eq1- 为什么要重新学习如何阅读书籍的策略与方法)\n- [相关链接](#相关链接)\n\n\u003c!-- markdown-toc end --\u003e\n\n## 《如何阅读一本书》目录简评\n\n本书的翻译版书籍的目录如下：\n\n- 第一篇：阅读的层次\n  - ch01: 阅读的活力与艺术\n  - ch02: 阅读的层次\n  - ch03: 阅读的第一个层次：基础阅读\n  - ch04: 阅读的第二个层次：检视阅读\n  - ch05: 如何做一个自我要求的读者\n- 第二篇：阅读的第三个层次：分析阅读\n  - ch06: 一本书的分类\n  - ch07: 透视一本书\n  - ch08: 与作者找出共通的词义\n  - ch09: 判断作者的主旨\n  - ch10: 公正的评断一本书\n  - ch11: 赞同或反对作者\n  - ch12: 辅助阅读\n- 第三篇：阅读不同读物的方法\n  - ch13: 如何阅读实用型的书\n  - ch14: 如何阅读想象文学\n  - ch15: 阅读故事，戏剧，诗的一些建议\n  - ch16: 如何阅读历史书\n  - ch17: 如何阅读科学和数学\n  - ch18: 如何阅读哲学书\n  - ch19: 如何阅读社会科学\n- 第四篇：阅读的最终目标\n  - ch20: 阅读的第四个层次：主题阅读\n  - ch21: 阅读与心智的成长\n\n这本书的目录看起来比较奇怪，分为四个部分，但是第一篇和第二篇分类比较混乱，ch03,ch04, 第二篇，ch20 不是应该是同一级嘛？\n\n以为找英文原版的目录拿来对照，译者还是严格的遵守了原文目录的排布。\n\n译者把**Part**翻译为**篇**, 我觉得就直接翻译为**部分**比较好。整理目录，补充一部分 Part,Chapter,Section 的标题。\n\n于是做了点体力活，把英文书籍的目录部分搬运过来。\n\n- 第一篇：阅读的层次 \u003cThe Dimensions of Reading\u003e\n  - ch01: 阅读的活力与艺术 \u003cThe Activity and Art of Reading\u003e\n    1.  Active Reading\n    2.  The Goals of Reading: Reading for Information and Reading for Understanding\n    3.  Reading as Learning: The Difference Betweenn Learning By Instruction and Learning by Instruction and Learning by Discovery\n    4.  Present and Absent Teachers\n  - ch02: 阅读的层次 \u003cThe Levels of Reading\u003e\n  - ch03: 阅读的第一个层次：基础阅读 \u003cThe First Level of Reading: Elementary Reading\u003e\n    1.  Stages Of Learning to Read\n    2.  Stages and Levels\n    3.  Higher Levels of Reading and Higher Education\n    4.  Reading and the Democratic Ideal of Education\n  - ch04: 阅读的第二个层次：检视阅读 \u003cThe Second Level of Reading: Inspectional Reading\u003e\n    1.  Inspectional Reading I: Systemmatic Skimming or Pre-reading\n    2.  Inspectional Reading II: Superficial Reading\n    3.  On Reading Speeds\n    4.  Fixations and Regressions\n    5.  The Problem of Comprehension\n    6.  Summary of Inspectional Reading\n  - ch05: 如何做一个自我要求的读者 \u003cHow to Be a Demanding Reader\u003e\n    1.  The Essence of Active Reading: The Four Basic Questions a Reader Asks\n    2.  How to Make a Book Your Own\n    3.  The Three Kinds of Note-making\n    4.  Forming the Habit of Reading\n    5.  From Many Rules to One Habit\n- 第二篇：阅读的第三个层次：分析阅读 \u003cThe Third Level Of Reading: Analytical Reading\u003e\n  - ch06: 分类一本书 \u003cPigeonholing a Book\u003e\n    1.  The Importance of Classifying Books\n    2.  What You Can Learn from the Title of a Book\n    3.  Practical vs. Theoretical Books\n    4.  Kinds of Theoretical Books\n  - ch07: 透视一本书 \u003cX-raying a Book\u003e\n    1.  Of Plots and Plans: Stating the Unity of a Book\n    2.  Mastering the Multiplicity: The Art of Outlining a Book\n    3.  The Reciprocal Arts of Reading and Writing\n    4.  Discovering the Author's Intentions\n    5.  The First Stage of Analytical Reading\n  - ch08: 与作者找出共通的词义 \u003cComing to Terms with and Author\u003e\n    1.  Words vs. Terms\n    2.  Finding the Key Words\n    3.  Technical Words and Special Vocabularies\n    4.  Finding the Meanings\n  - ch09: 判断作者的主旨 \u003cDeterming an Author's Message\u003e\n    1.  Sentences vs. Propositions\n    2.  Finding the Key Sentences\n    3.  Finding the Arguments\n    4.  Finding the Solutions\n    5.  The Second Stage of Analytical Reading\n  - ch10: 公正的评断一本书 \u003cCritizing a Book Fairly\u003e\n    1.  Teachability as a Virtue\n    2.  The Role of Rhetoric\n    3.  The importance of Suspending Judgement\n    4.  The Importance of Avoiding Contentiousness\n    5.  On the Resolution of Disagreements\n  - ch11: 赞同或反对作者 \u003cAgreeing or Disagreeing with an Author\u003e\n    1.  Prejudice and Judgment\n    2.  Judging the Author's Soundness\n    3.  Judging the Author's Completeness\n    4.  The Third Stage of Analytical Reading\n  - ch12: 辅助阅读 \u003cAids to Reading\u003e\n    1.  The Role Of Relevant Experience\n    2.  Other Books as Extrinsic Aids to Reading\n    3.  How to Use Commentaries and Abstracts\n    4.  How to Reference Books\n    5.  How to Use a Dictionary\n    6.  How to Use an Encyclopedia\n- 第三篇：阅读不同读物的方法 \u003cApproaches To Different Kinds of Reading Matter\u003e\n  - ch13: 如何阅读实用型的书 \u003cHow to Read Practical Books\u003e\n    1.  The Two Kinds of Practical Books\n    2.  The Role of Persuation\n    3.  What Does Agreement Entail in the Case of a Practical Book?\n  - ch14: 如何阅读想象文学 \u003cHow to Read Imaginative Literature\u003e\n    1.  How Not to Read Imageinative Literature\n    2.  Genaral Rules for Reading Imaginative Literature\n  - ch15: 阅读故事，戏剧，诗的一些建议 \u003cSuggestion for Reading Stories , Plays and Poems\u003e\n    1.  How to Read Stories\n    2.  A Note About Epics\n    3.  How to Read Plays\n    4.  A Note About Tragedy\n    5.  How to Read Lyric Poetry\n  - ch16: 如何阅读历史书 \u003cHow to Read History\u003e\n    1.  The Elusiveness of Historial Facts\n    2.  Theories of History\n    3.  Questions to Ask of Historical Book\n    4.  How to Reading Biography and Autobiography\n    5.  How to Read About Current Events\n    6.  A Note on Digests\n  - ch17: 如何阅读科学和数学 \u003cHow to Read Science and Mathematics\u003e\n    1.  Understanding the Scientific Enterprise\n    2.  Suggestions for Reading Classical Scientific Books\n    3.  Facing the Problem of Mathematics\n    4.  Handlding the Mathematics in Scientific Books\n    5.  A Note on Popular Science\n  - ch18: 如何阅读哲学书 \u003cHow to Read Philosophy\u003e\n    1.  The Questions Philosophers Ask\n    2.  Modern Philosophy and the Great Tradition\n    3.  On Philosophical Method\n    4.  On Philosophical Styles\n    5.  Hints for Reading Philosophy\n    6.  On Making Up Your Own Mind\n    7.  A Note on Theology\n    8.  How to Read \"Canoncial\"\n  - ch19: 如何阅读社会科学 \u003cHow to Read Social Science\u003e\n    1.  What Is Social Science?\n    2.  The Apparent Ease of Reading Social Science\n    3.  Didfficulties of Reading Social Science\n    4.  Reading Social Science Literature\n    - 第四篇：阅读的最终目标 \u003cThe Ultimate Goals Of Reading\u003e\n  - ch20: 阅读的第四个层次：主题阅读 \u003cThe Fourth Level of Reading: Syntopical Reading\u003e\n    1.  The Role of Inspection in Syntopical Reading\n    2.  The Five Steps in Syntopical Reading\n    3.  The Need for Objectivity\n    4.  An Example of an Exercise in Syntopical Reading: The Idea of Progress\n    5.  The Syntopicon and How to Use It\n    6.  On the Principles That Underlie Syntopical Reading\n    7.  Summary of Syntopical Reading\n  - ch21: 阅读与心智的成长 \u003cReading and the Growth of the Mind\u003e\n    1.  What Good Books Can Do For Us\n    2.  The Pyramid of Books\n    3.  The Life and Growth of the Mind\n\n## 问与答\n\n如何阅读一本书里面有很多技巧，其中有个就是通过**提问**的方式来使得读书效率更高。\n\n下文是我在读这本书之前和读这本书之后提出的部分问题，挑选一部分写出来作为自己的读书笔记。\n\n我把提问类型标记为如下：\n\n- CQ Common Question : 所有书提问。\n- SQ Specific Question : 本类书提问。\n- EQ Extended Question : 脑洞类提问。\n\n### CQ1: 本书整体讲了什么？\n\n\u003e You see, but you do not observe. The distinction is clear.\n\u003e\n\u003e -         Sherlock Holmes/Arthur Conan Doyle, A Scandal in Bohemia (1891)\n\n一句话概括：\n\n\u003e 本书讲的是读书的策略与技巧 (HOW).\n\n再详细一些：\n\n\u003e 本书讲的是，当面对不同层次的书，不同种类的书，同一本书的不同部分，挑书，看书，读书，吃透书的策略与技巧。\n\n作者从阅读的活力与艺术入手，介绍了阅读的必要性，然后介绍了阅读的四种层次，接着点出了阅读层次的进入一些阅读层次的要求，方法，技巧。着重介绍了分析阅读，以及面对各种各样的读物的阅读技巧。\n\n第一部分 花了一章简单的介绍了基础阅读。花了一章介绍了检视阅读，附加另一章介绍做一个自我要求的读者。\n\n接着是第二部分重点介绍阅读的第三个层次，分析阅读：\n\n这个层次需要\n\n- 『分类这本书』\n- 『透视这本书』\n- 『判断作者主旨』\n- 『评断一本书』\n- 『赞同或者反对』\n\nPS: 译者把 Pigeonholing a Book 翻译为一本书的分类，这个放在标题上和分类一本书意思相差大了。\n\n也介绍了辅助阅读的通用的一些方法和手段。\n\n接着进入第三部分，作者用自己的经验来分享对于每一种不同类型（阅读使用类书籍，想象文学，故事 / 戏剧 / 诗篇，历史，科学与数学，哲学，社科）的书籍，有哪些注意点（抓重点）, 有哪些技巧。\n\n第四个部分则是介绍了阅读的终极目的：\n\n其实每一个人的读书都是主题阅读\n\n挑选《沟通的艺术》基本上都是为了提升沟通上的技巧。换而言之，其实我们都是为了丰富自己在沟通上面的知识体系从而选择了看这本书。\n\n当然，作者并不是新造一个概念，然后一本正经的说没有干货的道理，作者还举了一个例子用于如何在主题之间作取舍，更加有条理的去看某些类别的书。\n\n### SQ1: 较好的阅读一本书的步骤\n\n#### 确定要补充那些知识 / 技能体系\n\n\u003e \"Some books are to be tasted, others to be swallowed, and some few to be chewed and digested\" - Francis Bacon\n\n有的书适合浅尝，有的书适合吞咽，只有少部分适合咀嚼和消化到变为身体的一部分。 培根对书归类的这句话相当形象。\n\n看书除非是热爱读书，否则随便拿起一本书，实在是难以激发自己探索这本书的冲动。\n\n而，这里面有一个隐藏的问题，就是**要补充哪些知识 / 技能体系**, 首先是要知道有哪些知识体系。\n\n- 维护健康\n- 高效自学\n- 逻辑思考\n- 规划管理\n- 沟通表达\n- 团队协作\n- ......\n\n#### 筛选书籍阶段 : 过滤不适合的书\n\n\u003e 目的：用一些比较通用的技巧筛选出书籍。然后进入下一阶段\n\n技巧：\n\n- 泛读书衣：书衣和封面是重要的宣传点，书衣没有亮点。基本上这本书也不会有太大亮点。\n- 泛读封面：\n  - 出版社不行，基本上这本书也不行，出版社的可能在某个领域特别牛，比如图灵 / 机械在计算机方面特别牛，我就特别青睐于选这两家的新出来的技术书籍。但不管外面怎么说，反正我自从不考试了之后，我就拒绝看清华大学出版社的所有计算机相关的书籍。清华大学出版社的计算机类作者就几乎进入了我的计算机不读书籍作者的黑名单。\n  - 作者的其他书不行，新书八成也不怎么样。作者有一本书写的巨牛无比，他的其他书籍也不会差到哪里去。假如《母猪的产后护理》质量很高甚至连高科技养猪的网易老总都专门给这本书作序，那作者的《世界如此残酷，你一定要内心强大》一定是另一本仙风道骨的自传。\n  - 一本精心构造的书的内容，插画都是有一定的寓意的。很少有作家出一本书是忍心让自己的书封面长的巨丑。\n  - 这也需要注意的是：有的烂作品也会在封面下一番功夫，这就需要进入下一阶段的的探索了。\n  - 版次越高，则越好。\n  - 印次越高，则越好。\n  - 首印数量很少，则出版社对这本书没有多大信心。\n  - 编著，著是原创，编则是整合。\n  - 如果可以的话，优先阅读英文书。\n  - 豆瓣和亚马逊的书评。\n- 泛读目录：好的书籍的目录一定是（注意是一定是）逻辑清晰，结构层次分明，足以概括该章节的，甚至对如果稍微懂一点点的人，仅仅凭着目录就可以脑补出整本书的结构。\n- 其他技巧：比如，直接买某个社群推荐的书单。我在不懂编程的时候就是这么做的。当然，后来稍微入了编程的大门才发现当初买了很多烂书。当然，用别人的书单也会逐渐让自己挑选书的能力退化。\n\n如果不适合口味，比如你想看《面向对象编程思想》过程中的翻到了一本《找对象，就这么做》的书，果断换一本；或者这书质量实在是太差，比如你翻到了《公猪在母猪的产后护理过程中不得不做的 138 件小事》, 书总共就 350 页，居然讲什么是母猪花了 147.6 页，果断换一本书。这样你就节约了看一本不合适的书的时间。\n\n#### 检视阅读阶段 : 判断一本书的质量\n\n\u003e 目的：判断一本书的质量，以及评估当前的书本是否值得进入下一阶段。然后进入下一阶段。\n\n\u003e 适用场景：不知道这本书适不适合进行更高质量的阅读。或者时间有限并且急于挖掘书中的知识。\n\n经过上个阶段的过滤，不合适的书基本上也就差不了多少了，这时候就需要对这本书进行检视阅读了：\n\n##### 检视阅读阶段 STEP1 : 大体定位这本书。\n\n1. 看书名页 / 序 : 了解这本书的主题，归类这本书的类型。\n2. 研究目录页 : 对这本书的基本架构做概括性的理解。\n3. 查看索引\n4. 出版者的介绍\n5. 挑选几个和主题相关的篇章，着重看篇章的开头或结尾。\n6. 把书打开，随意翻，有时候连续看几页，但不要太多。\n\n定位这本书的用途：\n\n1. 弃而不看。\n2. 放着做参考书。\n3. 进行检视阅读的第二阶段\n\n##### 检视阅读阶段 STEP2 :\n\n这篇作者 / 译者使用了一个很容易被误会词，粗读。\n\n即：\n\n\u003e 头一次面对一本难读的书的时候，从头到尾先读完一遍，碰到不懂的地方不要停下来查询或者思索。\n\n那什么标准的读才叫粗读呢？\n\n\u003e 把握主干，不拘泥于细枝末节，把握大原则，不拘泥于细微的重点，而不是那种随便翻翻的\"粗读\".\n\n##### 检视阅读的一些误区：\n\n\u003e 速读也只能回答出\"这是在说什么的\"的问题。对深入理解，回答更深层次的问题没有大帮助。\n\n#### 分析阅读阶段 : 全方位吃透这本书\n\n经过筛选与检视，剩下的书则是很有价值的书。\n\n\u003e 而，读一本书的阅读技巧，明显是高于比书本长度少，比书本难度易的读物。即 **这些阅读技巧也同样适用于非书籍的读物上**\n\n##### 分析阅读第一阶段：找出一本书在谈写什么的规则\n\n步骤：\n\n1. 依照书的种类与主题来分类\n2. 使用最简短的文字说明整本书在谈些什么\n3. 将主要部分按顺序和关联性列举出来。将全书的大纲列举出来，并将各个部分的大纲也列出来。\n4. 确定作者想要解决的问题。\n\n\u003e 如果心中没有一个分类的标准，再清楚的书名也没有用。\n\n\u003e 每一本书都有一个骨架，作为一个合格的读者，目的就是找出这个骨架。\n\n1. 掌握一本书的架构\n2. 使用单一的句子，或者最多几句话来叙述整本书的内容。\n3. 将书中的重要篇章列举出来，说明他们如何按照顺序组成一个整体的架构。\n\n\u003e PS: 建筑架构与书本架构的那个比方真的是精彩。\n\n第三点可以用列提纲来解决：\n\n- 作者将全数分为五个部分，第 1/2/3/4/5 部分讲的是什么\n- 第一部分的第一节（注：Section, 译者翻译为段落）, 有 X/Y/Z 节 /\n- X 节作者做出四个观点 (Point),I/II/III\n\n\u003e 由于纸笔速度跟不上大脑运转速度，对每一本书这样读并且列提纲的话相当耗费精力，但是具备这样的意识还是很重要的。\n\n##### 分析阅读第二阶段：诠释一本书的内容的规则。\n\n步骤：\n\n1. 诠释作者的关键字，与他达成共识。\n2. 由最重要的句子中，抓住作者的重要主旨。\n3. 知道作者的论述是什么，从内容中找出相关的句子，再重新架构出来。\n4. 确定作者已经解决了哪些问题，还有哪些问题是没有解决的，在判断那些是作者知道他没有解决的问题。\n\n\u003e 1. 作者的主旨如果没有理论的支持，只是在书法个人想法罢了。2. 为什么他认为我们应该被说服，以接受这样的观点。\n\n1. 找出关键句\n2. 找出主旨\n3. 找出论述\n4. 找出解答\n\n他沟通的主要核心是他所辖的肯定与否定的判断，以及他为什么会这么做的立构。\n\n\u003e 不能用他们自己的话，重述你的观点。则是代表不理解。\n\n##### 分析阅读第三阶段：评论一本书的规则\n\n规则：\n\nA. 智慧礼节的一般规则\n\n1. 除非你已经完成了大纲架构，也能诠释整本书了，否则不要轻易评断。\n2. 不要争强好胜，非辩到底不可。\n3. 在说出评论之前，你要能证明自己区别得出真正的知识与个人观点的不同。\n   B. 批评观点的特别标准\n4. 证明作者的知识不足。\n5. 证明作者的知识错误。\n6. 证明作者不合逻辑。\n7. 证明作者的分析与理由是不完整的。\n\n甚至，可以用于其他的类型的学习。\n\n#### 主题阅读阶段 : 纳入自己的知识体系\n\n主题阅读其实就是对同一个主题挑选几本书进行查看。\n\n多问问自己：这本书谈的内容对我研究的主题内容道理有没有帮助？\n\n主题阅读 STEP1. 找到与主题相关的章节。只看与该章节相关的内容。\n主题阅读 STEP2. 带领作者与你达成共识。与检视阅读的第二步骤相反。\n主题阅读 STEP3. 理清问题。\n主题阅读 STEP4. 界定议题。\n主题阅读 STEP5. 分析讨论。\n\n### SQ2: 上面关于阅读一本书的步骤是适用于所有书，即是通用的步骤吗？\n\n\u003e 不是\n\n作者在书中介绍了四个问题，用来帮助读者进行更好的阅读，这些问题除了不适合小说类的书籍，基本上可以适用于绝大部分的书籍。\n\n- CQ1 : **本书整体讲了什么？** （主题，作者如何依次发展主题，如何逐步从核心主题分解出从属的关键议题来）\n- CQ2 : **作者细说了什么？怎么说的？** （找出主要的 ideas,assertions,arguments, 汗，译者翻译为了 想法，声明，论点，实际上应该翻译为想法，主张，论据......)\n- CQ3 : **这本书说的有道理吗？是全部有道理，还是部分有道理？**\n- CQ4 : **这本书跟我有什么关系？** 如果是资讯，则询问是否有意义。是否值得有更深入的了解。这本书可以补充我哪些知识体系\n\n作者在书中已经介绍完分析阅读，按理来说应该进入的是下一部分，即主题阅读。\n\n但是第三部分**莫名其妙**硬塞了一部分内容叫做**阅读不同读物的方法**\n\n内容是如何阅读下面的读物：\n\n- 实用型的书\n- 想象文学\n- 故事，戏剧，诗\n- 历史书\n- 科学与数学\n- 哲学书\n- 社会科学\n\n而这么做的答案在第十三章的开头（不是应该在第三部分的开头嘛？).\n\n\u003e 在任何艺术或实务领域，规则太通用是一件令人扫兴的事情。少量的通用性规则是优势。越通用的规则也就意味着越易懂，而与此同时当遇到真实案例的时候，往往通用规则太宽泛而难以应用。\n\n\u003e 即，尽管作者做了抽象的总结的经验，但还是要具体落实到具体的案例上。\n\n##### 分析阅读之如何阅读实用型的书\n\n\u003e 注：由于时间有限，仅仅对阅读实用类和历史书籍做了笔记，以后补上。\n\n\u003e 注意：**任何一本实用性的书不能解决该书所关心的实际问题.**\n\n就像学会**如何阅读一本书**, 看完做好笔记并不意味着**你不会阅读一本书**这个问题**消失了**, 只有行动才能解决问题。\n\n\u003e **听过那么多道理，却不行动，不能过好这一生**也没有那必要怪道理。\n\n\u003e **Just Do It**\n\n- 如果是阅读数学类的书，可能了解作者本人是没有任何必要的。\n- 如果是阅读道德论述，经济论文和经济论著，则非常有必要了解作者的人格，生活所处的时代背景。\n\n第一个问题：这本书是在谈些什么。\n第二个问题：这本书的意义或内容，共识，主旨，论述。\n第三个问题：内容真实吗？\n第四个问题：这本书与我何干？\n\n##### 分析阅读之如何阅读历史书\n\n这部分刚开始就通过法庭陪审团的车祸事件来说明，在严格规范的证据之下，加上详细检验之后，身为陪审员都很难百分之百的确定一件事情的真相。\n\n而，一个人连一件单纯的事都难以确知真相，遑论历史？\n\n由于历史的理论不同，历史学家对历史事件的描述则不同。\n\n阅读历史的两个要点：\n\n1. 对你感兴趣的时间或者时期，尽量阅读一种以上的历史书\n2. 不要只关心在过去某个时间地点真正发生了什么事情，还要读懂在任何时空中，尤其是现在，人们为什么会有这般行动的原因。\n\n### SQ3: 关于读书的有哪些误区\n\n#### 速读\n\n1. 许多书连略读都是不值得的，另外一些书只需要快速读过就行了。有少数的书需要用某种速度，通常是相当慢的速度，才能完全理解。\n2. 一本只需要快速阅读的书，却用很慢的速度来读，就是在浪费时间，这时速读的技巧就能帮你解决问题。\n\nPS: 无论是多么难读的书，在无关精要的间隙部分都可以读快一些。而那些比较困难的部分，应该慢慢阅读。\n\n\u003e 核心的注意点应该放在：理解了多少。\n\u003e 恰似沟通需要注意的：不是你说了多少，说的多快，而是对方理解了多少。\n\n#### 随便翻翻\n\n读书如果不是为了娱乐消遣，切忌进行在很松散的状态下随便拿一本书看看。\n\n\u003e 为了解决很随便的看一本书，我的技巧就是带着问题去看。\n\n#### 陷入细枝末节\n\n\u003e 头一次面对一本难读的书的时候，从头到尾先读完一遍，碰到不懂的地方不要停下来查询或者思索。\n\n不停的停下来查一些陌生的知识会不断的破坏兴趣。并且会忽略掉一些大的原则性的东西。\n比如：当你努力的去了解那些细微的重点时，就会错过大原则：关于成本中包含的薪水，租金，利润与利息种种因素，市场在定价中的角色，垄断专卖的害处，自由贸易的理由等等。\n\n\u003e 作者的意思其实就是从枝干再到树叶。不要上来就陷入一些细小的琐碎事物中。\n\n### EQ1: 为什么要**重新学习**如何阅读书籍的策略与方法\n\n\u003e 初学者的无知在于未学，而学者的无知在于学后\n\n以上。\n\n## 相关链接\n\nhttps://en.wikipedia.org/wiki/How_to_Read_A_Book\nhttps://en.wikipedia.org/wiki/How_to_Read_Literature_Like_a_Professor\n[亚马逊地址《如何阅读一本书》](https://www.amazon.com/How-Read-Book-Intelligent-Touchstone/dp/0671212095/ref=pd_bxgy_14_2?_encoding=UTF8\u0026psc=1\u0026refRID=MMHSVKSVYBBGSMZRWDQE)\n\nUPDATE:\n\n| 日期           | 类型 | 详细操作                       |\n| -------------- | ---- | ------------------------------ |\n| **2017-02-13** | 创建 | 初始化本文                     |\n| **2017-02-17** | 重构 | 删除零散笔记，重新组织本文结构 |\n| **2017-02-26** | 重构 | 调整部分内容                   |\n"},{"tags":["编辑器"],"path":"20170115_Spacemacs.md","title":"写给 Pythoner 的 Spacemacs 入门指北","slug":"写给 Pythoner 的 Spacemacs 入门指北","date":"2017-01-15","category":"善用佳软","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n# 写给 Pythoner 的 Spacemacs 入门指北\n\n最开始，使用 Sublime Text 编码，后来用 Vim 混合 PyCharm 写 Python。\n\n前几天，Github 上的 Spacemacs 已经成功的突破一万 Star, 听说几个我非常佩服的 Pythoner（比如『Python Web 开发实战』的作者董伟明） 也是非常喜欢 Spacemacs, 我就萌生了从 Vim 切换到 Spacemacs 的想法，说做就做。\n\n\u003e 注：本文所有内容基于 macOS 10.11, 软件环境为 zsh , pyenv , python3.5.2 , node5.12.0. 其他类 Unix 平台略作修改即可使用。至于 Windows 平台，建议安装 Ubuntu 虚拟机。本文也需要读者具备基本的 VIM 基本常识和 Python 常识。\n\n本文只负责把读者带入 Spacemacs 的世界中，而不是涉及到 Spacemacs 的方方面面，所以此文为指北。而非详细的指南 (Guide).\n\n## 0x00 基本软件环境安装\n\n### zsh 与 ohmyzsh\n\n```bash\nbrew install zsh\nchsh -s /bin/zsh\nsh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"\n```\n\n### pyenv 与 pyenv virtualenv\n\n```bash\ngit clone https://github.com/yyuu/pyenv.git ~/.pyenv\ngit clone https://github.com/yyuu/pyenv-virtualenv.git ~/.pyenv/plugins/pyenv-virtualenv\necho 'export PYENV_ROOT=\"$HOME/.pyenv\"' \u003e\u003e ~/.zshrc\necho 'export PATH=\"$PYENV_ROOT/bin:$PATH\"' \u003e\u003e ~/.zshrc\necho 'eval \"$(pyenv init -)\"' \u003e\u003e ~/.zshrc\necho 'eval \"$(pyenv virtualenv-init -)\"' \u003e\u003e ~/.zshrc\n\n# 不喜写兼容代码，所有代码均向 3.5+ 靠拢\nv=3.5.2|wget http://mirrors.sohu.com/python/$v/Python-$v.tar.xz -P ~/.pyenv/cache/;pyenv install $v\nv=3.6.0|wget http://mirrors.sohu.com/python/$v/Python-$v.tar.xz -P ~/.pyenv/cache/;pyenv install $v\nv=2.7.11|wget http://mirrors.sohu.com/python/$v/Python-$v.tar.xz -P ~/.pyenv/cache/;pyenv install $v\n\n# 设置 Global Python 为 2.7.11, 备注：尽量不要把 Py3 设置为全局，否则由于 Homebrew 本身有一些依赖是依赖于 Py2 的，这样容易出现一些奇怪的问题。\npyenv global 2.7.11\npip install -i https://pypi.doubanio.com/simple requests\n# 下面这个是用于安装基本的代码补全功能\npip install -i https://pypi.doubanio.com/simple --upgrade \"jedi\u003e=0.9.0\" \"json-rpc\u003e=1.8.1\" \"service_factory\u003e=0.1.5\" flake8 pytest autoflake hy\n\npyenv virtualenv 3.5.2 py3-daily\npyenv activate py3-daily\npip install -i https://pypi.doubanio.com/simple requests\npip install -i https://pypi.doubanio.com/simple beatutifulsoup4\npip install -i https://pypi.doubanio.com/simple ipython[notebook]\npip install -i https://pypi.doubanio.com/simple jupyter\n# 下面这个是用于安装基本的代码补全功能\npip install -i https://pypi.doubanio.com/simple --upgrade \"jedi\u003e=0.9.0\" \"json-rpc\u003e=1.8.1\" \"service_factory\u003e=0.1.5\" flake8 pytest autoflake hy\npyenv deactivate\n# pyenv uninstall py3-daily\n\n```\n\n### nvm 以及常用 npm 包\n\n```bash\n# 安装 nvm\ncurl -o- https://raw.githubusercontent.com/creationix/nvm/v0.32.1/install.sh | bash\nnvm install 5.12.0\necho '\\n#alias for cnpm\\nalias cnpm=\"npm --registry=https://registry.npm.taobao.org \\\n  --cache=$HOME/.npm/.cache/cnpm \\\n  --disturl=https://npm.taobao.org/dist \\\n  --userconfig=$HOME/.cnpmrc\"' \u003e\u003e ~/.zshrc \u0026\u0026 source ~/.zshrc\nnpm install -g vmd\nnpm install -g gitbook-cli\nnpm install -g hexo-cli\nnpm install -g tern\nnpm install -g js-beautify\nnpm install -g js-hint\n```\n\n### Spacemacs 安装以及基本配置\n\n```bash\nbrew install ag\nbrew install grep\nbrew tap d12frosted/emacs-plus\nbrew install emacs-plus\n# 安装完毕之后，克隆我的配置 repo, 有一些基本的配置用于解决墙的问题。解决方案来自于子龙山人\ngit clone https://github.com/syl20bnr/spacemacs ~/.emacs.d\nmv ~/.spacemacs .spacemacs.bak\ngit clone https://github.com/twocucao/spacemacs.d.git ~/.spacemacs.d\n# 输入 emacs 进行初始化，如果你可以正常访问 Github 的话时间在半小时之内。\nemacs\n```\n\n安装 Spacemacs 过程中画面如下：\n\n![安装 Spacemacs 过程中画面](http://upload-images.jianshu.io/upload_images/52890-d5c8171294ec9f3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n安装前，Emacs 长这个样子：\n\n![安装前](http://upload-images.jianshu.io/upload_images/52890-4e6026d213191939.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n安装后，Emacs 长这个样子：\n\n![安装后.png](http://upload-images.jianshu.io/upload_images/52890-45747c68366ef275.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**在正式进入，请牢牢记住下面几个按键已经功能，以备不时之需**\n\n- spc : 跳出命令面板\n- spc-spc : 跳出命令列表，可运行命令，也可以查找快捷键\n- spc-h-spc : 查找包的用途与定义\n\n嗯，可以谈下一话题了！\n\n## 0x01 日常的编辑\n\n### 1.1 文件导航\n\n- (VIM 流）hjkloOaA zz\n- (VIM 流）查找 \\* /words\n- spc-f-j 开发 neotree\n- spc-tab 切换到上一个 buffer\n- spc-f-f 打开文件 spc-p-f fuzzfind 类似于 ctrlp spc-s-g-p grep 搜索项目 spc-s-a-p ag 搜索项目\n\n搜索项目如图 (spc-s-a-p ag 搜索项目）:\n\n![按照关键字搜索项目](http://upload-images.jianshu.io/upload_images/52890-b2ce54f91a91e9d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\u003e 实在是方便至极\n\n### 1.2 文件编辑\n\n文件内容编辑\n\n- (VIM 流）u 与 c-r d c 等\n- 有趣的是查找替换功能也是自带预览的。比如 :%s/foo/bar/g\n\n![查找替换预览](http://upload-images.jianshu.io/upload_images/52890-e37a81a2a399e5f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n文件本身编辑\n\n- 在 dired mode 下：copy - C , delete - D, new folder - +\n- 也可以 spc-f-t 在 neotree 下进行编辑\n\n\u003e 除去这些和 Vim 相似的文件编辑功能之外，甚至窗口管理都和 Vim 一致了，使用 c-w+hjkl 直接跳转。\n\u003e 强烈建议在读者抽空过一遍基本的 Vimtutor\n\n### 1.3 Markdown Writing\n\n- spc-spc-markdown-generate-to 回车即可生成本文的 Toc(Table Of Content)\n- spc-b-i 打开 buffer 的 imenu（类似于 Vim 的 Tagbar 插件），enter 跳转\n\n搜索项目如图 (spc-b-i 开启 buffer imenu ，enter 跳转）:\n\n![IMenu](http://upload-images.jianshu.io/upload_images/52890-250852ddc15bd7a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 0x02. Python 编程\n\n### 2.1 代码补全\n\n当你按照前面的所有配置走一圈下来，基本上就已经可以完美的进行补全了。\n比如，当我编辑一个 py 文件的时候，\n\n```bash\n# 先激活虚拟环境\npyenv activate 3.5.2/envs/py3-daily\nemacs py.py\n```\n\n如图所示，因为 requests,numpy 这种第三方库都可以完美补全，其他自然不在话下。\n\n![代码补全](http://upload-images.jianshu.io/upload_images/52890-7516130bb7fe70c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n代码补全还有另一个神器，就是可以内嵌 lisp 的 Snippet 模板 -- yasnippet, 由于模板功能基本上和其他编辑器相同，而使用 elisp 语言进行编写动态 Snippet 模板则需要会 elisp, 这以后有机会再学学。\n\n### 2.2 代码跳转\n\n- 文件代码跳转 spc-spc-helm-imenu 查看文件结构\n- 文件跳转 在 normal-mode 下，gd 即可跳转到函数定义上，但是不能跨文件跳转。\n\n![单文件使用 helm_imenu 进行浏览](http://upload-images.jianshu.io/upload_images/52890-4a2b2df1e6be0dfd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![使用 ag 进行代码搜索](http://upload-images.jianshu.io/upload_images/52890-3406b060737bffa3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 2.3 pytest 测试\n\n- spc-m-s-py3-daily enter 选择 py3-daily 虚拟环境\n- spc-spc-pytest-all enter 即可运行所有 pytest 测试。\n\n测试过程：\n\n运行测试失败，运行测试失败，使用 c-w-j 跳转到下面窗口，对红色标记处 enter, 即可跳转到出错文件行。\n\n![pytest 运行测试失败](http://upload-images.jianshu.io/upload_images/52890-8ef2bac3163f166c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n修正运行测试成功，如图：\n\n![pytest 运行测试成功](http://upload-images.jianshu.io/upload_images/52890-b90176c2e97df7dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 0x03. IPython Notebook\n\n通常情况下我使用 IPython Notebook 都是在 Web 端，因为是 Web 端，实际上大量的 Dom 渲染对浏览器的渲染速度还是有一定的影响的，我还是比较喜欢客户端，因为客户端的快捷键可以定制，而 Web 端的快捷键实在是相当的不方便。\n\n是不是 IPython Notebook 的 web 端没有好处呢？有的，比如我可以借用外部的 JS 可视化图表对 js 进行可视化呀。\n\n比如我发在简书上的这篇技术文 [IPython Notebook 引入 ECharts 做可视化](http://www.jianshu.com/p/609193efee1a)\n\n但，如果不需要 js 功能的话，还是用客户端舒服一些。\n\n### 3.1 IPython Notebook 基本配置\n\nspacemacs 貌似只支持密码访问 IPython Notebook, 那么我们就生成密码。\n\n```bash\n# 首先激活 py3-daily 环境\npython -c \"from notebook.auth import passwd;print(passwd())\" | pbcopy\n# 恩，于是剪切板上就有如下的字符串\nsha1:9bf4c48a6b83:26bc24a78a1e4aea7baa36874f5e86bafac0dbb9\n# 打开 config 文件取消注释并修改 c.NotebookApp.password\nvim ~/.jupyter/jupyter_notebook_config.py\nc.NotebookApp.password = 'sha1:35543659622f:f9a78f0b20132f3e04aa1d4ed4060f9fd9eb7663'\n```\n\n### 3.2 Emacs IPython Notebook\n\n```bash\n# 首先在终端打开 IPython Notebook\nipython notebook\n```\n\n接着打开 emacs, 输入 spc-a-i-n, 默认端口，然后输入密码即可。首次登陆后还需要在输入一次 spc-a-i-n 即可看到 IPython Notebook 的主界面。\n\n![IPYNB 的主界面](http://upload-images.jianshu.io/upload_images/52890-86a9a546e350994c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n光标移到 [New Notebook] 键击 enter 新建 IPython Notebook.\n\n输入如下代码：\n\n```python\n# The %... is an iPython thing, and is not part of the Python language.\n# In this case we're just telling the plotting library to draw things on\n# the notebook, instead of on a separate window.\n%matplotlib inline\n# See all the \"as ...\" contructs? They're just aliasing the package names.\n# That way we can call methods like plt.plot() instead of matplotlib.pyplot.plot().\nimport numpy as np\nimport scipy as sp\nimport matplotlib as mpl\nimport matplotlib.cm as cm\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport time\npd.set_option('display.width', 1000)\npd.set_option('display.max_columns', 100)\npd.set_option('display.notebook_repr_html', True)\nimport seaborn as sns\nsns.set_style(\"darkgrid\")\nsns.set_context(\"poster\")\nsns.set()\n\n# Load the example flights dataset and conver to long-form\nflights_long = sns.load_dataset(\"flights\")\nflights = flights_long.pivot(\"month\", \"year\", \"passengers\")\n\n# Draw a heatmap with the numeric values in each cell\nsns.heatmap(flights, annot=True, fmt=\"d\", linewidths=.5)\n\n```\n\nshift+enter , 咣\n\n热力图就出来了\n\n![热力图](http://upload-images.jianshu.io/upload_images/52890-aec8c9f278f74600.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 0x04. 扩展\n\n看完上文，就可以深入文档进行探索了。\n\n- 打开 Vim, 输入：help vimtutor 熟悉基本的 Vim 操作。\n- [Spacemacs Layer 文档](https://github.com/syl20bnr/spacemacs/tree/master/layers)\n- [Spacemacs 文档](http://spacemacs.org/doc/DOCUMENTATION.html)\n- [我的 Spacemacs 配置页面](https://github.com/twocucao/spacemacs.d)\n- [Spacemacs 达人子龙山人的教程](https://github.com/emacs-china/Spacemacs-rocks)\n\nChangeLog:\n\n- **2017-01-15 18:53:45** 重修文字\n- **2017-01-16 12:49:19** 润饰文字，增加可读性，首发简书。\n- **2018-01-01 12:49:19** 最后弃坑并回归 Vim 与 IDE\n"},{"tags":["Python"],"path":"20170114_PythonScope.md","title":"从一个小问题来说 Python 的作用域","slug":"从一个小问题来说 Python 的作用域","date":"2017-01-14","category":"Python","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n\u003e 备注，这种动态设置 module 里的方法不推荐\n\n## 前言\n\n整理工具字符类的时候，想借助正则表达式来实现一部分的文字判断抽取等操作。\n\n比如实现：\n\n- 判断文字是否为 UUID\n- 判断文字是否包含 UUID\n- 抽取文字是中第一个 UUID\n- 抽取文字是中所有 UUID\n\n\u003c!-- more --\u003e\n\n### 一个暴力的实现方法\n\n如果正则表达式比较少，就只一个 UUID，我们就不需要思考什么，我们分别编写四个函数：\n\n- is_uuid(\\_str)\n- has_uuid(\\_str)\n- extract_first_uuid(\\_str)\n- extract_all_uuid(\\_str)\n\n\u003e 没错，过早优化是万恶之源\n\n但很显然，手动方法显得很弱智，当我需要编写判断 QQ 号的时候，我又必须编写四个函数：\n\n- is_qq_num(\\_str)\n- has_qq_num(\\_str)\n- extract_first_qq_num(\\_str)\n- extract_all_qq_num(\\_str)\n\n然而：\n\n- 如果，我还需要判断手机号、日期、时间等等，这手动复制粘贴的过程就比较痛苦了。\n- 如果，我去要添加一个方法，给 QQ 号码，uuid 等打码 那就必须要给所有的 uuid, 手机，邮箱都添加一个 dama_xxx(\\_str) 方法\n\n有没有好一点的解决方法呢？\n\n\u003c!-- more --\u003e\n\n### 两个方法\n\n第一种，比如把函数修改为：\n\n- is(\\_str,QQ_NUM_PATTEN)\n- has(\\_str,QQ_NUM_PATTEN)\n- extract_first(\\_str,QQ_NUM_PATTEN)\n- extract_all(\\_str,QQ_NUM_PATTEN)\n\n第二种，Python 中动态添加工具方法，我个人比较喜欢这种：\n\n```python\n# 一个优雅的错误实现方式\nfor regex, regex_pattern in REGEXES.items():\n    def has_regex_func(_str):\n        return has_pattern(_str, regex_pattern)\n\n    def is_regex_func(_str):\n        return match_pattern(_str, regex_pattern)\n\n    def extract_first_regex_func(_str):\n        return find_first_matched_pattern(_str, regex_pattern)\n\n    def extract_all_regex_func(_str):\n        return find_all_matched_pattern(_str, regex_pattern)\n\n    setattr(sys.modules[__name__], 'has_{regex_suffix}'.format(regex_suffix=regex), has_regex_func)\n    setattr(sys.modules[__name__], 'is_{regex_suffix}'.format(regex_suffix=regex), is_regex_func)\n    setattr(sys.modules[__name__], 'extract_first_{regex_suffix}'.format(regex_suffix=regex), extract_first_regex_func)\n    setattr(sys.modules[__name__], 'extract_all_{regex_suffix}'.format(regex_suffix=regex), extract_all_regex_func)\n```\n\n于是我添加了测试方法：\n\n\u003e 一个不对稍微有些复杂的逻辑的程序进行测试的程序员不是一个称职的老司机。\n\n```python\n@pytest.mark.parametrize('test_input,expected', [\n    (\"321323199509234453\", False),\n    (\"000528-332222\", False),\n    (\"521e7bb0-d8d5-4f49-a5c2-fee1aaf9e8c4\", True),\n])\ndef test_is_uuid(test_input, expected):\n    assert is_uuid(test_input) == expected\n\n@pytest.mark.parametrize('test_input,expected', [\n    (\"321323199509234453\", False),\n    (\"000528-332222\", False),\n    (\"521e7bb0-d8d5-4f49-a5c2-fee1aaf9e8c4\", True),\n])\ndef test_has_uuid(test_input, expected):\n    assert has_uuid(test_input) == expected\n\n@pytest.mark.parametrize('test_input,expected', [\n    (\"321323199509234453\", None),\n    (\"000528-332222\", None),\n    (\"521e7bb0-d8d5-4f49-a5c2-fee1aaf9e8c4\", \"521e7bb0-d8d5-4f49-a5c2-fee1aaf9e8c4\"),\n])\ndef test_extract_first_uuid(test_input, expected):\n    assert extract_first_uuid(test_input) == expected\n\n@pytest.mark.parametrize('test_input,expected', [\n    (\"321323199509234453\", None),\n    (\"000528-332222\", None),\n    (\n            \"521e7bb0-d8d5-4f49-a5c2-fee1aaf9e8c4521e7bb0-d8d5-4f49-a5c2-fee1aaf9e8c4521e7bb0-d8d5-4f49-a5c2-fee1aaf9e8c4521e7bb0-d8d5-4f49-a5c2-fee1aaf9e8c4\",\n            ['521e7bb0-d8d5-4f49-a5c2-fee1aaf9e8c4', '521e7bb0-d8d5-4f49-a5c2-fee1aaf9e8c4',\n             '521e7bb0-d8d5-4f49-a5c2-fee1aaf9e8c4', '521e7bb0-d8d5-4f49-a5c2-fee1aaf9e8c4']),\n    (\n            \"521e7bb0-d8d5-4f49-a5c2-fee1aaf9e8c4   521e7bb0-d8d5-4f49-a5c2-fee1aaf9e8c4   521e7bb0-d8d5-4f49-a5c2-fee1aaf9e8c4   aslakdj 521e7bb0-d8d5-4f49-a5c2-fee1aaf9e8c4\",\n            ['521e7bb0-d8d5-4f49-a5c2-fee1aaf9e8c4', '521e7bb0-d8d5-4f49-a5c2-fee1aaf9e8c4',\n             '521e7bb0-d8d5-4f49-a5c2-fee1aaf9e8c4', '521e7bb0-d8d5-4f49-a5c2-fee1aaf9e8c4']),\n])\ndef test_extract_all_uuid(test_input, expected):\n    assert extract_all_uuid(test_input) == expected\n```\n\n测试未通过：\n\n怎么查看代码本身都没有什么逻辑问题，那么问题出在哪里？\n\n对程序植入一些 print 代码来 Debug 一下：\n\n```python\nfor regex, regex_pattern in REGEXES.items():\n    def has_regex_func(_str, regex_pattern=regex_pattern):\n        # 当函数被调用之后，打印 regex_pattern 查看对应的字符串\n        print(regex_pattern)\n        return has_pattern(_str, regex_pattern)\n\n    def is_regex_func(_str, regex_pattern=regex_pattern):\n        return match_pattern(_str, regex_pattern)\n\n    def extract_first_regex_func(_str, regex_pattern=regex_pattern):\n        return find_first_matched_pattern(_str, regex_pattern)\n\n    def extract_all_regex_func(_str, regex_pattern=regex_pattern):\n        return find_all_matched_pattern(_str, regex_pattern)\n\n    # 查看是否为同一个函数\n    print(id(has_regex_func))\n\n    setattr(sys.modules[__name__], 'has_{regex_suffix}'.format(regex_suffix=regex), has_regex_func)\n    setattr(sys.modules[__name__], 'is_{regex_suffix}'.format(regex_suffix=regex), is_regex_func)\n    setattr(sys.modules[__name__], 'extract_first_{regex_suffix}'.format(regex_suffix=regex), extract_first_regex_func)\n    setattr(sys.modules[__name__], 'extract_all_{regex_suffix}'.format(regex_suffix=regex), extract_all_regex_func)\n```\n\n于是发现问题，所有打印出来的 regex_pattern 都是一致的。也就是，不管是 has_uuid 还是 has_qq_num 还是其他，最后 regex_pattern 都是我在字典中实现的\n"},{"tags":["PostgreSQL"],"path":"20170105_PostgreSQLCheatSheet.md","title":"PostgreSQL CheatSheat","slug":"PostgreSQL CheatSheat","date":"2017-01-05","category":"DevOps","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n本文为 Cheatsheet 类型文章，用于记录我在日常编程中经常使用的 PostgreSQL 相关和命令。\n\nPostGIS 相关的资料参考文章 [Geo Processing With Python](/2016/10/05/UbuntuCheatsheet/)\n\n- 安装与基本配置\n- PostgreSQL 配套工具\n- PostgreSQL SQL 常用代码片段\n- Python Driver : psycopg2 , 与两个 ORM ( Django ORM / SQLAlchemy )\n\n不定期更新。\n\n\u003c!-- more --\u003e\n\n## 0x01 安装，配置，基本 shell 命令\n\n### 安装\n\n### 配置\n\n### 基本 Shell 命令\n\n```\n# 开启关闭\npg_ctl -D /usr/local/var/postgres -l /usr/local/var/postgres/server.log start\npg_ctl -D /usr/local/var/postgres -l /usr/local/var/postgres/server.log stop\npg_ctl -D /usr/local/var/postgres start\npg_ctl -D /usr/local/var/postgres stop -s -m fast\n```\n\n### 数据的导入导出\n\n```bash\npg_dump -C -Fp -f dump.sql -U twocucao QCS -h 192.168.2.175\npg_dump -C -Fp -f 20160602-150144-dump.sql -U twocucao QCS --column-inserts --data-only --table=users_table -h 192.168.2.175\n# 插入数据\npsql -U twocucao -d QCS -a -f insert_doc_ids.sql -h 192.168.2.175\npg_restore --verbose --clean --no-acl --no-owner -h localhost example.dump\n```\n\n## 0x02 PostgreSQL 配套工具\n\n- JetBrain 的 Datagrip 作为 编写大段 SQL 语句的 IDE\n- 通过网络或者 Dash 查看文档\n- PostgreSQL 官方自带工具\n\n## 0x03 PostgreSQL SQL 常用代码\n\n### 3.1 PostgreSQL 相关\n\n```sql\n-- 强行中断连接到此数据库的 session\nSELECT\n    pg_terminate_backend(pid)\nFROM\n    pg_stat_activity\nWHERE\n    -- don't kill my own connection!\n    pid \u003c\u003e pg_backend_pid()\n    -- don't kill the connections to other databases\n    AND datname = 'demoweb' ;\n```\n\n### 3.2 DCL ( Data Control Languge )\n\n```sql\n-- 创建只读用户\n\\c demoweb\nCREATE ROLE ro_user WITH LOGIN ENCRYPTED PASSWORD 'xxx123456';\nGRANT CONNECT ON DATABASE demoweb TO ro_user;\n-- This assumes you're actually connected to mydb..\nGRANT USAGE ON SCHEMA public TO ro_user;\nGRANT SELECT ON ALL TABLES IN SCHEMA public TO ro_user;\nGRANT SELECT ON ALL SEQUENCES IN SCHEMA public TO ro_user;\n\n-- 撤销数据库连接 ()\nREVOKE CONNECT ON DATABASE demoweb FROM PUBLIC, demoweb;\n```\n\n### 3.3 DDL ( Data Definition Language )\n\nCREATE\nALTER\nDROP\nTRUNCATE\nCOMMENT\nRENAME\n\n### 3.4 DML ( Data Manipulation Languge )\n\nSELECT\nINSERT\nUPDATE\nDELETE\nMERGE\nCALL\nEXPLAIN PLAN\nLOCK TABLE\n\n### 3.5 TCL ( Transaction Control Languge )\n\n## 0x04. 常用代码片段\n\n### 4.1. Tips And Hacks\n\n#### Recursive Query\n\n```bash\nWITH cte_name(\n    CTE_query_definition -- non-recursive term\n    UNION [ALL]\n    CTE_query_definition -- recursive term\n) SELECT * FROM cte_name;\n```\n\n### 4.2. 大数据量运算技巧\n\n### 4.3 备份还原技巧\n\n```bash\n# 需要备份的机器\nDB_NAME='xxxdb'\nDUMP_DB_FILE='latest_dump.sql.gz'\nsudo -u postgres pg_dump $DB_NAME | gzip -9 \u003e $DUMP_DB_FILE\nTARGET_HOSTNAME='xxx.org'\nTARGET_PATH='/webapps/'\nscp $DUMP_DB_FILE root@$TARGET_HOSTNAME:/webapps/\n\n# 需要还原的机器\nDB_NAME='xxxdb'\nDUMP_DB_FILE='latest_dump.sql.gz'\nsudo -u postgres dropdb $DB_NAME\nsudo -u postgres createdb $DB_NAME\ngunzip \u003c $DUMP_DB_FILE | sudo -u postgres psql $DB_NAME\n```\n\n## 0x05. 并发优化技巧\n\n\u003e 优化技巧请参考我关于 MySQL 的一片文章。\n\n### 5.1 ACID\n\n- Atomicity : 行不行，给个准话\n- Consistency : 完成时候，数据保持一致（多版本并发控制）\n- Isolation : 事务与事务之间是隔离的。即一事务无法查看另一个事务正在修改的数据（默认，如果不默认这玩意，则隔离程度是可以设置的）\n- Durablity : 就是存下来了。\n\n#### 多版本并发控制模型\n\n- Each query sees only transactions completed before it started\n- On query start, PostgreSQL records:\n  - the transaction counter\n  - all transaction id’s that are in-process\n- In a multi-statement transaction, a transaction’s own previous queries are also visible\n- The above assumes the default read committed isolation level\n\n使用 MVCC 多版本并发控制比锁定模型的主要优点是在 MVCC 里， 对检索（读）数据的锁要求与写数据的锁要求不冲突， 所以读不会阻塞写，而写也从不阻塞读。\n在数据库里也有表和行级别的锁定机制， 用于给那些无法轻松接受 MVCC 行为的应用。 不过，恰当地使用 MVCC 总会提供比锁更好地性能。\n\n### 5.2 DDL 事务\n\nDDL 可以多条放在一起，然后直接 DDL, 据说可以在 sharding 时候用....\n\n### 5.3 事务使用\n\n```sql\nbegin;\n-- insert_somethings;\nsavepoint my_savepoint01;\n-- wrong ops\nrollback to my_savepoint01;\ncommit;\n```\n\n### 5.4 事务隔离级别\n\n- READ UNCOMMITED\n- READ COMMITED\n- REPEATABLE READ\n- SEARLIZABLE\n\n- 脏读 : 和程序的并发一致 默认是不可能的。\n- 不可重复读 : 一个事物重新读取前面读过的数，但是发现被改过了。能读原来则是可重复读。读新的，则是不可重复读。\n- 幻读 : （举一个为赋新词强说愁的例子）比如，先 count 一下，然后依照 count 值遍历 cursor, 结果发现数量发生变化。\n\n读已提交，是默认。在这里，脏读（不会）、不可重复读（可能）、幻读（可能）。\n\n### 5.5 锁机制\n\n- 表级锁模式\n- 行级锁模式\n\n### 5.6 死锁\n\n死锁的典型案例就是：\n\n1. 当你找你爸要钱的时候，你爸说，要是你妈给你钱，我就给你钱。\n2. 当你找你妈要钱的时候，你妈说，要是你爸给你钱，我就给你钱。\n\n死锁的四个必要条件：\n\n- 互斥条件\n- 请求和保持条件\n- 不剥夺条件\n- 环路等待条件\n\n避免死锁的方式，一般是按照顺序来。\n\n当然，数据库可以自动检测出死锁，但是由于捕获死锁需要一定的代价。可能会导致应用程序过久地持有排他锁。\n\n\u003e 慎用排他锁。\n\n## 0x07. 踩坑集\n\n- 序列问题\n"}],"total":5},{"name":"2016-12","posts":[{"tags":["Windows"],"path":"20161221_LeetCodePythonSolution.md","title":"LeetCode Python Solution","slug":"LeetCode Python Solution","date":"2016-12-21","category":"善用佳软","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 前言\n\n刷刷简单的算法问题，顺手提升一下编程的裸写代码的能力。\n\n本文为 LeetCode 的 Easy 算法的解法集合。\n\n\u003c!-- more --\u003e\n\n## Easy 集合\n\n### 1. Two Sum 29.4%\n\n```python\n\n# 尝试：暴力解决\n# 结果：超时\nclass Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        begin = 0\n        end = 0\n        for i in range(len(nums)):\n            for j in range(i,len(nums)):\n                if i != j and target == nums[i] + nums[j]:\n                    return [i,j]\n\n# 尝试：字典也就是 HashMap 解决\n# 结果：读题不准确，数组不行\nclass Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        nums_dict = {}\n        for i,num in enumerate(nums):\n            nums_dict[num] = i\n        for num in nums:\n            item_num_1st = nums_dict.get(num)\n            item_num_2st = nums_dict.get(target-num)\n            if item_num_2st is not None and item_num_1st != item_num_2st:\n                return [item_num_1st,item_num_2st]\n# 尝试：其他\n# 结果：其他\n\n```\n\n### 6. ZigZag Conversion 25.8%\n\n### 7 Reverse Integer 23.7% Easy\n\n```python\nclass Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        preffix = \"\"\n        if \"-\" in str(x):\n            num = int(str(x).strip(\"-\")[::-1])\n            preffix = \"-\"\n        else:\n            num = int(str(x)[::-1])\n        if num \u003e= 2147483648 or num \u003c= -2147483647:\n            return 0\n        return  int(preffix+str(num))\n```\n\n### 8 String to Integer (atoi) 13.8% Easy\n\n### 9 Palindrome Number 34.0% Easy\n\n```python\n# 使用了额外的存储，亟待优化\nclass Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        l_x = list(str(x))\n        return l_x == l_x[::-1]\n```\n\n### 13 Roman to Integer 43.2% Easy\n\n### 14 Longest Common Prefix 30.4% Easy\n\n```python\nclass Solution(object):\n    def longestCommonPrefix(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: str\n        \"\"\"\n        if len(strs) == 0:\n            return \"\"\n        current_clip = \"\"\n        len_strs = [len(_str) for _str in strs]\n        min_strs_len = min(len_strs)\n        has_common_flag = False\n        for _len in range(min_strs_len,0,-1):\n            cliped_strs_set = set()\n            for _str in strs:\n                current_clip = _str[0:_len]\n                cliped_strs_set.add(current_clip)\n            if len(cliped_strs_set) == 1:\n                has_common_flag = True\n                break\n        if has_common_flag:\n            return current_clip\n        else:\n            return \"\"\n```\n\n### 19 Remove Nth Node From End of List 32.0% Easy\n\n### 20 Valid Parentheses 31.9% Easy\n\n### 21 Merge Two Sorted Lists 37.7% Easy\n\n### 24 Swap Nodes in Pairs 37.0% Easy\n\n### 26 Remove Duplicates from Sorted Array 35.2% Easy\n\n### 27 Remove Element 36.7% Easy\n\n### 28 Implement strStr() 26.8% Easy\n\n```python\nclass Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        cur = -1\n        try:\n            cur = haystack.index(needle)\n        except Exception:\n            pass\n        return cur\n```\n\n### 36 Valid Sudoku 33.7% Easy\n\n```python\nclass Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        # 横向\n\n```\n\n### 38 Count and Say 32.3% Easy\n\n### 58 Length of Last Word 31.0% Easy\n\n### 66 Plus One 36.7% Easy\n\n### 67 Add Binary 30.2% Easy\n\n### 70 Climbing Stairs 38.5% Easy\n\n### 83 Remove Duplicates from Sorted List 38.7% Easy\n\n### 88 Merge Sorted Array 31.3% Easy\n\n### 100 Same Tree 45.1% Easy\n\n```python\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        if p is None and q is None:\n            return True\n        elif p is not None and q is not None:\n            return p.val == q.val and self.isSameTree(p.left,q.left) and  self.isSameTree(p.right,q.right)\n        else:\n            return False\n\n```\n\n### 101 Symmetric Tree 36.7% Easy\n\n### 102 Binary Tree Level Order Traversal 36.7% Easy\n\n### 104 Maximum Depth of Binary Tree 50.6% Easy\n\n### 107 Binary Tree Level Order Traversal II 37.5% Easy\n\n### 110 Balanced Binary Tree 36.1% Easy\n\n### 111 Minimum Depth of Binary Tree 32.2% Easy\n\n### 112 Path Sum 32.8% Easy\n\n### 118 Pascal's Triangle 36.5% Easy\n\n### 119 Pascal's Triangle II 34.8% Easy\n\n### 121 Best Time to Buy and Sell Stock 38.9% Easy\n\n### 125 Valid Palindrome 25.2% Easy\n\n### 136 Single Number 52.6% Easy\n\n### 141 Linked List Cycle 35.9% Easy\n\n### 155 Min Stack 26.0% Easy\n\n### 157 Read N Characters Given Read4 29.4% Easy\n\n### 160 Intersection of Two Linked Lists 30.0% Easy\n\n### 165 Compare Version Numbers 19.1% Easy\n\n### 168 Excel Sheet Column Title 24.2% Easy\n\n```python\nclass Solution(object):\n    def titleToNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        result = 0\n        for i,c in enumerate(s[::-1]):\n            result += (ord(c) - ord(\"A\") + 1) * (26 ** i)\n        return result\n```\n\n### 169 Majority Element 44.6% Easy\n\n```python\nclass Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        from collections import Counter\n        return Counter(nums).most_common()[0][0]\n\n```\n\n### 170 Two Sum III - Data structure design 22.6% Easy\n\n### 171 Excel Sheet Column Number 45.0% Easy\n\n### 172 Factorial Trailing Zeroes 34.7% Easy\n\n### 189 Rotate Array 23.3% Easy\n\n### 190 Reverse Bits 29.5% Easy\n\n```\nclass Solution:\n    # @param n, an integer\n    # @return an integer\n    def reverseBits(self, n):\n        return int(bin(n).replace(\"0b\",\"\").zfill(32)[::-1],2)\n```\n\n### 191 Number of 1 Bits 38.4% Easy\n\n### 198 House Robber 37.2% Easy\n\n### 202 Happy Number 39.0% Easy\n\n```python\nclass Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        return self.isHappyNum(self,n,[])\n\n    def isHappyNum(self,n,result_list):\n        result = reduce(lambda x , y : x+ y,map(lambda x : int(x) ** 2 ,str(n).split()))\n        if result in result_list:\n            return False\n        else:\n            result_list.append(result)\n            self.isHappyNum(result,result_list)\n\n```\n\n### 203 Remove Linked List Elements 30.8% Easy\n\n### 204 Count Primes 26.0% Easy\n\n### 205 Isomorphic Strings 32.3% Easy\n\n### 206 Reverse Linked List 43.2% Easy\n\n### 217 Contains Duplicate 43.5% Easy\n\n```python\nclass Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        return nums is not None and len(nums) \u003e= 1 and len(nums) \u003e len(set(nums))\n```\n\n### 219 Contains Duplicate II 31.3% Easy\n\n### 223 Rectangle Area 31.8% Easy\n\n### 225 Implement Stack using Queues 31.0% Easy\n\n### 226 Invert Binary Tree 49.5% Easy\n\n### 231 Power of Two 39.1% Easy\n\n```\nclass Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        if n % 2 == 1 and n \u003e 1:\n            return False\n        elif n \u003c= 0:\n            return False\n        elif n in (2,1):\n            return True\n        else:\n            return self.isPowerOfTwo(n / 2)\n```\n\n### 232 Implement Queue using Stacks 34.9% Easy\n\n### 234 Palindrome Linked List 31.4% Easy\n\n### 235 Lowest Common Ancestor of a Binary Search Tree 38.0% Easy\n\n### 237 Delete Node in a Linked List 45.2% Easy\n\n```python\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def deleteNode(self, node):\n        \"\"\"\n        :type node: ListNode\n        :rtype: void Do not return anything, modify node in-place instead.\n        这个方法是可以 Get 到 node 点的，但是题目的要求应该不是这个意思\n        \"\"\"\n        if node.next is not None:\n            node = node.next\n```\n\n### 242 Valid Anagram 44.6% Easy\n\n```\nclass Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        from collections import Counter\n        return Counter(s) == Counter(t)\n\n```\n\n### 243 Shortest Word Distance 50.5% Easy\n\n### 246 Strobogrammatic Number 38.7% Easy\n\n### 249 Group Shifted Strings 38.1% Easy\n\n### 252 Meeting Rooms 45.2% Easy\n\n### 257 Binary Tree Paths 34.3% Easy\n\n### 258 Add Digits 50.1% Easy\n\n### 263 Ugly Number 38.3% Easy\n\n### 266 Palindrome Permutation 54.8% Easy\n\n### 270 Closest Binary Search Tree Value 37.8% Easy\n\n### 276 Paint Fence 33.7% Easy\n\n### 278 First Bad Version 24.2% Easy\n\n### 283 Move Zeroes 47.5% Easy\n\n```python\n\n# 首先想到的这个答案\n# 然后 leetcode 上面居然还是打印的原来的值，我猜测肯定是用后台进行 id 比对内存地址。好吧，这个方式最好。\nclass Solution(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        zero_count = nums.count(0)\n        new_nums = [num for num in nums if num != 0]\n        new_nums.extend([0]*zero_count)\n        nums = new_nums\n\n## 蛋疼，三重排序\nclass Solution(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        begin_cur = 0\n        end_cur = len(nums) - 1\n        for i in range(len(nums)):\n            for j in range(i,len(nums)):\n                if nums[j] == 0 and nums[j+1] != 0:\n                    nums[j] , nums[j+1] = nums[j+1] , nums[j]\n        print(nums)\n\n```\n\n### 288 Unique Word Abbreviation 15.3% Easy\n\n### 290 Word Pattern 31.9% Easy\n\n### 292 Nim Game 54.6% Easy\n\n### 293 Flip Game 53.7% Easy\n\n### 299 Bulls and Cows 33.0% Easy\n\n### 303 Range Sum Query - Immutable 26.1% Easy\n\n### 326 Power of Three 39.1% Easy\n\n### 339 Nested List Weight Sum 59.5% Easy\n\n### 342 Power of Four 37.2% Easy\n\n### 344 Reverse String 57.4% Easy\n\n```\nclass Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        return s[::-1]\n```\n\n### 345 Reverse Vowels of a String 37.1% Easy\n\n### 346 Moving Average from Data Stream 57.1% Easy\n\n### 349 Intersection of Two Arrays 45.4% Easy\n\n```\nclass Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        return list(set(nums1) \u0026 set(nums2))\n```\n\n### 350 Intersection of Two Arrays II 43.4% Easy\n\n### 359 Logger Rate Limiter 58.0% Easy\n\n### 371 Sum of Two Integers 51.5% Easy\n\n### 374 Guess Number Higher or Lower 33.2% Easy\n\n### 383 Ransom Note 45.9% Easy\n\n### 387 First Unique Character in a String 45.1% Easy\n\n```python\nclass Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        flag = -1\n        from collections import Counter\n        uniq_chars_set = set([k for k , v in Counter(s).items() if v == 1])\n        for i,c in enumerate(s):\n            if c in uniq_chars_set:\n                return i\n        return flag\n```\n\n### 389 Find the Difference 50.3% Easy\n\n### 396 Rotate Function 30.1% Easy\n\n### 400 Nth Digit 30.6% Easy\n\n### 401 Binary Watch 43.1% Easy\n\n### 404 Sum of Left Leaves 45.6% Easy\n\n```\n# Definition for a binary tree node.\n\n# class TreeNode(object):\n\n#     def __init__(self, x):\n\n#         self.val = x\n\n#         self.left = None\n\n#         self.right = None\n\nclass Solution(object):\n\n    def sumOfLeftLeaves(self, root):\n\n        \"\"\"\n\n        :type root: TreeNode\n\n        :rtype: int\n\n        \"\"\"\n\n        if root is None:\n\n            return 0\n\n        return self.newSumOfLeftLeaves(root.left,-1) + self.newSumOfLeftLeaves(root.right,1)\n\n    def newSumOfLeftLeaves(self,root,flag):\n\n        if root is None:\n\n            return 0\n\n        elif root.left is not None and root.right is not None:\n\n            return self.newSumOfLeftLeaves(root.left,-1) + self.newSumOfLeftLeaves(root.right,1)\n\n        elif root.left is None and root.right is None:\n\n            if flag == -1:\n\n                return root.val + self.newSumOfLeftLeaves(root.right,1)\n\n            else:\n\n                return 0\n\n        elif root.left is None and root.right is not None:\n\n            return self.newSumOfLeftLeaves(root.right,1)\n\n        elif root.left is not None and root.right is None:\n\n            return self.newSumOfLeftLeaves(root.left,-1)\n```\n\n### 405 Convert a Number to Hexadecimal 40.6% Easy\n\n### 408 Valid Word Abbreviation 27.2% Easy\n\n### 409 Longest Palindrome 44.1% Easy\n\n```\nclass Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        from collections import Counter\n        max_len = 0\n        odd_count = 0\n        for _chr,_chrs_len in Counter(s).items():\n            if _chrs_len % 2 == 1:\n                odd_count = 1\n                max_len += _chrs_len - 1\n            else:\n                max_len += _chrs_len\n\n        return max_len + odd_count\n```\n\n### 412 Fizz Buzz 58.0% Easy\n\n```\nclass Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        arr = []\n        for i in range(1,n+1):\n            item = None\n            if i % 3 == 0 and i % 5 == 0:\n                item = \"FizzBuzz\"\n                arr.append(item)\n                continue\n            if i % 3 == 0:\n                item = \"Fizz\"\n                arr.append(item)\n                continue\n            if i % 5 == 0:\n                item = \"Buzz\"\n                arr.append(item)\n                continue\n            arr.append(str(i))\n        return arr\n```\n\n### 414 Third Maximum Number 26.7% Easy\n\n### 415 Add Strings 41.1% Easy\n\n```\n# 哼，让我不用，我偏偏要用转 int\nclass Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        return str(int(num1) + int(num2))\n\n# 我就不用 int 都可以 one line\nclass Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        return str(eval(\"{} + {}\".format(num1,num2)))\n```\n\n### 422 Valid Word Square 36.2% Easy\n\n### 434 Number of Segments in a String 39.0% Easy\n\n### 437 Path Sum III 38.6% Easy\n\n### 438 Find All Anagrams in a String 33.4% Easy\n\n### 441 Arranging Coins 36.2% Easy\n\n### 447 Number of Boomerangs 41.8% Easy\n\n### 448 Find All Numbers Disappeared in an Array 61.3% Easy\n\n```\nclass Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        len_nums = len(nums)\n        if len_nums \u003c 1:\n            return []\n        l = list(set(range(1,len_nums + 1)) - set(nums))\n        return l\n```\n\n### 453 Minimum Moves to Equal Array Elements 45.9% Easy\n\n```\nclass Solution(object):\n    def minMoves(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        n - 1 个元素 ++ 等同于 1 个元素 --\n        \"\"\"\n        return sum(nums) - len(nums) * min(nums)\n```\n\n### 455 Assign Cookies 48.7% Easy\n\n```python\n# 二叉树？\n\nclass Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        if len(g) == 0 or len(s) == 0:\n            return 0\n        g.sort()\n        s.sort()\n        satisfied_count = 0\n        while len(s) \u003e 0:\n            max_cookie = s.pop()\n            while len(g) \u003e 0:\n                max_child = g.pop()\n                if max_child \u003c= max_cookie:\n                    satisfied_count += 1\n                    break\n        return satisfied_count\n```\n\n### 459 Repeated Substring Pattern 39.6% Easy\n\n### 461 Hamming Distance 74.8% Easy\n\n```python\nclass Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        ma = str(bin(max(x,y))).replace(\"0b\",\"\").zfill(31)\n        ma_len = len(ma)\n        mi = str(bin(min(x,y))).replace(\"0b\",\"\").zfill(31)\n        print(mi)\n        print(ma)\n        count = 0;\n        for i, chr in enumerate(mi):\n            if ma[i] != chr:\n                count += 1\n        return count\n```\n\n### 463 Island Perimeter 56.3% Easy\n\n### 475 Heaters 30.3% Easy\n\n### 566. Reshape the Matrix\n\n```python\nclass Solution(object):\n    def matrixReshape(self, nums, r, c):\n        \"\"\"\n        :type nums: List[List[int]]\n        :type r: int\n        :type c: int\n        :rtype: List[List[int]]\n        \"\"\"\n        row_len = len(nums)\n        col_len = len(nums[0])\n        if row_len * col_len != r * c:\n            return nums\n        else:\n            new_nums = [[0 for i in range(c)] for j in range(r)]\n            cur = 0\n            for row_nu in range(row_len):\n                for col_nu in range(col_len):\n                    cur += 1\n                    new_row_nu = (cur - 1) // c\n                    new_col_nu = cur - new_row_nu * c - 1\n                    new_nums[new_row_nu][new_col_nu] = nums[row_nu][col_nu]\n        return new_nums\n```\n\n## Medium 集合\n\n### 2 Add Two Numbers 26.1% Medium\n\n### 3 Longest Substring Without Repeating Characters 23.6% Medium\n\n### 5 Longest Palindromic Substring 24.4% Medium\n\n### 11 Container With Most Water 36.0% Medium\n\n### 12 Integer to Roman 42.6% Medium\n\n### 15 3Sum 20.7% Medium\n\n### 16 3Sum Closest 30.4% Medium\n\n### 17 Letter Combinations of a Phone Number 32.1% Medium\n\n### 18 4Sum 25.5% Medium\n\n### 22 Generate Parentheses 41.5% Medium\n\n### 29 Divide Two Integers 15.9% Medium\n\n### 31 Next Permutation 28.0% Medium\n\n### 34 Search for a Range 30.8% Medium\n\n### 35 Search Insert Position 38.8% Medium\n\n### 39 Combination Sum 35.4% Medium\n\n### 40 Combination Sum II 31.0% Medium\n\n### 43 Multiply Strings 25.8% Medium\n\n### 46 Permutations 40.1% Medium\n\n### 47 Permutations II 30.8% Medium\n\n### 48 Rotate Image 36.9% Medium\n\n### 49 Group Anagrams 31.5% Medium\n\n### 50 Pow(x, n) 27.1% Medium\n\n### 53 Maximum Subarray 38.6% Medium\n\n### 54 Spiral Matrix 24.4% Medium\n\n### 55 Jump Game 29.1% Medium\n\n### 59 Spiral Matrix II 37.8% Medium\n\n### 60 Permutation Sequence 27.0% Medium\n\n### 61 Rotate List 24.0% Medium\n\n### 62 Unique Paths 39.0% Medium\n\n### 63 Unique Paths II 30.8% Medium\n\n### 64 Minimum Path Sum 37.0% Medium\n\n### 69 Sqrt(x) 26.8% Medium\n\n### 71 Simplify Path 23.9% Medium\n\n### 73 Set Matrix Zeroes 35.0% Medium\n\n### 74 Search a 2D Matrix 35.6% Medium\n\n### 75 Sort Colors 36.5% Medium\n\n### 77 Combinations 37.6% Medium\n\n### 78 Subsets 36.2% Medium\n\n### 79 Word Search 25.2% Medium\n\n### 80 Remove Duplicates from Sorted Array II 34.7% Medium\n\n### 81 Search in Rotated Sorted Array II 32.9% Medium\n\n### 82 Remove Duplicates from Sorted List II 28.5% Medium\n\n### 86 Partition List 31.4% Medium\n\n### 89 Gray Code 39.1% Medium\n\n### 90 Subsets II 33.6% Medium\n\n### 91 Decode Ways 18.8% Medium\n\n### 92 Reverse Linked List II 29.7% Medium\n\n### 93 Restore IP Addresses 25.7% Medium\n\n### 94 Binary Tree Inorder Traversal 43.5% Medium\n\n### 95 Unique Binary Search Trees II 30.5% Medium\n\n### 96 Unique Binary Search Trees 39.6% Medium\n\n### 98 Validate Binary Search Tree 22.2% Medium\n\n### 103 Binary Tree Zigzag Level Order Traversal 32.0% Medium\n\n### 105 Construct Binary Tree from Preorder and Inorder Traversal 30.6% Medium\n\n### 106 Construct Binary Tree from Inorder and Postorder Traversal 30.8% Medium\n\n### 108 Convert Sorted Array to Binary Search Tree 40.2% Medium\n\n### 109 Convert Sorted List to Binary Search Tree 32.6% Medium\n\n### 113 Path Sum II 31.2% Medium\n\n### 114 Flatten Binary Tree to Linked List 33.4% Medium\n\n### 116 Populating Next Right Pointers in Each Node 36.8% Medium\n\n### 120 Triangle 32.3% Medium\n\n### 122 Best Time to Buy and Sell Stock II 45.3% Medium\n\n### 127 Word Ladder 19.3% Medium\n\n### 129 Sum Root to Leaf Numbers 35.0% Medium\n\n### 130 Surrounded Regions 17.4% Medium\n\n### 131 Palindrome Partitioning 30.6% Medium\n\n### 133 Clone Graph 25.0% Medium\n\n### 134 Gas Station 28.5% Medium\n\n### 137 Single Number II 40.0% Medium\n\n### 139 Word Break 28.0% Medium\n\n### 142 Linked List Cycle II 31.2% Medium\n\n### 143 Reorder List 24.5% Medium\n\n### 144 Binary Tree Preorder Traversal 42.8% Medium\n\n### 147 Insertion Sort List 31.6% Medium\n\n### 148 Sort List 27.2% Medium\n\n### 150 Evaluate Reverse Polish Notation 25.7% Medium\n\n### 151 Reverse Words in a String 15.7% Medium\n\n### 152 Maximum Product Subarray 24.3% Medium\n\n### 153 Find Minimum in Rotated Sorted Array 38.4% Medium\n\n### 156 Binary Tree Upside Down 42.4% Medium\n\n### 161 One Edit Distance 30.3% Medium\n\n### 162 Find Peak Element 35.6% Medium\n\n### 163 Missing Ranges 28.5% Medium\n\n### 166 Fraction to Recurring Decimal 16.7% Medium\n\n### 167 Two Sum II - Input array is sorted 47.9% Medium\n\n### 173 Binary Search Tree Iterator 38.7% Medium\n\n### 179 Largest Number 21.3% Medium\n\n### 186 Reverse Words in a String II 28.5% Medium\n\n### 187 Repeated DNA Sequences 29.3% Medium\n\n### 199 Binary Tree Right Side View 38.4% Medium\n\n### 200 Number of Islands 32.0% Medium\n\n### 201 Bitwise AND of Numbers Range 33.0% Medium\n\n### 207 Course Schedule 30.2% Medium\n\n### 208 Implement Trie (Prefix Tree) 25.6% Medium\n\n### 209 Minimum Size Subarray Sum 28.4% Medium\n\n### 210 Course Schedule II 25.3% Medium\n\n### 211 Add and Search Word - Data structure design 20.1% Medium\n\n### 213 House Robber II 32.9% Medium\n\n### 215 Kth Largest Element in an Array 37.2% Medium\n\n### 216 Combination Sum III 41.5% Medium\n\n### 220 Contains Duplicate III 19.5% Medium\n\n### 221 Maximal Square 26.8% Medium\n\n### 222 Count Complete Tree Nodes 26.9% Medium\n\n### 227 Basic Calculator II 27.9% Medium\n\n### 228 Summary Ranges 27.8% Medium\n\n### 229 Majority Element II 27.6% Medium\n\n### 230 Kth Smallest Element in a BST 41.7% Medium\n\n### 236 Lowest Common Ancestor of a Binary Tree 29.2% Medium\n\n### 238 Product of Array Except Self 46.8% Medium\n\n### 240 Search a 2D Matrix II 37.8% Medium\n\n### 241 Different Ways to Add Parentheses 40.9% Medium\n\n### 244 Shortest Word Distance II 34.8% Medium\n\n### 245 Shortest Word Distance III 49.2% Medium\n\n### 247 Strobogrammatic Number II 38.0% Medium\n\n### 250 Count Univalue Subtrees 40.0% Medium\n\n### 251 Flatten 2D Vector 38.5% Medium\n\n### 253 Meeting Rooms II 38.0% Medium\n\n### 254 Factor Combinations 40.0% Medium\n\n### 255 Verify Preorder Sequence in Binary Search Tree 38.7% Medium\n\n### 256 Paint House 45.7% Medium\n\n### 259 3Sum Smaller 40.5% Medium\n\n### 260 Single Number III 48.9% Medium\n\n### 261 Graph Valid Tree 36.3% Medium\n\n### 264 Ugly Number II 31.3% Medium\n\n### 267 Palindrome Permutation II 30.8% Medium\n\n### 268 Missing Number 43.3% Medium\n\n### 271 Encode and Decode Strings 26.5% Medium\n\n### 274 H-Index 31.9% Medium\n\n### 275 H-Index II 33.5% Medium\n\n### 277 Find the Celebrity 35.4% Medium\n\n### 279 Perfect Squares 34.7% Medium\n\n### 280 Wiggle Sort 54.5% Medium\n\n### 281 Zigzag Iterator 47.9% Medium\n\n### 284 Peeking Iterator 35.0% Medium\n\n### 285 Inorder Successor in BST 36.2% Medium\n\n### 286 Walls and Gates 42.0% Medium\n\n### 289 Game of Life 36.2% Medium\n\n### 294 Flip Game II 44.9% Medium\n\n### 298 Binary Tree Longest Consecutive Sequence 39.7% Medium\n\n### 300 Longest Increasing Subsequence 37.2% Medium\n\n### 304 Range Sum Query 2D - Immutable 22.7% Medium\n\n### 306 Additive Number 27.1% Medium\n\n### 307 Range Sum Query - Mutable 18.5% Medium\n\n### 309 Best Time to Buy and Sell Stock with Cooldown 39.4% Medium\n\n### 310 Minimum Height Trees 28.3% Medium\n\n### 311 Sparse Matrix Multiplication 50.4% Medium\n\n### 313 Super Ugly Number 36.8% Medium\n\n### 314 Binary Tree Vertical Order Traversal 34.9% Medium\n\n### 318 Maximum Product of Word Lengths 41.9% Medium\n\n### 319 Bulb Switcher 41.8% Medium\n\n### 320 Generalized Abbreviation 43.0% Medium\n\n### 322 Coin Change 25.9% Medium\n\n### 323 Number of Connected Components in an Undirected Graph 46.2% Medium\n\n### 324 Wiggle Sort II 25.0% Medium\n\n### 325 Maximum Size Subarray Sum Equals k 41.4% Medium\n\n### 328 Odd Even Linked List 41.6% Medium\n\n### 331 Verify Preorder Serialization of a Binary Tree 34.9% Medium\n\n### 332 Reconstruct Itinerary 27.7% Medium\n\n### 333 Largest BST Subtree 29.6% Medium\n\n### 334 Increasing Triplet Subsequence 37.6% Medium\n\n### 337 House Robber III 41.3% Medium\n\n### 338 Counting Bits 59.3% Medium\n\n### 341 Flatten Nested List Iterator 38.2% Medium\n\n### 343 Integer Break 44.6% Medium\n\n### 347 Top K Frequent Elements 45.6% Medium\n\n### 348 Design Tic-Tac-Toe 45.0% Medium\n\n### 351 Android Unlock Patterns 42.3% Medium\n\n### 353 Design Snake Game 25.1% Medium\n\n### 355 Design Twitter 24.1% Medium\n\n### 356 Line Reflection 29.7% Medium\n\n### 357 Count Numbers with Unique Digits 44.8% Medium\n\n### 360 Sort Transformed Array 43.0% Medium\n\n### 361 Bomb Enemy 37.8% Medium\n\n### 362 Design Hit Counter 52.4% Medium\n\n### 364 Nested List Weight Sum II 50.2% Medium\n\n### 365 Water and Jug Problem 25.9% Medium\n\n### 366 Find Leaves of Binary Tree 56.7% Medium\n\n### 367 Valid Perfect Square 37.2% Medium\n\n### 368 Largest Divisible Subset 32.7% Medium\n\n### 369 Plus One Linked List 52.2% Medium\n\n### 370 Range Addition 52.8% Medium\n\n### 372 Super Pow 32.9% Medium\n\n### 373 Find K Pairs with Smallest Sums 29.5% Medium\n\n### 375 Guess Number Higher or Lower II 34.7% Medium\n\n### 376 Wiggle Subsequence 34.3% Medium\n\n### 377 Combination Sum IV 41.5% Medium\n\n### 378 Kth Smallest Element in a Sorted Matrix 42.9% Medium\n\n### 379 Design Phone Directory 29.1% Medium\n\n### 382 Linked List Random Node 46.1% Medium\n\n### 384 Shuffle an Array 44.7% Medium\n\n### 385 Mini Parser 29.4% Medium\n\n### 386 Lexicographical Numbers 39.0% Medium\n\n### 388 Longest Absolute File Path 34.4% Medium\n\n### 390 Elimination Game 37.4% Medium\n\n### 392 Is Subsequence 44.1% Medium\n\n### 393 UTF-8 Validation 35.2% Medium\n\n### 394 Decode String 39.7% Medium\n\n### 395 Longest Substring with At Least K Repeating Characters 35.3% Medium\n\n### 397 Integer Replacement 28.9% Medium\n\n### 398 Random Pick Index 39.0% Medium\n\n### 399 Evaluate Division 39.2% Medium\n\n### 402 Remove K Digits 25.9% Medium\n\n### 406 Queue Reconstruction by Height 54.1% Medium\n\n### 413 Arithmetic Slices 54.2% Medium\n\n### 416 Partition Equal Subset Sum 37.2% Medium\n\n### 417 Pacific Atlantic Water Flow 32.7% Medium\n\n### 418 Sentence Screen Fitting 26.9% Medium\n\n### 419 Battleships in a Board 59.8% Medium\n\n### 421 Maximum XOR of Two Numbers in an Array 40.6% Medium\n\n### 423 Reconstruct Original Digits from English 41.7% Medium\n\n### 424 Longest Repeating Character Replacement 39.6% Medium\n\n### 435 Non-overlapping Intervals 39.8% Medium\n\n### 436 Find Right Interval 41.9% Medium\n\n### 439 Ternary Expression Parser 49.3% Medium\n\n### 442 Find All Duplicates in an Array 45.6% Medium\n\n### 444 Sequence Reconstruction 20.1% Medium\n\n### 445 Add Two Numbers II 44.5% Medium\n\n### 449 Serialize and Deserialize BST 40.1% Medium\n\n### 450 Delete Node in a BST 32.4% Medium\n\n### 451 Sort Characters By Frequency 50.3% Medium\n\n### 452 Minimum Number of Arrows to Burst Balloons 41.9% Medium\n\n### 454 4Sum II 41.2% Medium\n\n### 456 132 Pattern 27.3% Medium\n\n### 462 Minimum Moves to Equal Array Elements II 50.3% Medium\n\n### 464 Can I Win 21.4% Medium\n\n### 467 Unique Substrings in Wraparound String 28.4% Medium\n\n### 468 Validate IP Address 21.8% Medium\n\n### 469 Convex Polygon 24.6% Medium\n\n### 473 Matchsticks to Square 27.5% Medium\n\n### 474 Ones and Zeroes 32.7% Medium\n\n### 477 Total Hamming Distance 40.1% Medium\n\n## Hard 集合\n\n### 4 Median of Two Sorted Arrays 20.7% Hard\n\n### 10 Regular Expression Matching 23.4% Hard\n\n### 23 Merge k Sorted Lists 25.7% Hard\n\n### 25 Reverse Nodes in k-Group 29.6% Hard\n\n### 30 Substring with Concatenation of All Words 21.6% Hard\n\n### 32 Longest Valid Parentheses 23.0% Hard\n\n### 33 Search in Rotated Sorted Array 31.8% Hard\n\n### 37 Sudoku Solver 27.8% Hard\n\n### 41 First Missing Positive 24.9% Hard\n\n### 42 Trapping Rain Water 35.1% Hard\n\n### 44 Wildcard Matching 18.9% Hard\n\n### 45 Jump Game II 26.0% Hard\n\n### 51 N-Queens 28.8% Hard\n\n### 52 N-Queens II 42.5% Hard\n\n### 56 Merge Intervals 28.2% Hard\n\n### 57 Insert Interval 26.2% Hard\n\n### 65 Valid Number 12.6% Hard\n\n### 68 Text Justification 17.9% Hard\n\n### 72 Edit Distance 30.5% Hard\n\n### 76 Minimum Window Substring 23.6% Hard\n\n### 84 Largest Rectangle in Histogram 25.5% Hard\n\n### 85 Maximal Rectangle 25.8% Hard\n\n### 87 Scramble String 28.1% Hard\n\n### 97 Interleaving String 23.9% Hard\n\n### 99 Recover Binary Search Tree 28.6% Hard\n\n### 115 Distinct Subsequences 30.5% Hard\n\n### 117 Populating Next Right Pointers in Each Node II 33.4% Hard\n\n### 123 Best Time to Buy and Sell Stock III 28.1% Hard\n\n### 124 Binary Tree Maximum Path Sum 24.9% Hard\n\n### 126 Word Ladder II 13.6% Hard\n\n### 128 Longest Consecutive Sequence 35.1% Hard\n\n### 132 Palindrome Partitioning II 23.3% Hard\n\n### 135 Candy 23.8% Hard\n\n### 138 Copy List with Random Pointer 26.5% Hard\n\n### 140 Word Break II 22.0% Hard\n\n### 145 Binary Tree Postorder Traversal 38.2% Hard\n\n### 146 LRU Cache 16.0% Hard\n\n### 149 Max Points on a Line 15.5% Hard\n\n### 154 Find Minimum in Rotated Sorted Array II 36.0% Hard\n\n### 158 Read N Characters Given Read4 II - Call multiple times 24.2% Hard\n\n### 159 Longest Substring with At Most Two Distinct Characters 39.3% Hard\n\n### 164 Maximum Gap 28.5% Hard\n\n### 174 Dungeon Game 22.8% Hard\n\n### 188 Best Time to Buy and Sell Stock IV 23.7% Hard\n\n### 212 Word Search II 22.1% Hard\n\n### 214 Shortest Palindrome 22.7% Hard\n\n### 218 The Skyline Problem 25.3% Hard\n\n### 224 Basic Calculator 25.3% Hard\n\n### 233 Number of Digit One 27.2% Hard\n\n### 239 Sliding Window Maximum 31.2% Hard\n\n### 248 Strobogrammatic Number III 30.2% Hard\n\n### 265 Paint House II 37.0% Hard\n\n### 269 Alien Dictionary 22.5% Hard\n\n### 272 Closest Binary Search Tree Value II 37.2% Hard\n\n### 273 Integer to English Words 20.9% Hard\n\n### 282 Expression Add Operators 28.3% Hard\n\n### 287 Find the Duplicate Number 41.6% Hard\n\n### 291 Word Pattern II 37.4% Hard\n\n### 295 Find Median from Data Stream 23.2% Hard\n\n### 296 Best Meeting Point 50.0% Hard\n\n### 297 Serialize and Deserialize Binary Tree 31.3% Hard\n\n### 301 Remove Invalid Parentheses 34.5% Hard\n\n### 302 Smallest Rectangle Enclosing Black Pixels 43.3% Hard\n\n### 305 Number of Islands II 37.9% Hard\n\n### 308 Range Sum Query 2D - Mutable 19.9% Hard\n\n### 312 Burst Balloons 41.4% Hard\n\n### 315 Count of Smaller Numbers After Self 33.4% Hard\n\n### 316 Remove Duplicate Letters 28.3% Hard\n\n### 317 Shortest Distance from All Buildings 33.2% Hard\n\n### 321 Create Maximum Number 23.8% Hard\n\n### 327 Count of Range Sum 28.6% Hard\n\n### 329 Longest Increasing Path in a Matrix 35.1% Hard\n\n### 330 Patching Array 31.3% Hard\n\n### 335 Self Crossing 23.7% Hard\n\n### 336 Palindrome Pairs 24.3% Hard\n\n### 340 Longest Substring with At Most K Distinct Characters 38.6% Hard\n\n### 352 Data Stream as Disjoint Intervals 38.7% Hard\n\n### 354 Russian Doll Envelopes 31.4% Hard\n\n### 358 Rearrange String k Distance Apart 31.7% Hard\n\n### 363 Max Sum of Rectangle No Larger Than K 32.0% Hard\n\n### 380 Insert Delete GetRandom O(1) 38.0% Hard\n\n### 381 Insert Delete GetRandom O(1) - Duplicates allowed 27.7% Hard\n\n### 391 Perfect Rectangle 23.3% Hard\n\n### 403 Frog Jump 30.2% Hard\n\n### 407 Trapping Rain Water II 35.0% Hard\n\n### 410 Split Array Largest Sum 31.1% Hard\n\n### 411 Minimum Unique Word Abbreviation 30.9% Hard\n\n### 420 Strong Password Checker 21.5% Hard\n\n### 425 Word Squares 42.0% Hard\n\n### 432 All O`one Data Structure 28.4% Hard\n\n### 440 K-th Smallest in Lexicographical Order 21.4% Hard\n\n### 446 Arithmetic Slices II - Subsequence 22.0% Hard\n\n### 465 Optimal Account Balancing 27.5% Hard\n\n### 466 Count The Repetitions 24.6% Hard\n\n### 471 Encode String with Shortest Length 45.9% Hard\n\n### 472 Concatenated Words 28.2% Hard\n"},{"tags":["PostgreSQL"],"path":"20161211_RedisCheatSheet.md","title":"Redis Cheatsheet","slug":"Redis Cheatsheet","date":"2016-12-11","category":"DevOps","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n# Redis Cheatsheet\n\n## 0x00. 前言\n\n本文为 Cheatsheet 类型文章，用于记录我在日常编程中经常使用的 MongoDB 相关命令。\n\n- Redis Shell\n- Redis 配套工具\n- Redis-Py\n- 常见问题\n- 踩坑记录\n\n不定期更新。\n\n\u003c!-- more --\u003e\n\n## 0x01 Redis Shell\n\n- RedisClient\n- 通过网络或者 Dash 查看文档\n- Redis 官方自带工具\n\n## 0x02 Redis 使用场景\n\n1. 记录点赞数 hash\n2. 记录最近帖子列表 便于快速显示 zset\n3. 记录帖子的点赞人，和去重 zset\n4. 相关内容。list\n5. 计数器，用于分配 ID\n\n### 分布式锁\n\n基本用法就是\n\n```\nset lock:upgdatenewprofile true ex 5 nx\nTODO: 搞事情\ndel lock:upgdatenewprofile\n```\n\n但是呢？这个逻辑还是有问题的，比如第一个线程的搞事情的时间大于 5s, 那么第二个线程就会加个锁，然后第一个线程释放掉锁。\n\n于是第三个线程一看，哟，没锁，就开始搞事情。\n\n这种情况可以使用可重入锁.（但可重入锁本身就会增加代码的复杂度）\n\n### 延时队列\n\n```\nbrpop\nblpop\n```\n\nblocking 本身也会爆异常，所以，也要处理好异常。\n\n## 0x03 Redis-Py\n\n### 基本类型与其操作\n\n- string\n- hash\n- set\n- zset 有序集合\n\n```\nset/get\nmget name1,name2,name3\nmset name1 value1 name2 value2\nexpire name1 5\nsetex name1 5 value1\n```\n\n```\n# 队列\nrpush queue item1 item2 item3\nllen queue\nlpop queue\n```\n\n```\n# 栈\nrpush stack item1 item2 item3\nllen stack\nrpop stack\n```\n\n慢操作\n\n```\nlindex # O(n)\n\nlrange queue 0 -1\n```\n\n```\n# hash 操作\nhgetall\nhlen\nhget\nhset\nhmset\n```\n\n```\n# 有序列表\nzadd\nxrange\nzrevrange\nzcard\n```\n\n### 高级类型与其操作\n\n## 0x04 常见问题\n\n```\nbgsave 镜像全量持久化 耗时长\nbgsave 子进程创建之后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开.fork / cow\naof 增量持久化，定期 aof 重写，redis4.0 混合了 bgsave 和 aof, 效果更好\naof 如果每条数据 sync 一下，那么就会不丢数据。然而，鬼才会这么做。\n```\n\n## 0x05 踩坑记录\n\n### 1. 无法磁盘持久化\n\n用 scrapy 配合 scrapy-redis 抓取网页并且存储到 MongoDB 里面。\n\n由于 scrapy-redis 重写了 scrapy 的几个核心模块，借助 redis 来实现多个 scrapy 节点从而实现分布式。\n\n默认的 scrapy 设置会把 items 放在 redis 从而方便程序对 items 进行后续处理。这个设计很完美，只是美中不足的是，我常常需要抓取大量页面直接缓存到数据库中。这就导致了 redis 很快就满了。\n\n于是很容易报出这么一个错误。\n\n\u003e (error) MISCONF Redis is configured to save RDB snapshots, but is currently not able to persist on disk. Commands that may modify the data set are disabled. Please check Redis logs for details about the error.\n\n出错原因如同提示所言，无法磁盘持久化。\n\n基本上问题可能就是：\n\n1. 磁盘满了。\n2. redis 本身在某个地方配置了磁盘缓存的大小。\n3. 其他权限之类的问题。\n\n最快的解决方式就是删除占用磁盘的部分。\n\n```bash\n# 进入 redis-cli 删除 items\nconfig set stop-writes-on-bgsave-error no\ndel xxx_html:items\nconfig set stop-writes-on-bgsave-error yes\n# 到 bash 下面检查磁盘，我的机器瞬间释放了 3GB 的磁盘空间\ndf -hl\n```\n\n备注：del 一次即可，因为有程序正在运行，所以当 del 之后，原来阻塞的程序接着开始运行。 xxx_html:items 会不断出现新的值。\n\nScrapy 立马就开始工作了（无需重启）\n\n但是这也不是没有弊端的，依据官方文档所言，只有你完全不 care 数据持久化的情况下才可以使用这种方式\n\n最好的方式当然是让 bgsave 完全 work 了\n\n```\n# redis-cli\n127.0.0.1:6379\u003e CONFIG SET dir /data/tmp\nOK\n127.0.0.1:6379\u003e CONFIG SET dbfilename temp.rdb\nOK\n127.0.0.1:6379\u003e BGSAVE\nBackground saving started\n127.0.0.1:6379\u003e\n```\n\n---\n\nChangeLog:\n\n- **2016-12-11** 重修文字\n- **2018-08-28** 常用场景\n"},{"tags":["CheatSheet"],"path":"20161210_CheatSheet.md","title":"Cheatsheet 集合篇","slug":"Cheatsheet 集合篇","date":"2016-12-10","category":"技术未分类","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n# Cheatsheet 集合篇\n\n## 0x00. 前言\n\n本文为 Cheatsheet 类型文章的集合。\n\n编码最重要的是思路。\n\n\u003e 做什么不是呢？\n\n- 有人问：你想那么多不累吗？\n- 答：比起出乱子，想多当然是最省事的方式。\n\n截止今日已经更新 7 篇 CheatSheet 文章，打算不断完善它们。\n\n\u003c!-- more --\u003e\n\n## 0x01. 目录\n\n- [Ubuntu CheatSheet](/2016/10/05/UbuntuCheatsheet/)\n- [Mac CheatSheet](/2016/12/05/MacCheatsheet/)\n\n- [Vim CheatSheet](/2016/10/05/VimCheatsheet/)\n- [VSCode CheatSheet](/2016/12/11/RedisCheatSheet/)\n\n- [Shell CheatSheet](/2015/04/18/ShellCheatCheet/)\n- [Pandas CheatSheet](/2016/12/11/RedisCheatSheet/)\n- [XPath CheatSheet](/2016/12/03/XPathCheatsheet/)\n\n- [Docker CheatSheet](/2016/09/12/MySQLCheatSheet/)\n- [MySQL CheatSheet](/2016/09/12/MySQLCheatSheet/)\n- [PostgreSQL CheatSheet](/2016/09/12/MySQLCheatSheet/)\n- [Mongo CheatSheet](/2016/12/09/MongoCheatSheet/)\n- [Redis CheatSheet](/2016/12/11/RedisCheatSheet/)\n"},{"tags":["PostgreSQL"],"path":"20161209_MongoCheatSheet.md","title":"MongoDB Cheatsheet","slug":"MongoDB Cheatsheet","date":"2016-12-09","category":"DevOps","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n# MongoDB Cheatsheet\n\n## 0x01 前言\n\n本文为 Cheatsheet 类型文章，用于记录我在日常编程中经常使用的 MongoDB 相关命令。\n\n- Mongo Shell\n- Mongo 配套工具\n- Python API\n\n不定期更新。\n\n\u003c!-- more --\u003e\n\n## 0x02 安装\n\n```bash\n# MacOS 安装\nbrew install mongodb\nbrew services start mongodb\n# Ubuntu Server 16.04\nsudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv EA312927\necho \"deb http://repo.mongodb.org/apt/ubuntu xenial/mongodb-org/3.2 multiverse\" | sudo tee /etc/apt/sources.list.d/mongodb-org-3.2.list\napt-get update -y\napt-get install -y mongodb-org\nservice mongod start\n```\n\n## 0x03 配置\n\n### IP 地址\n\n## MongoDB 配套工具\n\n- RoboMongo\n- 通过网络或者 Dash 查看文档\n- Mongo 官方自带工具\n\n## MongoDB Shell\n\n## 基本查询\n\ndb.users.find({\"name\": /._m._/})\ndb.users.find({'name': {'$regex': 'sometext'}})\n\nhttps://docs.mongodb.com/manual/\n\n### 增删改查\n\nuse myNewDatabase\ndb.myCollection.insert( { x: 1 } );\n\n### 聚合操作\n\n## PyMongo\n\n```bash\n# 建索引的时候，会阻塞当前的操作，甚至是查询操作\n# 据说转为 background 方式不会阻塞但是，没有实践过\n\"msg\" : \"Index Build Index Build: 167413/751748 22%\",\n\"progress\" : {\n\t\"done\" : 167413,\n\t\"total\" : 751748\n},\n```\n"},{"tags":["Python"],"path":"20161203_Python文本处理.md","title":"Text Processing In Python","slug":"Text Processing In Python","date":"2016-12-03","category":"Python","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n# Text Processing In Python\n\n## 0x00 前言\n\n本文为 Cheatsheet 类型文章，用于记录我在日常编程中的文本处理相关思路。\n\n本文的目录为：\n\n- 正则处理相关\n- HTML/XML 处理相关\n- Python 中的文本处理\n\n## 0x01 正则处理相关\n\n### 1.1. 正则表达式\n\n正则是个很奇葩的名字，为什么叫做正则表达式呢，首先是个表达式，其次，这是一种叫做正则 (regular expression, rational expression) 的表达式。\n名称为什么叫做 regular 呢，因为它基于 regular language. 而 regular language 是一种 formal language. 得，现在又开始是编译原理相关概念了。为了逃避概念，通过用途来简单定义正则表达式。\n\n简而言之，就是一种用于字符串搜索的模式。或者就是一种领域专用编程语言。\n\nhttps://en.wikipedia.org/wiki/Regular_expression\n\n### 1.2. Python 中正则表达式语法\n\n```python\n# 元字符\n. ^ $ * + ? { } [ ] \\ | ( )\n\n* # 速记，天上一个星星都没有，0 到多个。\n+ # 一加手机..... 1 到多个。\n? # 有还是没有 即 0 or 1\n*? # 没有疑问就是贪婪，有疑问就是非贪婪\n+?\n??\n\n{m} # m 份\n{m,n} # 优先匹配 a{2,}b 优先匹配 aaaab 中 aaaab\n{m,n}? # 优先匹配 a{2,}b 优先匹配 aaaab 中 aab\n\n[] # [a\\-z] == [az-]\n# 1. [\\w] [\\S]\n# 2. [^5]\n# 3. [akm$]  在 [] 中 $ 并不具备元字符特点\n\nPattenA | PattenB\n(...) # 捕获 , 引用可以使用、1 , 但是还有一种扩展语法\n\n(?...) # 扩展\n# - (?aiLmsux)\n# - (?:...) 不捕获\n# - (?P\u003cquote\u003e...) 正则内引用 (?P=quote);python 内获取 m.group('quote') ,m.end('quote');re.sub 内 repl 参数为、g\u003cquote\u003e \\g\u003c1\u003e \\1\n\n```\n\n### 1.3. Python 中使用正则的方法\n\n#### 1.3.1. re 模块的用法\n\n- sub 替换\n- match / fullmatch 匹配\n- search 搜索\n- split 分片\n\n```python\nre.split('(\\W+)', '...words, words...')\n# ['', '...', 'words', ', ', 'words', '...', '']\n```\n\n\u003e match 为匹配起始字符 / fullmatch 为全部字符 / search 为搜索\n\n#### 1.3.2. match object 的用法\n\n```python\nm.group(0)\nm.group(1, 2)\n\u003e\u003e\u003e m = re.match(r\"(?P\u003cfirst_name\u003e\\w+) (?P\u003clast_name\u003e\\w+)\", \"Malcolm Reynolds\")\n\u003e\u003e\u003e m.group('first_name')\n'Malcolm'\n\u003e\u003e\u003e m.group('last_name')\n'Reynolds'\nm.start() # 起始\nm.end()   # 结尾\n```\n\n## 1.4. 正则表达式性能\n\n```python\n# 编译优于不编译\nprog = re.compile(pattern)\nresult = prog.match(string)\nre.match(pattern,string)\n```\n\n## 0x02 HTML/XML 处理相关\n\n### 2.1. Beautifulsoup 处理 HTML\n\n解析往往伴随着各种各样奇葩的不奇葩的，诡异的不诡异的网页数据抽取，这个过程中，我们常使用两个库来解决问题，一个库叫做 lxml, 另一个库叫做 BeautifulSoup.\n\nbeautifulsoup 可是让我们通过直接手动编写遍历 dom 树的方法来快速遍历 dom 树从而获得数据。相比自己写解析器而言，可以算得上非常的节省时间了。\n\n只要能手动遍历 dom 树，基本上所有的数据都是可以获取的。痛点就是手动编写遍历 Dom 树并且完成测试的时间可能长一些。\n\n但是开发效率就比较低了。\n\n举个例子：\n\n```html\n\u003cdiv id=\"lal\"\u003e\n  \u003cspan class=\"item\" itemprop=\"street-address\" title=\"浦东南路八佰伴西面\"\u003e\n    地址：浦东南路八佰伴西面\n  \u003c/span\u003e\n  \u003cdiv class=\"item\" itemprop=\"street-address\" title=\"浦东南路\"\u003e名称：xxxx\u003c/div\u003e\n\u003c/div\u003e\n```\n\n我想要地址属性，如果是 beautifulsoup, 则我们需要先定位到 id 为 lal 的 div 元素。然后获取每个元素的 text 部分，然后使用 if 判断地址属性，然后提取 text.\n\n**但是如果用 xpath, 则可以把对元素的简单定位简单判断直接写在 xpath 表达式。**\n\n```python\nsel.xpath('//div[@id=\"lal\"]/*[contains(text(),\"地址\")]/text()').extract_first()\n# 如果还需要添加筛选名称，则可是使用\nsel.xpath('//div[@id=\"lal\"]/*[contains(text(),\"名称\")]/text()').extract_first()\n```\n\n这样可以极大的提升开发效率。\n\n页面的结构越复杂，则 xpath 带来的开发效率越高。\n\n### 2.2. XPath 处理 HTML\n\n#### 2.2.1. 概念\n\nXPath 是一种通过路径表达式定位 XML 文档内容的语法。\n由于内置了大量的表达式函数，可以通过极少的代码完成定位。\n有七种**节点类型**:\n\n- element\n- attribute\n- text\n- namespace\n- processing-instruction\n- comment\n- document nodes\n\n有五种**节点间关系**:\n\n- 父节点 Parent\n- 子节点 Children\n- 兄弟节点 Siblings\n- 先祖节点，即父与父父节点。Ancestors\n- 后代节点，即子与子子节点。Descendants\n\n| 语法     | 描述       | 例子                     |\n| -------- | ---------- | ------------------------ |\n| nodename | 节点名称   | a                        |\n| /        | 根节点     | /                        |\n| //       | 匹配所有   | bookstore//book          |\n| .        | 当前节点   |                          |\n| ..       | 父节点     | a/../a/..                |\n| @        | 属性       | a/@href                  |\n| []       | 谓语       | book[1] , book[last()-1] |\n| func()   | 表达式函数 | postion()                |\n\n```python\nresponse.xpath(\"//*[@id=\\\"landlb_B04_04\\\"]/span[2]/a[contains(@href,'market')]\")\nresponse.xpath(\"//*[@id=\\\"landlb_B04_04\\\"]/span[2]/a[not(@class)]\")\nresponse.xpath(\"//ul/li/b[contains(text(),'什么玩意')]/following-sibling::span/text()\")\nresponse.xpath(\"//div[@class='address']/text()[preceding::span[@class='item' and contains(text(),'地址：')]]\")\nresponse.xpath(\"//ul/li/b[contains(text(),'什么玩意：')]/following-sibling::a/text()\")\n```\n\n```bash\n//*[contains(text(),'ABC')]\n# http://stackoverflow.com/questions/3655549/xpath-containstext-some-string-doesnt-work-when-used-with-node-with-more/3655588#3655588\n\n\u003cdiv class=\"atag btag\" /\u003e\n//div[contains(@class, 'atag') and contains(@class ,'btag')]\n```\n\n#### 2.2.2. lxml parsel\n\n这两个库是 Python 中常用的解析表达式， parsel 依赖于 lxml , 安装完 lxml 后直接安装即可。\n\n#### 2.2.3. lxml 的番外\n\n众所周知，Mac 的 Homebrew 很方便，每一次遇到需要下载编译的组件的时候，只需要执行 brew install xxx, 很快就可以使用了。\n\n但 homebrew 安装的软件都是最新的，这很容易导致部分软件由于版本更新带来的兼容性问题。\n\n这不，最近在 Mac 上进行开发的时候每次调用初始化 lxml 的时候总是无法进行解析，最后经过排查发现问题是 lxml 在编译的时候使用的 libxml 2.9.4 但是 使用的版本为 2.9.2 , 于是每当我使用 lxml 的时候，就会报错。\n\n不得已，找到 lxml 的 F\u0026Q 部分发现提 issue 之前需要先查看依赖版本。\n\n于是进入 IPython 排查。\n\n```Python\nimport sys\nfrom lxml import etree\n\nprint(\"%-20s: %s\" % ('Python', sys.version_info))\nprint(\"%-20s: %s\" % ('lxml.etree', etree.LXML_VERSION))\nprint(\"%-20s: %s\" % ('libxml used', etree.LIBXML_VERSION))\nprint(\"%-20s: %s\" % ('libxml compiled', etree.LIBXML_COMPILED_VERSION))\nprint(\"%-20s: %s\" % ('libxslt used', etree.LIBXSLT_VERSION))\nprint(\"%-20s: %s\" % ('libxslt compiled', etree.LIBXSLT_COMPILED_VERSION))\n\n# Python : sys.version_info(major=3, minor=5, micro=1, releaselevel='final', serial=0)\n# lxml.etree : (3, 6, 2, 0)\n# libxml used : (2, 9, 2)\n# libxml compiled : (2, 9, 4) # 注意问题出在这里。\n# libxslt used : (1, 1, 28)\n# libxslt compiled : (1, 1, 28)\n```\n\n于是使用 pip 强制进行安装升级。\n\n```\nSTATIC_DEPS=true pip install -i http://pypi.douban.com/simple/ –trusted-host pypi.douban.com lxml –ignore-installed –no-cache-dir –upgrade -vvv\n```\n\n安装完毕即可。\n\n### 2.3. 标准库处理 HTML\n"}],"total":5},{"name":"2016-11","posts":[{"tags":["清单"],"path":"20161126_Pythonista_List.md","title":"Awesome-Python","slug":"Awesome-Python","date":"2016-11-26","category":"Python","lastMod":"2021-06-30","description":"Awesome-Python","thumbnail":"","content":"\n# Python Awesome\n\n清单入选标准\n\n1. 笔者正在使用的，即，过时的东西不入选\n2. 并不拘泥于 Python, 即如果在其他语言里有更好的解决方案，我会在其他语言的 Awesome list 里推荐\n\n## 0x01 环境搭建\n\n- pyenv\n- pyenv virtualenv\n- poetry\n- pipenv （更推荐 poetry)\n\n## 0x02 爬虫\n\n爬虫的流程如下，获取 - 解析 - 分析 - 入库\n\n扩展的时候需要各自做好拆分\n\n- 获取\n- 解析\n- 分析\n- 入库\n\n社区爱用 PySpider Scrapy 这类框架\n\n也有喜欢直接手动组装的库来做爬虫的\n\n分析\n\n- charles 用于抓包和测试\n- mitmproxy\n\n请求\n\n- requests\n- headless-chrome\n- socket\n\nApp 模拟点击\n\n- appnium\n\n解析\n\n- json\n- nodejs 配合 v8 引擎可以复用一部分 js 代码得出真实数据。\n- beautifulsoup\n- lxml\n- pyquery\n\n清洗与入库\n\n并发\n\n- multiprocessing\n- threading\n- asyncio\n- gevent\n\n## 0x03 Flask Web\n\n```bash\nflask-sqlalchemy\nflask-migrate\n```\n\n## 0x04 Django Web\n\n```bash\nDjango\ncelery\ndjango-debug-toolbar\ndjango-extensions\ndjango-filter\ndjango-grappelli\nxadmin\ndjango-mptt\ndjango-redis\ndjangorestframework\n```\n\n## 0x04 FastApi Web\n\n```bash\nfastapi\nuvicorn\njwt\npsycopg2-binary\naiofiles\norjson\ntortoise-orm\nasyncpg\naioredis\naiokafka\n```\n\n## 0x07 调试与测试\n\n```\nipython\njupyter notebook\nipdb\nhttps://github.com/joerick/pyinstrument\nhttps://github.com/joerick/pyinstrument_cext\nspeedscope\npyspeedscope\n```\n\n## 0x08 dry python\n\n- https://github.com/dry-python/returns\n- https://github.com/jd/tenacity\n\n## 0x09 clear code\n\n## 0x08 工具\n\n## 0xBB News\n\n- https://github.com/markshannon/faster-cpython\n\n## 0xCC 推荐源码\n\n### 简单\n\n- kennethreitz/records: SQL for Humans™\n- chrisallenlane/cheat\n- jek/blinker: A fast Python in-process signal/event dispatching system.\n- mitsuhiko/platter: A useful helper for wheel deployments.\n- kennethreitz/tablib: Python Module for Tabular Datasets in XLS, CSV, JSON, YAML, \u0026c.\n\n### 中级\n\n- faif/python-patterns 使用 Python 实现一些设计模式的例子。\n- pallets/werkzeug flask 的 WSGI 工具集。其中包含了实现非常好的 LocalProxy,cached_property,import_string,find_modules,TypeConversionDict 等。\n- msiemens/tinydb 了解用 Python 实现数据库。\n\n### 高级\n\n以及一个非常神奇的进阶项目 500lines https://github.com/aosabook/500lines\n\n### 其他\n\n- https://github.com/howie6879/ruia\n\n## 0xDD 书籍\n\n- [x] CPython Internals\n- [x] Python Cookbook\n- [x] Python Web 开发实战\n- [x] Python For Data Analysis\n- [x] 深入浅出 MySQL\n- [x] 大型网站技术架构 - 核心原理与案例分析\n\n## 0xEE 结语\n\n---\n\nChangeLog:\n\n- **2020-10-24** 重修文字\n"},{"tags":["Blog"],"path":"20161123_重新整理再度出发.md","title":"整理博客","slug":"整理博客","date":"2016-11-23","category":"碎碎念","lastMod":"2020-01-01","description":"整理博客.","thumbnail":"","content":"\n# 整理博客\n\n\u003e 整理自己的心情，整理自己的经历，也要整理自己的博客。\n\n\u003c!-- more --\u003e\n\n\u003e 重新整理，再度出发。\n\n来到上海的第 9 个月，对自己的水平还是不是很满意。\n\n前几天回常州遇到几个不错的学弟，问了问他们的状况，也大致如此，总觉得自己的水平还是太烂太烂。\n\n李笑来在《把时间当做朋友》这本书里面写过，一个优秀的人，因为对自己的要求高，所以即便他有一门技术 90 分，其他的技术都是 70 分，但是相对于一个普通的人，他的最牛技术为 80 分，而他的其他技术都是 60 分，但由于本身对自己要求就不高，也就心安理得的很接纳自己。\n\n这让我意识到了这一点：恰好是我的高要求让我成为了一个出色的我。\n\n\u003e 每次到了夜深人静的时候我总是睡不着，我怀疑是不是只有我的明天没有变得更好。\n\n重新捡起博客，只想证明给自己看，我想做的事情，我一定要去做。\n\n\u003e 人生总是那么短暂，如果不抓紧时间做一些事情，总觉得自己没有存在过。\n\n\u003e Get Busy Living, Or Get Busy Dying.\n\n写这篇文章，重新理清楚自己编写文章的分类和标签。也准备把很多太监在自己的笔记里面的技术知识转为代码和文章陆陆续续放出来。\n\n分类如下：\n\n- 善用佳软\n- 深入理解 macOS\n- Python 黑魔法\n- Linux DevOps\n- 进击的 JavaScript\n- 后端框架之 Django 进阶\n- 前端框架之 Vue 进阶\n- Python 爬虫\n- 其他编程语言\n- 后台组件\n- 数据科学\n- 编程漫谈\n- 逆向工程\n- 源码阅读\n- 写在人生的边上\n\n标签如下：\n\n- MongoDB\n- MySQL\n- RabbitMQ\n- Redis\n- ElasticSearch\n- 分布式\n- 前端开发\n- 可视化\n- 后台组件\n- 后端开发\n- 影评\n- 性能优化\n- 数据分析\n- 机器学习\n- 算法与数据结构\n- 编程工具\n- 编辑器\n- 重构技巧\n- 知乎专业回答\n- 书单与简评\n- 碎碎念\n- 沟通交流\n\n\u003ciframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"http://music.163.com/outchain/player?type=2\u0026id=189259\u0026auto=1\u0026height=66\"\u003e\u003c/iframe\u003e\n\n---\n\n## UPDATE:\n\n- **2016-11-23** : 更新标签内容\n- **2016-12-03** : 修订标签内容\n- **2017-01-15** : 更新分类与标签内容\n- **2017-12-19** : 更新分类与标签内容\n"}],"total":2},{"name":"2016-10","posts":[{"tags":["Ubuntu"],"path":"20161005_UbuntuCheatSheet.md","title":"Ubuntu CheatSheet","slug":"Ubuntu CheatSheet","date":"2016-10-05","category":"善用佳软","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n# Ubuntu CheatSheet\n\n## 0x01 基础设置\n\n## 0x02 软件安装\n\n```\nsudo apt-get --purge autoremove\n```\n\n```bash\n# 更新\nsudo apt update\nsudo apt install git-core curl zlib1g-dev build-essential libssl-dev libreadline-dev libyaml-dev libsqlite3-dev sqlite3 libxml2-dev libxslt1-dev libcurl4-openssl-dev python-software-properties libffi-devsudo apt-get install zsh tree htopsudo apt-get install build-essential acl ntp htop git libpq-dev libmysqlclient-dev libffi-dev libfreetype6-dev libjpeg8-dev liblcms2-dev libtiff5-dev libwebp-dev libxml2-dev libxslt1-dev tcl8.6-dev tk8.6-dev zlib1g-dev python-dev python-pip python-pycurl python-tk ipython supervisor python3.5 python3.5-dev python3-pip python3-lxml python3-tk ipython3sudo apt-get install mysql-server mysql-client libmysqlclient-dev slurm\n\n# GIT 配置\ngit config --global color.ui true\ngit config --global user.name \"twocucao\"\ngit config --global user.email \"twocucao@gmail.com\"\nssh-keygen -t rsa -b 4096 -C \"twocucao@gmail.com\"\n```\n\n第一步，更新源：\n\n### 2.1 设置无登录密钥\n\n```\n# 刚开始用了一个很蠢的方法\nscp ~/.ssh/id_rsa.pub twocucao@192.168.2.156:.ssh/id_rsa.pub\nssh twocucao@192.168.2.156 \"mkdir .ssh;chmod 0700 .ssh\"\n# 现在想想，可以直接 ssh-copy-id\nssh-copy-id twocucao@192.168.2.156\n```\n\n## 0x02 了解 Linux 服务器运行情况\n\n```\n# 运行时间 uptime\n# 内存情况 free -h\n# 网络类\n## 实时流量监控 iftop\n## 进程占用带宽 nethogs\n## sudo nethogs eth0\niptraf\n# 磁盘类 iotop\n## 当 dstat 的 wai 字段值比较大时，可以使用 iotop 找出哪些进程出了问题\n# 综合类 之 监控进程，进程管理\ntop\nhtop\nglances # PS , 这个监控粒度更细\n# 综合类 可以取代 vmstat , iostat , netstat , ifstatdstat\n# 综合类\n# 约等于 strace + tcpdump + htop + iftop + lsofsysdig\n```\n\n## 0x04 踩坑集合\n\n### 3.1 磁盘问题\n\n```\ndf -h 查看磁盘块占用的文件（block）\ndf -i 查看索引节点的占用（Inodes）\nfind / -size +100M |xargs ls -lh\n# 删除 5 天前的文件\nfind /path/to/files* -mtime +5 -exec rm {} \\;\ndu -h\nrm xxx.log\necho \"\" \u003e xxx.log\n```\n\n---\n\nChangeLog:\n\n- **2017-03-19** 重修文字，准备整理安装配置将结果转化为 Ansible PlayBook\n- **2017-10-20** 重修文字，准备整理安装配置将结果转化为 Ansible PlayBook\n"}],"total":1},{"name":"2016-09","posts":[{"tags":["Python"],"path":"20160923_IPynb和ECharts.md","title":"IPython Notebook 引入 ECharts 做可视化","slug":"IPython Notebook 引入 ECharts 做可视化","date":"2016-09-23","category":"Python","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n# IPython Notebook 引入 ECharts 做可视化\n\n## 0x01 前言\n\nPython 的开发生态圈有相当多的好用的数据分析挖掘工具。Pandas,Numpy,Scikit-Learn 等等。\n\n在进行数据分析挖掘的方面，我们选用 IPython Notebook 对数据进行前期的探索和挖掘。以及内部的可视化交流。\n\n也需要经常新的进行一些可视化来使得探索过程更加的顺利。面对海量的数据可视化，也依照目的使用不同的工具。\n\n- 对于后台开发 / 数据挖掘 / 爬虫工程师而言，内部沟通的过程中注重信息交流沟通的快捷和准确，而不需要考虑可视化的美观程度，所以使用 IPython Notebook 配上 Matplotlib 或者是 Seaborn 进行可视化。\n- 与其他非开发的技术人员交流沟通的时候，这个时候优美的图表就成为了重中之重。\n\n\u003e 可是 Seaborn Matplotlib 这些库画出来的图，如同那些其貌不扬的高手，包含大量信息，美中不足的就是**不美**。那可不可以使用更加漂亮的图来可视化呢？\n\n有，ECharts[案例地址戳这里](http://echarts.baidu.com/examples.html)\n\n\u003e 想拥有 IPython Notebook 的优点上，还能够最大化 IPython Notebook 的美观程度，这就是我们想在 IPython Notebook 中引入 ECharts 作为可视化的初衷。\n\n\u003e 如果你使用过 IPython Notebook，细心的你一定大致了解，核心困难点在于如何在 IPython Notebook 中引入 ECharts.\n\n今天我们使用 IPython NoteBook 来演示一个简单的 ECharts 饼图案例。本文的数据来自大众点评闵行区部分美食店铺。\n\n## 0x01 代码思路\n\nIPython 中，我们知道，可以通过 IPython.display 导入 HTML.\n\n```python\nfrom IPython.display import HTML\nHTML(\"\"\"\n\u003cdiv\u003e这是一小块 HTML\u003c/div\u003e\n\"\"\")\n```\n\n执行就 IPython Notebook 中看到：\n\n```\n\u003cdiv\u003e这是一小块 HTML\u003c/div\u003e\n```\n\n![显示 HTML](http://upload-images.jianshu.io/upload_images/52890-e7646baa6145766b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n但问题来了，我们知道，在通常的情况下，是不能动态引入 JS 脚本的。因此我们在开发 HTML 静态页面的时候，往往脚本都是在 Head 或者 Body 结束标签之前就写死了。如果要在 IPython 中增加 ECharts, 是不是需要修改一些配置文件，让 IPython Notebook 在 Header 部分引入 ECharts 脚本呢？\n\n答案是**不需要**.\n\n\u003e 为何？因为 IPython Notebook 本身自带一个 Js 模块，叫做 RequireJS. 通过这个模块**可以动态引入并执行 JS.**\n\n具体原理不详细介绍，但是这个模块为 IPython Notebook 动态引入其他 JS 框架和代码带来了无限的可能性。注意，再次强调，这个模块可以帮助我们**可以动态引入并执行 JS.**\n\n于是通过下面的代码，我们就轻松的将 ECharts 引入到 IPython Notebook 中。\n\n```python\nchart_header_html = \"\"\"\n\u003cdiv id=\"chart\" style=\"width:800px; height:600px;\"\u003e\u003c/div\u003e\n\u003cscript\u003e\n    require.config({\n         paths:{\n            echarts: '//cdn.bootcss.com/echarts/3.2.3/echarts.min',\n         }\n    });\n    require(['echarts'],function(ec){\nvar myChart = ec.init(document.getElementById('chart'));\n                var option = {\n                    title: {\n                        text: '闵行区美食类人均消费餐馆分布',\n                        subtext: '数据来自大众点评',\n                        x: 'center'\n                    },\n                    tooltip: {\n                        trigger: 'item',\n                        formatter: \"{a} \u003cbr/\u003e{b} : {c} ({d}%)\"\n                    },\n                    legend: {\n                        orient: 'vertical',\n                        left: 'left',\n                        data: ['人均消费不明','人均消费 0~50 元', '人均消费 50~100 元', '人均消费 100~150 元', '人均消费 150~200 元', '人均消费 200 元以上']\n                    },\n                    series: [\n                        {\n                            name: '店铺比例',\n                            type: 'pie',\n                            radius: '55%',\n                            center: ['50%', '60%'],\n                            data: [\n\n\"\"\"\nchart_content_html = \"\"\"\n                                {value: %s, name: '人均消费不明'},\n                                {value: %s, name: '人均消费 0~50 元'},\n                                {value: %s, name: '人均消费 50~100 元'},\n                                {value: %s, name: '人均消费 100~150 元'},\n                                {value: %s, name: '人均消费 150~200 元'},\n                                {value: %s, name: '人均消费 200 元以上'}\n\"\"\" % (consume_unknown_restaurant_count,consume_0_50_restaurant_count,consume_50_100_restaurant_count,consume_100_150_restaurant_count,consume_150_200_restaurant_count,consume_200_greater_restaurant_count)\nchart_footer_html = \"\"\"\n                            ],\n                            itemStyle: {\n                                emphasis: {\n                                    shadowBlur: 10,\n                                    shadowOffsetX: 0,\n                                    shadowColor: 'rgba(0, 0, 0, 0.5)'\n                                }\n                            }\n                        }\n                    ]\n                };\n                myChart.setOption(option);\n    });\n\u003c/script\u003e\n\"\"\"\n\nHTML(\n chart_header_html + chart_content_html + chart_footer_html\n)\n\n```\n\n看一看代码，首先，配置对应的脚本。引入 requirejs 的配置模块。\n\n```javascript\nrequire.config({\n  paths: {\n    echarts: \"//cdn.bootcss.com/echarts/3.2.3/echarts.min\",\n  },\n})\n```\n\n接着使用如下代码进行引入和执行代码，具体的 Demo 可以参考文章末尾的代码：\n\n```javascript\nrequire(['echarts'],function(ec){\n var option = {\n//... 图表配置\n}\n//... 获取图表 div\n//... 为所获取的图表 DIV 设置\n}\n```\n\n## 0x03 效果\n\n于是，美观漂亮的可视化图就出来了。\n\n![ECharts 饼图](http://upload-images.jianshu.io/upload_images/52890-59bffc49212928be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 0x04 代码\n\n附上 IPythonNotebook 以及 Excel 表用于大家分析。\n\n- [对应的 IPythonNotebook](https://github.com/twocucao/DataScience/blob/master/project_03_dianpin/simple_stat.ipynb)\n- [对应的 Excel 表](https://github.com/twocucao/DataScience/blob/master/project_03_dianpin/%E5%A4%A7%E4%BC%97%E7%82%B9%E8%AF%84%E9%97%B5%E8%A1%8C%E5%8C%BA%E7%BE%8E%E9%A3%9F%E9%A4%90%E5%8E%85%E7%AE%80%E5%8D%95%E7%BB%9F%E8%AE%A1.xlsx)\n"},{"tags":["MySQL"],"path":"20160912_MySQLCheatSheet.md","title":"MySQL CheatSheet","slug":"MySQL CheatSheet","date":"2016-09-02","category":"DevOps","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n# MySQL CheatSheet\n\n## 0x00 前言\n\n本文为 Cheatsheet 类型文章，用于记录我在日常编程中经常使用的 MySQL 相关命令。主要包含：\n\n- MySQL Shell, 其实就是 SQL 命令。\n- MySQL 配套工具\n- Python API\n\n不定期更新。\n\n\u003c!-- more --\u003e\n\n## 0x01 安装，配置，基本 shell 命令\n\n### 字符编码\n\n\u003e UTF-8 , Please\n\n真的很讨厌那些用 GBK 的程序员啊！\n\n```bash\n# 注意，下面的设置 MySQL 是无法保存 emoji 的 /\n[mysql]\ndefault-character-set=utf8\n\n[mysqld]\ncollation-server = utf8_general_ci\ninit-connect='SET NAMES utf8'\ncharacter-set-server = utf8\n```\n\n然后在 mysql console 执行：\n\n```bash\nshow variables like \"%character%\";show variables like \"%collation%\";\n```\n\n如下即可\n\n## 0x02 MySQL 配套工具\n\n- JetBrain 的 Datagrip 作为 编写大段 SQL 语句的 IDE\n- 通过网络或者 Dash 查看文档\n- 强烈推荐 mycli 作为正常情况下的 MySQL 命令的替代品。\n- MySQL 官方自带工具\n\n只挑选几个重要的，常用的说一说。\n\n```bash\n# 启动 MYSQL\n\n# 常规 mysql\nmysql -u username -p password\n## 命令的用户名和密码最好与命令合在一起\nmysqlshow -uroot -psomepass some_db;\n# 导入数据\nmysql -u username -p password \u003c filename\n# 优雅的导入数据，可以查看进度条的 Hacks\npv -i 1 -p -t -e /Users/twocucao/Codes/update_new_date.sql | mysql -uadmin -p123456 -h 192.168.2.254 --port=3306 some_db\n# 导出数据\nmysqldump -u username -p password database [tables] \u003e filename\nmysqldump database table_bame --where=\"date_column BETWEEN '2012-07-01 00:00:00' and '2012-12-01 00:00:00'\"\n\n# ref : http://dev.mysql.com/doc/refman/5.7/en/mysqldump.html#option_mysqldump_where\n```\n\n## 0x03 MySQL 常用代码\n\n```bash\nSHOW DATABASES;\nCREATE DATABASE database;\nUSE database;\nSHOW TABLES;\nDESCRIBE table;\nSHOW COLUMN FROM table;\nDROP DATEBASE;\n```\n\n## 0x04 常用代码片段\n\n### 1. 数据清洗常用脚本\n\n```sql\n-- 少量去重\nCREATE TABLE everyday_info_temp AS SELECT * FROM  everyday_info GROUP BY id,date,numbers;\n-- 大量去重\nCREATE TABLE everyday_info_temp AS SELECT * FROM  everyday_info GROUP BY id,date,numbers ORDER BY null;\n```\n\nhttp://stackoverflow.com/questions/16568228/how-to-transpose-mysql-table-rows-into-columns\n\n```\n  SELECT @max := MAX(ID)+ 1 FROM ABC;\n\n  PREPARE stmt FROM 'ALTER TABLE ABC AUTO_INCREMENT = ?';\n  EXECUTE stmt USING @max;\n\n  DEALLOCATE PREPARE stmt;\n```\n\nmysql\u003e delete from shophtml;\nQuery OK, 117141 rows affected (4 min 2.92 sec)\nTRUNCATE shophtml;\n\n### 2. 用户管理常用脚本\n\n```bash\nSELECT User FROM mysql.user;\n```\n\n### 3. 备份迁移常用脚本\n\n```\n#! /bin/bash\n\nTIMESTAMP=$(date +\"%F\")\nBACKUP_DIR=\"/mnt/$TIMESTAMP\"\nMYSQL_USER=\"root\"\nMYSQL=/usr/bin/mysql\nMYSQL_PASSWORD=\"password\"\nMYSQLDUMP=/usr/bin/mysqldump\nDATABASE=\"cyjoycity\"\n\nmkdir -p \"$BACKUP_DIR/mysql\"\n\nfor t in $($MYSQL -NBA -u $MYSQL_USER -p$MYSQL_PASSWORD -D $DATABASE -e 'show tables')\ndo\n    echo \"DUMPING TABLE: $DB.$t\"\n    $MYSQLDUMP --force --opt --user=$MYSQL_USER -p$MYSQL_PASSWORD $DATABASE $t | gzip \u003e \"$BACKUP_DIR/mysql/$t.sql.gz\"\ndone\n\n```\n\n### 4. 性能优化常用脚本\n\nSHOW FULL PROCESSLIST;\n\n### 6. 远程连接\n\n```mysql\n\n/etc/mysql/my.cnf\n\n# bind-address = 127.0.0.1\n\nGRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'password' WITH GRANT OPTION;\nFLUSH PRIVILEGES;\n```\n\n### 5. 其他脚本\n\n```sql\n\n# 6. 随机选择 10 组记录\n-- 慢速\nSELECT * FROM Table_Name ORDER BY RAND() LIMIT 0,10;\n\n-- 快速\nSELECT name\n  FROM random AS r1 JOIN\n       (SELECT CEIL(RAND() *\n                     (SELECT MAX(id)\n                        FROM random)) AS id)\n        AS r2\n WHERE r1.id \u003e= r2.id\n ORDER BY r1.id ASC\n LIMIT 1\n```\n\n```sql\n\n# 1. 查询时间\nselect date_format(create_time, '%Y-%m-%d') as day from table_name\nselect from_unixtime(create_time, '%Y-%m-%d') as day from table_name\n\n# 2. CASE WHEN 案例\n\n## 2.1 返回同一列多个结果\n\n## 2.2 行列值颠倒\n\n# 3. 替换某字段内容\nupdate table_name set content = REPLACE(content, 'aaa', 'bbb')  where (content like '%aaa%')\n\n# 4. 获取表中某字段包含某字符串的数据\nSELECT * FROM `表名` WHERE LOCATE('关键字', 字段名）\n\n# 5. 字符串处理\nSELECT SUBSTRING（字段名，1,4) FROM 表名\n\n# 6. 求解数字的连续范围\n\nselect min(number) start_range,max(number) end_range\nfrom\n(\n    select number,rn,number-rn diff from\n    (\n        select number,@number:=@number+1 rn from test_number,(select @number:=0) as number\n    ) b\n) c group by diff;\n\n```\n\n## 0x05 性能优化切入点\n\n应用的切入点也比较简单和暴力：\n\n1. 优化应用层面的查询。\n2. 优化数据库的 SQL 查询。\n3. 优化数据库的存储结构。\n4. 优化单个数据库服务器的性能。\n5. 遵循『机多运算大』的原则，上几台机器。\n6. 更好的机器，即加内存条，上好的 CPU。\n\n优化前三点，则需要理解取数据的客户端从发送 SQL 语句到接受数据之间都发生了什么？流程如下：\n\n1. 开启连接\n2. 发送查询给服务器\n3. 分析查询\n4. 执行查询\n5. 传输数据\n6. 关闭连接\n\n### 优化应用层面的查询\n\n在同样工作量的情况下不断的减少数据库的连接，将多个动作放在一起使用 TRANSACTION 可以显著提高速度。\n\n1. 对于 OLTP 类型的数据库设计的数据库，一些耗时查询往往是可以在应用层面查询进行优化的，比如在手写代码应用级缓存，借助外部组件 (redis) 应用内缓存。\n2. 对于一些有性能要求的场景，不要使用 select \\* from xxx 这种查询，服务器到客户端传输也是需要时间的，而是要选择需要的字段。\n3. 如果有必要，不要在循环内部进行数据库查询，而是直接取出来放在内存中进行运算。学过的算法与数据结构用起来！!\n\n### 优化数据库的 SQL 查询\n\n如同前文所见，到了 SQL 命令这层切入点能够优化的地方只有步骤 4.\n\n对于查找，效率取决于：\n\n1. 取记录数量\n2. 搜索到这些记录的时间。\n\n对于插入，执行查询则插入记录和更新索引两个部分，也是插入的瓶颈所在：\n\n1. 插入记录 速度取决于记录数量，记录大小\n2. 更新索引 速度取决于索引数量。\n\n对于更新，执行查询则有查找，更新记录和更新索引两个部分，也是更新的瓶颈所在：\n\n1. 查找 需要参考查找\n2. 更新记录 速度取决于记录数量，记录大小\n3. 更新索引 速度取决于更新索引字段的数量。\n\n对于删除，执行查询则有查找，删除记录和删除索引两个部分，也是删除的瓶颈所在：\n\n1. 查找 需要参考查找\n2. 删除记录 速度取决于记录数量，记录大小\n3. 更新索引 速度取决于更新索引字段的数量。\n\n#### 查询的优化\n\n#### 索引的代价\n\n\u003e 在计算机这个神奇的世界里面，没有一个算法与数据结构的挑选是没有代价的。便于查询，则不便于插入更新。\n\n有的人把索引比作字典。说字典的索引页面就好像是数据表中的索引。\n\n这个比方很贴切，可以用在索引的比方上，也可以用在索引的代价上。\n\n- 一个没有索引的页面，即是一个只有页码，编号的字典。当我们查询一个新字的时候，只能从第一页翻到结尾，效率很低。\n- 一个有一个索引的页面，即是一个有页码，编号，拼音索引的字典。当我们查询一个新字的时候，先查询索引，然后从索引查页码，于是很快找到字。当我们**增加 / 删除 / 更新**一个字之后，还需要更新拼音索引。\n- 一个有多个索引的页面，即是一个有页码，编号，拼音索引和部首索引以及其他索引的字典。当我们**增加 / 删除 / 更新**一个字之后，还需要更新拼音索引，部首索引等等索引。\n\n\u003e **计算机世界就是这样，没有完美的算法，也没有完美的模型。**\n\n### 数据存储结构\n\n### 硬件优化\n\n留空，这个可能比较接近运维或者 DBA 的工作\n\n### 配置优化\n\n留空，这个可能比较接近运维或者 DBA 的工作\n\n## 0x06 常见问题\n\n### 密码忘了怎么办？\n\n```bash\n/etc/init.d/mysql stop\nmysqld_safe --skip-grant-tables \u0026\n# 在另一个终端 输入 mysql 进入终端\n在另一端执行 SQL 命令\nUPDATE mysql.user SET password=PASSWORD('nouveau') WHERE user='root';\n## Kill mysqld_safe from the terminal, using Control + \\\n/etc/init.d/mysql start\n```\n\n## 0xEE 参考链接\n\n关于 SQL 与数据库的有趣解释\n\n1. [Inner Join 和 Outer Join](http://stackoverflow.com/questions/38549/what-is-the-difference-between-inner-join-and-outer-join)\n2. [如何防止 SQL 注入](http://stackoverflow.com/questions/60174/how-can-i-prevent-sql-injection-in-php)\n3. [索引是怎么工作的](http://stackoverflow.com/questions/1108/how-does-database-indexing-work)\n4. [Mysql 常用 SQL 语句集锦（本文部分 SQL 语句取自此博文）](https://gold.xitu.io/post/584e7b298d6d81005456eb53)\n\nhttp://stackoverflow.com/questions/194852/concatenate-many-rows-into-a-single-text-string\n"}],"total":2},{"name":"2016-07","posts":[{"tags":["macOS"],"path":"20160701_MacCheatSheet.md","title":"macOS Cheatsheet","slug":"macOS Cheatsheet","date":"2016-07-01","category":"善用佳软","lastMod":"2021-06-30","description":"macOS Cheatsheet","thumbnail":"","content":"\n# macOS Cheatsheet\n\n## 0x00. 前言\n\n\u003e 好的工匠懂得挑选合适的工具。\n\n做软件行业之间长了，见多了各种操作系统孰优孰劣 / 编程语言哪家强的论战，也就渐渐懂得了这个异常朴素的道理。也懒得去争论。有争论的时间，不如好好的编写代码，多看些技术书籍。以及熟悉自己的工具。\n\n如果说，你现在问我到底是哪个 OS 好，我只能说：\n\n\u003e 好的工匠懂得挑选合适的工具。而不是炫耀自己的工具。\n\nBTW : **大约在 2015 年 12 月份有了第一台 MAC, 如今更加喜爱。**\n\n本文为 Cheatsheet 类型文章，用于记录我在日常编程中经常使用的 Mac 快捷键和工具。\n\n不定期更新。\n\n\u003c!-- more --\u003e\n\n## 0x01. 必备软件\n\n### 1.1. 常见应用\n\n**非技术流**\n\n- 启动器 Alfred 3\n- 浏览器 Chrome Firefox\n- 输入法 搜狗输入法\n- 系统清理 AppCleaner\n- 系统增强 Caffeine / PopClip / BetterZip / Amphetamine\n- 手机管理工具 HandShaker / AirDroid\n- 邮件客户端 Airmail 2\n- 录屏截图 Annotate / Camtasia 2 / Snagit / ScreenFlow\n- 下载工具 Aria2GUI / 迅雷\n- 影音处理 Adobe PhotoShop CC , Adobe PhotoShop , Adobe LightingRoom , Final Cut Pro\n- 影音浏览 MPlayerX, QuickTime , IQIYI , NeteaseMusic , iina\n- 远程协助 TeamViewer\n- 办公软件 Wiznote , PDF Expert , Office（虚拟机内部）OmniFocus , OmniGraffle , EuDic , MacTex : Latex\n- 云存储 iCloud , 百度云\n- 手机管理 HandShaker\n\n**技术流**\n\n- 终端：iTerm2\n- GIS 相关 QGIS , PostgreSQL + PostGIS\n- IDE 选择 JetBrain 家的软件 PyCharm, IntellijIDEA\n- 编辑器 MacVim （主力）, 配合 [C-VIM](https://github.com/twocucao/c-vim) 作为日常编写文字的利器。\n- 数据库 MySQL , PostgreSQL（主力） , Redis , MongoDB\n- 数据管理 Navicat,Datagrip,RoboMongo,rdm\n- 文档查看 Dash\n- 网络工具 SS QT 不解释\n- 网络抓包 Charles, Wireshark, Chrome\n- 代码仓库 Github SourceTree\n- 数据分析 Tableau\n- 虚拟机 Vmware Fusion\n- 抓包工具 Wireshark\n\n**mac 独有命令行**\n\n- open\n- pbcopy\n- pbpaste\n- screencapture\n- launchctl\n- mdfind（还是 linux 的 find 好用）\n- sip （还是比较推荐 imagemagic)\n\n### 1.2. Homebrew 和 iTerm2\n\n[iterm2 下载](http://www.iterm2.com/)\n\n```bash\n# homebrew 安装\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n```\n\n另起终端\n\n```bash\n# aerial 屏保\n# https://github.com/JohnCoates/Aerial\nbrew cask install aerial\n# https://github.com/sindresorhus/quick-look-plugins\nbrew cask install qlcolorcode qlstephen qlmarkdown quicklook-json qlprettypatch quicklook-csv betterzipql qlimagesize webpquicklook suspicious-package quicklookase qlvideo\n# Install some other useful utilities like `sponge`.\nbrew install moreutils\n# Install GNU `find`, `locate`, `updatedb`, and `xargs`, `g`-prefixed.\nbrew install findutils\n# Install GNU `sed`, overwriting the built-in `sed`.\nbrew install gnu-sed --with-default-names\n\nbrew install bash zsh\nbrew install wget --with-iri\n\n# Install Python\nbrew install python\nbrew install python3\n\nbrew tap bramstein/webfonttools\nbrew install sfnt2woff\nbrew install sfnt2woff-zopfli\nbrew install woff2\n\n# Install other useful binaries.\nbrew install ack\nbrew install dark-mode\n#brew install exiv2\nbrew install git\nbrew install git-lfs\nbrew install git-flow\nbrew install git-extras\nbrew install hub\nbrew install imagemagick --with-webp\nbrew install lua\nbrew install lynx\nbrew install p7zip\nbrew install pigz\nbrew install pv\nbrew install rename\nbrew install rhino\nbrew install speedtest_cli\nbrew install ssh-copy-id\nbrew install tree\nbrew install webkit2png\nbrew install zopfli\nbrew install pkg-config libffi\nbrew install pandoc\n\n# Lxml and Libxslt\nbrew install libxml2\nbrew install libxslt\nbrew link libxml2 --force\nbrew link libxslt --force\n\nbrew cleanup\n# 如果需要升级\nbrew update \u0026\u0026 brew upgrade --all \u0026\u0026 brew cleanup \u0026\u0026 brew prune\n```\n\n有时候 /usr/local 的可能会存在权限问题，建议如果可能出现问题，则需要执行下面的命令修复权限。\n\n```bash\nsudo chown -R $(whoami):admin /usr/local/\n```\n\n## 0x02. 开发者必备\n\n### 2.0. Shell\n\n\u003e 注意：MAC 使用的大多命令来自于 FreeBSD , 并不是来自 GNU , 所以很多命令会与常规的 linux 命令不太一样。\n\u003e 所以，Shell 命令请在安装完 Gnu 的工具集之后，可以到我的文章 Shell CheatSheat 查看语法。\n\n关于 shell 脚本，请参考我的另一篇文章。\n\n[Shell CheatSheat](/2015/04/18/ShellCheatSheet/)\n\n### 2.1. Python\n\n\u003e 笔者虽然也接触过很多语言，都是粗浅一过，但无一精通，唯一可以稍微谈谈的就是 Python 语言。\n\n\u003e 当然，安装完毕自然是可以参考一下我的 Python 武器库啦 [Python 工程师的武器库](http://www.url.com)\n\n#### 2.1.1. Python 安装\n\n```bash\ngit clone https://github.com/yyuu/pyenv.git ~/.pyenv\ngit clone https://github.com/yyuu/pyenv-virtualenv.git ~/.pyenv/plugins/pyenv-virtualenv\necho 'export PYENV_ROOT=\"$HOME/.pyenv\"' \u003e\u003e ~/.zshrc\necho 'export PATH=\"$PYENV_ROOT/bin:$PATH\"' \u003e\u003e ~/.zshrc\necho 'eval \"$(pyenv init -)\"' \u003e\u003e ~/.zshrc\necho 'eval \"$(pyenv virtualenv-init -)\"' \u003e\u003e ~/.zshrc\n\n# 接着另开终端\n# 不喜写兼容代码，所有代码均向 3.5+ 靠拢\nv=3.5.2|wget http://mirrors.sohu.com/python/$v/Python-$v.tar.xz -P ~/.pyenv/cache/;pyenv install $v\nv=3.6.0|wget http://mirrors.sohu.com/python/$v/Python-$v.tar.xz -P ~/.pyenv/cache/;pyenv install $v\nv=2.7.11|wget http://mirrors.sohu.com/python/$v/Python-$v.tar.xz -P ~/.pyenv/cache/;pyenv install $v\n# 可以先用迅雷把 官网的 Anaconda3-4.4.0-MacOSX-x86_64.sh 下载下来，然后\nmv Anaconda3-4.4.0-MacOSX-x86_64.sh ~/.pyenv/cache/ \u0026\u0026 pyenv install anaconda3-4.4.0\n\n# 设置 Global Python 为 2.7.11, 备注：尽量不要把 Py3 设置为全局，否则由于 Homebrew 本身有一些依赖是依赖于 Py2 的，这样容易出现一些奇怪的问题。\npyenv global 2.7.11\npip install -i https://pypi.doubanio.com/simple requests\n# 下面这个是用于安装基本的代码补全功能\npip install -i https://pypi.doubanio.com/simple --upgrade \"jedi\u003e=0.9.0\" \"json-rpc\u003e=1.8.1\" \"service_factory\u003e=0.1.5\" flake8 pytest autoflake hy\n\n# 创建最常用 Py3 虚拟环境\npyenv virtualenv 3.5.2 py3-daily\npyenv activate py3-daily\npip install -i https://pypi.doubanio.com/simple requests\npip install -i https://pypi.doubanio.com/simple beatutifulsoup4\npip install -i https://pypi.doubanio.com/simple ipython[notebook]\npip install -i https://pypi.doubanio.com/simple jupyter\n# 下面这个是用于安装基本的代码补全功能\npip install -i https://pypi.doubanio.com/simple --upgrade \"jedi\u003e=0.9.0\" \"json-rpc\u003e=1.8.1\" \"service_factory\u003e=0.1.5\" flake8 pytest autoflake hy\n\n# 创建 Anaconda 的数据科学 AI 环境\npyenv virtualenv anaconda3-4.4.0 py3-ai\npyenv activate anaconda3-4.4.0/envs/py3-ai\npyenv deactivate\n```\n\n#### 2.1.2 Python 环境的坑\n\n##### Homebrew 的 Python 问题\n\n如果本机安装了 Homebrew 如果后面使用 PyEnv 或者 Anaconda 设置当前环境为默认 Python 为 Python3（不建议这么搞）, 但是如果偏偏要把默认的 Python 版本换成 Python3, 会弹出一些 pythonpath 的问题，执行下面命令即可暂时屏蔽这个问题，但是后没有隐患则不清楚。\n\n```bash\nmv /usr/local/lib/python2.7/site-packages/sitecustomize.py /usr/local/lib/python2.7/site-packages/sitecustomize.py.back\n```\n\n##### 网络问题\n\n在 Python 中执行下面的代码的时候总是报错：\n\n```python\nip = socket.gethostbyname(socket.gethostname())\n# socket.gaierror: [Errno 8] nodename nor servname provided, or not known\n```\n\n最后发现是因为设置主机名没有设置好\n\n```bash\nsudo scutil --set ComputerName \"newname\"\nsudo scutil --set LocalHostName \"newname\"\nsudo scutil --set HostName \"newname\"\ndscacheutil -flushcache\n# 然后重启电脑即可\n```\n\n## 0x03. 高效率软件 \u0026\u0026 专业软件\n\n### 3.1. OmniFocus\n\n### 3.2. OmniGraffle\n\n### 3.3. Final Cut Pro\n\n### 3.4. Keynote\n\n## 0xDD. 参考链接\n\n- https://github.com/donnemartin/dev-setup\n\n## 0xEE. 扩展阅读\n\n- [关于 Mac 我的回答](https://www.zhihu.com/question/30816866/answer/59415036)\n- [关于 Ubuntu 我的回答](https://www.zhihu.com/question/30816866/answer/59415036)\n- [关于 Win10 我的回答](https://www.zhihu.com/question/32129337/answer/59379401)\n\n---\n\nChangeLog:\n\n- **2017-06-28** Python 环境 和 Homebrew 安装环境\n"}],"total":1},{"name":"2016-03","posts":[{"tags":["Python"],"path":"20160315_如何发布一个Py命令行工具.md","title":"如何发布一个 Python 命令行工具","slug":"如何发布一个 Python 命令行工具","date":"2016-03-15","category":"Python","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n# 如何发布一个 Python 命令行工具\n\n## 0x01 本文简介\n\n上次写的一个终端里面斗鱼 TV 弹幕 Python 版本和 Ruby 版本，并且发布到 PIP 和 RubyGems 上面。在发布 PIP 包的时候，居然 Google 不到一篇可以非常好的讲解这个流程的文章。于是整理这篇文章，并且方便后来自己检索，并且方便他人找资料。\n\n自推荐下依照本文定制的命令行工具 danmu.fm 的 github 地址：\n\nhttps://github.com/twocucao/danmu.fm\n\n本文的目的也是非常简单：\n\n\u003e **写一个 Python 命令行工具，并且发布到 PIP 上面.**并且在这个过程中给出我自己的一些思考。\n\n\u003c!-- more --\u003e\n\n## 0x02 如何分解这个发布任务？\n\n只需要进行如下的两个步骤便可以：\n\n- 1.  写好一个 Python 命令行工具。\n- 2.  发布它。\n\n当然，这样不够细致。再细分一下。\n\n- 1.  写好一个 Python 命令行工具\n  - 1.1. 命令行的特点，以及 Python 的如何编写命令行\n  - 1.2. 如何组织代码结构。\n- 2.  发布\n- 2.1. 注册 pypi 账户\n  - 2.2. 注册在账户下面注册 Python 包\n  - 2.3. 上传**打包**好的 Python 命令行工具。\n- 3. 完善代码\n\n## 0x03 写好一个 Python 命令行工具\n\n写好一个命令行工具首先要知道命令行工具是什么？\n\n\u003e 在我看来，命令行工具就是一种完成某种类型的任务的终端程序。\n\n也就是基本上没有什么用户界面的程序。\n\n由于基本上没有什么用户界面，所以导致单个命令行的交互能力及其低下。但这种低下的交互性对于一些固定工作而言，简直就是最灵活的工具。只需要输入一些命令便可以完成某种类型的工作。实在是方便的很。\n\n所以，某种程度上，终端程序低交互的缺点反而成了优点。\n\n### 1.1.Python 的如何编写一个简单的命令行\n\n对于 Python 和命令行交互，我们很容易想出一个比较方便的方案。\n\nsys.argv 就是这样的嘛！\n\n我们很容易这样写代码。\n\n```bash\n python testargv.py thisisaargv1\n```\n\n甚至我们也可以这样写命令行，\n\n```bash\n python testargv.py thisisaargv1 -d -f 0\n```\n\n那么，这样写的后果就是，不方便解析出（不是不能，是不方便） -d -f 0 以及 thisisaargv1.\n\n不信的话，你解析一个下面场景的命令行试试，\n\n```bash\n# 用户可能这样输入\ndanmu.fm http://www.douyutv.com/xiaocang -q 1 -v 2\ndanmu.fm -q 1 -v 2 http://www.douyutv.com/xiaocang\n# 当然，肯定还有漏写啦，等等，你得需要转类型，增加各种 blablabla 的描述吧，添加默认的参数值吧。\n```\n\n于是 Python 就提供了一个非常好用的模块可以使用。叫做 argparse.\n\n上面的描述就变成了这个样子\n\n```python\nimport argparse\n\nAPP_DESC=\"\"\"\n这就是描述\n\"\"\"\nprint(APP_DESC)\nif len(sys.argv) == 1:\n    sys.argv.append('--help')\nparser = argparse.ArgumentParser()\nparser.add_argument('-q','--quality',type=int,default=0,help=\"download video quality : 1 for the standard-definition; 3 for the super-definition\")\nparser.add_argument('-v','--verbose', default=0,help=\"print more debuging information\")\nparser.add_argument('-s','--store',help=\"保存流媒体文件到指定位置\")\nparser.add_argument('-c','--config',default=0,help=\"读取~/.danmu.fm 配置，请~/.danmu.fm 指定数据库\")\nparser.add_argument('url',metavar='URL',nargs='+', help=\"zhubo page URL (http://www.douyutv.com/*/)\")\nargs = parser.parse_args()\n# 获取对应参数只需要 args.quality,args.url 之类。\nurl = (args.url)[0]\nprint(url)\n#其他执行逻辑\n```\n\n保存为 danmu.py\n\n这样就可以执行命令\n\n```bash\npython danmu.py http://www.douyutv.com/xiaocang -q 1 -v 2\n```\n\n通过 args 就可以获取参数，然后进行终端程序的参数初始化。\n\n可是这和我们的要求还是不同嘛，我们不想多写 Python XXX, 我们想直接 XXX. 就像这样。\n\n```bash\ndanmu.fm -q 1 -v 2 http://www.douyutv.com/xiaocang\n```\n\n不急，下面就是了。\n\n### 1.2. 如何组织代码结构。\n\n于是，现在就要开始组织代码结构了。\n\n我们在最终的代码目录大概是这样的。\n\n```bash\ndanmu.fm\n├── README.md\n├── danmufm\n│   ├── __init__.py\n│   ├── client\n│   │   ├── __init__.py\n│   │   ├── __init__.pyc\n│   │   ├── douyu_client.py\n│   │   └── douyu_danmu_client.py\n│   ├── danmu.py\n│   ├── misc\n│   │   ├── __init__.py\n│   │   ├── color_printer.py\n│   │   ├── downloaders.py\n│   │   └── player.py\n│   └── model\n│       ├── __init__.py\n│       └── douyu_msg.py\n├── docs\n├── setup.cfg\n├── setup.py\n├── sh.py\n└── tests\n```\n\n这就是我上次写的 danmu.fm 的代码目录。\n\n聪明的你这时候你注意到了：\n\n1. 主要的程序不是放在根目录下面，而是放在第二目录 danmufm 下面。\n2. setup.cfg 是什么鬼东西\n3. setup.py 是什么鬼东西\n\n对于上面几点，我们分别进行解释\n\n### 1.2.1 为什么主要程序在第二目录下\n\n为了把主要的程序分离出来，放在第二目录下面，这样的待会打包以后多出很多文件夹就不会对源码造成干扰。\n\n当然，由于把程序放在了第二目录下面，所以，脚本里面的 from import 语句应该使用相对路径导入。\n\n相对路径导入的的时候需要注意运行的时候使用如下命令\n\n```bash\npython3 -m danmufm.danmu [xxxx]\n```\n\n### 1.2.2 setup.cfg\n\n填写如下内容即可。\n\n```\n[metadata]\ndescription-file = README.md\n```\n\n然后去写 Markdown 的 Readme 就好了。\n\n### 1.2.3 setup.py\n\n这个是重头戏了。\n\nsetup 这个 py 文件就是打包配置文件。对这个程序是谁的，有什么依赖，入口是什么，等等等等的配置。\n\n```python\n#-*- encoding: UTF-8 -*-\nfrom setuptools import setup, find_packages\n\"\"\"\n打包的用的 setup 必须引入，\n\"\"\"\n\nVERSION = '0.1.1'\n\nsetup(name='danmu.fm',\n      version=VERSION,\n      description=\"a tiny and smart cli player of douyutv,ximalayad,anmu based on Python\",\n      long_description='just enjoy',\n      classifiers=[], # Get strings from http://pypi.python.org/pypi?%3Aaction=list_classifiers\n      keywords='python douyu danmu danmu.fm terminal',\n      author='twocucao',\n      author_email='twocucao@gmail.com',\n      url='https://github.com/twocucao/doumu.fm',\n      license='MIT',\n      packages=find_packages(),\n      include_package_data=True,\n      zip_safe=True,\n      install_requires=[\n        'requests',\n      ],\n      entry_points={\n        'console_scripts':[\n            'danmu.fm = danmufm.danmu:main'\n        ]\n      },\n)\n\n```\n\n官方有 distutils 这个包管理器工具，设置也非常的简单，只是，它不支持 entry_points 属性，由于无法使用 entry_point, 也就无法通过命令来跳转到指定模块运行程序，这也就意味着，官方工具不方便写成命令行。还是 setuptools 好。\n\n上面需要注意的就是 install_requires 可以添加依赖。其他的你猜都可以猜出来是做什么的。自己去看代码，我就不多说了。\n\n## 2. 发布\n\n所谓的发布，就是将打包好的程序的某个版本发布到某个仓库中。\n\n### 2.1. 注册 pypi 账户\n\n到这个上面注册账号：\nhttps://pypi.python.org/pypi\n\n### 2.2. 注册在账户下面注册 Python 包\n\n进入对应项目根文件，然后执行\n\n```bash\npython3 setup.py register\n```\n\n这一步程序会让你输入刚刚注册的账号和密码，然后注册该包。注册该包以后，你就有了一个小仓库。可以存放不同版本的 danmu.fm.\n\n注册的仓库是可以在这个地址看到的，\nhttps://pypi.python.org/pypi?%3Aaction=pkg_edit\u0026name=danmu.fm\n\n### 2.3. 上传**打包**好的 Python 命令行工具。\n\n这里需要借助一个小工具，twine.twine 是一个更加安全方便上传打包好的代码的工具。\n\n```bash\npip3 install twine\n```\n\n接着开始打包，打包成两个版本，一个是不需要 build 的版本，另一个是需要 build 的版本（顺带吐槽下，这两个诡异的命名）.\n\n```bash\npython setup.py sdist bdist_wheel\n```\n\n于是剩下来的就显而易见了，上传 build 完毕的程序到仓库中。\n\n```bash\ntwine upload dist/danmu.fm-0.1.2*\n```\n\n于是，安装一下，测试是否成功\n\n```bash\npip3 install danmu.fm --upgrade\n```\n\n命令行的工具是这样使用的。\n\n```bash\ndanmu.fm -q 2 -v 1 http://www.douyutv.com/16789\n```\n\n## 3. 完善\n\n不断的完善代码，然后打包终端程序发布到仓库给别人用，这就是整个的 PIP 打包发布流程。\n\n- 这个时候，你可能需要使用版本控制软件。\n- 你可能需要增多的代码的测试。\n"}],"total":1},{"name":"2016-02","posts":[{"tags":["Python"],"path":"20160224_关于背单词软件,你不知道的惊人真相.md","title":"关于背单词软件，你不知道的惊人真相","slug":"关于背单词软件，你不知道的惊人真相","date":"2016-02-24","category":"数据分析","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n# 关于背单词软件，你不知道的惊人真相\n\n## 0x00 前言\n\n- 你想知道背单词软件有大概多少人注册第一天都没有背完嘛？\n- 你想知道背单词软件这么火，这么多人在使用，真的有多少人真的在背诵嘛？\n\n别急，Python 程序员用数据给你说话。\n\n文章目录如下：\n\n- 0x00 前言\n- 0x01 问题的提出和任务的分解\n- 0x02 任务一，信息爬取\n- ox03 任务二，清理和存储\n- 0x04 任务三，分析\n- 0x05 任务四，结论\n- 0x06 整个流程的不足和反思。\n- 0x07 代码。\n\n## 0x01 问题的提出和任务的分解\n\n前两天，就在一个雷电交加的夜晚，我躺在床上，草草的看了一篇英文文章，突然想到一个非常有意思的问题：\n\n\u003e 是不是大部分的人做事真的不能坚持呢？比如，背单词。\n\n好，那我就看看到底有多少人是坚持不下来的？\n\n那么，我们的问题就变成了这样子：\n\n- 有多少人是在坚持或者曾经坚持过背单词呢？（假设 100 天以上算的上是背单词的话）\n- 有多少梦想，毁于不能坚持？\n- 背单词的人们学习的量，是不是符合正太分布呢？\n\n于是我选中了业内的标杆扇贝软件作为分析的对象。抽取其中的大约 1/30 的用户的公开数据，也就是游客用户都可以看得到的数据，进行抽样调查。\n\n调查的具体内容如下：\n\n- 打卡最高 / 成长值最高 / 学习单词数量最高\n- 平均每个人打卡次数 / 成长值 / 学习单词数量\n- 打卡 / 成长值 / 学习单词数量的分布（也就是已经坚持了多少天了）\n\n那么，我的任务也就可以分解如下：\n\n- 爬取数据\n  - 使用 Python2 的 Scrapy 进行爬站\n- 清理数据\n  - sql 语句和 pandas 运算\n- 分析数据\n  - pandas + seaborn + ipython book\n- 得出结论\n\n## 0x02 任务一，信息爬取，清理和存储\n\n每个用户的信息都在这里：\n\nhttp://www.shanbay.com/bdc/review/progress/2\n\n使用 beautifulsoup4 进行解析即可。其他部分参考代码。\n\n扇贝的工程师反爬虫做的还不错，主要有两点：\n\n- 访问数量超标，封禁 IP 半个小时。对应的方法就是代理服务器.（代码中已经删除代理服务器，所以，如果你运行不了代码，那你应该知道怎么做了.)\n- cookie 如果不禁用很快就无法爬取。对应的方法就是禁用 Cookie.\n\n## 0x03 任务二，清理和存储\n\n对于数据库，使用 Postgresql 存储就好了。也没有什么大问题。参考代码。有问题在评论下面问。\n\n通常情况下在存入数据库的时候需要进行数据的净化，不处理也没有什么大问题。\n\n## 0x04 任务三，分析\n\n分析阶段，使用 IPython notebook. 通常情况下，我们使用的是 Anaconda 里面的 Python3 版本 . 可以到这里下载，注意，mac 和 ubuntu 下载的是命令行版本。\n\nhttps://www.continuum.io/downloads\n\n安装完毕以后，重启终端。环境变量生效。\n\n```bash\n#直接安装 seaborn\npip install seaborn\n```\n\n切换到指定目录然后敲入命令 ipython notebook 打开浏览器进行编辑。\n\n至于怎么使用，请看代码。\n\n## 0x05 任务三，结论\n\n在这里省去部分的分析过程直接贴出结论。\n\n总共抓取 1111111 张网页，成功获取 610888 个用户的信息。\n\n于是得出结论如下：\n\n**扇贝之最：**\n\n- 最高打卡天数：chainyu 1830 天\n- 最高成长值：Lerystal 成长值 28767\n- 最高单词数量：chenmaoboss 单词量 38313\n\n**平均到每一个人身上**\n\n- 平均每人打卡天数：14.18, 而超过成长平均值的人数为 71342, 占总抽样人数的，额，11.69%\n- 平均成长值：121.79, 而超过平均成长的人数为 13351, 占总抽样人数的，额，11.42%\n- 平均学习单词数量：78.92, 而背超过平均单词的人数为 13351, 占总抽样人数的，额，2.19%（注意，真的是 2% 左右）\n\n**那么，我们来看看打卡，成长值，单词数量的，分布吧.**\n\n第一个，所有人的打卡数量直方图。\n\n![这是所有人的打卡数量直方图](http://upload-images.jianshu.io/upload_images/52890-700e3adc4e88dd4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n简直惨不忍睹。\n\n第二个，非零用户的打卡数量直方图。\n\n![非零用户的打卡数量的直方图](http://upload-images.jianshu.io/upload_images/52890-d43f053706de8b37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这真是一段悲伤的故事。由于坚持不了几天的用户实在是太多，简直就是反比例函数嘛，导致图像严重畸形。那么，我们只能分段了看用户打卡天数在 0~20,20~100,100~500,500~2000 范围的分布图了。\n\n分别如下：\n\n![0~20](http://upload-images.jianshu.io/upload_images/52890-532a24af7f6a4c0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![20~100](http://upload-images.jianshu.io/upload_images/52890-a1adbb9a925128a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![100~500](http://upload-images.jianshu.io/upload_images/52890-6e0b3c72b5c02c13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![500~2000](http://upload-images.jianshu.io/upload_images/52890-2cf944cc1c837507.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n其他成长值的各种分布也是如此，在此就不贴出来了。\n\n正如你所看到的，我再来总结一下，\n\n在抽样中，\n\n1. 英语梦死在前 0 天的有 416351 人，占总比 68.15%;\n2. 英语梦死在前 1 天的有 466761 人，占总比 76.40%;\n3. 英语梦死在前 2 天的有 484535 人，占总比 79.31%;\n4. 英语梦死在前 5 天的有 510230 人，占总比 83.52%;\n5. 英语梦死在前 10 天的有 531219 人，占总比 86.95%;\n6. 英语梦死在前 20 天的有 551557 人，占总比 90.28%;\n7. 英语梦死在前 50 天的有 575975 人，占总比的 94.28%;\n8. 英语梦死在前 100 天的有 590700 人，占总比 96.69%;\n9. 英语梦死在前 200 天的有 575975 人，占总比 98.36%;\n10. 英语梦死在前 263 天的有 600875 人，占总比 98.81%;\n\n你可以大致感受到残酷的现实，几乎没有多少人可以坚持到 200 天以后。\n\n但是，你还需要注意到的事情是：\n\n\u003e 抽样的来源是 ID 为 1~1111111 之间的 60W 成员\n\n众所周知的事情是：\n\n- 早期的用户往往质量相对会高一些。而且，注册的 ID 越大，证明注册时间距离现在越近。获得 200 天的几率也就低了不少。\n\n\u003e 那么，这样的话，英语梦死在 200 天之前的人数比例还会大上不少。\n\n回到文章开始：\n\n问：背单词软件有大概多少人注册第一天都没有背完嘛？\n答：68.15%\n\n问：有多少人是在坚持或者曾经坚持过背单词呢？（假设 100 天以上算的上是背单词的话）\n答：保守估计，不足 3.4%\n\n问：有多少梦想，毁于不能坚持？\n答：不妨干了这碗鸡汤，歌唱青春一去不复返。\n\n问：背单词的人们学习的量，是不是符合正太分布呢？\n答：不是，简直就是反比例函数。\n\n抛出一个结论：\n\n\u003e 以绝大部分人努力之低，根本就用不着拼天赋。\n\n赠给你我，共勉。\n\n## 0x06 整个流程的不足和反思。\n\n扇贝的工程师反爬虫做的还不错，主要有两点：\n\n- 访问数量超标，封禁 IP 半个小时。对应的方法就是代理服务器。\n- cookie 如果不禁用很快就无法爬取。对应的方法就是禁用 Cookie.\n\n爬虫框架使用 Scrapy, 这样就免去了大量的繁琐的线程调度问题，直接写获取信息的逻辑代码，以及存储信息的逻辑代码就好了。\n\n在编写爬虫的过程中，有一些经验：\n\n- 在爬虫开启以后，由于我暴力的关闭，导致还是有不少的 item 没有完成请求处理和存储。\n- 我在处理异常的时候忘了应当把失败的 item 存放放在文件中，方便我第二次补充，这样的话就不会丢失一部分的用户信息了。\n- 代理服务器需要自己写脚本进行测试，否则你可能有很多很多的请求都会超时（毕竟很多代理服务器还是很不靠谱的）.\n\n我的分析数据能力并不是很强，仅仅是从 CS109 里面偷学了一点点，然后使用 Seaborn 画图，但是这整个过程中还是觉得自己分析不过来，不是写不出代码，而是不清楚使用什么样的数据模型进行分析更好。\n\n## 0x07 代码\n\n代码放在了 Github 上面，咳咳，注意，没有把代理服务器放进去。如果你跑一下会发现只能半小时抓取 300+ 页面，这不是我的问题，是你没有把代理服务器填好。代码比较粗糙，还请轻拍。\n\n代码的地址为：\n\nhttps://github.com/twocucao/DataScience/\n\n仓库里包含了抓取网站的代码和分析数据的 IPython Notebook, 自己阅读吧。\n\n如果喜欢本文，就点个喜欢吧。\n"},{"tags":["Python"],"path":"20160215_Python斗鱼弹幕助手.md","title":"Python 程序员如何优雅的看斗鱼 TV","slug":"Python 程序员如何优雅的看斗鱼 TV","date":"2016-02-15","category":"Python","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n# Python 程序员如何优雅的看斗鱼 TV\n\n## 0x00 前言\n\n过年的一段时间抽空研究写了一些关于斗鱼 TV 的弹幕的获取。分别使用 Python 和 Ruby 写了弹幕获取的客户端。\n\n文章地址为：\n\nPython 版本：\nhttp://www.jianshu.com/p/2e0d14978ae9\n\nRuby 版本附加原理讲解：\nhttp://www.jianshu.com/p/ef0225b6bb0e\n\n文章末尾写到了我有一个痛点 --rtmp 直播视频无法获取，后来在网友 [往事侞湮](http://www.jianshu.com/users/0675b42ac3ba)] 的友善提醒下，终于 Get 到了。\n\n于是，稍微完善了一下，我就发布了第一个命令行版本的斗鱼 TV 浏览弹幕小助手。\n\n如果你是 MacOSX 的用户，你只需要\n\n```bash\nbrew install mplayer\npip3 install danmu.fm\n# danmu.fm -q 1 -v 1 [url]\n# 比如\ndanmu.fm -q 2 -v 1 http://www.douyutv.com/16789\n# -q 参数 0 为不调用 mplayer 进行播放，1 为使用 mplayer 进行普清视频的播放，2 为使用 mplayer 进行高清视频的播放，3 为使用 mplayer 进行超清视频的播放\n```\n\n如果你是 Ubuntu 用户，你只需要\n\n```bash\nsudo apt-get install mplayer\npip3 install danmu.fm\n# danmu.fm  -v 1 [url]\n# 比如\ndanmu.fm  -v 1 -q http://www.douyutv.com/16789\n#ubuntu 上 mplayer 播放器可以正常播放\n```\n\n如果你是 Win 用户，\n\n\u003e 唉，windows 上面糟糕的编码问题。那单纯来看字幕的话也不是不可以的。只是我暂时没有对 Win 进行兼容。还是换 Linux 吧。\n\n## 0x01 演示效果\n\n![1123.gif](http://upload-images.jianshu.io/upload_images/52890-396d6451c68d2a83.gif?imageMogr2/auto-orient/strip)\n\n## 0xEE 代码地址\n\nhttps://github.com/twocucao/danmu.fm\n\n如果喜欢，请点个喜欢或者 star 一下\n\n---\n\nChangeLog:\n\n- **Update 20160609 : ** 更新 Python 客户端，修复由于斗鱼网页版面修改带来的小问题，直接开启海量弹幕模式（请大家不要问我为什么端午节这一天为什么闲着没事更新代码，这个真的和情人节是同一个原因）.\n- **Update 20160220 : **更新 Python 客户端，增加直播视频的 Live 获取，以及 Mac 平台下面的 Mplayer 的视频播放。代码均放在 Github 上面。[GitHub - twocucao/danmu.fm: douyutv danmu 斗鱼 TV 弹幕助手\\*\\*](//link.zhihu.com/?target=https%3A//github.com/twocucao/danmu.fm)\n- **Update 20160214 : **更新 Python 和 Ruby 客户端（请大家不要问我为什么情人节这一天为什么闲着没事更新代码）\\*\\*\n"},{"tags":["Ruby"],"path":"20160204_斗鱼TV弹幕助手.md","title":"斗鱼 TV 弹幕助手","slug":"斗鱼 TV 弹幕助手","date":"2016-02-04","category":"善用佳软","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n# 斗鱼弹幕助手\n\n## 0. 前言\n\n前几天闲着无聊，看到舍友们都在看斗鱼 TV，虽然我对那些网络游戏东西都不是非常感兴趣。只是我突然间想到，如果我可以获取上面的弹幕内容。不就有点意思了么？\n\n## 1. 分析阶段\n\n如果我想要抓取网页上面的东西，无非就是两种方法\n\n\u003c!-- more --\u003e\n\n1. 使用浏览器，手工（自己点击）或者非手工（使用 JS 脚本），存取我想要的东西。\n2. 编写 HTTP 客户端（斗鱼无 HTTPS 通讯）\n\n第一种方法是万能的，但显然是不行的， 原因如下：\n\n- 手动保存实在是不可行，程序员不为也。\n- 浏览器与本地交互有限，换而言之，也就是即使我抓取了对应的弹幕，我也没有办法解决持久化的问题。\n- 假设你选择的是 Chrome 或者 firefox 浏览器，也不是不能实现持久化，但这需要写扩展，Chrome 扩展没有写过，也不是很感兴趣。\n\n第二种方法显然是一个正常的程序员的做法。\n\n写一个客户端，也就是写一个小爬虫，使用的场景：\n\n\u003e 用户在终端执行命令\n\n```bash\n\n```\n\n回想一下抓取网站的方法\n\n四步走：请求网页（原始数据） - 提取数据（提纯数据） - 保存数据 - 分析数据\n\n很显然，只要解决了请求网页，其他的也就无非解析和 SQL 语句什么的。\n\n### 1.1. 斗鱼 TV 弹幕抓取的思路确定\n\n如果是像我上面说的那么简单，也就不必再写一篇文章。毕竟，网页小爬虫没有什么技术含量。分布式爬虫才有。\n\n通常情况下的网页小爬虫无非要解决如下问题：\n\n请求，如果对方有一定策略的反爬虫，那需要反反爬虫。比如，\n\n- header 带上 host，带上 refer，带上其他\n- 需要验证，那就申请用户名和密码，然后登陆\n- 如果在登录时期有防跨站机制，那就先获取一次登录页面，然后解析出 token，带上对应的 token 然后登陆。\n- 在程序中加入 Log，并且存到本地。防止出现各种各样的反爬虫机制 ban 掉了程序，从而方便进行下一步防反爬虫对策。\n\n并且，由于请求响应机制的存在，通常情况下，每一个请求对应一个响应，如果出错了，要么超时，要么有状态码，所以 web 爬虫实在也相对而言比较容易些。\n\n那么，斗鱼 TV 的站点是不是这样子的容易爬取呢？\n\n你猜到了，答案是“不是”。\n\n由于弹幕具有实时性，就决定了斗鱼 TV 的弹幕无法通过保存完整指定时间端弹幕的 XML（比如 BILIBILI 的一个视频弹幕是存在一段 xml 中的）或者 Json 数据来显示弹幕。要不然的话，那主播操作很出色的时候，观众的弹幕岂不是无法实时显示了么？\n\n那么，肯定就是 WebSocket 了，于是，我一如既往的打开 F12，查看网络流量。\n\n\u003e 正如你想到的那样，没有任何的弹幕流量来往。一个 WebSocket 的消息都没有。\n\n那么，消息肯定是有的，但是消息并不是通过 HTTP 协议或者 WebSocket 协议传输的，那么问题会出在哪呢？\n\n分析前端的代码，找出获取弹幕的 JS 代码，苦于代码太多，找了很久没有找到。那也就是执行逻辑可能在 flash 里面。\n\n于是祭出大杀器 WireShark，抓一下流量。终于看到弹幕的样子了。\n\n是这样的。\n\n![每条消息的内容](/images/douyutveachmsg.png)\n\n原来使用的是 Flash 的 Socket 功能。\n\n多分析几组数据，但还是对发送消息内容缺乏把握，特别是在用户认证，用户接收弹幕这一块。在搜索引擎上搜索了一阵，发现知乎上有个帖子，读完终于解了我的疑惑。\n\n省略若干消息分析过程。\n\n总结后得出斗鱼 TV 网站的服务器分布。\n\n![猜测网站架构图](/images/douyutvinfo.jpg)\n\n### 1.2. 房间信息和弹幕认证服务器获取\n\n首先我们拿随便一个主播房间来说，比如，mkk\n\nTa 的房间链接分为两种\n\n- http://www.douyutv.com/mkk\n- http://www.douyutv.com/『房间 id]\n\n对这个主播房间页面请求，正常，所有的有用信息都不是放在 HTML 中渲染出来，而是放在 HTML 中内置的 JS 脚本中，这是为了减少服务器渲染 HTML 的压力？可是渲染放在 JS 里面不也一样需要渲染？（不明白）总之，就是程序先加载没有具体数据填充页面，然后 JS 更新数据。\n\n内置的两段 JS 脚本，JS 脚本中有两个变量，该变量很容易转换成 JSON 数据，也就是两段 JSON 数据，一个是关于主播的个人信息，另一个是关于弹幕认证服务器的列表（该列表中的任意一个服务器均可以认证，但每一次请求主播页面得到的认证服务器列表都不一样）\n\n通过这步，我们就拿到了主播的信息以及弹幕服务器的认证地址，端口。\n\n### 1.3. 发送 Socket 消息的流程简介\n\n我们通过抓包，分析那一大坨数据包，可以确定以下通过以下的流程便可以获取弹幕消息。（分析过程比较繁琐）\n\n首先建立两个 Socket。一个用于认证 (@danmu_auth_socket)，另一个用户获取弹幕 (@danmu_client)。\n\n- **步骤 1:** @danmu_auth_socket 发送消息登陆，获取消息 1 解析出匿名用户的用户名，再获取消息 2 解析出 gid\n- **步骤 2:** @danmu_auth_socket 发送 qrl 消息，获取两个没有什么用的消息\n- **步骤 3:** @danmu_auth_socket 发送 keeplive 消息\n- **步骤 4:** @danmu_socket 发送伪登陆消息（所有匿名用户都一样只需要输入步骤一中用户名就行了，因为认证已经在上面做过了）\n- **步骤 5:** @danmu_socket 发送 join_group 消息需要步骤一中国的 gid\n- **步骤 6:** @danmu_socket 不断的 recv 消息就可以获取弹幕消息了\n\n后面会详细解释\n\n### 2.1. 消息 Socket 消息格式以及发送一条消息\n\n既然是发消息，那么每条消息总是有些格式的。\n\n斗鱼的消息格式大致如下：\n\n![每条消息的内容](/images/douyutveachmsg.png)\n\n并遵循下面的格式：\n\n1. 通信协议长度，后四个部分的长度，四个字节\n2. 第二部分与第一部分一样\n3. 请求代码，发送给斗鱼的话，内容为 0xb1,0x02, 斗鱼返回的代码为 0xb2,0x02\n4. 发送内容\n5. 末尾字节\n\n```ruby\n# -*- encoding : utf-8 -*-\nclass Message\n  # 向斗鱼发送的消息\n  # 1. 通信协议长度，后四个部分的长度，四个字节\n  # 2. 第二部分与第一部分一样\n  # 3. 请求代码，发送给斗鱼的话，内容为 0xb1,0x02, 斗鱼返回的代码为 0xb2,0x02\n  # 4. 发送内容\n  # 5. 末尾字节\n  #pack('c*') 是字节数组转字符串的一种诡异的转化方式\n  def initialize(content)\n    @length = [content.size + 9,0x00,0x00,0x00].pack('c*')\n    @code = @length.dup\n    @magic = [0xb1,0x02,0x00,0x00].pack('c*')\n    @content  = content\n    @end = [0x00].pack('c*')\n  end\n\n  def to_s\n    @length + @code + @magic + @content + @end\n  end\n\nend\n\n```\n\n经过封装，我们仅仅关注那些可见的字符串，也就是 Content 部分就可以了。\ncontent 部分，也就是发送消息的内容，在文章后面将会详解。\n\n开启两个 Socket，一个用户认证，另一个用于弹幕的获取。\n\n用于用户弹幕认证的，是 2.1 中所说的认证服务器列表中任意一个。挑选出来一组 ip 和端口\n\n\u003e @danmu_auth_socket = TCPSocket.new @auth_dst_ip,@auth_dst_port\n\n用户获取弹幕的只要为\n\n```ruby\ndanmu.douyutv.com:8601\ndanmu.douyutv.com:8602\ndanmu.douyutv.com:12601\ndanmu.douyutv.com:12602\n```\n\n四组域名：端口均可以作为如下的 DANMU_SERVER 和 PORT\n\n\u003e @danmu_socket = TCPSocket.new DANMU_SERVER,DANMU_PORT\n\n发送一条消息只需如此\n\n```ruby\n    data = \"type@=loginreq/username@=\"+@username+\"/password@=1234567890123456/roomid@=\" + @room_id.to_s + \"/\"\n    all_data = message(data)\n    @danmu_socket.write all_data\n```\n\n**接下来，我们需处理上面说的六个步骤**\n\n### 2.2. 发送消息详细流程之步骤一\n\n发送消息内容为：\n\n\u003e type@=loginreq/username@=/ct@=0/password@=/roomid@=156277/devid@=DF9E4515E0EE766B39F8D8A2E928BB7C/rt@=1453795822/vk@=4fc6e613fc650a058757331ed6c8a619/ver@=20150929/\n\n我们需要注意的内容如下：\n\n```ruby\ntype 表示消息的类型登陆消息为 loginreq\nusername 不需要，请求登陆以后系统会自动的返回对应的游客账号。\nct 不清楚什么意思，默认为 0 并无影响\npassword 不需要\nroomid 房间的 id\ndevid 为设备标识，无所谓，所以我们使用随机的 UUID 生成\nrt 应该是 runtime 吧，时间戳\nvk 为时间戳 +\"7oE9nPEG9xXV69phU31FYCLUagKeYtsF\"+devid 的字符串拼接结果的 MD5 值（这个是参考了一篇文章，关于这一处我也不大明白怎么探究出来的）\nver 默认\n```\n\n通过这一步，我们可以获取两条消息，并从消息中使用正则表达式获取对应的用户名以及 gid\n\n```ruby\n    str = @danmu_auth_socket.recv(4000)\n    @username= str[/\\/username@=(.+)\\/nickname/,1]\n    str = @danmu_auth_socket.recv(4000)\n    @gid = str[/\\/gid@=(\\d+)\\//,1]\n```\n\n### 2.3. 发送消息详细流程之步骤二\n\n发送的消息内容为\n\n\u003e \"type@=qrl/rid@=\" + @room_id.to_s + \"/\"\n\n无需多说，类型为 qrl，rid 为 roomid，直接发送这条消息就好。返回的两条消息也没有什么价值。\n\n```ruby\n    send_message(:qrl,@danmu_auth_socket,\"\")\n    str = @danmu_auth_socket.recv(4000)\n    str = @danmu_auth_socket.recv(4000)\n```\n\n### 2.4. 发送消息详细流程之步骤三\n\n发送的消息内容为\n\n\u003e \"type@=keeplive/tick@=\" + timestamp + \"/vbw@=0/k@=19beba41da8ac2b4c7895a66cab81e23/\"\n\n直接发送。无太大意义。\n\n```ruby\n    send_message(:keeplive,@danmu_auth_socket,\"\")\n    str = @danmu_auth_socket.recv(4000)\n```\n\n**前三步，也就是 2.2-2.3-2.4 三步骤，也就是使用 @danmu_auth_socket 完成获取 username 和 gid 的重要步骤。获取这两个字段以后，也就完成了它存在的使命。**\n\n接下来的就是 @danmu_socket 获取弹幕的时候了！\n\n### 2.5. 发送消息详细流程之步骤四\n\n消息内容为：\"type@=loginreq/username@=\"+@username+\"/password@=1234567890123456/roomid@=\" + @room_id.to_s + \"/\"\n\n和上面 2.2 中略有不同。但是，需要注意的是\n\n```ruby\nusername 为 2.2 中所得到的 username\npassword 的变化\n少了几个字段\n```\n\n```ruby\n    data = \"type@=loginreq/username@=\"+@username+\"/password@=1234567890123456/roomid@=\" + @room_id.to_s + \"/\"\n    all_data = message(data)\n    @danmu_socket.write all_data\n    str = @danmu_socket.recv(4000)\n```\n\n### 2.6. 发送消息详细流程之步骤五\n\n接下来就是完成认证的最后一步了，join_group 的消息内容为\n\n\u003e \"type@=joingroup/rid@=\" + @room_id.to_s + \"/gid@=\"+@gid+\"/\"\n\ngid 为 2.2 中所得到的 gid。\n\n```ruby\n    send_message(:join_group,@danmu_socket,\"\")\n```\n\n### 2.7. 发送消息详细流程之步骤六\n\n获取弹幕，并且打印出来。\n\n```ruby\n    danmu_data = @danmu_socket.recv(4000)\n    type = danmu_data[danmu_data.index(\"type@=\")..-3]\n    puts type.gsub('sui','').gsub('@S','/').gsub('@A=',':').gsub('@=',':').split('/')\n```\n\n**后三步，则是 @danmu_socket** 获取弹幕的步骤。\n\n于是，通过这些步骤，就可以完成了简单的 douutv 的和新代码，接下来的步骤就是完善，重构这些代码了。\n\n## 总结\n\n### 1. 痛点一，头疼的过度封装\n\n我们知道，在编写 Ruby 的 Socket Server 和 Client 的时候，非常方便，特别是传输的 socket 消息内容为字符串的时候。\n\n但是，当处理的消息内容不可打印的字符串的时候，必须要转化成字节数组的时候，让我着实混乱了一阵，直到使用了 pack(”c\\*“) 和 unpack(\"c\\*\"), 并且通过 wireshark 抓包验证了自己的发送的数据包和接受的数据包才安心使用 pack 与 unpack。\n\n### 2. 痛点二，至今还没有解决 rtmp 地址的获取\n\n找了很久没有办法解决 rtmp 地址的自动获取：\n\n路径如下\n\nhttp://www.douyutv.com/swf_api/room/301712?cdn=\u0026nofan=yes\u0026_t=24243097\u0026sign=3b2efb130cb25a85e621f477f95c7341\n\n这一处的请求不是 XHR，也就是不是 JS 脚本通过 XMLHttpRequest 异步加载；那么，八成是 flash 通过 http 协议获取的。我估计八成执行逻辑应该是在 flash 之中。\n\n## 代码\n\n核心代码的地址为：\n\n重构版本即将出炉。\n\n还请轻拍。\n\n## 参考链接\n\nPS: 如果有问题可以在下方留言或者发送 email 到 twocucao@gmail.com 给我。\n\n## ChangeLog\n\n2016-02-09 09:01:00 - 重写部分内容。增加 Ruby Socket 部分。\n"},{"tags":["macOS"],"path":"20160201_PC2MAC.md","title":"Windows 迁移到 macOS 的一些经验","slug":"Windows 迁移到 macOS 的一些经验","date":"2016-02-01","category":"善用佳软","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 前言\n\n我会想念 Windows 上面的一切，但我选择了 Mac。\n\n从某种程度上讲，我并不是讨厌 Windows。尽管我是一个伪装成、\\*nix 程序员的技术菜鸟。\n\n我还记得高一时候家里给我买的第一台二手电脑，那是一台烂到令人发指的破电脑，你可能见过那种俗称大屁股的电脑，512M 内存，64M 显存。我就在那一台机器上打了仙剑三通关和仙剑四的青鸾峰到寿阳城阶段，千佛寺时候家里电脑实在是烂到令人发指，于是电脑就报废了。后来，家里面换了一台电脑，128 显存，内存 2g 的联想杨天电脑。我就在这一台机器上打了仙剑四的寿阳城之后的剧情。\n\n\u003c!-- more --\u003e\n\n正如你可以看出来的，我并不讨厌 Windows，甚至某种程度上，我非常喜欢 Windows，正是盗版时代风靡全球的 Windows 才给了我电脑的启蒙。\n\n喜欢 Windows 的部分原因也是因为穷，只能用盗版（我当年以为是免费，后来才知道这叫做盗版）。就像当我知道仙剑四团队因为我这样只知道免费的盗版人群解散了以后，心痛不已。自此以后，如果经济上可以，我一定会买正版。倒也不是为了买给别人看，这只是代表我对软件开发者的最崇高的敬意。也是弥补我因为无知犯下的错误的愧疚感。\n\nWindows 对我来说就是启蒙老师。\n\n但 Windows 的种种环境配置，日常使用和我*inux 的技术栈完全不兼容了。从 XP 到 Vista 再到 7 再到 8 再到 10，这种情况依旧没有发生什么本质的变化。这样的我不得不选择模拟、*nix 工具，虚拟机或者双系统。但，模拟的*nix 实在太难用，虚拟机里面的系统用起来根本操作根本就不丝滑，双系统一会切换到 Win，一会切换到 Ubuntu 这种情况简直让我非常的抓狂。*nux 的环境又不能不要，可 Win 的桌面软件实在是难以割舍。\n\n于是，一个切换到 OSX 的想法在我的脑海中不断的浮现。但是正如你所知道的一个很现实的情况：\n\n\u003e 没钱，也不愿意给父母添麻烦。\n\n但\n\n\u003e 幽灵，一个想买 MacBook Pro 的想法，像幽灵一样，在脑海中不断的浮现。\n\n直到前几天才攒够足够的钱买了一台二手 mbp 改装一下 SSD。作为丐帮 Mac 第一新人，进入了 MAC 的世界里。\n\n_对，我受够了 Windows 里面各种奇葩的问题，也受够了 Ubuntu 等 Linux 系统的糟糕的桌面体验。_\n\n对于一个不研究。net 的人来说，Windows 完成了他伟大的启蒙任务。也是时候与你告别了。\n\n只是人总要和以前的一些人和事情不断的做告别，不是吗？\n\n以前看过很多比较浅显的讲解，正是那些讲解，让我逐渐入了门，然后我就不得不与他们做告别。\n\n他们完成了他们伟大的任务，他们的伟大之处永远都在为新手敞开大门，所以，我们成长之后不应该去鄙视那些给你带来进步的事物，而是礼貌的挥挥手向他们告别。\n\n## 开始迁移\n\n那么，依照我丰富的 Windows 使用经验来说，我需要解决的问题就是把原有的 Windows 和 Ubuntu 上的东西搬运到我的新电脑上。\n\n使用电脑 = 软件 + 操作\n学会使用电脑 = 描述问题 + 搜索引擎 + 笔记\n\n### 0. 自带的软件各种 Hack\n\n其实，自带的软件往往有不可忽略的强大之处。比如，Windows 世界里面的 Win+R 按键。\n\n目前来说，发现苹果上面自带软件不错的地方如下：\n\n- 自带软件，苹果的一些应用，itunes，iphoto，isg 等等。使用这些软件简直就是易如反掌。没什么好说，不错的软件就是 spotlight 了，这个软件非常的强大。可以说是进阶版本的 Windows 上面的搜索 +Win+R。但是然并卵，我们用 alfred2 这个神一样的东西，逐渐就把这基本的软件废弃了。我使用的也就是自带的 finder。\n- Mac 上的软件的快捷键可以通过一个叫做 cheatsheet 的的软件进行查看，安装好这个软件，打开一个软件，然后长按 cmd 按键。\n\n#### 0.0 系统设置调整\n\n从 Win 过来人在一些细节操作上与 Mac 的设计有一些不同。这些可以在系统里面进行设置。\n\n比如， 鼠标滚轮调整\n\npreference - mouse - 取消勾选：scroll direction ：natural\n\n#### 0.1 文件的操作\n\nwindows 里面管理文件的东西叫做 explorer.\nmac 里面叫做 finder.\n二者，图形操作上大致相同。但是结合快捷键的操作就不同了。\n\n```\n# cmd 为 command 按键，通常情况下为所有桌面程序通用性的快捷键。\n# ctrl ，通常情况下是针对程序的功能进行加强，并且此功能往往是非 cmd 类（窗口操作，选择，复制粘贴等等）操作。\n# shift 按键通常用于加强操作。一般会让操作更进一步 or 相反操作。\ncmd+tab =~ alt+tab 程序之间的切换\ncmd+` 应用内窗口切换\n\ncmd+h 窗口 hide\ncmd+m 窗口 minimize\ncmd+n 新建窗口\ncmd+o 打开\ncmd+s 保存\ncmd+shift+s 另存为\ncmd+p 打印 print\ncmd+w 关闭\ncmd+q quit\n\ncmd+a select all\ncmd+i show info\ncmd+n create a new folder\ncmd+f search\ncmd+c copy\ncmd+v paste\ncmd+delete  删除选中文件\ncmd+shift+delete 清空回收站\n\ncmd+= 放大\ncmd+- 缩小\ncmd+t 新建选项卡\ncmd+r 刷新\n\ncmd+shift+3 截取整个屏幕\ncmd+shift+4 截取选择区域\ncmd+shift+4+SPACE 截取选择窗口\ncmd+ 鼠标点击 -\u003e 选中不连续文件\ncontrol+ 鼠标点击 -\u003e 相当于 win 中右键点击\n\nfn+left home\nfn+right end\nfn+up pageup\nfn+down pagedown\n```\n\n#### 0.2 Trackpad\n\n到 trackpad 中设置对应鼠标手势\n\n1. 点击\n\n单指点击 - 单击\n单指滑动 - 滑动鼠标光标\n双指点击 - 相当于 Windows 的鼠标右键\n三指点击 - 划词查找\n\n2. 滑动与缩放\n\n双指上下滑动 - 滚动\n双指缩放 - 与 Android 上图片缩放一致\n双指双击 - 只能缩放\n双指旋转 - 旋转\n双指左右滑动 - 应用内切换网页\n双指头从右往左\n三指头左右滑动 - 全屏幕 App 切换\n大拇指和食中无名缩放 - launchpad\n\n### 1. 日常软件\n\n#### 1.1 一些满足日常生活的软件\n\nAlfred - 让你的 spotlight 更上一层楼，程序打开 / 切换、文件搜索、互联网搜索、与其他软件交互的利器。\nweixin，qq - 这是必须的。\nCleanMyMac - 系统清理软件。\n欧陆词典 - 国产词典领域最牛。别说有道词典了好伐。\ncalibre - 电子书必备，下载免费经济学人。\nWiznote - 为知笔记，实在是国产良心之作。可惜，Mac 上面的功能比较少。\nPS，Sketch - P 图必备吧？\nSafari，Chrome+ 大量的插件 - 不多说，Chrome 简直就是我的第二操作系统。那犀利的插件，Get 到痛点的功能，用起来纵享丝滑一般的流畅，都深深的迷住了我。除了吃内存，其他都好。\nPDF reader，ibook - 文档查看必备。\nMS OFFICE，Work 套件：包括 pages, numbers, keynote. 其实 Windows 的生产力之说大抵也就是 Office 系列 VS 系列了，虽然我不喜欢 Office，但是不得不说，Excel 做的真的是世界级的牛。其他，PPT，Word 嘛？反正我不喜欢，奈何别人都用这个。我只好在电脑上安装一份了。\n虚拟机：parallels desktop\n迅雷 本来挺简洁的，最近出来一个商城。哦，看来距离我卸载他的日期已经不多了。\n管理 Android 手机：airdroid 用于管理我的坚果手机。\n写作与编码，Sublime+ 插件，MacVim+ 插件\n邮件：airmail 好简洁，好强大，和 Gmail 简直就是无缝对接嘛。\n思维导图：xmind - 一直在用。依赖 Java 环境。\n解压缩：BetterZip 7z 解压缩 我比较喜欢 7z\n你懂的：shadowsocks 不多说了，看小粉红出墙征战四方寸草不生的优良工具。\n其他系统自带软件\n\n### 2. 开发环境\n\nide 类：xcode 和 xcode-cli 工具（用于安装 homebrew 和 homebrew cask）\n\n#### 2.1 homebrew\n\n少什么？homebrew 一下就好。\n\n如果你想更深一步，那就使用 homebrew cask\n\n#### 2.2 sublime text\n\nsublime text 作为我很长一段时间的主力编辑器，优点如下：\n\n- 快，打开文件比较快。当然，比 notepad++ 要慢\n- 多光标编辑。\n- 强大的插件库\n\n对，加上第三点，sublime 成为了编辑器世界的女神级别人物。哎，想起我对别人大力推荐这个编辑器别人还是一如既往的使用 npp，实在是糟心。\n\n插件库里面的主题我比较喜欢 sodarized\n喜欢的功能性插件为 pretty 系插件，比如，对 json,html,js.css 进行一键格式化。哦，简直帅爆了。\n当然其他能留下深刻印象的就是 lint 系列插件和部分对编辑器的侧边栏，右键菜单，以及对应语言的库进行补充的插件了。\n\n现在继续使用这一款软件的原因也是如此。\n\n#### 2.3 macvim + spf13-vim\n\n我对计算机上古时代的前辈们总是有很崇高的敬意。这在我是用来了 Vim 以后才逐渐有这种想法。\n\n对，Vim 真的很神奇。但是 Vim 是我见过的为数不多的使用难度超越了我认识到的所有软件的软件。之前排名在 top 1 的应该是 Windows 上面的 Totalcmd。\n\n出于 Vim 及其陡峭的学习路径，我认为 Vim 本身适合可以盲打，并且是键盘流爱好者的情况下再学习。否则，学习效率会极其的低下。为什么我知道？一把辛酸泪。\n\n在这个时代，最宝贵的就是有用的信息，对，我遇到了 SPF13Vim 这个已经配置好的 VIm 版本。并且从中学习到了一些奇技淫巧。\n\n现在基本上是离不开 Vim 了。甚至面对没有 Vim 类型操作的编辑器或者浏览器的时候，简直无法忍受。\n\n尽管现在我还是一个 Vim 菜鸟。有机会我会整理好自己的 Vim 配置，放在 github 上面。\n\nVim 使用一定要改按键！！！\n\nCapsLock 按键没有什么用，改成 Escape 按键或者改成 Ctrl 按键，推荐改成 Ctrl，因为 ESC 除了 Vim 里面使用的比较少，但是使用 Ctrl 的场景就比较多了（Vim 中 ESC 可以使用 Ctrl+\\『代替，而且不需要使用第三方工具），这样让小拇指很舒服。\n\n#### 2.4 Chrome\n\n由于一些众所周知，或者你不知道我也懒得告诉你的原因。我们比较信赖国外的好的产品。\n\nChrome 就是这样的产品。\n\n我以前的文章也写过，只是由于硬盘发生了一次数据丢失事件，关于 chrome 的笔记都已经丢掉了，我就再也没有写过 chrome 的那些牛的要死的功能。\n\n但是我还是要推荐一些我喜欢的插件。\n\nadblock - 去广告标准配置了吧\nautoPatchWork - 自动拼接下一页到本页\ncapture，explain and send screenshots - 截图\ncssviewer - 查看 css 的工具\nDream Afar New Tab - 美化新标签页面必备\njson editor - 格式化 json 专用\nisometric contribution - 其实也就是美化 github 上面提交的工具\nOne Click extensions Manager - 由于 chrome 的标签数量惊人，所以有的时候为了提升速度还是禁用掉一些比较好。\nPocket - read it later PS：虽然我自从用了为知笔记以后就不用 pocket 了。但 pocket 真的值得一用\nVimium - 快速浏览网页的神器\nWeb Timer - 记录花在每个站点的时间。\nWiznote WebCliper - Pocket 的替代品\nOctotree - 如果你玩 github 没装这个插件，是时候使用这个插件然后感叹时光一去永不回了。\nSwitchyOMega - 你懂得\n\n#### 2.5 Lang 环境\n\nLang 环境，顾名思义，就是各种语言的环境。\n\n我们程序员需要懂和计算机交流的本事，所以，我们需要学很多的语言。但，问题也就因此而来。选择什么样的软件来管理不同的软件环境呢？如果是 Ruby 环境，我们又怎么配置 Ruby 不同版本呢？\n\n计算机世界的铁律：\n\n\u003e 只要有树叶飞舞的地方，火就会燃烧\n\n额，等等，说串场了\n\n\u003e 只要有痛点，就有解决痛点的工具。\n\nJava 这个需要切换版本的要求比较低。无所谓。何况，已经很久没有写 Java 了。 我一般情况下使用的是 Java8\nrvm ruby 社区的人都喜欢使用最新最潮的技术，所以，切换版本这种事情必须要做，rbenv 和 rvm 都是非常有用 ruby 版本管理器。我喜欢 rvm。\nnvm nodejs 比较火，虽然我对 nodejs 并不是很感冒，但是我不得不承认，有些人写出来的 nodejs 工具实在是方便的要死。比如，gitbook-cli，hexo-cli，二者都是记录自己的笔记的好东西。\nLang 对于 Python，我选择了 anaconda，anaconda 为特殊的 Python 分发包。里面的库比较全面，不需要我特地为一个包找教程来安装。\n\n#### 2.6 终端\n\n首先，我们对终端的认识可能还停留在 unix 机器或者 ubuntu 桌面进不了的时代。Mac 上面 iterm2 作为一个终端模拟器，则是做到了同类中的最强者。好用到想让人哭。\n\nshell 一般情况下使用的 bash，但是那是对运维人员来说的，我们开发者使用的是 zsh。配置 zsh 的文件使用是 OhMyZsh.\n\n好用到想哭。\n\n## 结束语\n\n从我的角度来看 Win 和 Mac 的好于不好\n\nWin 的好在于系统优良的兼容性，以及入门就可以上手的强大的操作性。由于出自于什么都爱做的微软公司，从整体来说，VS，.NET, 游戏性，兼容性，性能，新手上手速度来说，都是遥遥领先 Mac 的。\n也可惜了，微软的战线实在是拉的太长，什么都想做，什么都想垄断。于是，与之服务密切相关的公司也就受到了 MS 的牵制。这对大公司来说，几乎是不能够忍受的行为。于是硅谷的公司使用微软服务的也就接近 5%（可能有误差）。并且，糟糕的终端环境（DOS）和无法与、*nux 世界的脚本友好相处使得系统的可定制性和进阶操作性大大降低。\n虽然有 Everything，TotalCMD，AHK 这种神级辅助工具可以满足定制要求。但由于过高的学习成本（AHK 语言真的很混乱啊，TC 实在是太难用了）但也无法满足、*nux 程序员的要求。这就是我不得不切换到 Mac 上面的理由。\n\nMac 的好在于终端和美观的图形的结合。也就是开发基于、\\*nux 应用的非常方便以及非常容易与脚本文件配合出强大的组合技能，反观 Win 上，则这种组合技能则在环境配置上和操作流畅度上差了很多。\n缺点也是相当容易看出来的 -- 娱乐项目实在是少的要死。再者说，我们也不需要娱乐性那么强的软件，不是么？\n\n哦，终于集齐了 PC，Linux，Mac 的配置文章\n\n[关于 Ubuntu 我的回答](https://www.zhihu.com/question/30816866/answer/59415036)\n\n[关于 Win10 我的回答](https://www.zhihu.com/question/32129337/answer/59379401)\n\n就酱紫。\n\n## 更新\n\n- 2016-02-03 : 更新 Trackpad 部分，修改部分文字\n- 2016-02-07 : 重写快捷键部分，将快捷键按照程序划分。\n- 2017-04-01 : 重写碎碎念部分。\n- 2017-05-01 : 已经更换最新款 Macbook Pro, 算是实现了一个小目标吧。\n"}],"total":4},{"name":"2015-12","posts":[{"tags":["书单"],"path":"20151231_书单.md","title":"书单","slug":"书单","date":"2015-12-31","category":"读书笔记","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 前言\n\n记下一些看过的和没有看过的书籍。\n\n标记如下：\n\n- [o] 看过，并且留有读书笔记\n- [x] 没看过，或者准备再看一次\n- [-] 正在看\n\n### 技术类\n\n其实程序员的编程类知识的获取大多来源于官网的 api docment 以及 guide, 但也并不完全如此。\n\n有的官网的 tutorial 写的不够入门，guide 写的缺乏案例，api document 写的相当及简略。\n\n\u003e 很多时候，还是需要去阅读源码的。\n\n但下面的一些书籍，或多或少让我觉得应该和官网结合起来看。\n\n\u003c!-- more --\u003e\n\n#### Web 与爬虫\n\n- [x] 鸟哥的私房菜 两本\n- [x] Python Cookbook\n- [x] Python 算法教程\n- [x] Python 可视化编程\n- [x] Python Web 开发实战\n- [x] Python For Data Analysis\n- [x] Flask Web 开发\n- [x] MySQL 技术内幕 : SQL 编程\n- [x] MySQL 技术内幕 : InnoDB 技术内幕\n- [x] 深入浅出 MySQL\n- [x] SQL 反模式\n- [x] Linux 集群和自动化运维\n- [x] Practical Vim\n- [x] Javascript 语言精髓与编程实践\n- [x] Javascript 高级程序设计\n- [x] Javascript 设计模式与开发实践\n- [x] Javascript 设计模式\n- [x] 高性能 Javascript\n\n#### 基本功\n\n- [x] 深入理解计算机系统\n- [x] 计算机网络\n- [x] 设计模式\n- [x] 重构\n- [x] 算法（第四版）\n\n#### 科技与人文\n\n- [x] MacTalk 人生元编程\n\n### 非技术类\n\n#### 未分类\n\n- [x] 异类\n- [x] 眨眼之间\n- [x] 引爆点\n- [x] 逆转\n- [x] 大开眼界\n\n#### 励志鸡汤\n\n- [x] 技巧：如何用一年的时间获得十年的经验\n\n#### 思考与写作\n\n- [x] 学会独立思考\n- [x] 清醒思考的艺术\n- [x] 厚黑学\n- [x] 如何阅读一本书 [我的笔记](http://twocucao.xyz/2017/01/27/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_%E4%B8%8E%E6%97%B6%E9%97%B4%E5%81%9A%E6%9C%8B%E5%8F%8B/)\n- [x] 把时间当作朋友 [我的笔记](http://twocucao.xyz/2017/01/27/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_%E4%B8%8E%E6%97%B6%E9%97%B4%E5%81%9A%E6%9C%8B%E5%8F%8B/)\n- [x] [正解：从写作文到写作](#)\n- [x] [小说课](#)\n- [x] 精进：如何成为一个很厉害的人\n- [x] Beyond Feelings\n- [x] 公正：该如何做是好？\n\n#### 沟通与交流\n\n- [x] 好好说话 [我的笔记](http://twocucao.xyz/2017/01/27/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_%E5%A5%BD%E5%A5%BD%E8%AF%B4%E8%AF%9D/)\n- [x] [沟通的艺术（插图修订第 14 版） : 看入人里，看出人外](https://book.douban.com/subject/5321463/)\n- [x] [非暴力沟通](https://book.douban.com/subject/3533221/)\n- [x] [所谓情商高，就是会说话](#)\n- [x] [演讲的力量 : 如何让公众表达变成影响力](#)\n- [x] [谈话的力量](#)\n- [x] [高难度谈话](#)\n- [x] [沟通圣经 : 听说读写全方位沟通技巧（修订第 5 版）](#)\n- [x] [关键对话 : 如何高效能沟通（原书第 2 版）](#)\n- [x] [谈判是什么](#)\n- [x] [沃顿商学院最受欢迎的谈判课](#)\n- [x] [遇谁都能聊得开 : 92 个技巧让你的谈话充满魅力](#)\n- [x] [沃顿商学院最受欢迎的谈判课](#)\n\n#### 小说\n\n** 金庸 **\n\n飞雪连天射白鹿，笑书神侠倚碧鸳\n\n- [x] 飞狐外传\n- [x] 雪山飞狐\n- [x] 连城诀\n- [x] 天龙八部\n- [x] 射雕英雄传\n- [x] 白马啸西风\n- [x] 鹿鼎记\n- [x] 笑傲江湖\n- [x] 书剑恩仇录\n- [x] 神雕侠侣\n- [x] 倚天屠龙记\n- [x] 碧血剑\n- [x] 鸳鸯刀\n\n** 古龙 **\n\n- [x] 天涯明月刀\n- [x] 绝代双骄\n- [x] 陆小凤传奇\n- [x] 萧十一郎\n- [x] 火并萧十一郎\n- [x] 多情剑客无情剑\n- [x] 小李飞刀\n- [x] 楚留香传奇\n- [x] 天涯明月刀\n\n** 福尔摩斯 **\n\n- [x] 柯南道尔 福尔摩斯探案集\n- [x] BBC 神探夏洛克\n\n#### 历史\n\n** 历史虚构类 **\n\n- [x] 明朝那些事儿\n- [x] 唐浩明 - 曾国藩\n- [x] 唐浩明 - 杨度\n- [x] 唐浩明 - 张之洞\n\n** 世界史 **\n\n- [x] 全球通史\n\n** 中国史 - 先秦 **\n\n- [x] 《易中天中华史·第一卷 ：祖先》\n- [x] 《易中天中华史·第二卷 ：国家》\n- [x] 《易中天中华史·第三卷 ：奠基者》\n- [x] 《易中天中华史·第四卷 ：青春志》\n- [x] 《易中天中华史·第五卷 ：从春秋到战国》\n- [x] 《易中天中华史·第六卷 ：百家争鸣》\n\n** 中国史 - 秦汉魏晋南北朝 **\n\n- [x] 《易中天中华史·第七卷 ：秦并天下》\n- [x] 《易中天中华史·第八卷 ：汉武的帝国》\n- [x] 《易中天中华史·第九卷 ：两汉两罗马》\n- [x] 《易中天中华史·第十卷 ：三国纪》\n- [x] 《易中天中华史·第十一卷 ：魏晋风度》\n- [x] 《易中天中华史·第十二卷 ：南朝，北朝》\n\n** 中国史 - 隋唐 **\n\n- [x] 《易中天中华史·第十三卷 ：隋唐定局》\n- [x] 《易中天中华史·第十四卷 ：禅宗兴起》\n- [x] 《易中天中华史·第十五卷 ：女皇武则天》\n- [x] 《易中天中华史·第十六卷 ：安史之乱》\n\n** 中国史 - 宋元 **\n\n- [x] 《易中天中华史·第十七卷 ：大宋革新》\n\n#### 杂文\n\n- [x] 李敖 - 活着你就得有趣\n- [x] 李敖 - 活着你就得有种\n- [x] 李敖 - 活着你就得有料\n\n#### 新技能 Get\n\n- [x] 和你一样，爱上手机拍照\n- [x] 居家超级整理术\n\n#### 运动健身\n\n- [x] 硬派健身\n- [x] 一平米健身\n\n---\n\nUPDATE:\n\n| 日期           | 类型 | 详细操作                           |\n| -------------- | ---- | ---------------------------------- |\n| **2017-02-10** | 创建 | 初始化本文                         |\n| **2017-02-18** | 更新 | 添加两篇读书笔记地址，细化读书书目 |\n"}],"total":1},{"name":"2015-09","posts":[{"tags":["随笔","影评"],"path":"20150919_博人传影评.md","title":"『博人传』影评","slug":"『博人传』影评","date":"2015-09-19","category":"碎碎念","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n# 『博人传』影评\n## 『博人传』影评\n\n**全国最大忍者村火影忍者村倒闭了！！！**\n\n博人传影评内无剧透。\n\n故事发生在鸣人当上火影之后。天天忙于公务，一直没有时间陪自己的孩子。\n\n也是在这时，世界的科技日新月异，转眼间木叶的电脑技术已经杰出到世人无法理解的地步。\n\n宇智波童参考这查克拉的结构，结合中国功夫中的内功，外功，亦欲以究天人之际，通古今之变，终于在 SCI 上发表论文《查克拉的数学原理和中国周易的必然联系》，该论文深刻阐述了**查克拉的本质**，查克拉由两个东西构成，一个叫做阴，另一个叫做阳，而所有人的查克拉都可以都可以通过一定量的排序组合变成不同属性的查克拉。\n\n\u003c!-- more --\u003e\n\n宇智波童在此基础上提出了查克拉论，并建立不同属性的查克拉与两极四象五行之间的联系。他还写到，在人发出忍术的时候，首先将自己的体内的阴阳进行排序，接着转为两极能，接着再添加方向编码，变为四象能，附加自身的体质就可以转为具象的查克拉能。也就是，人们看到的查克拉，本质上就是『阴阳组合』四象』体质』。阴阳组合的长度代表一组忍术的强度，四象也就是四个方向，组合的越好，忍术就越灵活，而体质方面，像鸣人那样的风一样的男子，使用的就是风遁，像佐助那样的脾气火爆，做事比较雷人的使用的就是火遁和雷遁，像鹿丸那样聪明的，经常求别人心里阴影面积的人，使用的就是影子系术。既然查克拉是通过阴阳编码而成，那么，就可以对自己忍术的查克拉进行充分的抽样研究，从而不断优化自己忍术的编码。通过优化自己忍术的编码，就可以通过少量的查克拉调用比较强大的忍术方法。\n\n论文发表的第二年，宇智波童发明了一种卷轴纸，这种卷轴纸张的正面在查克拉的激发下可以留下痕迹，而且不同的忍术留下的痕迹也是不相同，除非摔在地上破碎，否则几乎痕迹不会发生变化。于是宇智波童在这张纸上将自己的忍术口遁 - 一本正经胡说八道之术 通过查克拉留在了卷轴纸上。并将此种类型的纸张命名为磁卷轴。磁卷轴在背面接触查克拉的同时会释放忍术。也就是通与激发卷轴痕迹同等查克拉的时候，释放忍术。\n\n第三年，宇智波童对卷轴进行大幅度改造，卷轴已经具有极小的体积，极大的容量了，并且造出了世界上第一个磁性忍术卷轴 3D 解释器。\n\n![火影：博人传](http://upload-images.jianshu.io/upload_images/52890-89b39501ba26fbcc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n就如同你看到的，只需要你把卷轴放进去。解释器就会对卷轴进行解释。可是释放多种不同类型的忍术。对这些都不需要和与激发卷轴痕迹同等查克拉，我们在解释阶段做了大量的优化，比如，为了提高执行速度，我们引入了 just-in-time 技术，由于忍术 = 『 『 『阴阳组合』四象』体质』，大幅度提升阴阳组合构成就可以无敌于战场，我们引入了压缩技术，通过大量的压缩算法，把自然能源压缩到卷轴中，基本上，使用者只需使用极少的查克拉就可以释放极大的忍术。\n\n![火影博人传.jpg](http://upload-images.jianshu.io/upload_images/52890-ea42906081e3d177.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n如同你所看到的，只需一点点，卷轴，就可以有无限的能量。\n\n![火影：博人传.jpg](http://upload-images.jianshu.io/upload_images/52890-73a7dcaba3454879.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n木叶忍者村开发出这种技术以后，把技术的步骤放到 NinjutsuHub 上，于是，世界忍者纷纷加入到这种磁性忍术卷轴 3D 解释器的开发商，当然，正如你所知道的，在遥远的东方某国在技术公开以后第二天就有不要脸的忍术公司发表文章说他们自主研发了一套磁性忍术卷轴 3D 技术。\n\n磁性忍术卷轴 3D 解释器风靡全国之后，木叶忍者村的忍者渐渐也不需要会什么忍术的人了。人才日渐凋零。火影漩涡鸣人不堪重负。逃离木叶。于是，宇智波童携带着一流的技术和人才，流浪到遥远的东方。\n\n突然的出现，\n\n在街角的咖啡店，\n\n也带着笑脸，\n\n用大喇叭大声吼道：\n\n**木叶忍村，木叶忍村，全球最牛忍者村，木叶忍者村倒闭啦，王八蛋火影吃喝嫖赌欠下三点五个亿的赌债，带着他的老婆佐助逃跑了，我们没有办法，拿着忍术抵现金，原来五影才能使用的忍术，无需背口诀，无需结印，不开刀，无痛苦，第一天买装备，第二天无痛打怪，全场清仓大甩卖，统统只要三十元，统统只要三十元，统统只要三十元。**\n\nPS：鸣人和佐助终于在一起了。\n\n![火影：博人传.jpg](http://upload-images.jianshu.io/upload_images/52890-5f006dcb1edc053c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![火影：博人传.jpg](http://upload-images.jianshu.io/upload_images/52890-d8b1c80e990c41ad.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![火影：博人传.jpg](http://upload-images.jianshu.io/upload_images/52890-1ef75a12932690eb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n---\n\nChangeLog:\n\n- **2017-03-19** 重修文字，祝贺鸣人君和雏田君终成眷属\n"}],"total":1},{"name":"2015-06","posts":[{"tags":["Windows"],"path":"20150614_如何优雅的使用Windows10.md","title":"如何优雅的使用 Windows 10","slug":"如何优雅的使用 Windows 10","date":"2015-06-14","category":"善用佳软","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n# 如何优雅的使用 Windows 10\n\n## 0x00. 前言\n\n刚开始 Win10 发布没有多久的时候我就写了这篇回答，放在知乎上，后来又搬运到 jianshu 上，现在搬运到自己的博客上，也算是落叶归根。\n\n\u003e 已经过了折腾的年龄，答案仅仅从提升效率方面来说，是否优雅就看诸位的审美了。\n\n本文目录\n\n1. 文件夹与文件一定要分类命名好。\n2. Win10 自带功能怎样提升效率。\n\n- 2.1 快捷键\n- 2.2  触摸板手势\n- 2.3 Win+R\n\n3. 非 Windows 自带的必备的提升效率，节省时间的软件。\n\n- 3.1 文档，图片，文本，以及通用文件管理器\n- 3.2 Everything is OK\n- 3.3 Chrome （Google 出品，必属精品）\n- 3.4 阅读方面 calibre ， 欧路词典\n- 3.5 笔记软件 xmind，wiznote\n- 3.6 播放器\n- 3.7 其他想到再补充\n  4.  不写点代码优化一下工作流程，你都不好意思说自己逼格高。\n- 4.1 autohotkey\n\n## 0x01. 文件命名\n\n\u003e 文件夹与文件一定要分类命名好\n\n贴上我的几张图来看一下我的文件夹命名：\n\n一级文件夹如下：\n![](http://upload-images.jianshu.io/upload_images/52890-b6a5322beca48d2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n二级文件夹如下：\n![](http://upload-images.jianshu.io/upload_images/52890-656d90e16abaff66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n三级或者三级以上文件夹\n\n![](http://upload-images.jianshu.io/upload_images/52890-bdf7349fccedda52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n文件命名规范（因为涉及到后面使用 Everything，所以我们的命名尽量追求便于搜索）\n\n举个例子，对于读书笔记 ：读书笔记、\\_设计模式、\\_20150303_v2.1.xmind\n\n对于照片这种文件比较多的，优先命名文件夹，其次按照地址人物日期命名，比如：大明湖胖、\\_夏雨荷、\\_20150101\n\n\u003e 无需刻意追求命名，方便搜索，方便管理就好。\n\n不妨参考下面文章：\n\n[电脑上的文件夹该如何命名（整理）才能做到很久都不用重新整理的那种？ - 文件整理](http://www.zhihu.com/question/21537488)\n\n嗯这样你在搜索笔记的时候在 Everything 里面只需要键入 2015 笔记就可以查看 2015 笔记文件。\n\n是不是很方便？\n\n![](http://upload-images.jianshu.io/upload_images/52890-f4a815755900d627.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![](http://upload-images.jianshu.io/upload_images/52890-1fb3ac3766e59044.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n当然桌面上尽量少放或者不放文件夹，我的桌面上仅仅有一个链接到 OneDrive 里面的 TEMP 文件夹的快捷方式，用于存放临时没有整理的文件。\n\n![](http://upload-images.jianshu.io/upload_images/52890-be22e9252b149d1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 0x02. Win10 自带功能怎样提升效率\n\n- 2.1 快捷键其他答主说的都可以，你就直接参考他们的答案中的关于快捷键。我仅仅说一些重点快捷键。Win+ 数字键 把常用的软件附在任务栏上。建议四个以内，方便单手操作。Win+X Alt+tab 切换窗口 WIn+R 运行\n\n- 2.2 触摸板手势参考最高票的答案。虽然我觉得增加的那么多的触摸手势比较鸡肋。\n\n- 2.3 Win+RWin+R 主要用于启动一些程序或者一些 DOS 小命令。\n\n![](http://upload-images.jianshu.io/upload_images/52890-d39ea3f078f1d800.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n我将所有的便携与非便携软件的快捷方式放在这里并且配置环境变量。比如，我需要启动为知笔记，我就仅仅需要闭上眼睛输入 Win+R + wz +\u003cEnter\u003e\n\n其他软件同理。\n\n```python\n# sublime text 打开需要输入 \nWin+R + st +\u003cEnter\u003e\n# 欧路词典 打开需要输入 \nWin+R + ol +\u003cEnter\u003e\n# 这里省去若干软件打开方式。\n```\n\n关于 Win+R 你可以参考善用佳软  [最绿色最高效，用 win+r 启动常用程序和文档](http://xbeta.info/win-run.htm)  的介绍。\n\n## 0x03. 非 Windows 自带的必备软件\n\n3. 非 Windows 自带的必备的提升效率，节省时间的软件。\n\n- 3.1 文档，图片，文本，以及通用文件管理器如果文件多，就一定需要一个用于管理这种类型文件的管理器 - 托马斯。电脑达人\n\n图片管理用 Picasa\n\n文本管理直接使用笔记软件比如为知笔记，或者印象笔记。\n\n![](http://upload-images.jianshu.io/upload_images/52890-efe86c9e4bd48b95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n文件管理进阶的话可以使用 totalcmd，不过学习路线比较陡峭，没有足够的需求，不要搞 TC.\n\n用 Everything。或者 listary\n\n- 3.2 Everything is OK\n\n无坚不摧，为快不破。 everything 是搜索效率最快的软件。没有之一。合理的命名可以为你的生活节省一半找资料的时间。\n\n- 3.3 Chrome （Google 出品，必属精品）\n\n浏览器本身速度快，配合强大的插件库。让你在实力派装逼的道路上越走越远\n\n这玩意的强大在哪到处都有，直接在知乎上搜一下就好了。\n\n- 3.4 阅读方面 calibre ， 欧路词典，\n\ncalibre 主要是用来看经济学人，老乡恶魔的奶爸推荐。\n\n欧路词典可以外挂其他的开源词库，查词速度超级快。\n\n- 3.5 笔记软件 xmind，wiznote 用于记录笔记。前者用于梳理思路，把一本书读薄，后者用于将自己的知识体系梳理一遍，把书读厚。消化资料。\n\n- 3.6 播放器\n\nQQ 影音 -- 满足普通播放需求\n\nkmplayer -- 用于视频截图\n\nfoobar2000 -- 逼格提升必备\n\n![](http://upload-images.jianshu.io/upload_images/52890-1d8bc57d69948d60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n网易云音乐 -- 这货真的不错。\n\n- 3.7 其他想到再补充\n\n## 0x04.  不写点代码优化一下工作流程，你都不好意思说自己逼格高。\n\n不写点代码优化一下工作流程，你都不好意思说自己逼格高。- autohotkey\n\n可以针对快捷键进行编程。有了它，妈妈再也不担心我操作速度慢的要死了。\n\n有如下场景：一大段文字中有一个网址，你需要访问它，我的解决方法就是选中那些文字，然后一个 Win+b，直接打开 chrome 进行搜索，如果文字中没有网址，那么对选中文字进行百度。同理可以推淘宝，京东 github 等等。或者这样一个场景，你需要大量的文本编辑，但是上下左右离自己的工作区比较远，你可以小拇指按住大写锁定按键，然后使用 HJKL 进行移动。\n\n教程参考 [AutoHotkey 之美 - 知乎专栏](http://zhuanlan.zhihu.com/autohotkey)\n\n新手可以先拿我搜刮整理的 AHK 代码看看。[twocucao/ChortHotKey · GitHub](https://github.com/twocucao/ChortHotKey)\n\nPS：我上面提到的软件几乎都是神级软件，都是入门容易精通难的深坑，想调教好也不是想象中呢么简单的，但，书到用时方恨少，你可以先挑一些使用。如果你以后有不少的文件需要管理，在未来，你一定会用到。\n\n至于哪些图标怎么搞定？步骤如下：制作出那样的图片文件 （PS）\n转换成 ico 文件（Iconmaster），把 ico 文件拷贝到指定文件夹内部（这步是为了方便修改文件夹切换电脑带来的文件夹图标恢复原样）\nico 设置到文件夹上 （修改文件夹内部的 desktop.ini 文件）\n\n附上制作的 PSD 文件，ICONMASTER 以及一个样板文件夹（注意要开启显示系统文件以及隐藏文件两个选项，然后查看样板文件夹中的 desktop.ini 以及 ico 文件。修改的话，也就是修改 desktop.ini 文件里面的对应文件名称就好了）\n\n链接： [百度云地址](http://pan.baidu.com/s/1qWyx6oc)  密码：g9up\n\nfoobar 链接：[百度云地址](http://pan.baidu.com/s/1e7xZC)  密码：e0as\n\n文件图标受此答案启发：[如何整理电脑文件夹？ - 计算机](http://www.zhihu.com/question/19901022)\n\n\u003e 2016-01-04 已经更换 Macbook Pro, 依然挂念 Windows.\n\u003e 2017-05-01 21:42:00 已经更换 2016 年 Macbook Pro With Multi-Touchbar, 再无挂念 Windows.\n\n## 0x05. 后续\n\n所谓用 Windows 还是 MacOS 都是一种选择而已，孰高孰下谁知道呢。并不是说用了一个操作系统，用了某个软件，就会显得自己多么高明，如果不能为自己的日常工作提高效率，让自己节省下来的时间留给自己，那又有什么意义呢？\n\n当我在 Windows 上的时候一味追求 APM, 即高效的操作，但其实最高效的还是自己的思路清晰，想好了再动手。\n\n\u003e 谋定而后动\n\n如是而已。\n\n\u003e 抓到老鼠的猫才是好猫呀！\n\nChangeLog:\n\n- 2017-03-08 09:32:15 整理知乎回答，搬运到博客上。\n- 2017-05-01 09:32:15 补充现在使用的电脑信息\n- 2017-06-10 09:32:15 重新排版，增加后续章节。\n"}],"total":1},{"name":"2015-05","posts":[{"tags":["Google"],"path":"20150504_GoogleTips.md","title":"搜索引擎的一些技巧","slug":"搜索引擎的一些技巧","date":"2015-05-04","category":"善用佳软","lastMod":"2020-01-01","description":"搜索引擎的一些技巧","thumbnail":"","content":"\n# Google Tips\n\n## 0x01 Google 搜索引擎技巧\n\n```bash\nintitle: 古文观止 site: pan.baidu.com\n+ or\nlink:http://www.reanren.com\ninurl\n\"\"\n『长城*』\n```\n\n## 0x02 Baidu 搜索引擎技巧\n\n```bash\nsite:\n```\n\n---\n\nChangeLog:\n\n- **2016-12-22** 几乎重修文字，修改标题为 搜索引擎的一些技巧。\n"}],"total":1},{"name":"2015-02","posts":[{"tags":["Windows"],"path":"20150222_Chorthotkey发布.md","title":"Chorthotkey 发布","slug":"Chorthotkey 发布","date":"2015-02-22","category":"开源项目","lastMod":"2015-10-25","description":"未描述","thumbnail":"","content":"\n# Chorthotkey 发布\n\n## 0x01 概要介绍\n\n经过长时间的电脑的使用，我渐渐的喜欢上了 Autohotkey 这个神器，喜欢 Python 是因为 Python 强大与高效，喜欢 AHK 则是太方便了。\n\n长时间的使用，毕竟也积攒了一些脚本，加上对很多脚本的收集以及修改，勉强算得上是一个入门的 AHK 菜鸟了。\n\nAHK 的优点可以对快捷键进行编程，对一个经常使用电脑自动化处理一些事情的人说，非常之方便，但缺点，太多，效率低，语法乱，数据结构乱。让我写一段文字处理简直就让我非常难受。\n\n但为了取长补短，我仅仅使用其中的对快捷键编程的功能，加上收集来的别人的一些函数。修改集成，然后做一个顺手的 AHK 脚本，名字就叫做 Chorthotkey。\n\n\u003e 开源，协议选择 Mit 协议。简而言之也就是你改了名字版权就是你的了。\n\n我在编写这篇文章的时候，也在重构并进行 V0.4 版本的完善。\n\n什么时候使用 AHK 脚本呢。\n\n\u003e 当繁杂的功能可以批量完成的时候。\n\n换而言之，当这个功能不值得用另一个大的专业性比较强的软件代替的时候，或者对快捷键进行编程的时候。\n\n- 先说第一点：当我想使用一个功能的时候，比如快速打开一个网页，或者进行文字上的简单处理，这个时候没有必要单独下载一个软件进行处理，这个在 AHK 中就是简单的几行代码就可以搞定。比如打开网站直接 Run www.baidu.com AHK 就会直接调用相关浏览器打开 baidu. 这么简单的东西没有必要单独下载一个软件进行管理。\n- 再说第二点：当我想着对快捷键进行编程调用进行自动化处理东西的时候，或者编写一套自己的热键用来打游戏或者其他的一些编辑用途等等，都可以。理论上来说，AHK 几乎是只有想不到没有做不到的。\n\n那么，AHK 不能替代什么东西？\n\n在文件管理方面，尽管你可以自己编写很多的快捷键，但你没有办法超越 TotalCMD，没有办法超越 Listary 或者 Everything，所以，你编写的东西只需要辅助你使用这些东西就好了。\n\n在文本编辑方面，你始终无法超越 sublime text 3，无法超越 vi，无法超越 Emacs，你只需要辅助你使用这些工具即可。\n\n其他专业软件同理。\n\n既然说了 AHK 那么多的不足和缺憾，但是 AHK 在我的脚本语言中依然傲立第二名，就是因为它擅长的快捷键编程。\n\n好了，废话这么多，总该说点干货了。\n\n我认为 Autohotkey 用好这三个脚本即可：\n\n- Candy 一个非常强大的第三方弹出菜单 amii 编写。\n- ChortHotKey 一个我编写的工具\n- vimd 无所不在的 vim 党编写的软件。\n\n好吧，我无耻的把三个工具放在一起了。虽然 Candy 和 vimdesktop 在使用上面甩 Chorthotkey 几条街，但是，我乐意把他们放在一起，怎么滴？\n\n## 0x02 设计思路\n\nAHK 的操作按照是否聪明分为两种：\n\n1. 第一种叫做非上下文的操作\n2. 第二种叫做上下文操作\n\nAHK 操作按照使用场景分为：\n\n1. 直接操作\n2. 选中操作\n\nAHK 按照操作目标分为\n\n1. 程序类操作\n2. 键盘类操作\n3. 文件类操作\n4. 文本类操作\n5. 命令类操作\n6. 其他操作\n\n选取一个角度对 Chorthotkey 描述 --- 按照操作目标\n\nPS：浏览器建议 chrome\n\n### 1. 程序类 -- 涉及运行程序，或者一些常用的小功能\n\n我的所有程序都是使用配置好的环境变量 D:\\Sysconfig 其中的快捷方式搞定的。比如 win+r 输入 qq 然后回车自动打开 QQ。这个并不使用 AHK。因为没有必要增加大量的热键来增加自己的记忆负担。\n但是使用频率非常高的必须设置快捷键。\n\n程序类快捷键我主要使用的是 Win 按键，AHK 中用 # 来表示\n\n```autohotkey\n #a 到有道官网查找单词翻译，并且保存到桌面上一个文本文档中。\n #b 选中某段文字进行解析，如果里面有网址则访问网址，否则使用百度进行搜索\n #g 选中某段文字进行解析，如果里面有网址则访问网址，否则使用 Google 进行搜索\n #f 打开 everything 进行搜索\n #e 替换原有的资源管理器，打开 TotalCMD\n #q 打开 QQ\n #v open with vim\n #s open with sublime text\n\n官方的操作\n\n #c Windows8 什么鸟菜单\n #x win8 快捷菜单\n #r 运行，比较方便\n #1-9 数字，建议把几个（四个之内，超过四个你的手可能就跟不上操作了）可能有变化的软件放在 pin 在 taskbar 上面。\n```\n\n### 2. 键盘鼠标操作\n\n```bash\nalt+f4 按住左键再按住右键输出\n\nCAPSLOCK 超级导航\nCAPSLOCK 输出 ESC\nSHIFT \u0026 CAPSLOCK 调用 Candy\n下面内容属于组合键的另一个按键\nhjkl 前下上右\na 行尾进行编辑\no 下一行进行编辑\n\nn ctrl+delete\nm delete\n, backspace\n. ctrl+backspace\n\n5 打开 coding workspace\n6 打开未整理文件\n7 打开 Onedirve\n8 打开同步文件夹\n9 打开娱乐文件\n0 打开 sysconfig\n```\n\n### 3. 文件类操作\n\n选中的文件夹在 TC 中打开，其余操作全部在 TC 中解决\n由于我使用了 Capslock 的导航功能，这时候的 capslock hjkl 完全可以当作左下上右使用。\nvim+tc，可以使用 vim desktop 进行超级强化。我一直对 TOTALCMD 的快捷键设计抱有不满和一丝丝的畏惧，但是这个软件把 TC 的快捷键常用快捷键精简到了令人发指的地步。\n\n\u003e I love TC plus AHK\n\n### 4. 文本类操作\n\ncandy 操作，保存，发送等等，凡是 Ctrl + c 飘落的地方，就一定会有 candy 的存在（火影忍者既视感）。请在我另一篇 Blog 中看看我是怎么使用 Candy 的。\n\n### 5. 命令类操作\n\n这里面存放的是 AHK 的命令。其实就是使用 ahk 调用 python 脚本执行之类的东西。起到一个胶水的作用。\n\n### 6. 其他操作\n\n热字符串输入其实和代码的 Snippet 比较相近。\n\n```bash\n用的特别频繁的\n//date 20150223\n/dd\n//time 08:52:33\n/tt\n//lastupdate 最后修改时间 2015-02-23 08:52:33\n/ll\n//mail twocucao@gmail.com\n/mm\n//anouncement  声明 lalalalalallalalalallalalalla\n/aa\n\n常用的\n//motto 我挥舞着纸笔和键盘，发誓要把这个世界写个明白。\n\n常用打开 Vim 的文字模板使用\n/hexo  打开 gvim，粘贴进去对应的模板。\n\n比如我输入\n//hexo\n那么就会 Copy 我之前定义的文字，然后存放在我的剪切板中。（时间是动态的）\n接着脚本打开 gvim，你要做的就是把文字粘贴进去就可以进行 HEXO 的编写了。\n\n```\n\n```python\ntitle: 标题\ndate:2015-02-23 10:16:30\ntags: 感悟\ncategory: 『生活，感悟』\n---\n\n正文\n\u003c!-- more --\u003e\n其他\n\n博客文章原创声明：\n本博文章如果没有声明为整理或者转载，均为本人原创。非商业可以任意转载分享。但是编写的代码如果没有特别声明，虽然我建议保留原作者出处，但是代码皆为 mit 协议，也就是修改了名字也算是你的版权，开源世界嘛，我就喜欢那些可以拿来直接使用的东西，贯彻最纯粹的免费自由，但是求求你，改掉名字等等信息再说是版权是你的啊。\n\n![关于本人](http://twocucao.xyz/about/),\n点击链接就可以以 web 幻灯片的方式看到我的介绍。\n\n我的 Github 地址：https://github.com/twocucao  （尽管东西不多，但是欢迎来 Star 和 Fork，就算你们来这里提前 Star Folk 了）\n简书地址：http://www.jianshu.com/users/9a7e0b9da317/latest_articles （不常更新，而且几乎没有技术文章的讲解）\n联系方式：twocucao@gmail.com\n本人才疏学浅，是一个水平比较菜的程序员，如果行文之间发现任何错误，欢迎指正，特别欢迎技术上的指正。\n```\n\n## 0x03 三剑客地址\n\n- Chorthotkey https://github.com/twocucao/ChortHotKey\n- Candy https://github.com/aamii/Candy\n- VimDesktop https://github.com/victorwoo/vimdesktop\n\n如果你想了解关于 ahk 的世界，请到这里来看：\n\n- [善用佳软的 ahk 地址](http://xbeta.info/autohotkey-guide-2.htm)\n- [A 大在知乎的系列专题](http://zhuanlan.zhihu.com/autohotkey)\n- [我的 AUTOHOTKEY 脚本使用我的脚本来上手速度会快很多）](https://github.com/twocucao/ChortHotKey)\n- [AWESOME AUTOHOTKEY_L 这里仅仅是关于 AHKL 的资源。](https://github.com/twocucao/AwesomeAutohotkeyL)\n- [AHK 论坛](http://www.ahk8.com/)\n\n- 欢迎加入 AUTOHOTKEY 的官方群 3222783 这里的大神喜欢解答有挑战性的问题，很多 AHK 的脚本都在这里。\n\n---\n\nChangeLog:\n\n- 2016-11-23 已经于 2015-12 月份转投苹果平台，从此不想念 Windows. 除了 Windows 上面的 Autohotkey / Everything / TotalCMD\n"}],"total":1},{"name":"2014-10","posts":[{"tags":["随笔","影评"],"path":"20141025_孙悟空和至尊宝.md","title":"至尊宝和孙悟空 - 『大话西游』影评","slug":"至尊宝和孙悟空 - 『大话西游』影评","date":"2014-10-25","category":"碎碎念","lastMod":"2014-10-25","description":"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore nulla facilities morbi tempus.","thumbnail":"","content":"\n# 至尊宝和孙悟空 - 『大话西游』影评\n\n有才的人往往是很有个性的，甚至个性难以驾驭，生活这么枯燥无味，天天做着同样的事情，吃饭，打怪，看着猪队友坑自己，还要听肉眼凡胎唐僧的绵延不绝的滔滔口水。\n\n这样的生活有什么意思呢？我可是当年踏碎凌霄，放肆桀骜的齐天大圣孙悟空啊！\n\n\u003c!-- more --\u003e\n\n于是，孙悟空打伤了紫霞仙子，把师傅送给牛魔王，抢走了月光宝盒。\n\n孙悟空是想逃走，想逃避这样的一份普度众生的伟大职业。众生与我何干？我只管红尘潇潇洒洒便好。\n\n那时候的孙悟空，放荡不羁爱自由，哪想着有一天会跌倒在观音和如来的手下。也不会想到，这个平时废话一大篇的唐僧居然用生命给自己换回了一个救赎的机会。\n\n可是他的命运从转生成至尊宝那一天起，就已经刻在了命运之轮上。注定逃不了的。\n\n五百年后，转世悟空至尊宝在五岳山第四边 101 号 B One 做着一份非常光辉的职业——山贼。偏偏蜘蛛精春三十娘来了，偏偏白骨精白晶晶来了，菩提老祖来了，牛魔王来了。甚至，这个时候，至尊宝以为自己爱上了那个爱上了孙猴子的白骨精。\n\n\u003e 只怪好景不长，该来的总是逃不掉。\n\n冥冥之中，一切早就按照命运之轮运行，为了拯救心上人白晶晶，至尊宝阴差阳错回到了 500 年前，却和紫霞仙子相识。为了回到五百年后，至尊宝不惜欺骗紫霞仙子，说上一段一万年的承诺。\n\n紫霞爱上了至尊宝，却落入了牛魔王的手中，至尊宝回到山洞，却意外的发现自己爱上的人是紫霞。却不是白晶晶。\n\n- 『我一定是太想念晶晶了！』\n- 『是啊，昏倒的时候叫了晶晶这个名字 98 次！』\n- 『晶晶是我娘子！』\n- 『还有一个名字叫做紫霞的你叫了 784 次，784 次.... 这个紫霞一定欠了你很多钱！』\n\n\u003e 爱情这东西总是后知后觉的，不是么？\n\n因为对白晶晶有责任感，至尊宝用月光宝盒想救白晶晶，却意外邂逅真爱紫霞。\n\n为了打败牛魔王，救回紫霞，就要成为孙悟空，但如果成为不了孙悟空，将永远失去紫霞。\n\n白晶晶和蜘蛛精再次闯进洞来，杀了至尊宝。死掉以后的至尊宝大彻大悟——为了化解人世间的仇恨，背负起该有的责任，救回紫霞，去取西经。\n\n带上紧箍圈，获得强大的力量却再也不能有人世间的半点情欲。\n\n唐僧对这孙悟空说：『你终于能够重返正途了，阿弥陀佛.』\n\n而最终，紫霞死去了。\n\n小的时候看《大话西游》的时候，可谓是单纯到只能解读笑点。\n现在看《大话西游》的时候，总是看着看着，就开始有些伤怀。其实众生依旧皆苦，剧中的至尊宝好歹是受过精神压力后戴上紧箍儿，瞬间开挂一般一夫当关万夫莫开。现实中想要去守护一些东西，还要经过漫长的修炼。\n\n『等你明白了舍生取义的道理，你自然会回来和我唱这首歌的』 唐僧仿佛看穿了一切，又仿佛和之前一样对自己认为的道理令人发指的相信。\n\n紧箍咒，圈住至尊宝昔日的梦想与爱情，圈住棱角分明的个性。至尊宝终究成为了悟空。\n\n天边的你，漂泊在云海。\n\n\u003ciframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"http://music.163.com/outchain/player?type=2\u0026id=33162226\u0026auto=1\u0026height=66\"\u003e\u003c/iframe\u003e\n\n- 月溅星河\n- 长路漫漫\n- 风烟残尽\n- 独影阑珊\n- 谁叫我身手不凡\n- 谁让我爱恨两难\n- 到后来\n- 肝肠寸断\n\n女孩问：『那个人样子好怪。』 男孩笑道：『我也看到了，他好像一条狗。』\n\n## UPDATE\n\n- 刘镇伟导演出了大话三，我觉得依旧是一个不错的番外，在我心里并不能算是续集。经典的续集总是难续的。\n\n---\n\nChangeLog:\n\n- 2014-10-25 完成初稿\n- 2016-12-03 重修文字\n"},{"tags":["编辑器"],"path":"20150227_编辑器Sublime.md","title":"Sublime Text","slug":"Sublime Text","date":"2014-10-25","category":"善用佳软","lastMod":"2014-10-25","description":"未描述","thumbnail":"","content":"\n# Sublime Text\n\n\u003e NOTE: 2021 年,已经全面转 vscode\n\n这个 Sublime 究竟好在哪里？\n\n- 方便的 Vim 模式。\n- 各种语言特性支持。\n- 强大的社区支持。插件教程，balbalbala\n- 长的好看，而且能干。\n\n## 0x01 最佳实践\n\n### 下载安装（建议便携版本）\n\nhttp://www.sublimetext.com/3\n\n### 安装 Package Control 用于管理插件\n\n步骤：view showconsole 输入下面代码\n\n```python\nimport urllib.request,os,hashlib; h = 'eb2297e1a458f27d836c04bb0cbaf282' + 'd0e7a3098092775ccb37ca9d6b2e4b7d'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)\n```\n\n重启，然后你就可以正常使用 Package Control 了\n\n## 0x02 基本使用方法之编辑功能\n\n### 命令面板\n\n^+p\n\nctrl+shift+p 打开的是命令面板\n命令面板主要内容分为四块。\n\n- 设置\n- 改变语法\n- 来自插件的命令\n\n### Go to Anything\n\n^p 打开的是切换面板\n直接输入文件名可以切换文件\n可以直接预览\n输入 @ 可以查看按照 Header 查看 (Markdown 语法）, 代码中按照函数来查找\n输入 # 可以查看变量\n\n#### 同一页面搜索\n\n^r\n\n#### 整个项目搜索\n\nctrl + shift + r\n\n#### Toggle Sidebar\n\nctrl+k Ctrl+b\n\n#### 切换面板\n\nalt + shift + 1 to 4\n\n#### 直达某行\n\nctrl+g\n\n#### 移动行\n\nctrl+shift+ 上下左右。\n\n## 0x03 结论一\n\n嘿嘿，这样看上去你基本的编辑任务都是可以比较出色完成的吧？\n好，我们依然可以看出来，这款编辑器的的确确足够日常编辑使用了，但是，还是并不代表有一定的优越性啊？\n\n你说，老师，能不能再给力一点啊？\n![](http://imgsrc.baidu.com/forum/w%3D580/sign=87eeeefcd688d43ff0a991fa4d1cd2aa/1f91e058ccbf6c81fbe76561bc3eb13532fa407e.jpg)\n\n## 0x04 深入研究其中的编辑功能\n\n把上面的一些功能进行系统性梳理。\n已经有前辈完成了，我就直接贴上他的地址了。\n\nhttp://feliving.github.io/Sublime-Text-3-Documentation/index.html\n\n## 0x05 结论二，确实强大。但是...\n\n你说，老师，能不能再给力一点啊？\n![](http://imgsrc.baidu.com/forum/w%3D580/sign=87eeeefcd688d43ff0a991fa4d1cd2aa/1f91e058ccbf6c81fbe76561bc3eb13532fa407e.jpg)\n..........................\n...........................\n..........................\n.......................\n.........................\n.........................\n\n当然可以！!\n\n## 0x06 插件，让 sublime 长出逆风飞翔的翅膀。\n\nsublime 的功能已经是比较强大了。可是还有什么地方可以优化的吗？\n加上插件，可以增强已经有的功能，可以扩展越来没有的功能。下面请看好！\n\n### 用 Vim 强化编辑功能。\n\n在编辑强化方面，Sublime 自带了一个非常好用的模式，叫做 Vintage mode\n这个模式有一点点的小问题，就是不方便，我们不妨使用另一个小插件来替换它。\n\nhttps://github.com/guillermooo/Vintageous\n\nctrl+shift+p 输入 install 输入{enter} 输入 Vintageous{Enter}\n\n安装完毕，你就可以在 Sublime 上面比较方便的使用 vim 编辑方式了。\n\n### 能不能好看一点？\n\nOf course!\n\n来来来，戳这里戳这里\n\nhttps://scotch.io/bar-talk/the-complete-visual-guide-to-sublime-text-3-themes-color-schemes-and-cool-features\n\n### 新建文件可以方便一点吗？\n\n可以，AdvancedNewFile\n你只需要 ctrl+alt+n 就可以使用这个插件。\n\n输入文件名可以直接在当前目录下新建。\n你也可以使用相对路径比如 ../ 或者 ../\\_drafts/AndroidShow\n是不是非常方便？\n\n### 侧边栏好像右键菜单好少，能不能再给力一点啊\n\n有，SidebarEnhancement\n\n### 只能补全功能不够用，能不能再给力一点啊\n\n好，SublimeCodeIntel\n\n### 我有强迫症，对齐功能不够强大，能不能再给力一点啊\n\n好，ALignment\n\n### 写注释可以方便一些，就像 Intellij IDEA 那样写注释吗？\n\n可以 Doc Blockr\n\n### 前端工程师要那些插件吗？\n\nEmmet\nHTML-CSS-JS\n等等\n\n### 我平时用 markdown 写 BLOG, 有什么比较方便的东西吗？\n\nmarkdown\n\n- extended\n- preview\n- light\n- toc\n\n## 0x07 结论三，老师真的很好用啊。但是...\n\n你说，老师，能不能再给力一点啊？\n![](http://imgsrc.baidu.com/forum/w%3D580/sign=87eeeefcd688d43ff0a991fa4d1cd2aa/1f91e058ccbf6c81fbe76561bc3eb13532fa407e.jpg)\n..........................\n...........................\n..........................\n.......................\n.........................\n..........................\n...........................\n..........................\n.......................\n.........................\n..........................\n...........................\n..........................\n.......................\n.........................\n..........................\n...........................\n..........................\n.......................\n.........................\n..........................\n...........................\n..........................\n.......................\n.........................\n\n特码的，你是来编程的还是来配置编辑器的啊！\n等你有需求了再去寻找更好的配置方案 OK?\n\n## 0xEE 其他链接\n\n这个 BLog 分享了不少关于 Sublime 的干货\n\nhttps://scotch.io/\n\n这个视频链接讲解了一些关于 Sublime 的一些小知识。\n\nhttp://www.imooc.com/learn/40\n\nsublime 非官方资源\n\nhttp://docs.sublimetext.info/en/latest/index.html\n\n---\n\nChangeLog:\n\n- **2016-12-05** 重修文字，已转投 Vim. sublime 作为非主力编辑器。\n- **2016 中期** 重修文字，声明已转投 Vim. sublime 作为非主力编辑器。\n- **2017 前期** 重修文字，声明已转投 Spacemacs.\n- **2020 后期** 重修文字，重回 Vim.\n"},{"tags":["随笔"],"path":"20141016_写在人生的边上.md","title":"写在人生的边上","slug":"写在人生的边上","date":"2014-10-16","category":"碎碎念","lastMod":"2014-10-16","description":"未描述","thumbnail":"","content":"\n# 写在人生的边上\n\n钱钟书先生有一本书叫做《写在人生的边上》。\n\n读罢，由于缺乏足够的文学涵养，记性差，并没有对这本书留下非常深刻的印象。\n\n\u003e 除了这本书的书名。\n\n当然，后来钱先生出了另一本书，叫做『人生边上的边上』, 那又是另一番意味了。\n\n古人总是在书籍的边上写下一些东西，此为批注，便好像是在书上留下了自己的痕迹。\n\n写下到此一游的风范，从古时候那孙猴子在如来的掌中留下一泡尿，到现在某些低素质游客随手乱刻乱画，可谓是一大特色，但细细想来这可能是老祖宗留下的传统。\n\n在茫茫然中度过自己的一生，就好像草草写下一本书籍，还来不及写下什么优质的内容，就已经就已经从一本书的扉页翻到了尾页。\n\n同样的剧情，同样的套路，只是人换了，而已。\n\n真的而已吗?\n\n可人总是想留下什么东西，总想向自己或者是他人证明，『我是独特的，是唯一的』。不是吗？\n\n比如在纸墨世界里留下一本书籍，或者是在比特世界里留下自己的博客。用这些文字，在一个已知的世界里，写一些已经知道的或者是不知道的世界，那多有趣。\n\n如果说人这种动物的一生仅仅用一本书就可以包容的话，那么我想，在我的故事的结尾，我可以看到我的人生的那本书，以及写在书本边上的那些批注，甚至写批注上的批注。这样，总归是让自己的一生，多了一些有趣的意义。\n\n\u003e 写东西，也是为了获得并且保持更加精确的思考。\n\n此为我写这些文字的原因，也是我重新开始写这些文字的原因。\n\n---\n\n## ChangeLog:\n\n- 2015-02-20 增加图片\n- 2016-11-23 重新润饰文字\n- 2017-03-08 增加几句新感慨\n"}],"total":3}]},"__N_SSG":true},"page":"/archive","query":{},"buildId":"uCwe9m-iio9bnoWMgWDqE","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>