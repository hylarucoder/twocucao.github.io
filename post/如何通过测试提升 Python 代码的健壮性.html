<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>如何通过测试提升 Python 代码的健壮性 | 海拉鲁编程客</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/49455a07b6dd33600cdf.css" as="style"/><link rel="stylesheet" href="/_next/static/css/49455a07b6dd33600cdf.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-a54b4f32bdc1ef890ddd.js"></script><script src="/_next/static/chunks/webpack-20d43e08bea62467b090.js" defer=""></script><script src="/_next/static/chunks/framework-0441fae7fd130f37dee1.js" defer=""></script><script src="/_next/static/chunks/main-4777350f2a9ff73ea2b0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-3050679c6e5142ffcaf5.js" defer=""></script><script src="/_next/static/chunks/ea88be26-9bcf6ead520f4ac26973.js" defer=""></script><script src="/_next/static/chunks/421-f2f33a86b546237f0325.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-173fe2de48c90365db9d.js" defer=""></script><script src="/_next/static/oDi_oBCBuu3qj6v7hDnrL/_buildManifest.js" defer=""></script><script src="/_next/static/oDi_oBCBuu3qj6v7hDnrL/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="v-page"><nav class="shadow"><div class="flex flex-col container mx-auto h-12 px-40 md:flex-row md:items-center md:justify-between"><div class="flex justify-between items-center"><div><a class="text-gray-800 text-xl md:text-xl leading-5" href="/">海拉鲁编程客</a></div><div><button type="button" class="block text-gray-800 hover:text-gray-600 focus:text-gray-600 focus:outline-none md:hidden"><svg viewBox="0 0 24 24" class="h-6 w-6 fill-current"><path d="M4 5h16a1 1 0 0 1 0 2H4a1 1 0 1 1 0-2zm0 6h16a1 1 0 0 1 0 2H4a1 1 0 0 1 0-2zm0 6h16a1 1 0 0 1 0 2H4a1 1 0 0 1 0-2z"></path></svg></button></div></div><div class="md:flex flex-col md:flex-row md:-mx-4 hidden"><a class="my-1 text-gray-800 hover:text-blue-500 md:mx-4 md:my-0" href="/">首页</a><a class="my-1 text-gray-800 hover:text-blue-500 md:mx-4 md:my-0" href="/archive">归档</a><a class="my-1 text-gray-800 hover:text-blue-500 md:mx-4 md:my-0" href="/about">关于我</a><button style="cursor:pointer;overflow:hidden;width:50px;height:23.5px;appearance:none;-moz-appearance:none;-webkit-appearance:none;border:none;background-color:transparent;padding:0" aria-hidden="true"><div style="display:flex;align-items:center;justify-content:center;margin-top:-28.749999999999996px;margin-left:-16px;width:82.5px;height:82.5px"><div></div></div></button></div></div></nav><div class="v-article"><div class="v-article-main" style="margin:auto;width:786px"><div><h2 id="0x00-前言"><a class="v-toc-item" href="#0x00-前言">#</a> 0x00 前言</h2>
<p>本文是《提升你的 Python 项目代码健壮性和性能》系列的第二篇文章。</p>
<p>本文的测试更多专注于 Python 后端的程序员。</p>
<p>在上一篇文章中，我提到了代码覆盖率，即测试的一种指标。</p>
<p>本期就聊聊测试这件小事情。</p>
<h2 id="0x01-测试的分类"><a class="v-toc-item" href="#0x01-测试的分类">#</a> 0x01 测试的分类</h2>
<p>测试有很多种，</p>
<p>按照测试设计的方法可以分为：</p>
<p>1. 黑盒<br>
2. 白盒</p>
<p>按照测试目的：</p>
<p>1. 功能测试</p>
<pre><code class="language-bash">单元测试
	功能测试
	集成测试
	场景测试
	<span class="token constant">A</span><span class="token operator">/</span><span class="token constant">B</span> 测试

<span class="token number">2.</span> 非功能测试

	压力测试
	安全性测试
	可访问性测试
</code></pre>
<p>其他</p>
<pre><code class="language-bash">回归测试
易用性测试
还有不少，懒得去整理了<span class="token operator">...</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre>
<p>代码覆盖率顾名思义，就是测试用例覆盖运行代码的比重。</p>
<h3 id="后端主要关注哪些测试"><a class="v-toc-item" href="#后端主要关注哪些测试">#</a> 后端主要关注哪些测试</h3>
<ul>
<li>单元测试</li>
<li>功能测试</li>
<li>端对端测试</li>
<li>性能测试</li>
</ul>
<h2 id="0x02-为什么要写测试"><a class="v-toc-item" href="#0x02-为什么要写测试">#</a> 0x02 为什么要写测试</h2>
<p>来讲讲测试的优点。</p>
<p>为什么要写测试来覆盖代码。</p>
<ol>
<li><strong>适当的测试可以让发布代码的时候更加有底气。</strong></li>
<li><strong>适当的测试可以让新手更快的了解代码。</strong></li>
<li><strong>适当的测试可以让程序更容易重构。</strong></li>
<li><strong>适当的测试可以加快团队的开发速度。</strong></li>
</ol>
<p>既不是不写，也不是狂写一气。看到这里你可能有些疑惑？写测试还加快速度？Are you kidding?</p>
<p>一个一个来解释吧。</p>
<p>举个简化版本的例子，『用户下单』到『用户收货』。</p>
<ol>
<li>用户『查询产品』</li>
<li>用户『使用优惠券』下单</li>
<li>用户『在线支付』。当然，用户也可以让不付款，让订单失效。或者直接取消订单。</li>
<li>商家『确认发货』。</li>
<li>物流公司更新运单『发货中』。</li>
<li>用户『确认收货』。当然，用户也可以发起退款。</li>
</ol>
<h3 id="让新手更快的了解代码"><a class="v-toc-item" href="#让新手更快的了解代码">#</a> 让新手更快的了解代码</h3>
<p>测试用例里的数据，往往是能跑通某段代码的最佳测试数据集合。</p>
<p>假如，有个程序员写了 『下单-在线支付-确认收货』的集成测试。作为刚接手这段代码的人。可以在最短的时间内，通过阅读测试代码从而理解整个流程。</p>
<p>有 fixture, 新手可以在很短的时间内知道 setup 能让项目跑起来的基本数据</p>
<p>当然，如果过多的写了测试，也会导致阅读起来比较困难。</p>
<h3 id="让发布代码的时候更加有底气"><a class="v-toc-item" href="#让发布代码的时候更加有底气">#</a> 让发布代码的时候更加有底气</h3>
<p>写测试，是为了验证代码运行正确。</p>
<p>一个流程，通常包含若干个子流程，子流程是对的，整个流程才是对的。</p>
<p>如果不写测试对一些关键的流程进行全面的覆盖，则会导致</p>
<ol>
<li>修改或者新增了一个子流程，需要重新跑个流程进行人肉测试。</li>
<li>如果人肉测试太费事，则一般程序员就会跳过这个步骤导致线上出问题。</li>
</ol>
<h3 id="让程序更容易重构"><a class="v-toc-item" href="#让程序更容易重构">#</a> 让程序更容易重构</h3>
<p>当你知道写测试代码有这么多优点的之后，你的第一反应是，这我都知道，但是，写测试还能加快开发速度？</p>
<blockquote>
<p>当然，你要知道，一个需要去维护的有价值的产品，往往需要不断的修改流程。</p>
</blockquote>
<p>一开始，PM 告诉你只需要下单买个东西，后来，要加上满减券，再后来要加上各种类型的券，然后你要对接第三方服务，接下来你要对付各种不按照你设定的流程出牌的用户…</p>
<p>写测试，则是通过不断的补充一些测试，实现整个流程的测试自动化。形成一套测试该项目的测试代码。流程长的令人发指，你指望全靠人肉来测试？</p>
<ol>
<li>当我修改或者新增子流程的时候，在已经构建出来的测试代码上，可以花少量的代码直接保证修改或者新增的子流程输入和输出被测试到位。</li>
<li>多人合作的时候，如果 A 原先维护了一套子流程，而 B 来改了一波 A 写的子流程。在有适当的测试的情况下，基本上改出问题来，都会跑不过测试的。</li>
</ol>
<p>当然，前提是</p>
<ol>
<li>A 用心写了测试，而不是写了仅仅能让 A 的代码跑的过去的测试。</li>
<li>是测试如果写过多的话，也会造成团队精力的分散。这下面谈到测试的缺点的时候就会知道。</li>
</ol>
<h3 id="加快团队的开发速度"><a class="v-toc-item" href="#加快团队的开发速度">#</a> 加快团队的开发速度</h3>
<p>虽然说，我写的是加快团队的开发速度，但实际上，也适用于个人。</p>
<blockquote>
<p><strong>除非，你是写渲染页面的… 所见即所得。无需任何测试</strong></p>
</blockquote>
<h2 id="0x03-为什么不要写测试"><a class="v-toc-item" href="#0x03-为什么不要写测试">#</a> 0x03 为什么不要写测试</h2>
<p>依照软件界著名的『没有银弹』理论，说完了测试的优越性，也要来说说测试的局限性，主要有三点：</p>
<ol>
<li><strong>测试不能解决什么问题？</strong></li>
<li><strong>不适当的测试，往往是负担。</strong></li>
<li><strong>并不是所有地方都容易测试的。</strong></li>
</ol>
<h3 id="测试不能解决的问题"><a class="v-toc-item" href="#测试不能解决的问题">#</a> 测试不能解决的问题</h3>
<blockquote>
<p>测试能确保代码的运行质量，但无法确保代码编写质量，也无法保证产品设计逻辑上的问题。</p>
</blockquote>
<p>也就是说</p>
<ol>
<li><strong>代码写的烂，测试代码只能确保编写代码是可以正常运行的。并不能改善代码质量。最多给烂代码的重构提供比较好的运行保证。</strong></li>
<li><strong>产品设计逻辑上的问题，测试代码也只能保证这个设计逻辑落地。</strong></li>
</ol>
<blockquote>
<p>当你觉得测试代码写起来比较难受的时候，你应该考虑重构一下你的程序了。</p>
</blockquote>
<h3 id="不适当的测试为什么是负担"><a class="v-toc-item" href="#不适当的测试为什么是负担">#</a> 不适当的测试为什么是负担</h3>
<p>人总要习惯的是：</p>
<ol>
<li>东西，学，是学不完的。未知的东西永远存在。新的事物总是在出现，老的事物也不断在演进。</li>
<li>时间有限，精力有限</li>
</ol>
<blockquote>
<p><strong>放到测试上来说，测试，也是测不完的。</strong></p>
</blockquote>
<p>写了一个 IF ELSE , 你需要测两组，多写了一个 IF ELSE, 你就要测四组。如果是一个比较复杂的流程的话，基本上全面测试就很难写完了。</p>
<p><strong>我的想法是：</strong></p>
<ol>
<li><strong>挑选关键的地方进行测试</strong></li>
<li><strong>减少用户不必要的数据获取</strong></li>
</ol>
<h3 id="并不是所有地方都容易测试的"><a class="v-toc-item" href="#并不是所有地方都容易测试的">#</a> 并不是所有地方都容易测试的</h3>
<p>并不是所有地方都容易测试的。</p>
<ol>
<li>特别依赖其他服务商的业务。比如，支付宝 / 微信的预支付。微信小程序的登陆。</li>
<li>跨端的业务。</li>
</ol>
<p>这类业务如果做的比较深入，需要 Mock 掉很多逻辑。</p>
<h2 id="0x04-写-python-测试的一些注意事项"><a class="v-toc-item" href="#0x04-写-python-测试的一些注意事项">#</a> 0x04 写 Python 测试的一些注意事项</h2>
<h3 id="项目的环境隔离"><a class="v-toc-item" href="#项目的环境隔离">#</a> 项目的环境隔离</h3>
<p>从整体项目角度，代码的运行环境应该区分 Local/Test/Stage/Prod 四种环境。</p>
<ul>
<li>本地环境：开发者电脑上的环境</li>
<li>测试环境：开发者电脑上 / 持续集成上的环境，之前比较喜欢用 GitlabCI, 后来 团队上了 jenkins, 用起来也还行。</li>
<li>预发布环境：预发布环境，对后端来说，通常情况下就是前端可以通过调用 API 的环境。</li>
<li>生产环境：生产环境。</li>
</ul>
<p>之所以要做这种区分，是因为不同的环境侧重点不同。</p>
<ul>
<li>Local 环境 针对开发者设置的，这个环境的代码变更比较频繁。Web 应用 / Worker / Beat / Deamon 在本地环境中，一般报错比较多，一般我会在禁掉日志。</li>
<li>Test 环境 用于执行 make lint &amp;&amp; make test，用于检查 lint 相关代码并运行测试。</li>
<li>Stage 环境</li>
<li>Prod 环境 和 Stage 环境就比较接近了。但也不完全一致。比如生产环境的组织或商家的一些开发资料。</li>
</ul>
<h3 id="测试的基本环境"><a class="v-toc-item" href="#测试的基本环境">#</a> 测试的基本环境</h3>
<p>一般起一个 Docker-Compose 文件，来快速初始化测试环境。</p>
<p>比如 WebApp / Celery Worker / Celery Beats / Redis / RabbitMQ / MySQL 可以 make start 直接起这些服务。</p>
<h3 id="单测-功测-端对端"><a class="v-toc-item" href="#单测-功测-端对端">#</a> 单测 / 功测 / 端对端</h3>
<p>之前说，后端需要注意下面的测试</p>
<ul>
<li><strong>单元测试</strong></li>
<li><strong>功能测试</strong></li>
<li><strong>端对端测试</strong></li>
<li>性能测试</li>
</ul>
<blockquote>
<p>性能测试一般可以通过监控来提前对系统在哪些地方有瓶颈。看场景，一般观察监控会更加容易预测系统的瓶颈，这个更多偏向于调优，放到后面来说吧。</p>
</blockquote>
<p>框架假设我们使用 Flask , 再假设有这么一个 BBS（我知道你想吐槽为什么又拿博客 /BBS 举例子，懒得交代过多的业务场景背景知识了，逃…）</p>
<ol>
<li><strong>组织 Organization 发布了一个 Thread</strong></li>
<li><strong>用户 User 在这个 Thread 进行了 Reply 『未注册的用户能看见』</strong></li>
<li><strong>管理员 Admin 发现了 User 似乎发布了不该发布的信息。删 Reply。『未注册的用户看不见 / 所有者是能看见的』</strong></li>
<li><strong>最后 User 进行申诉，Admin 发现其实发布的东西挺 OK 的，给予通过。『未注册的用户能看见』</strong></li>
</ol>
<pre><code class="language-bash">tests # 测试文件目录
├── __init__<span class="token punctuation">.</span>py
├── conftest<span class="token punctuation">.</span>py # 这里存放可能被子目录引用到的集合
├── e2e # 『端对端测试』
│   ├── __init__<span class="token punctuation">.</span>py
│   ├── test_viewer<span class="token punctuation">.</span>py
│   ├── test_user<span class="token punctuation">.</span>py
│   ├── test_admin<span class="token punctuation">.</span>py
│   └── test_organization<span class="token punctuation">.</span>py
├── functional # 『功能测试』
│   ├── __init__<span class="token punctuation">.</span>py
│   ├── test_do_simple_reply<span class="token punctuation">.</span>py
│   ├── test_do_complex_reply<span class="token punctuation">.</span>py
│   └── test_helper<span class="token punctuation">.</span>py
├── unit # 『单元测试』
<span class="token operator">|</span>   ├── __init__<span class="token punctuation">.</span>py
<span class="token operator">|</span>   ├── test_auth<span class="token punctuation">.</span>py
<span class="token operator">|</span>   └── test_calc_some_thing<span class="token punctuation">.</span>py
├── test_auth_helper<span class="token punctuation">.</span>py # 存放基本的用于切换身份的代码
├── test_const<span class="token punctuation">.</span>py
└── test_factory_helper<span class="token punctuation">.</span>py # 可以用来批量初始化数据
</code></pre>
<p>这个流程并不算复杂，但足以写测试了。</p>
<ol>
<li><strong>在 test_factory_helper 完成数据的基本初始化。</strong></li>
<li><strong>在端对端测试中简单测试浏览。包含未注册用户 viewer 的访问，user/admin/org 的带有效 / 无效 / 过期登陆凭据访问</strong></li>
<li><strong>在 unit 中测试一些和业务联系不紧密的逻辑。比如，计算时间</strong></li>
<li><strong>在 functional 进行比较独立的测试。有的时候也会把几个功能拉起来做测试。相对独立的测试，就是新建一个 User 的 Thread, 删除 Reply, 拉起来测试就是 1/2/3/4 一个测试就完了。</strong></li>
</ol>
<p>前者比较简单，后者相对而言更加靠近集成测试。各有利弊。我一般在关键流程上多做几个拉起来测试的代码。</p>
<p>但拉起来测试要解决的问题就多了一个，即，用户登陆认证。你调用某个 Service 的时候，是以匿名用户 / 用户身份 / Admin / Org 调用的。</p>
<p>即在调用不同的 Service 解决问题的时候，你可能需要快速的切换身份。切换完身份再速<br>
度切换回来。于是，test auth helper 出来了。helper 里面有个 switch as 函数，每次需<br>
要切换身份的时候，把 g 变量里面的登陆快照 g.user g.admin <a href="https://link.zhihu.com/?target=http%3A//g.org">http://g.org</a> push 到 LocalStack 栈里 (from werkzeug.local import LocalStack), 调用完 Service 再 Pop 出来。</p>
<p>拉起来测试的效果是这样子的。</p>
<pre><code class="language-python">def <span class="token function">test_complex_process</span><span class="token punctuation">(</span>org<span class="token punctuation">,</span> user<span class="token punctuation">,</span> admin<span class="token punctuation">)</span><span class="token operator">:</span>
	<span class="token keyword">with</span> <span class="token function">switch_as_org</span><span class="token punctuation">(</span>org<span class="token punctuation">)</span> <span class="token keyword">as</span> org<span class="token operator">:</span>		# <span class="token number">1.</span> 组织 Organization 发布了一个 Thread
		thread <span class="token operator">=</span> <span class="token function">publish_thread_by_org</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token keyword">with</span> <span class="token function">switch_as_user</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span> <span class="token keyword">as</span> user<span class="token operator">:</span> # <span class="token number">2.</span> 用户 User 在这个 Thread 进行了 Reply
			reply <span class="token operator">=</span> <span class="token function">reply_thread</span><span class="token punctuation">(</span>thread<span class="token punctuation">)</span>
			assert reply
			<span class="token keyword">with</span> <span class="token function">switch_as_anonymous</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> anonymous_user<span class="token operator">:</span>
				_thread <span class="token operator">=</span> <span class="token function">see_thread</span><span class="token punctuation">(</span>thread<span class="token punctuation">)</span>
				assert reply <span class="token keyword">in</span> _thread<span class="token punctuation">.</span>replies # 『未注册的用户能看见』
			<span class="token keyword">with</span> <span class="token function">switch_as_admin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> admin<span class="token operator">:</span> # <span class="token number">3.</span> 管理员 Admin 发现了 User 似乎发布了不该发布的信息。删 Reply。
				<span class="token function">delete_reply</span><span class="token punctuation">(</span>reply<span class="token punctuation">)</span>
				assert reply<span class="token punctuation">.</span>deleled
			<span class="token keyword">with</span> <span class="token function">switch_as_anonymous</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> anonymous_user<span class="token operator">:</span>『未注册的用户看不见』
				_thread <span class="token operator">=</span> <span class="token function">see_thread</span><span class="token punctuation">(</span>thread<span class="token punctuation">)</span>
				assert reply not <span class="token keyword">in</span> _thread<span class="token punctuation">.</span>replies
			# 在这里，我的身份还是 user
			_thread <span class="token operator">=</span> <span class="token function">see_thread</span><span class="token punctuation">(</span>thread<span class="token punctuation">)</span>
			assert reply <span class="token keyword">in</span> _thread<span class="token punctuation">.</span>replies # 『Ower 用户能看见』
		# <span class="token number">4.</span> 最后 User 进行申诉，Admin 发现其实发布的东西挺 <span class="token constant">OK</span> 的，给予通过。『未注册的用户能看见』
</code></pre>
<p>作为开发者，你只需要让这个测试跑通就基本开发完毕了。在这个过程中，你也可以更好的梳理你的代码。</p>
<h3 id="如何处理外部服务"><a class="v-toc-item" href="#如何处理外部服务">#</a> 如何处理外部服务</h3>
<p>在拉起来做测试的时候，假如我们多了一个流程，用户可以通过微信支付赞赏 reply, 这就不得不依赖于外部的服务。</p>
<p>而拉起来做测试的时候，就会遇到一个非常尴尬的问题，因为我上面的接口都粒度都比较大，是赞赏这个流程里面的非常小的流程，必须要走微信的 http 请求。</p>
<p>解决方式也很简单。 mock 掉请求微信的函数。手动调用一下支付回调函数，即可。</p>
<p>当然，对于 http 请求，也可以使用 <strong>responses</strong> 这个神器来快速 mock 神器 requests 的 response</p>
<p>大致的用法如下</p>
<pre><code class="language-python">def <span class="token function">mock_success_pay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span>
    def <span class="token function">request_callback</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token operator">:</span>
        headers <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token function">dispatch_callback</span><span class="token punctuation">(</span>data<span class="token operator">=</span>data<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">200</span><span class="token punctuation">,</span> headers<span class="token punctuation">,</span> resp_body

    responses<span class="token punctuation">.</span><span class="token function">add_callback</span><span class="token punctuation">(</span>
        responses<span class="token punctuation">.</span><span class="token constant">POST</span><span class="token punctuation">,</span>
        <span class="token constant">PAY_URL</span><span class="token punctuation">,</span>
        callback<span class="token operator">=</span>request_callback<span class="token punctuation">,</span>
        content_type<span class="token operator">=</span><span class="token string">"application/json"</span><span class="token punctuation">,</span>
    <span class="token punctuation">)</span>

@responses<span class="token punctuation">.</span>activate
def <span class="token function">test_pay</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token operator">:</span>
    <span class="token function">mock_success_pay</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token function">switch_as_user</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span> <span class="token keyword">as</span> u<span class="token operator">:</span>
			order <span class="token operator">=</span> <span class="token function">pay_order</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span>
		assert order<span class="token punctuation">.</span>status <span class="token operator">==</span> <span class="token string">"PAID"</span>
</code></pre>
<h3 id="其他-pytest-小技巧"><a class="v-toc-item" href="#其他-pytest-小技巧">#</a> 其他 Pytest 小技巧</h3>
<p>有的时候 ipdb 比 pdb 用起来不止好了一点点。如何在 pytest 里用上呢？</p>
<pre><code class="language-bash">pytest <span class="token operator">-</span>v <span class="token operator">--</span>pdb <span class="token operator">--</span>pdbcls<span class="token operator">=</span>IPython<span class="token punctuation">.</span>terminal<span class="token punctuation">.</span>debugger<span class="token operator">:</span>Pdb
</code></pre>
<h2 id="0xee-参考"><a class="v-toc-item" href="#0xee-参考">#</a> 0xEE 参考</h2>
<ul>
<li><a href="https://www.zhihu.com/question/21017354/answer/589574939">https://www.zhihu.com/question/21017354/answer/589574939</a></li>
<li><a href="https://www.zhihu.com/question/312395573/answer/604772703">https://www.zhihu.com/question/312395573/answer/604772703</a></li>
</ul>
</div></div><div><ul class="v-article-toc">
<li>
<ul>
<li><a href="#0x00-%E5%89%8D%E8%A8%80">0x00 前言</a></li>
<li><a href="#0x01-%E6%B5%8B%E8%AF%95%E7%9A%84%E5%88%86%E7%B1%BB">0x01 测试的分类</a>
<ul>
<li><a href="#%E5%90%8E%E7%AB%AF%E4%B8%BB%E8%A6%81%E5%85%B3%E6%B3%A8%E5%93%AA%E4%BA%9B%E6%B5%8B%E8%AF%95">后端主要关注哪些测试</a></li>
</ul>
</li>
<li><a href="#0x02-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E6%B5%8B%E8%AF%95">0x02 为什么要写测试</a>
<ul>
<li><a href="#%E8%AE%A9%E6%96%B0%E6%89%8B%E6%9B%B4%E5%BF%AB%E7%9A%84%E4%BA%86%E8%A7%A3%E4%BB%A3%E7%A0%81">让新手更快的了解代码</a></li>
<li><a href="#%E8%AE%A9%E5%8F%91%E5%B8%83%E4%BB%A3%E7%A0%81%E7%9A%84%E6%97%B6%E5%80%99%E6%9B%B4%E5%8A%A0%E6%9C%89%E5%BA%95%E6%B0%94">让发布代码的时候更加有底气</a></li>
<li><a href="#%E8%AE%A9%E7%A8%8B%E5%BA%8F%E6%9B%B4%E5%AE%B9%E6%98%93%E9%87%8D%E6%9E%84">让程序更容易重构</a></li>
<li><a href="#%E5%8A%A0%E5%BF%AB%E5%9B%A2%E9%98%9F%E7%9A%84%E5%BC%80%E5%8F%91%E9%80%9F%E5%BA%A6">加快团队的开发速度</a></li>
</ul>
</li>
<li><a href="#0x03-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%A6%81%E5%86%99%E6%B5%8B%E8%AF%95">0x03 为什么不要写测试</a>
<ul>
<li><a href="#%E6%B5%8B%E8%AF%95%E4%B8%8D%E8%83%BD%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98">测试不能解决的问题</a></li>
<li><a href="#%E4%B8%8D%E9%80%82%E5%BD%93%E7%9A%84%E6%B5%8B%E8%AF%95%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E8%B4%9F%E6%8B%85">不适当的测试为什么是负担</a></li>
<li><a href="#%E5%B9%B6%E4%B8%8D%E6%98%AF%E6%89%80%E6%9C%89%E5%9C%B0%E6%96%B9%E9%83%BD%E5%AE%B9%E6%98%93%E6%B5%8B%E8%AF%95%E7%9A%84">并不是所有地方都容易测试的</a></li>
</ul>
</li>
<li><a href="#0x04-%E5%86%99-python-%E6%B5%8B%E8%AF%95%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">0x04 写 Python 测试的一些注意事项</a>
<ul>
<li><a href="#%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%8E%AF%E5%A2%83%E9%9A%94%E7%A6%BB">项目的环境隔离</a></li>
<li><a href="#%E6%B5%8B%E8%AF%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83">测试的基本环境</a></li>
<li><a href="#%E5%8D%95%E6%B5%8B-%E5%8A%9F%E6%B5%8B-%E7%AB%AF%E5%AF%B9%E7%AB%AF">单测 / 功测 / 端对端</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%A4%96%E9%83%A8%E6%9C%8D%E5%8A%A1">如何处理外部服务</a></li>
<li><a href="#%E5%85%B6%E4%BB%96-pytest-%E5%B0%8F%E6%8A%80%E5%B7%A7">其他 Pytest 小技巧</a></li>
</ul>
</li>
<li><a href="#0xee-%E5%8F%82%E8%80%83">0xEE 参考</a></li>
</ul>
</li>
</ul>
</div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"tags":["Python","系列文章"],"path":"20190216_PyCode_02.md","title":"如何通过测试提升 Python 代码的健壮性","slug":"如何通过测试提升 Python 代码的健壮性","date":"2019-03-23","category":"Python 项目代码健壮性和性能","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\u003ch2 id=\"0x00-前言\"\u003e\u003ca class=\"v-toc-item\" href=\"#0x00-前言\"\u003e#\u003c/a\u003e 0x00 前言\u003c/h2\u003e\n\u003cp\u003e本文是《提升你的 Python 项目代码健壮性和性能》系列的第二篇文章。\u003c/p\u003e\n\u003cp\u003e本文的测试更多专注于 Python 后端的程序员。\u003c/p\u003e\n\u003cp\u003e在上一篇文章中，我提到了代码覆盖率，即测试的一种指标。\u003c/p\u003e\n\u003cp\u003e本期就聊聊测试这件小事情。\u003c/p\u003e\n\u003ch2 id=\"0x01-测试的分类\"\u003e\u003ca class=\"v-toc-item\" href=\"#0x01-测试的分类\"\u003e#\u003c/a\u003e 0x01 测试的分类\u003c/h2\u003e\n\u003cp\u003e测试有很多种，\u003c/p\u003e\n\u003cp\u003e按照测试设计的方法可以分为：\u003c/p\u003e\n\u003cp\u003e1. 黑盒\u003cbr\u003e\n2. 白盒\u003c/p\u003e\n\u003cp\u003e按照测试目的：\u003c/p\u003e\n\u003cp\u003e1. 功能测试\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e单元测试\n\t功能测试\n\t集成测试\n\t场景测试\n\t\u003cspan class=\"token constant\"\u003eA\u003c/span\u003e\u003cspan class=\"token operator\"\u003e/\u003c/span\u003e\u003cspan class=\"token constant\"\u003eB\u003c/span\u003e 测试\n\n\u003cspan class=\"token number\"\u003e2.\u003c/span\u003e 非功能测试\n\n\t压力测试\n\t安全性测试\n\t可访问性测试\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e其他\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e回归测试\n易用性测试\n还有不少，懒得去整理了\u003cspan class=\"token operator\"\u003e...\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e代码覆盖率顾名思义，就是测试用例覆盖运行代码的比重。\u003c/p\u003e\n\u003ch3 id=\"后端主要关注哪些测试\"\u003e\u003ca class=\"v-toc-item\" href=\"#后端主要关注哪些测试\"\u003e#\u003c/a\u003e 后端主要关注哪些测试\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e单元测试\u003c/li\u003e\n\u003cli\u003e功能测试\u003c/li\u003e\n\u003cli\u003e端对端测试\u003c/li\u003e\n\u003cli\u003e性能测试\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"0x02-为什么要写测试\"\u003e\u003ca class=\"v-toc-item\" href=\"#0x02-为什么要写测试\"\u003e#\u003c/a\u003e 0x02 为什么要写测试\u003c/h2\u003e\n\u003cp\u003e来讲讲测试的优点。\u003c/p\u003e\n\u003cp\u003e为什么要写测试来覆盖代码。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e适当的测试可以让发布代码的时候更加有底气。\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e适当的测试可以让新手更快的了解代码。\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e适当的测试可以让程序更容易重构。\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e适当的测试可以加快团队的开发速度。\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e既不是不写，也不是狂写一气。看到这里你可能有些疑惑？写测试还加快速度？Are you kidding?\u003c/p\u003e\n\u003cp\u003e一个一个来解释吧。\u003c/p\u003e\n\u003cp\u003e举个简化版本的例子，『用户下单』到『用户收货』。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e用户『查询产品』\u003c/li\u003e\n\u003cli\u003e用户『使用优惠券』下单\u003c/li\u003e\n\u003cli\u003e用户『在线支付』。当然，用户也可以让不付款，让订单失效。或者直接取消订单。\u003c/li\u003e\n\u003cli\u003e商家『确认发货』。\u003c/li\u003e\n\u003cli\u003e物流公司更新运单『发货中』。\u003c/li\u003e\n\u003cli\u003e用户『确认收货』。当然，用户也可以发起退款。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"让新手更快的了解代码\"\u003e\u003ca class=\"v-toc-item\" href=\"#让新手更快的了解代码\"\u003e#\u003c/a\u003e 让新手更快的了解代码\u003c/h3\u003e\n\u003cp\u003e测试用例里的数据，往往是能跑通某段代码的最佳测试数据集合。\u003c/p\u003e\n\u003cp\u003e假如，有个程序员写了 『下单-在线支付-确认收货』的集成测试。作为刚接手这段代码的人。可以在最短的时间内，通过阅读测试代码从而理解整个流程。\u003c/p\u003e\n\u003cp\u003e有 fixture, 新手可以在很短的时间内知道 setup 能让项目跑起来的基本数据\u003c/p\u003e\n\u003cp\u003e当然，如果过多的写了测试，也会导致阅读起来比较困难。\u003c/p\u003e\n\u003ch3 id=\"让发布代码的时候更加有底气\"\u003e\u003ca class=\"v-toc-item\" href=\"#让发布代码的时候更加有底气\"\u003e#\u003c/a\u003e 让发布代码的时候更加有底气\u003c/h3\u003e\n\u003cp\u003e写测试，是为了验证代码运行正确。\u003c/p\u003e\n\u003cp\u003e一个流程，通常包含若干个子流程，子流程是对的，整个流程才是对的。\u003c/p\u003e\n\u003cp\u003e如果不写测试对一些关键的流程进行全面的覆盖，则会导致\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e修改或者新增了一个子流程，需要重新跑个流程进行人肉测试。\u003c/li\u003e\n\u003cli\u003e如果人肉测试太费事，则一般程序员就会跳过这个步骤导致线上出问题。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"让程序更容易重构\"\u003e\u003ca class=\"v-toc-item\" href=\"#让程序更容易重构\"\u003e#\u003c/a\u003e 让程序更容易重构\u003c/h3\u003e\n\u003cp\u003e当你知道写测试代码有这么多优点的之后，你的第一反应是，这我都知道，但是，写测试还能加快开发速度？\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e当然，你要知道，一个需要去维护的有价值的产品，往往需要不断的修改流程。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e一开始，PM 告诉你只需要下单买个东西，后来，要加上满减券，再后来要加上各种类型的券，然后你要对接第三方服务，接下来你要对付各种不按照你设定的流程出牌的用户…\u003c/p\u003e\n\u003cp\u003e写测试，则是通过不断的补充一些测试，实现整个流程的测试自动化。形成一套测试该项目的测试代码。流程长的令人发指，你指望全靠人肉来测试？\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e当我修改或者新增子流程的时候，在已经构建出来的测试代码上，可以花少量的代码直接保证修改或者新增的子流程输入和输出被测试到位。\u003c/li\u003e\n\u003cli\u003e多人合作的时候，如果 A 原先维护了一套子流程，而 B 来改了一波 A 写的子流程。在有适当的测试的情况下，基本上改出问题来，都会跑不过测试的。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e当然，前提是\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eA 用心写了测试，而不是写了仅仅能让 A 的代码跑的过去的测试。\u003c/li\u003e\n\u003cli\u003e是测试如果写过多的话，也会造成团队精力的分散。这下面谈到测试的缺点的时候就会知道。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"加快团队的开发速度\"\u003e\u003ca class=\"v-toc-item\" href=\"#加快团队的开发速度\"\u003e#\u003c/a\u003e 加快团队的开发速度\u003c/h3\u003e\n\u003cp\u003e虽然说，我写的是加快团队的开发速度，但实际上，也适用于个人。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e除非，你是写渲染页面的… 所见即所得。无需任何测试\u003c/strong\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"0x03-为什么不要写测试\"\u003e\u003ca class=\"v-toc-item\" href=\"#0x03-为什么不要写测试\"\u003e#\u003c/a\u003e 0x03 为什么不要写测试\u003c/h2\u003e\n\u003cp\u003e依照软件界著名的『没有银弹』理论，说完了测试的优越性，也要来说说测试的局限性，主要有三点：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e测试不能解决什么问题？\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e不适当的测试，往往是负担。\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e并不是所有地方都容易测试的。\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"测试不能解决的问题\"\u003e\u003ca class=\"v-toc-item\" href=\"#测试不能解决的问题\"\u003e#\u003c/a\u003e 测试不能解决的问题\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e测试能确保代码的运行质量，但无法确保代码编写质量，也无法保证产品设计逻辑上的问题。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e也就是说\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e代码写的烂，测试代码只能确保编写代码是可以正常运行的。并不能改善代码质量。最多给烂代码的重构提供比较好的运行保证。\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e产品设计逻辑上的问题，测试代码也只能保证这个设计逻辑落地。\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cblockquote\u003e\n\u003cp\u003e当你觉得测试代码写起来比较难受的时候，你应该考虑重构一下你的程序了。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"不适当的测试为什么是负担\"\u003e\u003ca class=\"v-toc-item\" href=\"#不适当的测试为什么是负担\"\u003e#\u003c/a\u003e 不适当的测试为什么是负担\u003c/h3\u003e\n\u003cp\u003e人总要习惯的是：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e东西，学，是学不完的。未知的东西永远存在。新的事物总是在出现，老的事物也不断在演进。\u003c/li\u003e\n\u003cli\u003e时间有限，精力有限\u003c/li\u003e\n\u003c/ol\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e放到测试上来说，测试，也是测不完的。\u003c/strong\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e写了一个 IF ELSE , 你需要测两组，多写了一个 IF ELSE, 你就要测四组。如果是一个比较复杂的流程的话，基本上全面测试就很难写完了。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e我的想法是：\u003c/strong\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e挑选关键的地方进行测试\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e减少用户不必要的数据获取\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"并不是所有地方都容易测试的\"\u003e\u003ca class=\"v-toc-item\" href=\"#并不是所有地方都容易测试的\"\u003e#\u003c/a\u003e 并不是所有地方都容易测试的\u003c/h3\u003e\n\u003cp\u003e并不是所有地方都容易测试的。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e特别依赖其他服务商的业务。比如，支付宝 / 微信的预支付。微信小程序的登陆。\u003c/li\u003e\n\u003cli\u003e跨端的业务。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e这类业务如果做的比较深入，需要 Mock 掉很多逻辑。\u003c/p\u003e\n\u003ch2 id=\"0x04-写-python-测试的一些注意事项\"\u003e\u003ca class=\"v-toc-item\" href=\"#0x04-写-python-测试的一些注意事项\"\u003e#\u003c/a\u003e 0x04 写 Python 测试的一些注意事项\u003c/h2\u003e\n\u003ch3 id=\"项目的环境隔离\"\u003e\u003ca class=\"v-toc-item\" href=\"#项目的环境隔离\"\u003e#\u003c/a\u003e 项目的环境隔离\u003c/h3\u003e\n\u003cp\u003e从整体项目角度，代码的运行环境应该区分 Local/Test/Stage/Prod 四种环境。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e本地环境：开发者电脑上的环境\u003c/li\u003e\n\u003cli\u003e测试环境：开发者电脑上 / 持续集成上的环境，之前比较喜欢用 GitlabCI, 后来 团队上了 jenkins, 用起来也还行。\u003c/li\u003e\n\u003cli\u003e预发布环境：预发布环境，对后端来说，通常情况下就是前端可以通过调用 API 的环境。\u003c/li\u003e\n\u003cli\u003e生产环境：生产环境。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e之所以要做这种区分，是因为不同的环境侧重点不同。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eLocal 环境 针对开发者设置的，这个环境的代码变更比较频繁。Web 应用 / Worker / Beat / Deamon 在本地环境中，一般报错比较多，一般我会在禁掉日志。\u003c/li\u003e\n\u003cli\u003eTest 环境 用于执行 make lint \u0026amp;\u0026amp; make test，用于检查 lint 相关代码并运行测试。\u003c/li\u003e\n\u003cli\u003eStage 环境\u003c/li\u003e\n\u003cli\u003eProd 环境 和 Stage 环境就比较接近了。但也不完全一致。比如生产环境的组织或商家的一些开发资料。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"测试的基本环境\"\u003e\u003ca class=\"v-toc-item\" href=\"#测试的基本环境\"\u003e#\u003c/a\u003e 测试的基本环境\u003c/h3\u003e\n\u003cp\u003e一般起一个 Docker-Compose 文件，来快速初始化测试环境。\u003c/p\u003e\n\u003cp\u003e比如 WebApp / Celery Worker / Celery Beats / Redis / RabbitMQ / MySQL 可以 make start 直接起这些服务。\u003c/p\u003e\n\u003ch3 id=\"单测-功测-端对端\"\u003e\u003ca class=\"v-toc-item\" href=\"#单测-功测-端对端\"\u003e#\u003c/a\u003e 单测 / 功测 / 端对端\u003c/h3\u003e\n\u003cp\u003e之前说，后端需要注意下面的测试\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e单元测试\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e功能测试\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e端对端测试\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e性能测试\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e性能测试一般可以通过监控来提前对系统在哪些地方有瓶颈。看场景，一般观察监控会更加容易预测系统的瓶颈，这个更多偏向于调优，放到后面来说吧。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e框架假设我们使用 Flask , 再假设有这么一个 BBS（我知道你想吐槽为什么又拿博客 /BBS 举例子，懒得交代过多的业务场景背景知识了，逃…）\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e组织 Organization 发布了一个 Thread\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e用户 User 在这个 Thread 进行了 Reply 『未注册的用户能看见』\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e管理员 Admin 发现了 User 似乎发布了不该发布的信息。删 Reply。『未注册的用户看不见 / 所有者是能看见的』\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e最后 User 进行申诉，Admin 发现其实发布的东西挺 OK 的，给予通过。『未注册的用户能看见』\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003etests # 测试文件目录\n├── __init__\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003epy\n├── conftest\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003epy # 这里存放可能被子目录引用到的集合\n├── e2e # 『端对端测试』\n│   ├── __init__\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003epy\n│   ├── test_viewer\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003epy\n│   ├── test_user\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003epy\n│   ├── test_admin\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003epy\n│   └── test_organization\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003epy\n├── functional # 『功能测试』\n│   ├── __init__\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003epy\n│   ├── test_do_simple_reply\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003epy\n│   ├── test_do_complex_reply\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003epy\n│   └── test_helper\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003epy\n├── unit # 『单元测试』\n\u003cspan class=\"token operator\"\u003e|\u003c/span\u003e   ├── __init__\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003epy\n\u003cspan class=\"token operator\"\u003e|\u003c/span\u003e   ├── test_auth\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003epy\n\u003cspan class=\"token operator\"\u003e|\u003c/span\u003e   └── test_calc_some_thing\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003epy\n├── test_auth_helper\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003epy # 存放基本的用于切换身份的代码\n├── test_const\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003epy\n└── test_factory_helper\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003epy # 可以用来批量初始化数据\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这个流程并不算复杂，但足以写测试了。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e在 test_factory_helper 完成数据的基本初始化。\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e在端对端测试中简单测试浏览。包含未注册用户 viewer 的访问，user/admin/org 的带有效 / 无效 / 过期登陆凭据访问\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e在 unit 中测试一些和业务联系不紧密的逻辑。比如，计算时间\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e在 functional 进行比较独立的测试。有的时候也会把几个功能拉起来做测试。相对独立的测试，就是新建一个 User 的 Thread, 删除 Reply, 拉起来测试就是 1/2/3/4 一个测试就完了。\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e前者比较简单，后者相对而言更加靠近集成测试。各有利弊。我一般在关键流程上多做几个拉起来测试的代码。\u003c/p\u003e\n\u003cp\u003e但拉起来测试要解决的问题就多了一个，即，用户登陆认证。你调用某个 Service 的时候，是以匿名用户 / 用户身份 / Admin / Org 调用的。\u003c/p\u003e\n\u003cp\u003e即在调用不同的 Service 解决问题的时候，你可能需要快速的切换身份。切换完身份再速\u003cbr\u003e\n度切换回来。于是，test auth helper 出来了。helper 里面有个 switch as 函数，每次需\u003cbr\u003e\n要切换身份的时候，把 g 变量里面的登陆快照 g.user g.admin \u003ca href=\"https://link.zhihu.com/?target=http%3A//g.org\"\u003ehttp://g.org\u003c/a\u003e push 到 LocalStack 栈里 (from werkzeug.local import LocalStack), 调用完 Service 再 Pop 出来。\u003c/p\u003e\n\u003cp\u003e拉起来测试的效果是这样子的。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef \u003cspan class=\"token function\"\u003etest_complex_process\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eorg\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e user\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e admin\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n\t\u003cspan class=\"token keyword\"\u003ewith\u003c/span\u003e \u003cspan class=\"token function\"\u003eswitch_as_org\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eorg\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token keyword\"\u003eas\u003c/span\u003e org\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\t\t# \u003cspan class=\"token number\"\u003e1.\u003c/span\u003e 组织 Organization 发布了一个 Thread\n\t\tthread \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token function\"\u003epublish_thread_by_org\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\t\t\u003cspan class=\"token keyword\"\u003ewith\u003c/span\u003e \u003cspan class=\"token function\"\u003eswitch_as_user\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003euser\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token keyword\"\u003eas\u003c/span\u003e user\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e # \u003cspan class=\"token number\"\u003e2.\u003c/span\u003e 用户 User 在这个 Thread 进行了 Reply\n\t\t\treply \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token function\"\u003ereply_thread\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003ethread\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\t\t\tassert reply\n\t\t\t\u003cspan class=\"token keyword\"\u003ewith\u003c/span\u003e \u003cspan class=\"token function\"\u003eswitch_as_anonymous\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token keyword\"\u003eas\u003c/span\u003e anonymous_user\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n\t\t\t\t_thread \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token function\"\u003esee_thread\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003ethread\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\t\t\t\tassert reply \u003cspan class=\"token keyword\"\u003ein\u003c/span\u003e _thread\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003ereplies # 『未注册的用户能看见』\n\t\t\t\u003cspan class=\"token keyword\"\u003ewith\u003c/span\u003e \u003cspan class=\"token function\"\u003eswitch_as_admin\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token keyword\"\u003eas\u003c/span\u003e admin\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e # \u003cspan class=\"token number\"\u003e3.\u003c/span\u003e 管理员 Admin 发现了 User 似乎发布了不该发布的信息。删 Reply。\n\t\t\t\t\u003cspan class=\"token function\"\u003edelete_reply\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003ereply\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\t\t\t\tassert reply\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003edeleled\n\t\t\t\u003cspan class=\"token keyword\"\u003ewith\u003c/span\u003e \u003cspan class=\"token function\"\u003eswitch_as_anonymous\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token keyword\"\u003eas\u003c/span\u003e anonymous_user\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e『未注册的用户看不见』\n\t\t\t\t_thread \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token function\"\u003esee_thread\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003ethread\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\t\t\t\tassert reply not \u003cspan class=\"token keyword\"\u003ein\u003c/span\u003e _thread\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003ereplies\n\t\t\t# 在这里，我的身份还是 user\n\t\t\t_thread \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token function\"\u003esee_thread\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003ethread\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\t\t\tassert reply \u003cspan class=\"token keyword\"\u003ein\u003c/span\u003e _thread\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003ereplies # 『Ower 用户能看见』\n\t\t# \u003cspan class=\"token number\"\u003e4.\u003c/span\u003e 最后 User 进行申诉，Admin 发现其实发布的东西挺 \u003cspan class=\"token constant\"\u003eOK\u003c/span\u003e 的，给予通过。『未注册的用户能看见』\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e作为开发者，你只需要让这个测试跑通就基本开发完毕了。在这个过程中，你也可以更好的梳理你的代码。\u003c/p\u003e\n\u003ch3 id=\"如何处理外部服务\"\u003e\u003ca class=\"v-toc-item\" href=\"#如何处理外部服务\"\u003e#\u003c/a\u003e 如何处理外部服务\u003c/h3\u003e\n\u003cp\u003e在拉起来做测试的时候，假如我们多了一个流程，用户可以通过微信支付赞赏 reply, 这就不得不依赖于外部的服务。\u003c/p\u003e\n\u003cp\u003e而拉起来做测试的时候，就会遇到一个非常尴尬的问题，因为我上面的接口都粒度都比较大，是赞赏这个流程里面的非常小的流程，必须要走微信的 http 请求。\u003c/p\u003e\n\u003cp\u003e解决方式也很简单。 mock 掉请求微信的函数。手动调用一下支付回调函数，即可。\u003c/p\u003e\n\u003cp\u003e当然，对于 http 请求，也可以使用 \u003cstrong\u003eresponses\u003c/strong\u003e 这个神器来快速 mock 神器 requests 的 response\u003c/p\u003e\n\u003cp\u003e大致的用法如下\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef \u003cspan class=\"token function\"\u003emock_success_pay\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n    def \u003cspan class=\"token function\"\u003erequest_callback\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003erequest\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n        headers \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n        \u003cspan class=\"token function\"\u003edispatch_callback\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003edata\u003cspan class=\"token operator\"\u003e=\u003c/span\u003edata\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n        \u003cspan class=\"token keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"token number\"\u003e200\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e headers\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e resp_body\n\n    responses\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003eadd_callback\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\n        responses\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token constant\"\u003ePOST\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n        \u003cspan class=\"token constant\"\u003ePAY_URL\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n        callback\u003cspan class=\"token operator\"\u003e=\u003c/span\u003erequest_callback\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n        content_type\u003cspan class=\"token operator\"\u003e=\u003c/span\u003e\u003cspan class=\"token string\"\u003e\"application/json\"\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\n@responses\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003eactivate\ndef \u003cspan class=\"token function\"\u003etest_pay\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003euser\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n    \u003cspan class=\"token function\"\u003emock_success_pay\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\t\t\u003cspan class=\"token function\"\u003eswitch_as_user\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003euser\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token keyword\"\u003eas\u003c/span\u003e u\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n\t\t\torder \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token function\"\u003epay_order\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eu\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\t\tassert order\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003estatus \u003cspan class=\"token operator\"\u003e==\u003c/span\u003e \u003cspan class=\"token string\"\u003e\"PAID\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"其他-pytest-小技巧\"\u003e\u003ca class=\"v-toc-item\" href=\"#其他-pytest-小技巧\"\u003e#\u003c/a\u003e 其他 Pytest 小技巧\u003c/h3\u003e\n\u003cp\u003e有的时候 ipdb 比 pdb 用起来不止好了一点点。如何在 pytest 里用上呢？\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003epytest \u003cspan class=\"token operator\"\u003e-\u003c/span\u003ev \u003cspan class=\"token operator\"\u003e--\u003c/span\u003epdb \u003cspan class=\"token operator\"\u003e--\u003c/span\u003epdbcls\u003cspan class=\"token operator\"\u003e=\u003c/span\u003eIPython\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003eterminal\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003edebugger\u003cspan class=\"token operator\"\u003e:\u003c/span\u003ePdb\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"0xee-参考\"\u003e\u003ca class=\"v-toc-item\" href=\"#0xee-参考\"\u003e#\u003c/a\u003e 0xEE 参考\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.zhihu.com/question/21017354/answer/589574939\"\u003ehttps://www.zhihu.com/question/21017354/answer/589574939\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.zhihu.com/question/312395573/answer/604772703\"\u003ehttps://www.zhihu.com/question/312395573/answer/604772703\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n","toc":"\u003cul class=\"v-article-toc\"\u003e\n\u003cli\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#0x00-%E5%89%8D%E8%A8%80\"\u003e0x00 前言\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#0x01-%E6%B5%8B%E8%AF%95%E7%9A%84%E5%88%86%E7%B1%BB\"\u003e0x01 测试的分类\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#%E5%90%8E%E7%AB%AF%E4%B8%BB%E8%A6%81%E5%85%B3%E6%B3%A8%E5%93%AA%E4%BA%9B%E6%B5%8B%E8%AF%95\"\u003e后端主要关注哪些测试\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#0x02-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E6%B5%8B%E8%AF%95\"\u003e0x02 为什么要写测试\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#%E8%AE%A9%E6%96%B0%E6%89%8B%E6%9B%B4%E5%BF%AB%E7%9A%84%E4%BA%86%E8%A7%A3%E4%BB%A3%E7%A0%81\"\u003e让新手更快的了解代码\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E8%AE%A9%E5%8F%91%E5%B8%83%E4%BB%A3%E7%A0%81%E7%9A%84%E6%97%B6%E5%80%99%E6%9B%B4%E5%8A%A0%E6%9C%89%E5%BA%95%E6%B0%94\"\u003e让发布代码的时候更加有底气\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E8%AE%A9%E7%A8%8B%E5%BA%8F%E6%9B%B4%E5%AE%B9%E6%98%93%E9%87%8D%E6%9E%84\"\u003e让程序更容易重构\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E5%8A%A0%E5%BF%AB%E5%9B%A2%E9%98%9F%E7%9A%84%E5%BC%80%E5%8F%91%E9%80%9F%E5%BA%A6\"\u003e加快团队的开发速度\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#0x03-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%A6%81%E5%86%99%E6%B5%8B%E8%AF%95\"\u003e0x03 为什么不要写测试\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#%E6%B5%8B%E8%AF%95%E4%B8%8D%E8%83%BD%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98\"\u003e测试不能解决的问题\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E4%B8%8D%E9%80%82%E5%BD%93%E7%9A%84%E6%B5%8B%E8%AF%95%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E8%B4%9F%E6%8B%85\"\u003e不适当的测试为什么是负担\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E5%B9%B6%E4%B8%8D%E6%98%AF%E6%89%80%E6%9C%89%E5%9C%B0%E6%96%B9%E9%83%BD%E5%AE%B9%E6%98%93%E6%B5%8B%E8%AF%95%E7%9A%84\"\u003e并不是所有地方都容易测试的\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#0x04-%E5%86%99-python-%E6%B5%8B%E8%AF%95%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\"\u003e0x04 写 Python 测试的一些注意事项\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%8E%AF%E5%A2%83%E9%9A%94%E7%A6%BB\"\u003e项目的环境隔离\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E6%B5%8B%E8%AF%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83\"\u003e测试的基本环境\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E5%8D%95%E6%B5%8B-%E5%8A%9F%E6%B5%8B-%E7%AB%AF%E5%AF%B9%E7%AB%AF\"\u003e单测 / 功测 / 端对端\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%A4%96%E9%83%A8%E6%9C%8D%E5%8A%A1\"\u003e如何处理外部服务\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E5%85%B6%E4%BB%96-pytest-%E5%B0%8F%E6%8A%80%E5%B7%A7\"\u003e其他 Pytest 小技巧\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#0xee-%E5%8F%82%E8%80%83\"\u003e0xEE 参考\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n"}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"如何通过测试提升 Python 代码的健壮性"},"buildId":"oDi_oBCBuu3qj6v7hDnrL","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>