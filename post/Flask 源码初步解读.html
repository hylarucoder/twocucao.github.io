<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Flask 源码初步解读 | 海拉鲁编程客</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/49455a07b6dd33600cdf.css" as="style"/><link rel="stylesheet" href="/_next/static/css/49455a07b6dd33600cdf.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-a54b4f32bdc1ef890ddd.js"></script><script src="/_next/static/chunks/webpack-20d43e08bea62467b090.js" defer=""></script><script src="/_next/static/chunks/framework-0441fae7fd130f37dee1.js" defer=""></script><script src="/_next/static/chunks/main-4777350f2a9ff73ea2b0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-3050679c6e5142ffcaf5.js" defer=""></script><script src="/_next/static/chunks/ea88be26-9bcf6ead520f4ac26973.js" defer=""></script><script src="/_next/static/chunks/421-f2f33a86b546237f0325.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-173fe2de48c90365db9d.js" defer=""></script><script src="/_next/static/oDi_oBCBuu3qj6v7hDnrL/_buildManifest.js" defer=""></script><script src="/_next/static/oDi_oBCBuu3qj6v7hDnrL/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="v-page"><nav class="shadow"><div class="flex flex-col container mx-auto h-12 px-40 md:flex-row md:items-center md:justify-between"><div class="flex justify-between items-center"><div><a class="text-gray-800 text-xl md:text-xl leading-5" href="/">海拉鲁编程客</a></div><div><button type="button" class="block text-gray-800 hover:text-gray-600 focus:text-gray-600 focus:outline-none md:hidden"><svg viewBox="0 0 24 24" class="h-6 w-6 fill-current"><path d="M4 5h16a1 1 0 0 1 0 2H4a1 1 0 1 1 0-2zm0 6h16a1 1 0 0 1 0 2H4a1 1 0 0 1 0-2zm0 6h16a1 1 0 0 1 0 2H4a1 1 0 0 1 0-2z"></path></svg></button></div></div><div class="md:flex flex-col md:flex-row md:-mx-4 hidden"><a class="my-1 text-gray-800 hover:text-blue-500 md:mx-4 md:my-0" href="/">首页</a><a class="my-1 text-gray-800 hover:text-blue-500 md:mx-4 md:my-0" href="/archive">归档</a><a class="my-1 text-gray-800 hover:text-blue-500 md:mx-4 md:my-0" href="/about">关于我</a><button style="cursor:pointer;overflow:hidden;width:50px;height:23.5px;appearance:none;-moz-appearance:none;-webkit-appearance:none;border:none;background-color:transparent;padding:0" aria-hidden="true"><div style="display:flex;align-items:center;justify-content:center;margin-top:-28.749999999999996px;margin-left:-16px;width:82.5px;height:82.5px"><div></div></div></button></div></div></nav><div class="v-article"><div class="v-article-main" style="margin:auto;width:786px"><div><h2 id="0x00-前言"><a class="v-toc-item" href="#0x00-前言">#</a> 0x00 前言</h2>
<p>系列文章先暂时停更一下。今天换换口味。</p>
<p>久闻 Flask 是众多 Pythonist 喜欢的框架。这次借着换工作的机会熟悉一下 Flask</p>
<ol>
<li>本文先分享我阅读代码的一些小经验</li>
<li>接着通过最简单的一个 WSGI APP 开始，带着<strong>如何设计一个 Web 框架</strong>这个问题，先头脑风暴，从而脑补（而不是实现）出一个 Web 框架的基本要素。</li>
<li>从源码角度理解，Flask 从启动到接受第一个请求、返回第一个响应期间都发生了什么。</li>
<li>最后交代一些自己在这个过程中的一些突发的想法。</li>
</ol>
<blockquote>
<p>将解读 Flask 的源码放在一篇文章里，势必会造成广度有余而深度不足。所以本想定位于 Flask 源码初步解读。</p>
</blockquote>
<h2 id="0x01-阅读-flask-代码的一种较好的姿势"><a class="v-toc-item" href="#0x01-阅读-flask-代码的一种较好的姿势">#</a> 0x01 阅读 Flask 代码的一种较好的姿势</h2>
<p>之前在 <a href="https://www.zhihu.com/question/28509408/answer/299763091">https://www.zhihu.com/question/28509408/answer/299763091</a> 分享过自己一点阅读代码的粗浅的经验，是以阅读一个 Django 的应用为案例的。这里借着读 Flask 本身分享一下我的看法。</p>
<p>读源码，是一个技术活。一是忌讳要想读懂全部，另一个忌讳是以为自己能一下子毫无障碍的读懂全部代码。</p>
<ol start="0">
<li>建议 0 : 看源码的时候，<strong>务必务必带着问题去读</strong>。每一次阅读其实都是在尝试回答或小或大的问题（当然，读书看文章莫不如是）。</li>
<li>建议 1 : 先读现成的文档，不要上来就对着代码一通瞎看。</li>
<li>建议 2 : 所谓『横看成岭侧成峰，远近高低都不同』 你需要从不同的角度来读源码。</li>
<li>建议 3 : 抓大放小，该略读就略读（比如知道 Nginx 的大致作用就好，做优化请求响应的时候再翻看文档），该精读则精读（具体一个关键的功能）。</li>
</ol>
<blockquote>
<p>好，坐好，预备，开车。</p>
</blockquote>
<h2 id="0x02-问题-1-如何设计一个-web-框架"><a class="v-toc-item" href="#0x02-问题-1-如何设计一个-web-框架">#</a> 0x02 问题 1: 如何设计一个 Web 框架</h2>
<h3 id="头脑风暴"><a class="v-toc-item" href="#头脑风暴">#</a> 头脑风暴</h3>
<p>Flask 是一个微 Web 框架，换而言之，代码量少的 Web 框架。当然，其实 Flask 框架是一个微框架，但『常规的 Flask 应用』本身的代码加起来一点都不比『Django 应用』少。这个地方我们后面会讲到。</p>
<p>在阅读 Flask 相关代码的之前，先头脑风暴一下：</p>
<blockquote>
<p>如何设计一个 Web 框架？</p>
</blockquote>
<p>当心中对这个问题有一定的了解之后，读 Flask 代码会更好。</p>
<p>首先，Web 框架是为了提升 Web 开发的。(XX 框架是为了提升 XX 开发的）, 这种提升可能会是 开发体验 / 性能。</p>
<p>我们来看看那个 Python 世界最基础的 wsgi app 相关代码。</p>
<pre><code class="language-python">def <span class="token function">application</span><span class="token punctuation">(</span>environ<span class="token punctuation">,</span> start_response<span class="token punctuation">)</span><span class="token operator">:</span>
    <span class="token function">start_response</span><span class="token punctuation">(</span><span class="token string">'200 OK'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'Content-Type'</span><span class="token punctuation">,</span> <span class="token string">'text/plain'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token string">'Hello World!'</span><span class="token punctuation">]</span>
</code></pre>
<p>在之前的文章，我也借 Django 的 DRF 提到过这个极简的代码。</p>
<p>但这个简单的 webapp，显然是啥玩意都不够用的。比如说：</p>
<ul>
<li>没有路由，我访问啥玩意都是 hello world。</li>
<li>单线程 IO 阻塞模型基本上啥都不能干。你比如说，启动这个 webapp 的时候在 return 数据之前直接 sleep 十秒，然后请求都进不来。</li>
<li>没有数据存取，连个数据库链接 CURDE 啥玩意都没有</li>
<li>environ 太过于底层，如果是判断 headers 啥的太麻烦，要是像 django 里面一样能拿到一个 request 对象返回一个 response 对象就好了。</li>
<li>没有模板语言</li>
<li>还有其他能够提升开发体验的东西，比如自带 http server 代码热加载之类。</li>
</ul>
<pre><code class="language-python">def <span class="token function">application</span><span class="token punctuation">(</span>environ<span class="token punctuation">,</span> start_response<span class="token punctuation">)</span><span class="token operator">:</span>
    # 直接 thread local 支持多个请求。
    # 依据 environ 判断路由
    # 依据 路由 执行相关 view 层方法
    # 在相关 view 层方法内执行相关逻辑
    <span class="token function">start_response</span><span class="token punctuation">(</span><span class="token string">'200 OK'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'Content-Type'</span><span class="token punctuation">,</span> <span class="token string">'text/plain'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    # 返回对应响应
    <span class="token keyword">return</span> response
</code></pre>
<p>当然，思路是这么个思路，这个思路也确实非常的命令式，非常的面向过程。</p>
<p>至于我们如何把这个面向过程的思路变成面向对象的设计与实现，则需要更加细致的思考这些问题。</p>
<ol>
<li>能不能把 request 和 response 封装一下？方便在 view 里面处理？</li>
<li>能不能有个 URLDisparch 之类的东西，帮你解决 url 和 view 的 mapping 问题。或者路由能不能直接搞成 装饰器类型的比如 @router(“/”) 直接放在 view 层的 function 上。</li>
<li>能不能有个方便对数据库进行 CURDE 的东西？比如 ORM/ODM</li>
<li>这玩意会不会线程不安全，假如我想每一个请求都有单独的变量集合的话，线程怎么管理？</li>
<li>…</li>
</ol>
<h3 id="设计-web-框架"><a class="v-toc-item" href="#设计-web-框架">#</a> 设计 Web 框架</h3>
<p>利用 Flask 作者的另一个库 werkzeug 的案例中有这么一个东西。</p>
<p><a href="https://github.com/pallets/werkzeug/blob/master/examples/shortly/shortly.py">https://github.com/pallets/werkzeug/blob/master/examples/shortly/shortly.py</a></p>
<p>几百行代码就不贴在这里了。仔细看看还是挺有趣的。 这个可以算作另一个超简的 Webapp 了。</p>
<p>Flask 算作在这个基础上进行一定的扩展而成。</p>
<p>看完上面这个就可以出去吹牛逼可以自己写一个极简 Web 框架了。</p>
<p>那么，你可能有疑问，为何有了 Flask 之后，是否需要看这个更底层的 Werkzeug 的库，当然，有必要咯，Python 世界除了老牌的比较流行的 Django/Flask, 还有一个新星，叫做 APIStar</p>
<p><a href="https://github.com/encode/apistar">https://github.com/encode/apistar</a></p>
<h2 id="0x02-问题-2-请求流程是怎么样的"><a class="v-toc-item" href="#0x02-问题-2-请求流程是怎么样的">#</a> 0x02 问题 2: 请求流程是怎么样的</h2>
<p>我们就拿这个 flask 的极简案例，进行<strong>首次</strong>阅读 Flask 代码。</p>
<pre><code class="language-python"># hello<span class="token punctuation">.</span>py
from flask <span class="token keyword">import</span> Flask

app <span class="token operator">=</span> <span class="token function">Flask</span><span class="token punctuation">(</span>__name__<span class="token punctuation">)</span>

@app<span class="token punctuation">.</span><span class="token function">route</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span>
def <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span>
    <span class="token keyword">return</span> <span class="token string">'Hello, World!'</span>

$ <span class="token constant">FLASK_APP</span><span class="token operator">=</span>hello<span class="token punctuation">.</span>py flask run
</code></pre>
<blockquote>
<p>从请求到响应的整个流程，Flask 的是怎么处理请求的？</p>
</blockquote>
<h3 id="21-服务器是怎么起来的"><a class="v-toc-item" href="#21-服务器是怎么起来的">#</a> 2.1 服务器是怎么起来的</h3>
<p>首先 flask run 之后，发生了什么？</p>
<p>先初始化环境变量，然后导入 dotenv 文件，然后执行 run_command 方法，找到 <a href="http://hello.py">hello.py</a> 然后导入</p>
<pre><code class="language-python">#cli<span class="token punctuation">.</span>py#run_command 方法
app <span class="token operator">=</span> <span class="token function">DispatchingApp</span><span class="token punctuation">(</span>info<span class="token punctuation">.</span>load_app<span class="token punctuation">,</span> use_eager_loading<span class="token operator">=</span>eager_loading<span class="token punctuation">)</span>
# 上一行代表着其实我们每次在本地 flask run 的时候，起的服务并不是 flask_app<span class="token punctuation">,</span> 而是被 DispatchingApp 包装了一层的 flask app

from werkzeug<span class="token punctuation">.</span>serving <span class="token keyword">import</span> run_simple
<span class="token function">run_simple</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> port<span class="token punctuation">,</span> app<span class="token punctuation">,</span> use_reloader<span class="token operator">=</span>reload<span class="token punctuation">,</span> use_debugger<span class="token operator">=</span><span class="token keyword">debugger</span><span class="token punctuation">,</span>
            threaded<span class="token operator">=</span>with_threads<span class="token punctuation">,</span> ssl_context<span class="token operator">=</span>cert<span class="token punctuation">)</span>
</code></pre>
<p>进行这层包装之后，就可以显示 WERKZEUG 的所谓在浏览器中的 报错信息了。</p>
<p>通常开发时这里的 run_simple 最后会调用 run_with_reloader , 每当程序退出的时候，reloader 就依照策略重新跑一次 reload 一次。</p>
<pre><code class="language-python">def <span class="token function">run_with_reloader</span><span class="token punctuation">(</span>main_func<span class="token punctuation">,</span> extra_files<span class="token operator">=</span>None<span class="token punctuation">,</span> interval<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>
                      reloader_type<span class="token operator">=</span><span class="token string">'auto'</span><span class="token punctuation">)</span><span class="token operator">:</span>
    <span class="token string">""</span><span class="token string">"Run the given function in an independent python interpreter."</span><span class="token string">""</span>
    <span class="token keyword">import</span> signal
    reloader <span class="token operator">=</span> reloader_loops<span class="token punctuation">[</span>reloader_type<span class="token punctuation">]</span><span class="token punctuation">(</span>extra_files<span class="token punctuation">,</span> interval<span class="token punctuation">)</span>
    signal<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span>signal<span class="token punctuation">.</span><span class="token constant">SIGTERM</span><span class="token punctuation">,</span> lambda <span class="token operator">*</span>args<span class="token operator">:</span> sys<span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">try</span><span class="token operator">:</span>
        <span class="token keyword">if</span> os<span class="token punctuation">.</span>environ<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'WERKZEUG_RUN_MAIN'</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'true'</span><span class="token operator">:</span>
            t <span class="token operator">=</span> threading<span class="token punctuation">.</span><span class="token function">Thread</span><span class="token punctuation">(</span>target<span class="token operator">=</span>main_func<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            t<span class="token punctuation">.</span><span class="token function">setDaemon</span><span class="token punctuation">(</span>True<span class="token punctuation">)</span>
            t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            reloader<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token operator">:</span>
            sys<span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span>reloader<span class="token punctuation">.</span><span class="token function">restart_with_reloader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    except KeyboardInterrupt<span class="token operator">:</span>
        pass
</code></pre>
<p>好，服务起来了。</p>
<h3 id="22-请求-响应的流程"><a class="v-toc-item" href="#22-请求-响应的流程">#</a> 2.2 请求-响应的流程</h3>
<p>我们先看 Flask 类里面的比较关键的两个方法：</p>
<pre><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Flask</span><span class="token punctuation">(</span>_PackageBoundObject<span class="token punctuation">)</span><span class="token operator">:</span>
    # 一些方法 <span class="token operator">...</span><span class="token operator">...</span>
    def <span class="token function">full_dispatch_request</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token operator">:</span>
        # 主要是执行一些方法，最后返回响应
        self<span class="token punctuation">.</span><span class="token function">try_trigger_before_first_request_functions</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">try</span><span class="token operator">:</span>
            request_started<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span>
            rv <span class="token operator">=</span> self<span class="token punctuation">.</span><span class="token function">preprocess_request</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> rv is None<span class="token operator">:</span>
                rv <span class="token operator">=</span> self<span class="token punctuation">.</span><span class="token function">dispatch_request</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        except Exception <span class="token keyword">as</span> e<span class="token operator">:</span>
            rv <span class="token operator">=</span> self<span class="token punctuation">.</span><span class="token function">handle_user_exception</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
        # <span class="token operator">??</span><span class="token operator">?</span> <span class="token constant">TODO</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span><span class="token function">finalize_request</span><span class="token punctuation">(</span>rv<span class="token punctuation">)</span>

    # 这里是我们熟悉的 environ<span class="token punctuation">,</span> 和 start_response
    def <span class="token function">wsgi_app</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> environ<span class="token punctuation">,</span> start_response<span class="token punctuation">)</span><span class="token operator">:</span>
        <span class="token string">""</span>"
        <span class="token operator">:</span>param environ<span class="token operator">:</span> a <span class="token constant">WSGI</span> environment
        <span class="token operator">:</span>param start_response<span class="token operator">:</span> a callable accepting a status code<span class="token punctuation">,</span>
                               a list <span class="token keyword">of</span> headers and an optional
                               exception context to start the response
        <span class="token string">""</span>"
        # 在这里对 environ 进行封装，创建请求上下文
        ctx <span class="token operator">=</span> self<span class="token punctuation">.</span><span class="token function">request_context</span><span class="token punctuation">(</span>environ<span class="token punctuation">)</span>
        error <span class="token operator">=</span> None
        <span class="token keyword">try</span><span class="token operator">:</span>
            <span class="token keyword">try</span><span class="token operator">:</span>
                # 这里将请求上下文压入 _request_ctx_stack
                ctx<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                response <span class="token operator">=</span> self<span class="token punctuation">.</span><span class="token function">full_dispatch_request</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            except Exception <span class="token keyword">as</span> e<span class="token operator">:</span>
                error <span class="token operator">=</span> e
                response <span class="token operator">=</span> self<span class="token punctuation">.</span><span class="token function">handle_exception</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
            except<span class="token operator">:</span>
                error <span class="token operator">=</span> sys<span class="token punctuation">.</span><span class="token function">exc_info</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
                raise
            <span class="token keyword">return</span> <span class="token function">response</span><span class="token punctuation">(</span>environ<span class="token punctuation">,</span> start_response<span class="token punctuation">)</span>
        finally<span class="token operator">:</span>
            <span class="token keyword">if</span> self<span class="token punctuation">.</span><span class="token function">should_ignore_error</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token operator">:</span>
                error <span class="token operator">=</span> None
            # 这里将创建的请求上下文从中 _request_ctx_stack pop 出来
            ctx<span class="token punctuation">.</span><span class="token function">auto_pop</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>
</code></pre>
<p>从 wsgi_app 泪看，就可以看到我们之前在当时在开脑洞时候看到的。</p>
<ol>
<li>把 request 和 response 封装一下？方便在 view 里面处理？</li>
<li>有个 URLDisparch 之类的东西，帮你解决 url 和 view 的 mapping 问题。</li>
</ol>
<p>话说回来？</p>
<blockquote>
<p>这个 ctx 是啥？<br>
当然，flask 不带 ORM, 这我们也就不研究了。</p>
</blockquote>
<p>– TODO: 在这里需要重构一下</p>
<p>不过话说回来 请求上下文的容器 request_ctx_stack 到底是啥？</p>
<blockquote>
<p>另一种本地数据存储方式。</p>
</blockquote>
<p>在多线程的情况下，每一个请求都会创建一个线程，从这个请求被发起到销毁，我想拥有单独的变量（修改这个变量不会影响到其他变量），比如 sessions 之类。</p>
<p>显然，在多线程的情况下，以上的需求完全可以通过 threadlocal 来实现。</p>
<p>翻了 werkzeug 的文档，找到了原因：</p>
<blockquote>
<p>因为 python 里面的并发模型并不只有多线程一种。比如 greenlets, 每一个请求，都在一个线程里面。</p>
</blockquote>
<h2 id="0x02-问题-2-flask-中-context-机制"><a class="v-toc-item" href="#0x02-问题-2-flask-中-context-机制">#</a> 0x02 问题 2: Flask 中 Context 机制</h2>
<p>在 Django 完成一个 View 层的逻辑是这样的，Django 封装好了请求，请求经过 middleware 的处理，最后调用 login 函数，并且传入 request 方便 view 函数进行处理。</p>
<pre><code class="language-python">def <span class="token function">login</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token operator">:</span>
    <span class="token keyword">if</span> request<span class="token punctuation">.</span>method <span class="token operator">==</span> <span class="token string">'POST'</span><span class="token operator">:</span>
        error <span class="token operator">=</span> someerror
    <span class="token keyword">return</span> <span class="token function">render_template</span><span class="token punctuation">(</span><span class="token string">'login.html'</span><span class="token punctuation">,</span> error<span class="token operator">=</span>error<span class="token punctuation">)</span>
</code></pre>
<p>在 Flask 完成一个 View 层的逻辑是这样的</p>
<pre><code class="language-python">from flask <span class="token keyword">import</span> request
@app<span class="token punctuation">.</span><span class="token function">route</span><span class="token punctuation">(</span><span class="token string">'/login'</span><span class="token punctuation">,</span> methods<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'POST'</span><span class="token punctuation">,</span> <span class="token string">'GET'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
def <span class="token function">login</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span>
    <span class="token keyword">if</span> request<span class="token punctuation">.</span>method <span class="token operator">==</span> <span class="token string">'POST'</span><span class="token operator">:</span>
        error <span class="token operator">=</span> someerror
    <span class="token keyword">return</span> <span class="token function">render_template</span><span class="token punctuation">(</span><span class="token string">'login.html'</span><span class="token punctuation">,</span> error<span class="token operator">=</span>error<span class="token punctuation">)</span>
</code></pre>
<p>假如我是一个爱问问题的年轻人，这里肯定会有疑惑：</p>
<blockquote>
<p>从外部 import 过来，那就是利用了 python 自带的 import 单例模式。 那么线程和线程之间拿到的肯定是同一个 request 呀。但 Django 里面每个 request 都是不一样的，否则一些很基础功能的比如已经认证的用户就无法拿到了。</p>
</blockquote>
<p>我已经不是那个爱问问题的年轻人，因为年纪已经不小了。逃…</p>
<p>显然，每一次在 view 层引用的 request 肯定不是同一个 request , 那么，这是如何做到的呢？比如用 ThreadLocal , ThreadLocal 通过每个线程不同的 ID 拿到的本地变量，于是我们查看一下对应的实现。 这个 request 来自于 <a href="http://global.py">global.py</a> , 使用了一个 werkzeug.local 里面的 LocalProxy</p>
<pre><code class="language-python">from functools <span class="token keyword">import</span> partial
from werkzeug<span class="token punctuation">.</span>local <span class="token keyword">import</span> LocalStack<span class="token punctuation">,</span> LocalProxy

def <span class="token function">_lookup_req_object</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token operator">:</span>
    top <span class="token operator">=</span> _request_ctx_stack<span class="token punctuation">.</span>top
    <span class="token keyword">if</span> top is None<span class="token operator">:</span>
        raise <span class="token function">RuntimeError</span><span class="token punctuation">(</span>_request_ctx_err_msg<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token function">getattr</span><span class="token punctuation">(</span>top<span class="token punctuation">,</span> name<span class="token punctuation">)</span>

def <span class="token function">_lookup_app_object</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token operator">:</span>
    top <span class="token operator">=</span> _app_ctx_stack<span class="token punctuation">.</span>top
    <span class="token keyword">if</span> top is None<span class="token operator">:</span>
        raise <span class="token function">RuntimeError</span><span class="token punctuation">(</span>_app_ctx_err_msg<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token function">getattr</span><span class="token punctuation">(</span>top<span class="token punctuation">,</span> name<span class="token punctuation">)</span>

def <span class="token function">_find_app</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span>
    top <span class="token operator">=</span> _app_ctx_stack<span class="token punctuation">.</span>top
    <span class="token keyword">if</span> top is None<span class="token operator">:</span>
        raise <span class="token function">RuntimeError</span><span class="token punctuation">(</span>_app_ctx_err_msg<span class="token punctuation">)</span>
    <span class="token keyword">return</span> top<span class="token punctuation">.</span>app

# context locals
_request_ctx_stack <span class="token operator">=</span> <span class="token function">LocalStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
_app_ctx_stack <span class="token operator">=</span> <span class="token function">LocalStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
current_app <span class="token operator">=</span> <span class="token function">LocalProxy</span><span class="token punctuation">(</span>_find_app<span class="token punctuation">)</span>
# 这就是我们需要的注意的地方，LocalProxy
request <span class="token operator">=</span> <span class="token function">LocalProxy</span><span class="token punctuation">(</span><span class="token function">partial</span><span class="token punctuation">(</span>_lookup_req_object<span class="token punctuation">,</span> <span class="token string">'request'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
session <span class="token operator">=</span> <span class="token function">LocalProxy</span><span class="token punctuation">(</span><span class="token function">partial</span><span class="token punctuation">(</span>_lookup_req_object<span class="token punctuation">,</span> <span class="token string">'session'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
g <span class="token operator">=</span> <span class="token function">LocalProxy</span><span class="token punctuation">(</span><span class="token function">partial</span><span class="token punctuation">(</span>_lookup_app_object<span class="token punctuation">,</span> <span class="token string">'g'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
<p>看到这里一阵蛋疼，貌似没有 threadlocal ？再次查看相关实现最后还是定位到了如何区分不同的 request 的核心代码。</p>
<pre><code class="language-python"># since each thread has its own greenlet we can just use those <span class="token keyword">as</span> identifiers
# <span class="token keyword">for</span> the context<span class="token punctuation">.</span>  If greenlets are not available we fall back to the
# current thread ident depending on where it is<span class="token punctuation">.</span>
<span class="token keyword">try</span><span class="token operator">:</span>
    from greenlet <span class="token keyword">import</span> getcurrent <span class="token keyword">as</span> get_ident
    # greenlet 的代码是 <span class="token constant">C</span><span class="token punctuation">,</span> 时间长没看 <span class="token constant">C</span> 代码了，看了半天没看明白
    # 翻了文档返回当前的 greenlet<span class="token punctuation">,</span> 也就是返回调用此函数的 greenlet
except ImportError<span class="token operator">:</span>
    <span class="token keyword">try</span><span class="token operator">:</span>
        from thread <span class="token keyword">import</span> get_ident
    except ImportError<span class="token operator">:</span>
        from _thread <span class="token keyword">import</span> get_ident

<span class="token keyword">class</span> <span class="token class-name">Local</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token operator">:</span>
    __slots__ <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'__storage__'</span><span class="token punctuation">,</span> <span class="token string">'__ident_func__'</span><span class="token punctuation">)</span>

    def <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token operator">:</span>
        object<span class="token punctuation">.</span><span class="token function">__setattr__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token string">'__storage__'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
        # 这里传递的 ident 就可以直接
        object<span class="token punctuation">.</span><span class="token function">__setattr__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token string">'__ident_func__'</span><span class="token punctuation">,</span> get_ident<span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">LocalStack</span><span class="token operator">:</span>
    # 用 local 实现的栈

<span class="token keyword">class</span> <span class="token class-name">LocalProxy</span><span class="token operator">:</span>
    # 一个 local 的代理器
    def <span class="token function">__getattr__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token operator">:</span>
    <span class="token keyword">if</span> name <span class="token operator">==</span> <span class="token string">'__members__'</span><span class="token operator">:</span>
        <span class="token keyword">return</span> <span class="token function">dir</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span><span class="token function">_get_current_object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token function">getattr</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span><span class="token function">_get_current_object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span>
</code></pre>
<p>即：</p>
<ol>
<li>当 Flask 以多线程模型运行的时候，则使用的是 threadlocal 方式</li>
<li>当 Flask 以 greenlet 的模型运行的时候，则使用的是 greenlet 区分不同</li>
</ol>
<p>接下来回头看一下处理 request 的逻辑</p>
<pre><code class="language-python">from flask <span class="token keyword">import</span> request
@app<span class="token punctuation">.</span><span class="token function">route</span><span class="token punctuation">(</span><span class="token string">'/login'</span><span class="token punctuation">,</span> methods<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'POST'</span><span class="token punctuation">,</span> <span class="token string">'GET'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
def <span class="token function">login</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span>
    # 这个 request 哪里来？
    <span class="token keyword">if</span> request<span class="token punctuation">.</span>method <span class="token operator">==</span> <span class="token string">'POST'</span><span class="token operator">:</span>
        error <span class="token operator">=</span> someerror
    <span class="token keyword">return</span> <span class="token function">render_template</span><span class="token punctuation">(</span><span class="token string">'login.html'</span><span class="token punctuation">,</span> error<span class="token operator">=</span>error<span class="token punctuation">)</span>
</code></pre>
<p>于是，我们就知道了，当引用 request 这个 LocalProxy 的时候，引用的确实是同一个名称为 request 变量，并且这个变量也确实是 LocalProxy 的实例</p>
<blockquote>
<p>但是当使用 request.method 的时候，LocalProxy 重载了 取到的则是另一个『请求对象』的 method.</p>
</blockquote>
<p>于是拿到当前请求的信息。</p>
<p>当然，其实我们也可以依据利用这个技巧写一个 currentuser 的 ProxyLocal, 然后在每个 view 层里面使用 user.has_something 进行操作。</p>
<h2 id="0x03-问题-3-flask-中官方的机制"><a class="v-toc-item" href="#0x03-问题-3-flask-中官方的机制">#</a> 0x03 问题 3: Flask 中官方的机制</h2>
<h2 id="0x04-问题-3-flask-中是如何做到优雅扩展的"><a class="v-toc-item" href="#0x04-问题-3-flask-中是如何做到优雅扩展的">#</a> 0x04 问题 3: Flask 中是如何做到优雅扩展的</h2>
<h2 id="0x05-其他问题"><a class="v-toc-item" href="#0x05-其他问题">#</a> 0x05 其他问题</h2>
<h3 id="flask-应用"><a class="v-toc-item" href="#flask-应用">#</a> Flask 应用</h3>
<hr>
<p>ChangeLog:</p>
<ul>
<li><strong>2018-03-09</strong> 重修文字</li>
</ul>
</div></div><div><ul class="v-article-toc">
<li>
<ul>
<li><a href="#0x00-%E5%89%8D%E8%A8%80">0x00 前言</a></li>
<li><a href="#0x01-%E9%98%85%E8%AF%BB-flask-%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B8%80%E7%A7%8D%E8%BE%83%E5%A5%BD%E7%9A%84%E5%A7%BF%E5%8A%BF">0x01 阅读 Flask 代码的一种较好的姿势</a></li>
<li><a href="#0x02-%E9%97%AE%E9%A2%98-1-%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA-web-%E6%A1%86%E6%9E%B6">0x02 问题 1: 如何设计一个 Web 框架</a>
<ul>
<li><a href="#%E5%A4%B4%E8%84%91%E9%A3%8E%E6%9A%B4">头脑风暴</a></li>
<li><a href="#%E8%AE%BE%E8%AE%A1-web-%E6%A1%86%E6%9E%B6">设计 Web 框架</a></li>
</ul>
</li>
<li><a href="#0x02-%E9%97%AE%E9%A2%98-2-%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84">0x02 问题 2: 请求流程是怎么样的</a>
<ul>
<li><a href="#21-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%98%AF%E6%80%8E%E4%B9%88%E8%B5%B7%E6%9D%A5%E7%9A%84">2.1 服务器是怎么起来的</a></li>
<li><a href="#22-%E8%AF%B7%E6%B1%82-%E5%93%8D%E5%BA%94%E7%9A%84%E6%B5%81%E7%A8%8B">2.2 请求-响应的流程</a></li>
</ul>
</li>
<li><a href="#0x02-%E9%97%AE%E9%A2%98-2-flask-%E4%B8%AD-context-%E6%9C%BA%E5%88%B6">0x02 问题 2: Flask 中 Context 机制</a></li>
<li><a href="#0x03-%E9%97%AE%E9%A2%98-3-flask-%E4%B8%AD%E5%AE%98%E6%96%B9%E7%9A%84%E6%9C%BA%E5%88%B6">0x03 问题 3: Flask 中官方的机制</a></li>
<li><a href="#0x04-%E9%97%AE%E9%A2%98-3-flask-%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E4%BC%98%E9%9B%85%E6%89%A9%E5%B1%95%E7%9A%84">0x04 问题 3: Flask 中是如何做到优雅扩展的</a></li>
<li><a href="#0x05-%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98">0x05 其他问题</a>
<ul>
<li><a href="#flask-%E5%BA%94%E7%94%A8">Flask 应用</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"tags":["Python","Flask"],"path":"20180309_Flask源码解析.md","title":"Flask 源码初步解读","slug":"Flask 源码初步解读","date":"2018-03-09","category":"Flask","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\u003ch2 id=\"0x00-前言\"\u003e\u003ca class=\"v-toc-item\" href=\"#0x00-前言\"\u003e#\u003c/a\u003e 0x00 前言\u003c/h2\u003e\n\u003cp\u003e系列文章先暂时停更一下。今天换换口味。\u003c/p\u003e\n\u003cp\u003e久闻 Flask 是众多 Pythonist 喜欢的框架。这次借着换工作的机会熟悉一下 Flask\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e本文先分享我阅读代码的一些小经验\u003c/li\u003e\n\u003cli\u003e接着通过最简单的一个 WSGI APP 开始，带着\u003cstrong\u003e如何设计一个 Web 框架\u003c/strong\u003e这个问题，先头脑风暴，从而脑补（而不是实现）出一个 Web 框架的基本要素。\u003c/li\u003e\n\u003cli\u003e从源码角度理解，Flask 从启动到接受第一个请求、返回第一个响应期间都发生了什么。\u003c/li\u003e\n\u003cli\u003e最后交代一些自己在这个过程中的一些突发的想法。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cblockquote\u003e\n\u003cp\u003e将解读 Flask 的源码放在一篇文章里，势必会造成广度有余而深度不足。所以本想定位于 Flask 源码初步解读。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"0x01-阅读-flask-代码的一种较好的姿势\"\u003e\u003ca class=\"v-toc-item\" href=\"#0x01-阅读-flask-代码的一种较好的姿势\"\u003e#\u003c/a\u003e 0x01 阅读 Flask 代码的一种较好的姿势\u003c/h2\u003e\n\u003cp\u003e之前在 \u003ca href=\"https://www.zhihu.com/question/28509408/answer/299763091\"\u003ehttps://www.zhihu.com/question/28509408/answer/299763091\u003c/a\u003e 分享过自己一点阅读代码的粗浅的经验，是以阅读一个 Django 的应用为案例的。这里借着读 Flask 本身分享一下我的看法。\u003c/p\u003e\n\u003cp\u003e读源码，是一个技术活。一是忌讳要想读懂全部，另一个忌讳是以为自己能一下子毫无障碍的读懂全部代码。\u003c/p\u003e\n\u003col start=\"0\"\u003e\n\u003cli\u003e建议 0 : 看源码的时候，\u003cstrong\u003e务必务必带着问题去读\u003c/strong\u003e。每一次阅读其实都是在尝试回答或小或大的问题（当然，读书看文章莫不如是）。\u003c/li\u003e\n\u003cli\u003e建议 1 : 先读现成的文档，不要上来就对着代码一通瞎看。\u003c/li\u003e\n\u003cli\u003e建议 2 : 所谓『横看成岭侧成峰，远近高低都不同』 你需要从不同的角度来读源码。\u003c/li\u003e\n\u003cli\u003e建议 3 : 抓大放小，该略读就略读（比如知道 Nginx 的大致作用就好，做优化请求响应的时候再翻看文档），该精读则精读（具体一个关键的功能）。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cblockquote\u003e\n\u003cp\u003e好，坐好，预备，开车。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"0x02-问题-1-如何设计一个-web-框架\"\u003e\u003ca class=\"v-toc-item\" href=\"#0x02-问题-1-如何设计一个-web-框架\"\u003e#\u003c/a\u003e 0x02 问题 1: 如何设计一个 Web 框架\u003c/h2\u003e\n\u003ch3 id=\"头脑风暴\"\u003e\u003ca class=\"v-toc-item\" href=\"#头脑风暴\"\u003e#\u003c/a\u003e 头脑风暴\u003c/h3\u003e\n\u003cp\u003eFlask 是一个微 Web 框架，换而言之，代码量少的 Web 框架。当然，其实 Flask 框架是一个微框架，但『常规的 Flask 应用』本身的代码加起来一点都不比『Django 应用』少。这个地方我们后面会讲到。\u003c/p\u003e\n\u003cp\u003e在阅读 Flask 相关代码的之前，先头脑风暴一下：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e如何设计一个 Web 框架？\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e当心中对这个问题有一定的了解之后，读 Flask 代码会更好。\u003c/p\u003e\n\u003cp\u003e首先，Web 框架是为了提升 Web 开发的。(XX 框架是为了提升 XX 开发的）, 这种提升可能会是 开发体验 / 性能。\u003c/p\u003e\n\u003cp\u003e我们来看看那个 Python 世界最基础的 wsgi app 相关代码。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef \u003cspan class=\"token function\"\u003eapplication\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eenviron\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e start_response\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n    \u003cspan class=\"token function\"\u003estart_response\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token string\"\u003e'200 OK'\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token string\"\u003e'Content-Type'\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token string\"\u003e'text/plain'\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"token keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003e\u003cspan class=\"token string\"\u003e'Hello World!'\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在之前的文章，我也借 Django 的 DRF 提到过这个极简的代码。\u003c/p\u003e\n\u003cp\u003e但这个简单的 webapp，显然是啥玩意都不够用的。比如说：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e没有路由，我访问啥玩意都是 hello world。\u003c/li\u003e\n\u003cli\u003e单线程 IO 阻塞模型基本上啥都不能干。你比如说，启动这个 webapp 的时候在 return 数据之前直接 sleep 十秒，然后请求都进不来。\u003c/li\u003e\n\u003cli\u003e没有数据存取，连个数据库链接 CURDE 啥玩意都没有\u003c/li\u003e\n\u003cli\u003eenviron 太过于底层，如果是判断 headers 啥的太麻烦，要是像 django 里面一样能拿到一个 request 对象返回一个 response 对象就好了。\u003c/li\u003e\n\u003cli\u003e没有模板语言\u003c/li\u003e\n\u003cli\u003e还有其他能够提升开发体验的东西，比如自带 http server 代码热加载之类。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef \u003cspan class=\"token function\"\u003eapplication\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eenviron\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e start_response\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n    # 直接 thread local 支持多个请求。\n    # 依据 environ 判断路由\n    # 依据 路由 执行相关 view 层方法\n    # 在相关 view 层方法内执行相关逻辑\n    \u003cspan class=\"token function\"\u003estart_response\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token string\"\u003e'200 OK'\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token string\"\u003e'Content-Type'\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token string\"\u003e'text/plain'\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n    # 返回对应响应\n    \u003cspan class=\"token keyword\"\u003ereturn\u003c/span\u003e response\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e当然，思路是这么个思路，这个思路也确实非常的命令式，非常的面向过程。\u003c/p\u003e\n\u003cp\u003e至于我们如何把这个面向过程的思路变成面向对象的设计与实现，则需要更加细致的思考这些问题。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e能不能把 request 和 response 封装一下？方便在 view 里面处理？\u003c/li\u003e\n\u003cli\u003e能不能有个 URLDisparch 之类的东西，帮你解决 url 和 view 的 mapping 问题。或者路由能不能直接搞成 装饰器类型的比如 @router(“/”) 直接放在 view 层的 function 上。\u003c/li\u003e\n\u003cli\u003e能不能有个方便对数据库进行 CURDE 的东西？比如 ORM/ODM\u003c/li\u003e\n\u003cli\u003e这玩意会不会线程不安全，假如我想每一个请求都有单独的变量集合的话，线程怎么管理？\u003c/li\u003e\n\u003cli\u003e…\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"设计-web-框架\"\u003e\u003ca class=\"v-toc-item\" href=\"#设计-web-框架\"\u003e#\u003c/a\u003e 设计 Web 框架\u003c/h3\u003e\n\u003cp\u003e利用 Flask 作者的另一个库 werkzeug 的案例中有这么一个东西。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/pallets/werkzeug/blob/master/examples/shortly/shortly.py\"\u003ehttps://github.com/pallets/werkzeug/blob/master/examples/shortly/shortly.py\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e几百行代码就不贴在这里了。仔细看看还是挺有趣的。 这个可以算作另一个超简的 Webapp 了。\u003c/p\u003e\n\u003cp\u003eFlask 算作在这个基础上进行一定的扩展而成。\u003c/p\u003e\n\u003cp\u003e看完上面这个就可以出去吹牛逼可以自己写一个极简 Web 框架了。\u003c/p\u003e\n\u003cp\u003e那么，你可能有疑问，为何有了 Flask 之后，是否需要看这个更底层的 Werkzeug 的库，当然，有必要咯，Python 世界除了老牌的比较流行的 Django/Flask, 还有一个新星，叫做 APIStar\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/encode/apistar\"\u003ehttps://github.com/encode/apistar\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"0x02-问题-2-请求流程是怎么样的\"\u003e\u003ca class=\"v-toc-item\" href=\"#0x02-问题-2-请求流程是怎么样的\"\u003e#\u003c/a\u003e 0x02 问题 2: 请求流程是怎么样的\u003c/h2\u003e\n\u003cp\u003e我们就拿这个 flask 的极简案例，进行\u003cstrong\u003e首次\u003c/strong\u003e阅读 Flask 代码。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# hello\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003epy\nfrom flask \u003cspan class=\"token keyword\"\u003eimport\u003c/span\u003e Flask\n\napp \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token function\"\u003eFlask\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e__name__\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\n@app\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003eroute\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token string\"\u003e'/'\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\ndef \u003cspan class=\"token function\"\u003ehello\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n    \u003cspan class=\"token keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"token string\"\u003e'Hello, World!'\u003c/span\u003e\n\n$ \u003cspan class=\"token constant\"\u003eFLASK_APP\u003c/span\u003e\u003cspan class=\"token operator\"\u003e=\u003c/span\u003ehello\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003epy flask run\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e从请求到响应的整个流程，Flask 的是怎么处理请求的？\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"21-服务器是怎么起来的\"\u003e\u003ca class=\"v-toc-item\" href=\"#21-服务器是怎么起来的\"\u003e#\u003c/a\u003e 2.1 服务器是怎么起来的\u003c/h3\u003e\n\u003cp\u003e首先 flask run 之后，发生了什么？\u003c/p\u003e\n\u003cp\u003e先初始化环境变量，然后导入 dotenv 文件，然后执行 run_command 方法，找到 \u003ca href=\"http://hello.py\"\u003ehello.py\u003c/a\u003e 然后导入\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e#cli\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003epy#run_command 方法\napp \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token function\"\u003eDispatchingApp\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003einfo\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003eload_app\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e use_eager_loading\u003cspan class=\"token operator\"\u003e=\u003c/span\u003eeager_loading\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n# 上一行代表着其实我们每次在本地 flask run 的时候，起的服务并不是 flask_app\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e 而是被 DispatchingApp 包装了一层的 flask app\n\nfrom werkzeug\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003eserving \u003cspan class=\"token keyword\"\u003eimport\u003c/span\u003e run_simple\n\u003cspan class=\"token function\"\u003erun_simple\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003ehost\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e port\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e app\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e use_reloader\u003cspan class=\"token operator\"\u003e=\u003c/span\u003ereload\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e use_debugger\u003cspan class=\"token operator\"\u003e=\u003c/span\u003e\u003cspan class=\"token keyword\"\u003edebugger\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n            threaded\u003cspan class=\"token operator\"\u003e=\u003c/span\u003ewith_threads\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e ssl_context\u003cspan class=\"token operator\"\u003e=\u003c/span\u003ecert\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e进行这层包装之后，就可以显示 WERKZEUG 的所谓在浏览器中的 报错信息了。\u003c/p\u003e\n\u003cp\u003e通常开发时这里的 run_simple 最后会调用 run_with_reloader , 每当程序退出的时候，reloader 就依照策略重新跑一次 reload 一次。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef \u003cspan class=\"token function\"\u003erun_with_reloader\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003emain_func\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e extra_files\u003cspan class=\"token operator\"\u003e=\u003c/span\u003eNone\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e interval\u003cspan class=\"token operator\"\u003e=\u003c/span\u003e\u003cspan class=\"token number\"\u003e1\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n                      reloader_type\u003cspan class=\"token operator\"\u003e=\u003c/span\u003e\u003cspan class=\"token string\"\u003e'auto'\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n    \u003cspan class=\"token string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"token string\"\u003e\"Run the given function in an independent python interpreter.\"\u003c/span\u003e\u003cspan class=\"token string\"\u003e\"\"\u003c/span\u003e\n    \u003cspan class=\"token keyword\"\u003eimport\u003c/span\u003e signal\n    reloader \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e reloader_loops\u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003ereloader_type\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eextra_files\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e interval\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n    signal\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003esignal\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003esignal\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token constant\"\u003eSIGTERM\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e lambda \u003cspan class=\"token operator\"\u003e*\u003c/span\u003eargs\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e sys\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003eexit\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token number\"\u003e0\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"token keyword\"\u003etry\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n        \u003cspan class=\"token keyword\"\u003eif\u003c/span\u003e os\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003eenviron\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003eget\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token string\"\u003e'WERKZEUG_RUN_MAIN'\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token operator\"\u003e==\u003c/span\u003e \u003cspan class=\"token string\"\u003e'true'\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n            t \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e threading\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003eThread\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003etarget\u003cspan class=\"token operator\"\u003e=\u003c/span\u003emain_func\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e args\u003cspan class=\"token operator\"\u003e=\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n            t\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003esetDaemon\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eTrue\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n            t\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003estart\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n            reloader\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003erun\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n        \u003cspan class=\"token keyword\"\u003eelse\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n            sys\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003eexit\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003ereloader\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003erestart_with_reloader\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n    except KeyboardInterrupt\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n        pass\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e好，服务起来了。\u003c/p\u003e\n\u003ch3 id=\"22-请求-响应的流程\"\u003e\u003ca class=\"v-toc-item\" href=\"#22-请求-响应的流程\"\u003e#\u003c/a\u003e 2.2 请求-响应的流程\u003c/h3\u003e\n\u003cp\u003e我们先看 Flask 类里面的比较关键的两个方法：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003cspan class=\"token keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eFlask\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e_PackageBoundObject\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n    # 一些方法 \u003cspan class=\"token operator\"\u003e...\u003c/span\u003e\u003cspan class=\"token operator\"\u003e...\u003c/span\u003e\n    def \u003cspan class=\"token function\"\u003efull_dispatch_request\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eself\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n        # 主要是执行一些方法，最后返回响应\n        self\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003etry_trigger_before_first_request_functions\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n        \u003cspan class=\"token keyword\"\u003etry\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n            request_started\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003esend\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eself\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n            rv \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e self\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003epreprocess_request\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n            \u003cspan class=\"token keyword\"\u003eif\u003c/span\u003e rv is None\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n                rv \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e self\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003edispatch_request\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n        except Exception \u003cspan class=\"token keyword\"\u003eas\u003c/span\u003e e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n            rv \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e self\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003ehandle_user_exception\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003ee\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n        # \u003cspan class=\"token operator\"\u003e??\u003c/span\u003e\u003cspan class=\"token operator\"\u003e?\u003c/span\u003e \u003cspan class=\"token constant\"\u003eTODO\u003c/span\u003e\n        \u003cspan class=\"token keyword\"\u003ereturn\u003c/span\u003e self\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003efinalize_request\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003erv\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\n    # 这里是我们熟悉的 environ\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e 和 start_response\n    def \u003cspan class=\"token function\"\u003ewsgi_app\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eself\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e environ\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e start_response\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n        \u003cspan class=\"token string\"\u003e\"\"\u003c/span\u003e\"\n        \u003cspan class=\"token operator\"\u003e:\u003c/span\u003eparam environ\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e a \u003cspan class=\"token constant\"\u003eWSGI\u003c/span\u003e environment\n        \u003cspan class=\"token operator\"\u003e:\u003c/span\u003eparam start_response\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e a callable accepting a status code\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n                               a list \u003cspan class=\"token keyword\"\u003eof\u003c/span\u003e headers and an optional\n                               exception context to start the response\n        \u003cspan class=\"token string\"\u003e\"\"\u003c/span\u003e\"\n        # 在这里对 environ 进行封装，创建请求上下文\n        ctx \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e self\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003erequest_context\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eenviron\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n        error \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e None\n        \u003cspan class=\"token keyword\"\u003etry\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n            \u003cspan class=\"token keyword\"\u003etry\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n                # 这里将请求上下文压入 _request_ctx_stack\n                ctx\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003epush\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n                response \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e self\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003efull_dispatch_request\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n            except Exception \u003cspan class=\"token keyword\"\u003eas\u003c/span\u003e e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n                error \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e e\n                response \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e self\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003ehandle_exception\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003ee\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n            except\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n                error \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e sys\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003eexc_info\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003e\u003cspan class=\"token number\"\u003e1\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e\n                raise\n            \u003cspan class=\"token keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"token function\"\u003eresponse\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eenviron\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e start_response\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n        finally\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n            \u003cspan class=\"token keyword\"\u003eif\u003c/span\u003e self\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003eshould_ignore_error\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eerror\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n                error \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e None\n            # 这里将创建的请求上下文从中 _request_ctx_stack pop 出来\n            ctx\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003eauto_pop\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eerror\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e从 wsgi_app 泪看，就可以看到我们之前在当时在开脑洞时候看到的。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e把 request 和 response 封装一下？方便在 view 里面处理？\u003c/li\u003e\n\u003cli\u003e有个 URLDisparch 之类的东西，帮你解决 url 和 view 的 mapping 问题。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e话说回来？\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e这个 ctx 是啥？\u003cbr\u003e\n当然，flask 不带 ORM, 这我们也就不研究了。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e– TODO: 在这里需要重构一下\u003c/p\u003e\n\u003cp\u003e不过话说回来 请求上下文的容器 request_ctx_stack 到底是啥？\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e另一种本地数据存储方式。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e在多线程的情况下，每一个请求都会创建一个线程，从这个请求被发起到销毁，我想拥有单独的变量（修改这个变量不会影响到其他变量），比如 sessions 之类。\u003c/p\u003e\n\u003cp\u003e显然，在多线程的情况下，以上的需求完全可以通过 threadlocal 来实现。\u003c/p\u003e\n\u003cp\u003e翻了 werkzeug 的文档，找到了原因：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e因为 python 里面的并发模型并不只有多线程一种。比如 greenlets, 每一个请求，都在一个线程里面。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"0x02-问题-2-flask-中-context-机制\"\u003e\u003ca class=\"v-toc-item\" href=\"#0x02-问题-2-flask-中-context-机制\"\u003e#\u003c/a\u003e 0x02 问题 2: Flask 中 Context 机制\u003c/h2\u003e\n\u003cp\u003e在 Django 完成一个 View 层的逻辑是这样的，Django 封装好了请求，请求经过 middleware 的处理，最后调用 login 函数，并且传入 request 方便 view 函数进行处理。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef \u003cspan class=\"token function\"\u003elogin\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003erequest\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n    \u003cspan class=\"token keyword\"\u003eif\u003c/span\u003e request\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003emethod \u003cspan class=\"token operator\"\u003e==\u003c/span\u003e \u003cspan class=\"token string\"\u003e'POST'\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n        error \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e someerror\n    \u003cspan class=\"token keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"token function\"\u003erender_template\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token string\"\u003e'login.html'\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e error\u003cspan class=\"token operator\"\u003e=\u003c/span\u003eerror\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在 Flask 完成一个 View 层的逻辑是这样的\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom flask \u003cspan class=\"token keyword\"\u003eimport\u003c/span\u003e request\n@app\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003eroute\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token string\"\u003e'/login'\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e methods\u003cspan class=\"token operator\"\u003e=\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003e\u003cspan class=\"token string\"\u003e'POST'\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token string\"\u003e'GET'\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\ndef \u003cspan class=\"token function\"\u003elogin\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n    \u003cspan class=\"token keyword\"\u003eif\u003c/span\u003e request\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003emethod \u003cspan class=\"token operator\"\u003e==\u003c/span\u003e \u003cspan class=\"token string\"\u003e'POST'\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n        error \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e someerror\n    \u003cspan class=\"token keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"token function\"\u003erender_template\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token string\"\u003e'login.html'\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e error\u003cspan class=\"token operator\"\u003e=\u003c/span\u003eerror\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e假如我是一个爱问问题的年轻人，这里肯定会有疑惑：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e从外部 import 过来，那就是利用了 python 自带的 import 单例模式。 那么线程和线程之间拿到的肯定是同一个 request 呀。但 Django 里面每个 request 都是不一样的，否则一些很基础功能的比如已经认证的用户就无法拿到了。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e我已经不是那个爱问问题的年轻人，因为年纪已经不小了。逃…\u003c/p\u003e\n\u003cp\u003e显然，每一次在 view 层引用的 request 肯定不是同一个 request , 那么，这是如何做到的呢？比如用 ThreadLocal , ThreadLocal 通过每个线程不同的 ID 拿到的本地变量，于是我们查看一下对应的实现。 这个 request 来自于 \u003ca href=\"http://global.py\"\u003eglobal.py\u003c/a\u003e , 使用了一个 werkzeug.local 里面的 LocalProxy\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom functools \u003cspan class=\"token keyword\"\u003eimport\u003c/span\u003e partial\nfrom werkzeug\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003elocal \u003cspan class=\"token keyword\"\u003eimport\u003c/span\u003e LocalStack\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e LocalProxy\n\ndef \u003cspan class=\"token function\"\u003e_lookup_req_object\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003ename\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n    top \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e _request_ctx_stack\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003etop\n    \u003cspan class=\"token keyword\"\u003eif\u003c/span\u003e top is None\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n        raise \u003cspan class=\"token function\"\u003eRuntimeError\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e_request_ctx_err_msg\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"token keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"token function\"\u003egetattr\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003etop\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e name\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\ndef \u003cspan class=\"token function\"\u003e_lookup_app_object\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003ename\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n    top \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e _app_ctx_stack\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003etop\n    \u003cspan class=\"token keyword\"\u003eif\u003c/span\u003e top is None\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n        raise \u003cspan class=\"token function\"\u003eRuntimeError\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e_app_ctx_err_msg\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"token keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"token function\"\u003egetattr\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003etop\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e name\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\ndef \u003cspan class=\"token function\"\u003e_find_app\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n    top \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e _app_ctx_stack\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003etop\n    \u003cspan class=\"token keyword\"\u003eif\u003c/span\u003e top is None\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n        raise \u003cspan class=\"token function\"\u003eRuntimeError\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e_app_ctx_err_msg\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"token keyword\"\u003ereturn\u003c/span\u003e top\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003eapp\n\n# context locals\n_request_ctx_stack \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token function\"\u003eLocalStack\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n_app_ctx_stack \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token function\"\u003eLocalStack\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\ncurrent_app \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token function\"\u003eLocalProxy\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e_find_app\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n# 这就是我们需要的注意的地方，LocalProxy\nrequest \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token function\"\u003eLocalProxy\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token function\"\u003epartial\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e_lookup_req_object\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token string\"\u003e'request'\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\nsession \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token function\"\u003eLocalProxy\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token function\"\u003epartial\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e_lookup_req_object\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token string\"\u003e'session'\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\ng \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token function\"\u003eLocalProxy\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token function\"\u003epartial\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e_lookup_app_object\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token string\"\u003e'g'\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e看到这里一阵蛋疼，貌似没有 threadlocal ？再次查看相关实现最后还是定位到了如何区分不同的 request 的核心代码。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# since each thread has its own greenlet we can just use those \u003cspan class=\"token keyword\"\u003eas\u003c/span\u003e identifiers\n# \u003cspan class=\"token keyword\"\u003efor\u003c/span\u003e the context\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e  If greenlets are not available we fall back to the\n# current thread ident depending on where it is\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\n\u003cspan class=\"token keyword\"\u003etry\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n    from greenlet \u003cspan class=\"token keyword\"\u003eimport\u003c/span\u003e getcurrent \u003cspan class=\"token keyword\"\u003eas\u003c/span\u003e get_ident\n    # greenlet 的代码是 \u003cspan class=\"token constant\"\u003eC\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e 时间长没看 \u003cspan class=\"token constant\"\u003eC\u003c/span\u003e 代码了，看了半天没看明白\n    # 翻了文档返回当前的 greenlet\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e 也就是返回调用此函数的 greenlet\nexcept ImportError\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n    \u003cspan class=\"token keyword\"\u003etry\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n        from thread \u003cspan class=\"token keyword\"\u003eimport\u003c/span\u003e get_ident\n    except ImportError\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n        from _thread \u003cspan class=\"token keyword\"\u003eimport\u003c/span\u003e get_ident\n\n\u003cspan class=\"token keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eLocal\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eobject\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n    __slots__ \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token string\"\u003e'__storage__'\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token string\"\u003e'__ident_func__'\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\n    def \u003cspan class=\"token function\"\u003e__init__\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eself\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n        object\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003e__setattr__\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eself\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token string\"\u003e'__storage__'\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n        # 这里传递的 ident 就可以直接\n        object\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003e__setattr__\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eself\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token string\"\u003e'__ident_func__'\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e get_ident\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\n\u003cspan class=\"token keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eLocalStack\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n    # 用 local 实现的栈\n\n\u003cspan class=\"token keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eLocalProxy\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n    # 一个 local 的代理器\n    def \u003cspan class=\"token function\"\u003e__getattr__\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eself\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e name\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n    \u003cspan class=\"token keyword\"\u003eif\u003c/span\u003e name \u003cspan class=\"token operator\"\u003e==\u003c/span\u003e \u003cspan class=\"token string\"\u003e'__members__'\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n        \u003cspan class=\"token keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"token function\"\u003edir\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eself\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003e_get_current_object\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"token keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"token function\"\u003egetattr\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eself\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003e_get_current_object\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e name\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e即：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e当 Flask 以多线程模型运行的时候，则使用的是 threadlocal 方式\u003c/li\u003e\n\u003cli\u003e当 Flask 以 greenlet 的模型运行的时候，则使用的是 greenlet 区分不同\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e接下来回头看一下处理 request 的逻辑\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom flask \u003cspan class=\"token keyword\"\u003eimport\u003c/span\u003e request\n@app\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003eroute\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token string\"\u003e'/login'\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e methods\u003cspan class=\"token operator\"\u003e=\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003e\u003cspan class=\"token string\"\u003e'POST'\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token string\"\u003e'GET'\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\ndef \u003cspan class=\"token function\"\u003elogin\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n    # 这个 request 哪里来？\n    \u003cspan class=\"token keyword\"\u003eif\u003c/span\u003e request\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003emethod \u003cspan class=\"token operator\"\u003e==\u003c/span\u003e \u003cspan class=\"token string\"\u003e'POST'\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e\n        error \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e someerror\n    \u003cspan class=\"token keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"token function\"\u003erender_template\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token string\"\u003e'login.html'\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e error\u003cspan class=\"token operator\"\u003e=\u003c/span\u003eerror\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e于是，我们就知道了，当引用 request 这个 LocalProxy 的时候，引用的确实是同一个名称为 request 变量，并且这个变量也确实是 LocalProxy 的实例\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e但是当使用 request.method 的时候，LocalProxy 重载了 取到的则是另一个『请求对象』的 method.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e于是拿到当前请求的信息。\u003c/p\u003e\n\u003cp\u003e当然，其实我们也可以依据利用这个技巧写一个 currentuser 的 ProxyLocal, 然后在每个 view 层里面使用 user.has_something 进行操作。\u003c/p\u003e\n\u003ch2 id=\"0x03-问题-3-flask-中官方的机制\"\u003e\u003ca class=\"v-toc-item\" href=\"#0x03-问题-3-flask-中官方的机制\"\u003e#\u003c/a\u003e 0x03 问题 3: Flask 中官方的机制\u003c/h2\u003e\n\u003ch2 id=\"0x04-问题-3-flask-中是如何做到优雅扩展的\"\u003e\u003ca class=\"v-toc-item\" href=\"#0x04-问题-3-flask-中是如何做到优雅扩展的\"\u003e#\u003c/a\u003e 0x04 问题 3: Flask 中是如何做到优雅扩展的\u003c/h2\u003e\n\u003ch2 id=\"0x05-其他问题\"\u003e\u003ca class=\"v-toc-item\" href=\"#0x05-其他问题\"\u003e#\u003c/a\u003e 0x05 其他问题\u003c/h2\u003e\n\u003ch3 id=\"flask-应用\"\u003e\u003ca class=\"v-toc-item\" href=\"#flask-应用\"\u003e#\u003c/a\u003e Flask 应用\u003c/h3\u003e\n\u003chr\u003e\n\u003cp\u003eChangeLog:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e2018-03-09\u003c/strong\u003e 重修文字\u003c/li\u003e\n\u003c/ul\u003e\n","toc":"\u003cul class=\"v-article-toc\"\u003e\n\u003cli\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#0x00-%E5%89%8D%E8%A8%80\"\u003e0x00 前言\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#0x01-%E9%98%85%E8%AF%BB-flask-%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B8%80%E7%A7%8D%E8%BE%83%E5%A5%BD%E7%9A%84%E5%A7%BF%E5%8A%BF\"\u003e0x01 阅读 Flask 代码的一种较好的姿势\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#0x02-%E9%97%AE%E9%A2%98-1-%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA-web-%E6%A1%86%E6%9E%B6\"\u003e0x02 问题 1: 如何设计一个 Web 框架\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#%E5%A4%B4%E8%84%91%E9%A3%8E%E6%9A%B4\"\u003e头脑风暴\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E8%AE%BE%E8%AE%A1-web-%E6%A1%86%E6%9E%B6\"\u003e设计 Web 框架\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#0x02-%E9%97%AE%E9%A2%98-2-%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84\"\u003e0x02 问题 2: 请求流程是怎么样的\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#21-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%98%AF%E6%80%8E%E4%B9%88%E8%B5%B7%E6%9D%A5%E7%9A%84\"\u003e2.1 服务器是怎么起来的\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#22-%E8%AF%B7%E6%B1%82-%E5%93%8D%E5%BA%94%E7%9A%84%E6%B5%81%E7%A8%8B\"\u003e2.2 请求-响应的流程\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#0x02-%E9%97%AE%E9%A2%98-2-flask-%E4%B8%AD-context-%E6%9C%BA%E5%88%B6\"\u003e0x02 问题 2: Flask 中 Context 机制\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#0x03-%E9%97%AE%E9%A2%98-3-flask-%E4%B8%AD%E5%AE%98%E6%96%B9%E7%9A%84%E6%9C%BA%E5%88%B6\"\u003e0x03 问题 3: Flask 中官方的机制\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#0x04-%E9%97%AE%E9%A2%98-3-flask-%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E4%BC%98%E9%9B%85%E6%89%A9%E5%B1%95%E7%9A%84\"\u003e0x04 问题 3: Flask 中是如何做到优雅扩展的\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#0x05-%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98\"\u003e0x05 其他问题\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#flask-%E5%BA%94%E7%94%A8\"\u003eFlask 应用\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n"}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"Flask 源码初步解读"},"buildId":"oDi_oBCBuu3qj6v7hDnrL","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>