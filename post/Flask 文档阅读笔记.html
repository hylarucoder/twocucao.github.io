<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Flask 文档阅读笔记 | 海拉鲁编程客</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/49455a07b6dd33600cdf.css" as="style"/><link rel="stylesheet" href="/_next/static/css/49455a07b6dd33600cdf.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-a54b4f32bdc1ef890ddd.js"></script><script src="/_next/static/chunks/webpack-20d43e08bea62467b090.js" defer=""></script><script src="/_next/static/chunks/framework-0441fae7fd130f37dee1.js" defer=""></script><script src="/_next/static/chunks/main-4777350f2a9ff73ea2b0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-3050679c6e5142ffcaf5.js" defer=""></script><script src="/_next/static/chunks/ea88be26-9bcf6ead520f4ac26973.js" defer=""></script><script src="/_next/static/chunks/421-f2f33a86b546237f0325.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-173fe2de48c90365db9d.js" defer=""></script><script src="/_next/static/uCwe9m-iio9bnoWMgWDqE/_buildManifest.js" defer=""></script><script src="/_next/static/uCwe9m-iio9bnoWMgWDqE/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="v-page"><nav class="shadow"><div class="flex flex-col container mx-auto h-12 px-40 md:flex-row md:items-center md:justify-between"><div class="flex justify-between items-center"><div><a class="text-gray-800 text-xl md:text-xl leading-5" href="/">海拉鲁编程客</a></div><div><button type="button" class="block text-gray-800 hover:text-gray-600 focus:text-gray-600 focus:outline-none md:hidden"><svg viewBox="0 0 24 24" class="h-6 w-6 fill-current"><path d="M4 5h16a1 1 0 0 1 0 2H4a1 1 0 1 1 0-2zm0 6h16a1 1 0 0 1 0 2H4a1 1 0 0 1 0-2zm0 6h16a1 1 0 0 1 0 2H4a1 1 0 0 1 0-2z"></path></svg></button></div></div><div class="md:flex flex-col md:flex-row md:-mx-4 hidden"><a class="my-1 text-gray-800 hover:text-blue-500 md:mx-4 md:my-0" href="/">首页</a><a class="my-1 text-gray-800 hover:text-blue-500 md:mx-4 md:my-0" href="/archive">归档</a><a class="my-1 text-gray-800 hover:text-blue-500 md:mx-4 md:my-0" href="/about">关于我</a><button style="cursor:pointer;overflow:hidden;width:50px;height:23.5px;appearance:none;-moz-appearance:none;-webkit-appearance:none;border:none;background-color:transparent;padding:0" aria-hidden="true"><div style="display:flex;align-items:center;justify-content:center;margin-top:-28.749999999999996px;margin-left:-16px;width:82.5px;height:82.5px"><div></div></div></button></div></div></nav><div class="v-article"><div class="v-article-main" style="margin:auto;width:786px"><div><h2 id="0x00-前言"><a class="v-toc-item" href="#0x00-前言">#</a> 0x00 前言</h2>
<p>因为最近需要新增一个 Flask 技术栈，所以准备趁这休息的时候更新关于 Flask 的两篇文章。</p>
<p>前者是文档阅读笔记，后者是源码初步解析。</p>
<blockquote>
<p>嗯，其实这篇就是做了一些搬运的活。</p>
</blockquote>
<h2 id="0x01-文档"><a class="v-toc-item" href="#0x01-文档">#</a> 0x01 文档</h2>
<p>由于 Flask 还依赖 Jinja2 与 Werkzeug, 并且往往大家在使用 Flask 的时候还是会使用 itsdangerous. 所以，当大家说 Flask 代码少的时候，我还是不服的。但如果你说，Flask 本身实现确实是简洁，扩展性强，我还是服气的。</p>
<p>Flask 的文档有三种类型（其他框架类文档也是如此）：</p>
<ul>
<li>Tutorial 类，即教程类</li>
<li>Guide 类，即指南类</li>
<li>API 类，即接口级别的文档</li>
</ul>
<p>当你是一个老手，还想快速上手一个框架的时候，认真读一读前两者，然后挑选一个项目多看几遍即可。</p>
<p>但是当你深入到框架里面的设计与实现的时候，则必须要多读读 API Document , 由于通常情况下 API Document 的内容往往是代码中的注释，加上 Flask 代码量本来就不多。所以，有的时候阅读 Flask 代码代码也会比 API 好很多。</p>
<h2 id="0x02-guide"><a class="v-toc-item" href="#0x02-guide">#</a> 0x02 Guide</h2>
<h3 id="21-templates"><a class="v-toc-item" href="#21-templates">#</a> 2.1 Templates</h3>
<p>快速 Get 模板语言无非就是掌握：</p>
<ol>
<li>上下文变量</li>
<li>条件语法</li>
<li>列表语法</li>
<li>模板的继承 (extend 语法）与组合 (include)</li>
<li>额外的一些语法糖，比如 filter 的使用 / 组成</li>
</ol>
<h3 id="22-testing-flask-applications"><a class="v-toc-item" href="#22-testing-flask-applications">#</a> 2.2 Testing Flask Applications</h3>
<blockquote>
<p>Something that is untested is broken.</p>
</blockquote>
<p>这里的测试，有哪些测试呢？</p>
<ol>
<li>非 flask 相关逻辑的测试。比如，我对一小段无关于 View 层的纯粹的逻辑进行测试，我比较喜欢使用 pytest 进行测试。</li>
<li>Flask 相关</li>
</ol>
<ul>
<li>Setup</li>
<li>TearDown</li>
<li>登录前 / 登陆后</li>
</ul>
<h3 id="23-application-errors"><a class="v-toc-item" href="#23-application-errors">#</a> 2.3 Application Errors</h3>
<p>比如测试请求与响应结果。比如测试路由。测试某个与 View 层绑定的数据操作是否执行成功。</p>
<p>首先，大致扫一眼 tutorial ，知道了 Flask 的教程讲了如下的东西：</p>
<ol>
<li>路由</li>
<li>静态文件</li>
<li>模板渲染</li>
<li>接触请求数据</li>
<li>重定向和错误</li>
<li>响应</li>
<li>Session</li>
<li>Message Flash</li>
<li>日志</li>
<li>扩展</li>
</ol>
<p>当然，我们都是老手了，肯定是挑重点来看了。</p>
<p>Routing, 发现现在的问题在于</p>
<p>Flask 有两个主要依赖：</p>
<ul>
<li>路由、调试、WSGI</li>
<li>模板</li>
</ul>
<h2 id="0x02-社区支持"><a class="v-toc-item" href="#0x02-社区支持">#</a> 0x02 社区支持</h2>
<h2 id="0x04-读文档产生的疑问"><a class="v-toc-item" href="#0x04-读文档产生的疑问">#</a> 0x04 读文档产生的疑问</h2>
<ol>
<li></li>
</ol>
<p>For web applications it’s crucial to react to the data a client sends to the server. In Flask this information is provided by the global request object. If you have some experience with Python you might be wondering how that object can be global and how Flask manages to still be threadsafe. The answer is context locals:</p>
<p>Context Locals<br>
Insider Information<br>
If you want to understand how that works and how you can implement tests with context locals, read this section, otherwise just skip it.</p>
<p>Certain objects in Flask are global objects, but not of the usual kind. These objects are actually proxies to objects that are local to a specific context. What a mouthful. But that is actually quite easy to understand.</p>
<p>Imagine the context being the handling thread. A request comes in and the web server decides to spawn a new thread (or something else, the underlying object is capable of dealing with concurrency systems other than threads). When Flask starts its internal request handling it figures out that the current thread is the active context and binds the current application and the WSGI environments to that context (thread). It does that in an intelligent way so that one application can invoke another application without breaking.</p>
<p>So what does this mean to you? Basically you can completely ignore that this is the case unless you are doing something like unit testing. You will notice that code which depends on a request object will suddenly break because there is no request object. The solution is creating a request object yourself and binding it to the context. The easiest solution for unit testing is to use the test_request_context() context manager. In combination with the with statement it will bind a test request so that you can interact with it. Here is an example:</p>
<h3 id="thread-local"><a class="v-toc-item" href="#thread-local">#</a> Thread Local</h3>
<p>One of the design decisions in Flask was that simple tasks should be simple; they should not take a lot of code and yet they should not limit you. Because of that, Flask has a few design choices that some people might find surprising or unorthodox. For example, Flask uses thread-local objects internally so that you don’t have to pass objects around from function to function within a request in order to stay threadsafe. This approach is convenient, but requires a valid request context for dependency injection or when attempting to reuse code which uses a value pegged to the request. The Flask project is honest about thread-locals, does not hide them, and calls out in the code and documentation where they are used.</p>
</div></div><div><ul class="v-article-toc">
<li>
<ul>
<li><a href="#0x00-%E5%89%8D%E8%A8%80">0x00 前言</a></li>
<li><a href="#0x01-%E6%96%87%E6%A1%A3">0x01 文档</a></li>
<li><a href="#0x02-guide">0x02 Guide</a>
<ul>
<li><a href="#21-templates">2.1 Templates</a></li>
<li><a href="#22-testing-flask-applications">2.2 Testing Flask Applications</a></li>
<li><a href="#23-application-errors">2.3 Application Errors</a></li>
</ul>
</li>
<li><a href="#0x02-%E7%A4%BE%E5%8C%BA%E6%94%AF%E6%8C%81">0x02 社区支持</a></li>
<li><a href="#0x04-%E8%AF%BB%E6%96%87%E6%A1%A3%E4%BA%A7%E7%94%9F%E7%9A%84%E7%96%91%E9%97%AE">0x04 读文档产生的疑问</a>
<ul>
<li><a href="#thread-local">Thread Local</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"tags":["Python","Flask"],"path":"20180309_Flask文档阅读笔记.md","title":"Flask 文档阅读笔记","slug":"Flask 文档阅读笔记","date":"2018-03-09","category":"Flask","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\u003ch2 id=\"0x00-前言\"\u003e\u003ca class=\"v-toc-item\" href=\"#0x00-前言\"\u003e#\u003c/a\u003e 0x00 前言\u003c/h2\u003e\n\u003cp\u003e因为最近需要新增一个 Flask 技术栈，所以准备趁这休息的时候更新关于 Flask 的两篇文章。\u003c/p\u003e\n\u003cp\u003e前者是文档阅读笔记，后者是源码初步解析。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e嗯，其实这篇就是做了一些搬运的活。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"0x01-文档\"\u003e\u003ca class=\"v-toc-item\" href=\"#0x01-文档\"\u003e#\u003c/a\u003e 0x01 文档\u003c/h2\u003e\n\u003cp\u003e由于 Flask 还依赖 Jinja2 与 Werkzeug, 并且往往大家在使用 Flask 的时候还是会使用 itsdangerous. 所以，当大家说 Flask 代码少的时候，我还是不服的。但如果你说，Flask 本身实现确实是简洁，扩展性强，我还是服气的。\u003c/p\u003e\n\u003cp\u003eFlask 的文档有三种类型（其他框架类文档也是如此）：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTutorial 类，即教程类\u003c/li\u003e\n\u003cli\u003eGuide 类，即指南类\u003c/li\u003e\n\u003cli\u003eAPI 类，即接口级别的文档\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e当你是一个老手，还想快速上手一个框架的时候，认真读一读前两者，然后挑选一个项目多看几遍即可。\u003c/p\u003e\n\u003cp\u003e但是当你深入到框架里面的设计与实现的时候，则必须要多读读 API Document , 由于通常情况下 API Document 的内容往往是代码中的注释，加上 Flask 代码量本来就不多。所以，有的时候阅读 Flask 代码代码也会比 API 好很多。\u003c/p\u003e\n\u003ch2 id=\"0x02-guide\"\u003e\u003ca class=\"v-toc-item\" href=\"#0x02-guide\"\u003e#\u003c/a\u003e 0x02 Guide\u003c/h2\u003e\n\u003ch3 id=\"21-templates\"\u003e\u003ca class=\"v-toc-item\" href=\"#21-templates\"\u003e#\u003c/a\u003e 2.1 Templates\u003c/h3\u003e\n\u003cp\u003e快速 Get 模板语言无非就是掌握：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e上下文变量\u003c/li\u003e\n\u003cli\u003e条件语法\u003c/li\u003e\n\u003cli\u003e列表语法\u003c/li\u003e\n\u003cli\u003e模板的继承 (extend 语法）与组合 (include)\u003c/li\u003e\n\u003cli\u003e额外的一些语法糖，比如 filter 的使用 / 组成\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"22-testing-flask-applications\"\u003e\u003ca class=\"v-toc-item\" href=\"#22-testing-flask-applications\"\u003e#\u003c/a\u003e 2.2 Testing Flask Applications\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003eSomething that is untested is broken.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e这里的测试，有哪些测试呢？\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e非 flask 相关逻辑的测试。比如，我对一小段无关于 View 层的纯粹的逻辑进行测试，我比较喜欢使用 pytest 进行测试。\u003c/li\u003e\n\u003cli\u003eFlask 相关\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003eSetup\u003c/li\u003e\n\u003cli\u003eTearDown\u003c/li\u003e\n\u003cli\u003e登录前 / 登陆后\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"23-application-errors\"\u003e\u003ca class=\"v-toc-item\" href=\"#23-application-errors\"\u003e#\u003c/a\u003e 2.3 Application Errors\u003c/h3\u003e\n\u003cp\u003e比如测试请求与响应结果。比如测试路由。测试某个与 View 层绑定的数据操作是否执行成功。\u003c/p\u003e\n\u003cp\u003e首先，大致扫一眼 tutorial ，知道了 Flask 的教程讲了如下的东西：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e路由\u003c/li\u003e\n\u003cli\u003e静态文件\u003c/li\u003e\n\u003cli\u003e模板渲染\u003c/li\u003e\n\u003cli\u003e接触请求数据\u003c/li\u003e\n\u003cli\u003e重定向和错误\u003c/li\u003e\n\u003cli\u003e响应\u003c/li\u003e\n\u003cli\u003eSession\u003c/li\u003e\n\u003cli\u003eMessage Flash\u003c/li\u003e\n\u003cli\u003e日志\u003c/li\u003e\n\u003cli\u003e扩展\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e当然，我们都是老手了，肯定是挑重点来看了。\u003c/p\u003e\n\u003cp\u003eRouting, 发现现在的问题在于\u003c/p\u003e\n\u003cp\u003eFlask 有两个主要依赖：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e路由、调试、WSGI\u003c/li\u003e\n\u003cli\u003e模板\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"0x02-社区支持\"\u003e\u003ca class=\"v-toc-item\" href=\"#0x02-社区支持\"\u003e#\u003c/a\u003e 0x02 社区支持\u003c/h2\u003e\n\u003ch2 id=\"0x04-读文档产生的疑问\"\u003e\u003ca class=\"v-toc-item\" href=\"#0x04-读文档产生的疑问\"\u003e#\u003c/a\u003e 0x04 读文档产生的疑问\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eFor web applications it’s crucial to react to the data a client sends to the server. In Flask this information is provided by the global request object. If you have some experience with Python you might be wondering how that object can be global and how Flask manages to still be threadsafe. The answer is context locals:\u003c/p\u003e\n\u003cp\u003eContext Locals\u003cbr\u003e\nInsider Information\u003cbr\u003e\nIf you want to understand how that works and how you can implement tests with context locals, read this section, otherwise just skip it.\u003c/p\u003e\n\u003cp\u003eCertain objects in Flask are global objects, but not of the usual kind. These objects are actually proxies to objects that are local to a specific context. What a mouthful. But that is actually quite easy to understand.\u003c/p\u003e\n\u003cp\u003eImagine the context being the handling thread. A request comes in and the web server decides to spawn a new thread (or something else, the underlying object is capable of dealing with concurrency systems other than threads). When Flask starts its internal request handling it figures out that the current thread is the active context and binds the current application and the WSGI environments to that context (thread). It does that in an intelligent way so that one application can invoke another application without breaking.\u003c/p\u003e\n\u003cp\u003eSo what does this mean to you? Basically you can completely ignore that this is the case unless you are doing something like unit testing. You will notice that code which depends on a request object will suddenly break because there is no request object. The solution is creating a request object yourself and binding it to the context. The easiest solution for unit testing is to use the test_request_context() context manager. In combination with the with statement it will bind a test request so that you can interact with it. Here is an example:\u003c/p\u003e\n\u003ch3 id=\"thread-local\"\u003e\u003ca class=\"v-toc-item\" href=\"#thread-local\"\u003e#\u003c/a\u003e Thread Local\u003c/h3\u003e\n\u003cp\u003eOne of the design decisions in Flask was that simple tasks should be simple; they should not take a lot of code and yet they should not limit you. Because of that, Flask has a few design choices that some people might find surprising or unorthodox. For example, Flask uses thread-local objects internally so that you don’t have to pass objects around from function to function within a request in order to stay threadsafe. This approach is convenient, but requires a valid request context for dependency injection or when attempting to reuse code which uses a value pegged to the request. The Flask project is honest about thread-locals, does not hide them, and calls out in the code and documentation where they are used.\u003c/p\u003e\n","toc":"\u003cul class=\"v-article-toc\"\u003e\n\u003cli\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#0x00-%E5%89%8D%E8%A8%80\"\u003e0x00 前言\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#0x01-%E6%96%87%E6%A1%A3\"\u003e0x01 文档\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#0x02-guide\"\u003e0x02 Guide\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#21-templates\"\u003e2.1 Templates\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#22-testing-flask-applications\"\u003e2.2 Testing Flask Applications\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#23-application-errors\"\u003e2.3 Application Errors\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#0x02-%E7%A4%BE%E5%8C%BA%E6%94%AF%E6%8C%81\"\u003e0x02 社区支持\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#0x04-%E8%AF%BB%E6%96%87%E6%A1%A3%E4%BA%A7%E7%94%9F%E7%9A%84%E7%96%91%E9%97%AE\"\u003e0x04 读文档产生的疑问\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#thread-local\"\u003eThread Local\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n"}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"Flask 文档阅读笔记"},"buildId":"uCwe9m-iio9bnoWMgWDqE","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>