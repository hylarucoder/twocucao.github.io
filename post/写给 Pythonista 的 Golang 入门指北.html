<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>写给 Pythonista 的 Golang 入门指北 | 海拉鲁编程客</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/49455a07b6dd33600cdf.css" as="style"/><link rel="stylesheet" href="/_next/static/css/49455a07b6dd33600cdf.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-a54b4f32bdc1ef890ddd.js"></script><script src="/_next/static/chunks/webpack-20d43e08bea62467b090.js" defer=""></script><script src="/_next/static/chunks/framework-0441fae7fd130f37dee1.js" defer=""></script><script src="/_next/static/chunks/main-4777350f2a9ff73ea2b0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-3050679c6e5142ffcaf5.js" defer=""></script><script src="/_next/static/chunks/ea88be26-9bcf6ead520f4ac26973.js" defer=""></script><script src="/_next/static/chunks/421-f2f33a86b546237f0325.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-173fe2de48c90365db9d.js" defer=""></script><script src="/_next/static/oDi_oBCBuu3qj6v7hDnrL/_buildManifest.js" defer=""></script><script src="/_next/static/oDi_oBCBuu3qj6v7hDnrL/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="v-page"><nav class="shadow"><div class="flex flex-col container mx-auto h-12 px-40 md:flex-row md:items-center md:justify-between"><div class="flex justify-between items-center"><div><a class="text-gray-800 text-xl md:text-xl leading-5" href="/">海拉鲁编程客</a></div><div><button type="button" class="block text-gray-800 hover:text-gray-600 focus:text-gray-600 focus:outline-none md:hidden"><svg viewBox="0 0 24 24" class="h-6 w-6 fill-current"><path d="M4 5h16a1 1 0 0 1 0 2H4a1 1 0 1 1 0-2zm0 6h16a1 1 0 0 1 0 2H4a1 1 0 0 1 0-2zm0 6h16a1 1 0 0 1 0 2H4a1 1 0 0 1 0-2z"></path></svg></button></div></div><div class="md:flex flex-col md:flex-row md:-mx-4 hidden"><a class="my-1 text-gray-800 hover:text-blue-500 md:mx-4 md:my-0" href="/">首页</a><a class="my-1 text-gray-800 hover:text-blue-500 md:mx-4 md:my-0" href="/archive">归档</a><a class="my-1 text-gray-800 hover:text-blue-500 md:mx-4 md:my-0" href="/about">关于我</a><button style="cursor:pointer;overflow:hidden;width:50px;height:23.5px;appearance:none;-moz-appearance:none;-webkit-appearance:none;border:none;background-color:transparent;padding:0" aria-hidden="true"><div style="display:flex;align-items:center;justify-content:center;margin-top:-28.749999999999996px;margin-left:-16px;width:82.5px;height:82.5px"><div></div></div></button></div></div></nav><div class="v-article"><div class="v-article-main" style="margin:auto;width:786px"><div><p>原计划是去年 8 月份入 Golang 大法的，然后开一篇帖子进行写个入门指北来着。这一拖就拖到了今年。</p>
<p>同样是快速上手教程，这篇文章和其他的文章的不同点在于，完全假设你是 Pythonista 的入门。</p>
<h2 id="0x00-前言"><a class="v-toc-item" href="#0x00-前言">#</a> 0x00 前言</h2>
<h2 id="0x01-安装"><a class="v-toc-item" href="#0x01-安装">#</a> 0x01 安装</h2>
<p>Golang 安装</p>
<pre><code># 如果你是在 mac 上，建议先安装下面的 SDK 以防不测
open /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg
# 安装 golang
brew install golang
# 配置环境变量
echo $GOPATH # /Users/twocucao/Codes/ReposGo

cd /Users/twocucao/Codes/ReposPublic/

mkcd thanos # mkdir &amp;&amp; cd
go mod init github.com/twocucao/thanos
git remote add origin git@github.com:twocucao/thanos.git
</code></pre>
<p>接下来，需要解决卡 <a href="http://golang.org">golang.org</a> 的网络问题。</p>
<pre><code>export GOPROXY=https://goproxy.io
go get -v -u github.com/hqpko/go-mod-tidy
go mod tidy
</code></pre>
<p>接下来就是随便找一些带有依赖库的代码。放到该文件夹下面。</p>
<p>你也可以直接从这里 <a href="https://github.com/twocucao/thanos.git">https://github.com/twocucao/thanos.git</a> 拉取代码</p>
<h2 id="0x01-基本概念"><a class="v-toc-item" href="#0x01-基本概念">#</a> 0x01 基本概念</h2>
<h3 id="工具链"><a class="v-toc-item" href="#工具链">#</a> 工具链</h3>
<h3 id="文档"><a class="v-toc-item" href="#文档">#</a> 文档</h3>
<h3 id="社区"><a class="v-toc-item" href="#社区">#</a> 社区</h3>
<h3 id="书籍"><a class="v-toc-item" href="#书籍">#</a> 书籍</h3>
<h3 id="内置简单类型"><a class="v-toc-item" href="#内置简单类型">#</a> 内置简单类型</h3>
<p>对于一些基本的数据类型，操作为 加减乘除取余数位运算等等</p>
<ul>
<li>数字类型</li>
<li>布尔类型</li>
<li>字符串类型</li>
<li>数组 / 列表</li>
<li>字典</li>
</ul>
<h3 id="内置复杂类型"><a class="v-toc-item" href="#内置复杂类型">#</a> 内置复杂类型</h3>
<ul>
<li>集合结构 : 串</li>
<li>线性结构 : 线性表 （单链表，静态链表，循环链表，双向链表，<strong>栈，队列</strong>)</li>
<li>树形结构 : 树（二叉树，B+ 树，红黑树）</li>
<li>图形结构 : 图</li>
</ul>
<h3 id="对象"><a class="v-toc-item" href="#对象">#</a> 对象</h3>
<h3 id="字符串"><a class="v-toc-item" href="#字符串">#</a> 字符串</h3>
<h2 id="0x02-中级概念"><a class="v-toc-item" href="#0x02-中级概念">#</a> 0x02 中级概念</h2>
<h3 id="函数"><a class="v-toc-item" href="#函数">#</a> 函数</h3>
<h4 id="作用域"><a class="v-toc-item" href="#作用域">#</a> 作用域</h4>
<h3 id="模块"><a class="v-toc-item" href="#模块">#</a> 模块</h3>
<p>模块，这个概念，可大可小，大的时候，把一个程序说成是模块，小的时候，可以把一个文件，甚至你说这一个函数是一个模块，也行。</p>
<p>这里的模块指的是一个包下的函数。</p>
<h3 id="面向对象"><a class="v-toc-item" href="#面向对象">#</a> 面向对象</h3>
<p>面向对象有三大概念：</p>
<ul>
<li>封装</li>
<li>继承</li>
<li>多态</li>
</ul>
<h3 id="错误-调试测试"><a class="v-toc-item" href="#错误-调试测试">#</a> 错误 / 调试测试</h3>
<p>异常处理实际上可以考验一个程序员编写代码的健壮性。</p>
<p>事实上来说，代码写的健壮是一个程序员必备的素养。但其实在开发过程中，出于对项目进行赶工上线，需要对程序的健壮性做出一定的取舍。并且，在编写客户端，服务端，网页前端的时候基本上都会遇到这个问题。什么时候选择健壮的程序，什么时候选择是还可以的程序。需要自己的经验。</p>
<h3 id="io-编程"><a class="v-toc-item" href="#io-编程">#</a> IO 编程</h3>
<h3 id="进程和线程"><a class="v-toc-item" href="#进程和线程">#</a> 进程和线程</h3>
<h4 id="多线程"><a class="v-toc-item" href="#多线程">#</a> 多线程</h4>
<blockquote>
<p>Go 多线程约等于并发。</p>
</blockquote>
<h4 id="多进程"><a class="v-toc-item" href="#多进程">#</a> 多进程</h4>
<h5 id="协同式多任务处理"><a class="v-toc-item" href="#协同式多任务处理">#</a> 协同式多任务处理</h5>
<p>如果有两个线程，同时进行 IO 请求，当其中一个线程连接之后，立即会<strong>主动让出 GIL</strong>, 其他线程就可以运行。</p>
<blockquote>
<p>当 N 个线程在网络 I/O 堵塞，或等待重新获取 GIL，而一个线程运行 Python。</p>
</blockquote>
<p>让出之后还要执行代码呀，所以要有个收回 GIL 的动作。</p>
<h5 id="抢占式多任务处理"><a class="v-toc-item" href="#抢占式多任务处理">#</a> 抢占式多任务处理</h5>
<h5 id="线程安全"><a class="v-toc-item" href="#线程安全">#</a> 线程安全</h5>
<p>原子操作：sort 之类不需要<br>
非原子操作：n=n+2 的字节码分为 加载 n , 加载 2 , 相加，存储 n, 四个步骤，由于不是原子性，很可能被由于 15 ms 而被打断。</p>
<p>当然，懒人一向是 : <strong>优先级不决加括号，线程不决加 lock</strong></p>
<p>对于 Java, 程序员努力在尽可能短的时间内加锁存取共享数据，减轻线程的争夺，实现最大并行。但 Python 中，线程无法并行运行，细粒度的锁就没有了优势。</p>
<h3 id="正则表达式"><a class="v-toc-item" href="#正则表达式">#</a> 正则表达式</h3>
<h2 id="0x03-高级技巧"><a class="v-toc-item" href="#0x03-高级技巧">#</a> 0x03 高级技巧</h2>
<h2 id="0x04-标准库"><a class="v-toc-item" href="#0x04-标准库">#</a> 0x04 标准库</h2>
<h3 id="常用内建模块"><a class="v-toc-item" href="#常用内建模块">#</a> 常用内建模块</h3>
<h3 id="系统化模块"><a class="v-toc-item" href="#系统化模块">#</a> 系统化模块</h3>
<h2 id="0x05-第三方库"><a class="v-toc-item" href="#0x05-第三方库">#</a> 0x05 第三方库</h2>
<ul>
<li>Requests : API 人性化</li>
</ul>
<h2 id="0x06-代码质量"><a class="v-toc-item" href="#0x06-代码质量">#</a> 0x06 代码质量</h2>
<h3 id="正确性"><a class="v-toc-item" href="#正确性">#</a> 正确性</h3>
<h3 id="可维护性"><a class="v-toc-item" href="#可维护性">#</a> 可维护性</h3>
<h3 id="可读性"><a class="v-toc-item" href="#可读性">#</a> 可读性</h3>
<h3 id="安全性"><a class="v-toc-item" href="#安全性">#</a> 安全性</h3>
<h3 id="性能"><a class="v-toc-item" href="#性能">#</a> 性能</h3>
<h2 id="0x07-常用命令"><a class="v-toc-item" href="#0x07-常用命令">#</a> 0x07 常用命令</h2>
<pre><code>go build
go install -v
go clean
go fmt
go get
go test
go tool fix . # 修复老代码到新版本
go tool vet directory|files
go tool yacc -o gopher.go -p parser gopher.y
godoc -http=:8080
go version 查看 go 当前的版本
go env 查看当前 go 的环境变量
go list 列出当前全部安装的 package
go run 编译并运行 Go 程序
</code></pre>
<h2 id="0xee-文章更新"><a class="v-toc-item" href="#0xee-文章更新">#</a> 0xEE 文章更新</h2>
<pre><code># 如果你是在 mac 上，建议先安装下面的 SDK 以防不测
open /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg

</code></pre>
<h1 id="golang"><a class="v-toc-item" href="#golang">#</a> Golang</h1>
<h2 id="模块-01go-语言实践-runtime"><a class="v-toc-item" href="#模块-01go-语言实践-runtime">#</a> 模块 01：Go 语言实践 - Runtime</h2>
<h3 id="goroutine-的调度原理"><a class="v-toc-item" href="#goroutine-的调度原理">#</a> Goroutine 的调度原理</h3>
<ul>
<li>Goroutine 和线程的区别</li>
<li>Goroutine 的实现、GPM 调度模型、调度状态及流转、调度原理、协作式抢占以及和网络库的协作</li>
</ul>
<p><a href="https://www.jianshu.com/p/105719434c29">https://www.jianshu.com/p/105719434c29</a></p>
<p><a href="https://zboya.github.io/post/go_scheduler/">https://zboya.github.io/post/go_scheduler/</a></p>
<p><a href="https://studygolang.com/articles/16407">https://studygolang.com/articles/16407</a></p>
<h3 id="内存模型"><a class="v-toc-item" href="#内存模型">#</a> 内存模型</h3>
<p>Go 的内存分配机制<br>
Go 内存分配的内部结构和分配机制</p>
<p><a href="https://deepu.tech/memory-management-in-golang/">https://deepu.tech/memory-management-in-golang/</a></p>
<p><a href="https://medium.com/a-journey-with-go/go-memory-management-and-allocation-a7396d430f44">https://medium.com/a-journey-with-go/go-memory-management-and-allocation-a7396d430f44</a></p>
<h3 id="gc垃圾回收的原理"><a class="v-toc-item" href="#gc垃圾回收的原理">#</a> GC（垃圾回收）的原理</h3>
<p>GC 三色标记算法</p>
<p><a href="https://blog.golang.org/ismmkeynote">https://blog.golang.org/ismmkeynote</a></p>
<p>GC 介绍、三色标记的实现原理、GC 的流程以及 GC 的一些优化方案</p>
<h3 id="channel-的消息通讯原理"><a class="v-toc-item" href="#channel-的消息通讯原理">#</a> channel 的消息通讯原理</h3>
<p>channel 的底层实现<br>
channel 的通讯机制、环形队列的结构、调度和唤醒的原理</p>
<p><a href="https://stackoverflow.com/questions/19621149/how-are-go-channels-implemented">https://stackoverflow.com/questions/19621149/how-are-go-channels-implemented</a></p>
<h2 id="模块-02go-语言实践-并行编程"><a class="v-toc-item" href="#模块-02go-语言实践-并行编程">#</a> 模块 02：Go 语言实践 - 并行编程</h2>
<h3 id="memory-model"><a class="v-toc-item" href="#memory-model">#</a> Memory Model</h3>
<p>Go 中内存模型和同步语义</p>
<p><a href="https://zhuanlan.zhihu.com/p/110032965">https://zhuanlan.zhihu.com/p/110032965</a><br>
<a href="https://golang.org/ref/mem">https://golang.org/ref/mem</a><br>
<a href="https://golang.org/doc/">https://golang.org/doc/</a></p>
<p>内存模型：Happens Before、同步语义、channel 通讯、锁</p>
<h3 id="并发特性并发编程模式"><a class="v-toc-item" href="#并发特性并发编程模式">#</a> 并发特性并发编程模式</h3>
<p><a href="https://blog.golang.org/pipelines">https://blog.golang.org/pipelines</a></p>
<p>Timeout、Pipeline、Cancellation、Fanout、errgroup 等模式<br>
利用 channel 完成并行开发的设计模式，包含超时控制、管道、扇出、errgroup 并发<br>
无法熟练使用基于 channel 通讯方式的并行编程模式</p>
<h3 id="context-的原理并掌握其使用方法"><a class="v-toc-item" href="#context-的原理并掌握其使用方法">#</a> Context 的原理并掌握其使用方法</h3>
<p>Context 传播式传递有什么意义<br>
使用 Go 标准库 Context 的原理和最佳实践，包含超时控制、元数据传递、生命周期控制</p>
<p><a href="https://blog.golang.org/context">https://blog.golang.org/context</a><br>
<a href="https://levelup.gitconnected.com/context-in-golang-98908f042a57">https://levelup.gitconnected.com/context-in-golang-98908f042a57</a></p>
<h2 id="模块-03go-语言实践-网络编程"><a class="v-toc-item" href="#模块-03go-语言实践-网络编程">#</a> 模块 03：Go 语言实践 - 网络编程</h2>
<h3 id="golang-tcp-网络编程"><a class="v-toc-item" href="#golang-tcp-网络编程">#</a> Golang TCP 网络编程</h3>
<p>Go 实现高性能的 TCP Server</p>
<p>goim 项目了解 Go 语言中 TCP Server 的基础库和性能优化方案</p>
<h3 id="golang-http-网络编程"><a class="v-toc-item" href="#golang-http-网络编程">#</a> Golang HTTP 网络编程</h3>
<p>HTTP 框架选型<br>
针对业务需求对 HTTP 框架做针对性的扩展<br>
结合 gin 项目了解 Go 语言中的 HTTP Server 的基础库和框架</p>
<h2 id="模块-04go-语言实践-异常处理"><a class="v-toc-item" href="#模块-04go-语言实践-异常处理">#</a> 模块 04：Go 语言实践 - 异常处理</h2>
<h3 id="error-的处理方法"><a class="v-toc-item" href="#error-的处理方法">#</a> error 的处理方法</h3>
<h3 id="业务错误的处理方法"><a class="v-toc-item" href="#业务错误的处理方法">#</a> 业务错误的处理方法</h3>
<p>error 的处理复杂，不会正确使用<br>
业务错误定义和 error 整合难度较高</p>
<p>Go 语言中的 error 处理实践：检查错误、定义错误、追加上下文<br>
Go 项目中的业务错误码如何结合 error 的最佳实践</p>
<h2 id="模块-05go-工程化实践"><a class="v-toc-item" href="#模块-05go-工程化实践">#</a> 模块 05：Go 工程化实践</h2>
<h3 id="良好的项目目录组织原则和规范"><a class="v-toc-item" href="#良好的项目目录组织原则和规范">#</a> 良好的项目目录组织原则和规范</h3>
<h3 id="api-的设计方法和规范"><a class="v-toc-item" href="#api-的设计方法和规范">#</a> API 的设计方法和规范</h3>
<h3 id="package-的管理和设计方法"><a class="v-toc-item" href="#package-的管理和设计方法">#</a> Package 的管理和设计方法</h3>
<h3 id="单元测试"><a class="v-toc-item" href="#单元测试">#</a> 单元测试</h3>
<ol>
<li>
<p>Go 项目的标准化管理</p>
</li>
<li>
<p>设计 API</p>
</li>
<li>
<p>包管理</p>
</li>
<li>
<p>良好的 Go 项目中的分层目录结构组织和代码规范</p>
</li>
<li>
<p>Go 项目中 API 的设计原则和方法：定义、状态和业务错误码处理</p>
</li>
<li>
<p>Go 项目中包的设计和最佳实践、go mod 的使用</p>
</li>
<li>
<p>go test 工具链的使用方法、单元测试的最佳实践以及 Mock 技术</p>
</li>
</ol>
<h2 id="模块-06go-架构实践-分布式架构前端负载均衡"><a class="v-toc-item" href="#模块-06go-架构实践-分布式架构前端负载均衡">#</a> 模块 06：Go 架构实践 - 分布式架构（前端负载均衡）</h2>
<h3 id="高可用-dns-的最佳实践"><a class="v-toc-item" href="#高可用-dns-的最佳实践">#</a> 高可用 DNS 的最佳实践</h3>
<h3 id="cdn-的架构和应用场景"><a class="v-toc-item" href="#cdn-的架构和应用场景">#</a> CDN 的架构和应用场景</h3>
<h3 id="深入理解-47-层负载均衡的原理"><a class="v-toc-item" href="#深入理解-47-层负载均衡的原理">#</a> 深入理解 4/7 层负载均衡的原理</h3>
<p>在线服务的全链路视野<br>
应用服务上层的负载均衡</p>
<p>DNS 的原理、防劫持的方法、HTTPDNS + IP 长连接<br>
CDN 的系统架构、应用领域以及保证数据一致性的方法<br>
LVS、Nginx 4/7 层负载均衡的原理和实践</p>
<h2 id="模块-07go-架构实践-分布式架构数据分片"><a class="v-toc-item" href="#模块-07go-架构实践-分布式架构数据分片">#</a> 模块 07：Go 架构实践 - 分布式架构（数据分片）</h2>
<h3 id="数据-sharding-的设计原则"><a class="v-toc-item" href="#数据-sharding-的设计原则">#</a> 数据 Sharding 的设计原则</h3>
<h3 id="了解-hash-分片的算法和演进历史"><a class="v-toc-item" href="#了解-hash-分片的算法和演进历史">#</a> 了解 Hash 分片的算法和演进历史</h3>
<p>Sharding 的应用场景，不会合理使用<br>
Hash 算法的使用场景</p>
<p>数据分片设计，如：分库分表、多活的 Shard 设计等等<br>
分片算法的 Hash 实现和演进：Hash 求余、一致性 Hash、有界负载一致性 Hash、节点映射</p>
<h2 id="模块-08go-架构实践-微服务微服务概览与治理"><a class="v-toc-item" href="#模块-08go-架构实践-微服务微服务概览与治理">#</a> 模块 08：Go 架构实践 - 微服务（微服务概览与治理）</h2>
<h3 id="微服务的演进历史及优缺点"><a class="v-toc-item" href="#微服务的演进历史及优缺点">#</a> 微服务的演进历史及优缺点</h3>
<h3 id="微服务的设计方法"><a class="v-toc-item" href="#微服务的设计方法">#</a> 微服务的设计方法</h3>
<h3 id="微服务中-rpc-的底层原理"><a class="v-toc-item" href="#微服务中-rpc-的底层原理">#</a> 微服务中 RPC 的底层原理</h3>
<p>微服务的服务角色：API Gateway、BFF 还是 Service？<br>
微服务拆分<br>
RPC 的原理，不知道如何进行微服务 RPC 框架的选型</p>
<p>微服务的原理、概念，以及微服务的实现细节<br>
API Gateway、BFF、Service 等概念精讲<br>
微服务通讯 RPC 框架的细节和选型</p>
<h2 id="模块-09go-架构实践-微服务可用性设计"><a class="v-toc-item" href="#模块-09go-架构实践-微服务可用性设计">#</a> 模块 09：Go 架构实践 - 微服务（可用性设计）</h2>
<h3 id="可用性设计的最佳实践"><a class="v-toc-item" href="#可用性设计的最佳实践">#</a> 可用性设计的最佳实践</h3>
<h3 id="可用性设计的几大关键点隔离-超时控制-过载保护-限流-容错-重试"><a class="v-toc-item" href="#可用性设计的几大关键点隔离-超时控制-过载保护-限流-容错-重试">#</a> 可用性设计的几大关键点：隔离、超时控制、过载保护、限流、容错 &amp; 重试</h3>
<p>如何设计高可用的分布式服务<br>
何提升服务自愈能力</p>
<p>微服务的隔离实现，以及架构设计中的隔离实现<br>
进程内超时控制和跨进程超时控制<br>
程序自保护避免过载，抛弃一定的流量完成自适应限流<br>
单机限流、多租户场景的分布式限流<br>
节点故障的容错逻辑、重试容错的策略和设计</p>
<h2 id="模块-10go-架构实践-中间件日志-指标-链路追踪"><a class="v-toc-item" href="#模块-10go-架构实践-中间件日志-指标-链路追踪">#</a> 模块 10：Go 架构实践 - 中间件（日志、指标、链路追踪）</h2>
<h3 id="日志收集"><a class="v-toc-item" href="#日志收集">#</a> 日志收集</h3>
<h3 id="监控指标体系"><a class="v-toc-item" href="#监控指标体系">#</a> 监控指标体系</h3>
<h3 id="分布式链路追踪"><a class="v-toc-item" href="#分布式链路追踪">#</a> 分布式链路追踪</h3>
<p>如何解决微服务的可观测性难题<br>
怎么做微服务的可视化和标准化<br>
出故障后，难以对微服务进行问题诊断</p>
<p>实现一个可以集中收集所有微服务实例的日志，并能统一查看和检索的日志采集架构<br>
指标监控、使用 Prometheus 解决监控可视化、指标采集<br>
微服务中的跨服务性能问题诊断，结合 Jaeger 实现分布式链路追踪</p>
<h2 id="模块-11go-架构实践-中间件缓存-数据库"><a class="v-toc-item" href="#模块-11go-架构实践-中间件缓存-数据库">#</a> 模块 11：Go 架构实践 - 中间件（缓存、数据库）</h2>
<h3 id="redis-memcache-的原理和实战技巧"><a class="v-toc-item" href="#redis-memcache-的原理和实战技巧">#</a> Redis、Memcache 的原理和实战技巧</h3>
<h3 id="mysql-的常用设计和优化方法"><a class="v-toc-item" href="#mysql-的常用设计和优化方法">#</a> MySQL 的常用设计和优化方法</h3>
<ol>
<li>
<p>解决缓存的一致性问题</p>
</li>
<li>
<p>怎样合理地设计 MySQL 的表</p>
</li>
<li>
<p>Redis、Memcache 的应用场景、最佳实践，以及缓存的一致性设计</p>
</li>
<li>
<p>MySQL 的表设计、常用优化手段，以及如何解决分布式事务</p>
</li>
</ol>
<h2 id="模块-12go-架构实践-中间件消息队列-服务发现"><a class="v-toc-item" href="#模块-12go-架构实践-中间件消息队列-服务发现">#</a> 模块 12：Go 架构实践 - 中间件（消息队列、服务发现）</h2>
<h3 id="深入理解消息队列的原理掌握基于消息队列的架构设计方法"><a class="v-toc-item" href="#深入理解消息队列的原理掌握基于消息队列的架构设计方法">#</a> 深入理解消息队列的原理，掌握基于消息队列的架构设计方法</h3>
<h3 id="服务发现原理-选型策略以及服务发现实现的微服务多租户架构"><a class="v-toc-item" href="#服务发现原理-选型策略以及服务发现实现的微服务多租户架构">#</a> 服务发现原理、选型策略，以及服务发现实现的微服务多租户架构</h3>
<ol>
<li>
<p>消息解耦的架构设计</p>
</li>
<li>
<p>如何实现服务发现对平滑发布的支持</p>
</li>
<li>
<p>怎样利用多租户实现多测试环境</p>
</li>
<li>
<p>Kafka 的实现原理、异步消息系统的架构设计</p>
</li>
<li>
<p>RPC 服务发现、动态地址的选型和实现原理，以及基于服务发现的平滑重启和多租户架构</p>
</li>
</ol>
<hr>
<p>ChangeLog:</p>
<ul>
<li><strong>2018-08-22</strong> 初始化接口</li>
</ul>
</div></div><div><ul class="v-article-toc">
<li>
<ul>
<li><a href="#0x00-%E5%89%8D%E8%A8%80">0x00 前言</a></li>
<li><a href="#0x01-%E5%AE%89%E8%A3%85">0x01 安装</a></li>
<li><a href="#0x01-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">0x01 基本概念</a>
<ul>
<li><a href="#%E5%B7%A5%E5%85%B7%E9%93%BE">工具链</a></li>
<li><a href="#%E6%96%87%E6%A1%A3">文档</a></li>
<li><a href="#%E7%A4%BE%E5%8C%BA">社区</a></li>
<li><a href="#%E4%B9%A6%E7%B1%8D">书籍</a></li>
<li><a href="#%E5%86%85%E7%BD%AE%E7%AE%80%E5%8D%95%E7%B1%BB%E5%9E%8B">内置简单类型</a></li>
<li><a href="#%E5%86%85%E7%BD%AE%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B">内置复杂类型</a></li>
<li><a href="#%E5%AF%B9%E8%B1%A1">对象</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a></li>
</ul>
</li>
<li><a href="#0x02-%E4%B8%AD%E7%BA%A7%E6%A6%82%E5%BF%B5">0x02 中级概念</a>
<ul>
<li><a href="#%E5%87%BD%E6%95%B0">函数</a>
<ul>
<li><a href="#%E4%BD%9C%E7%94%A8%E5%9F%9F">作用域</a></li>
</ul>
</li>
<li><a href="#%E6%A8%A1%E5%9D%97">模块</a></li>
<li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">面向对象</a></li>
<li><a href="#%E9%94%99%E8%AF%AF-%E8%B0%83%E8%AF%95%E6%B5%8B%E8%AF%95">错误 / 调试测试</a></li>
<li><a href="#io-%E7%BC%96%E7%A8%8B">IO 编程</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B">进程和线程</a>
<ul>
<li><a href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B">多线程</a></li>
<li><a href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B">多进程</a>
<ul>
<li><a href="#%E5%8D%8F%E5%90%8C%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86">协同式多任务处理</a></li>
<li><a href="#%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86">抢占式多任务处理</a></li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8">线程安全</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">正则表达式</a></li>
</ul>
</li>
<li><a href="#0x03-%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7">0x03 高级技巧</a></li>
<li><a href="#0x04-%E6%A0%87%E5%87%86%E5%BA%93">0x04 标准库</a>
<ul>
<li><a href="#%E5%B8%B8%E7%94%A8%E5%86%85%E5%BB%BA%E6%A8%A1%E5%9D%97">常用内建模块</a></li>
<li><a href="#%E7%B3%BB%E7%BB%9F%E5%8C%96%E6%A8%A1%E5%9D%97">系统化模块</a></li>
</ul>
</li>
<li><a href="#0x05-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93">0x05 第三方库</a></li>
<li><a href="#0x06-%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F">0x06 代码质量</a>
<ul>
<li><a href="#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确性</a></li>
<li><a href="#%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7">可维护性</a></li>
<li><a href="#%E5%8F%AF%E8%AF%BB%E6%80%A7">可读性</a></li>
<li><a href="#%E5%AE%89%E5%85%A8%E6%80%A7">安全性</a></li>
<li><a href="#%E6%80%A7%E8%83%BD">性能</a></li>
</ul>
</li>
<li><a href="#0x07-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4">0x07 常用命令</a></li>
<li><a href="#0xee-%E6%96%87%E7%AB%A0%E6%9B%B4%E6%96%B0">0xEE 文章更新</a></li>
</ul>
</li>
<li><a href="#golang">Golang</a>
<ul>
<li><a href="#%E6%A8%A1%E5%9D%97-01go-%E8%AF%AD%E8%A8%80%E5%AE%9E%E8%B7%B5-runtime">模块 01：Go 语言实践 - Runtime</a>
<ul>
<li><a href="#goroutine-%E7%9A%84%E8%B0%83%E5%BA%A6%E5%8E%9F%E7%90%86">Goroutine 的调度原理</a></li>
<li><a href="#%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B">内存模型</a></li>
<li><a href="#gc%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%8E%9F%E7%90%86">GC（垃圾回收）的原理</a></li>
<li><a href="#channel-%E7%9A%84%E6%B6%88%E6%81%AF%E9%80%9A%E8%AE%AF%E5%8E%9F%E7%90%86">channel 的消息通讯原理</a></li>
</ul>
</li>
<li><a href="#%E6%A8%A1%E5%9D%97-02go-%E8%AF%AD%E8%A8%80%E5%AE%9E%E8%B7%B5-%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B">模块 02：Go 语言实践 - 并行编程</a>
<ul>
<li><a href="#memory-model">Memory Model</a></li>
<li><a href="#%E5%B9%B6%E5%8F%91%E7%89%B9%E6%80%A7%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F">并发特性并发编程模式</a></li>
<li><a href="#context-%E7%9A%84%E5%8E%9F%E7%90%86%E5%B9%B6%E6%8E%8C%E6%8F%A1%E5%85%B6%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">Context 的原理并掌握其使用方法</a></li>
</ul>
</li>
<li><a href="#%E6%A8%A1%E5%9D%97-03go-%E8%AF%AD%E8%A8%80%E5%AE%9E%E8%B7%B5-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B">模块 03：Go 语言实践 - 网络编程</a>
<ul>
<li><a href="#golang-tcp-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B">Golang TCP 网络编程</a></li>
<li><a href="#golang-http-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B">Golang HTTP 网络编程</a></li>
</ul>
</li>
<li><a href="#%E6%A8%A1%E5%9D%97-04go-%E8%AF%AD%E8%A8%80%E5%AE%9E%E8%B7%B5-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">模块 04：Go 语言实践 - 异常处理</a>
<ul>
<li><a href="#error-%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95">error 的处理方法</a></li>
<li><a href="#%E4%B8%9A%E5%8A%A1%E9%94%99%E8%AF%AF%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95">业务错误的处理方法</a></li>
</ul>
</li>
<li><a href="#%E6%A8%A1%E5%9D%97-05go-%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%AE%9E%E8%B7%B5">模块 05：Go 工程化实践</a>
<ul>
<li><a href="#%E8%89%AF%E5%A5%BD%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E7%BB%84%E7%BB%87%E5%8E%9F%E5%88%99%E5%92%8C%E8%A7%84%E8%8C%83">良好的项目目录组织原则和规范</a></li>
<li><a href="#api-%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%E5%92%8C%E8%A7%84%E8%8C%83">API 的设计方法和规范</a></li>
<li><a href="#package-%E7%9A%84%E7%AE%A1%E7%90%86%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95">Package 的管理和设计方法</a></li>
<li><a href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">单元测试</a></li>
</ul>
</li>
<li><a href="#%E6%A8%A1%E5%9D%97-06go-%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5-%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E5%89%8D%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">模块 06：Go 架构实践 - 分布式架构（前端负载均衡）</a>
<ul>
<li><a href="#%E9%AB%98%E5%8F%AF%E7%94%A8-dns-%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5">高可用 DNS 的最佳实践</a></li>
<li><a href="#cdn-%E7%9A%84%E6%9E%B6%E6%9E%84%E5%92%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">CDN 的架构和应用场景</a></li>
<li><a href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-47-%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E5%8E%9F%E7%90%86">深入理解 4/7 层负载均衡的原理</a></li>
</ul>
</li>
<li><a href="#%E6%A8%A1%E5%9D%97-07go-%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5-%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87">模块 07：Go 架构实践 - 分布式架构（数据分片）</a>
<ul>
<li><a href="#%E6%95%B0%E6%8D%AE-sharding-%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99">数据 Sharding 的设计原则</a></li>
<li><a href="#%E4%BA%86%E8%A7%A3-hash-%E5%88%86%E7%89%87%E7%9A%84%E7%AE%97%E6%B3%95%E5%92%8C%E6%BC%94%E8%BF%9B%E5%8E%86%E5%8F%B2">了解 Hash 分片的算法和演进历史</a></li>
</ul>
</li>
<li><a href="#%E6%A8%A1%E5%9D%97-08go-%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A6%82%E8%A7%88%E4%B8%8E%E6%B2%BB%E7%90%86">模块 08：Go 架构实践 - 微服务（微服务概览与治理）</a>
<ul>
<li><a href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%BC%94%E8%BF%9B%E5%8E%86%E5%8F%B2%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9">微服务的演进历史及优缺点</a></li>
<li><a href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95">微服务的设计方法</a></li>
<li><a href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%AD-rpc-%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86">微服务中 RPC 的底层原理</a></li>
</ul>
</li>
<li><a href="#%E6%A8%A1%E5%9D%97-09go-%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%8F%AF%E7%94%A8%E6%80%A7%E8%AE%BE%E8%AE%A1">模块 09：Go 架构实践 - 微服务（可用性设计）</a>
<ul>
<li><a href="#%E5%8F%AF%E7%94%A8%E6%80%A7%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5">可用性设计的最佳实践</a></li>
<li><a href="#%E5%8F%AF%E7%94%A8%E6%80%A7%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%87%A0%E5%A4%A7%E5%85%B3%E9%94%AE%E7%82%B9%E9%9A%94%E7%A6%BB-%E8%B6%85%E6%97%B6%E6%8E%A7%E5%88%B6-%E8%BF%87%E8%BD%BD%E4%BF%9D%E6%8A%A4-%E9%99%90%E6%B5%81-%E5%AE%B9%E9%94%99-%E9%87%8D%E8%AF%95">可用性设计的几大关键点：隔离、超时控制、过载保护、限流、容错 &amp; 重试</a></li>
</ul>
</li>
<li><a href="#%E6%A8%A1%E5%9D%97-10go-%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5-%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%97%A5%E5%BF%97-%E6%8C%87%E6%A0%87-%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA">模块 10：Go 架构实践 - 中间件（日志、指标、链路追踪）</a>
<ul>
<li><a href="#%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86">日志收集</a></li>
<li><a href="#%E7%9B%91%E6%8E%A7%E6%8C%87%E6%A0%87%E4%BD%93%E7%B3%BB">监控指标体系</a></li>
<li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA">分布式链路追踪</a></li>
</ul>
</li>
<li><a href="#%E6%A8%A1%E5%9D%97-11go-%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5-%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%BC%93%E5%AD%98-%E6%95%B0%E6%8D%AE%E5%BA%93">模块 11：Go 架构实践 - 中间件（缓存、数据库）</a>
<ul>
<li><a href="#redis-memcache-%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E6%88%98%E6%8A%80%E5%B7%A7">Redis、Memcache 的原理和实战技巧</a></li>
<li><a href="#mysql-%E7%9A%84%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E5%92%8C%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95">MySQL 的常用设计和优化方法</a></li>
</ul>
</li>
<li><a href="#%E6%A8%A1%E5%9D%97-12go-%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5-%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0">模块 12：Go 架构实践 - 中间件（消息队列、服务发现）</a>
<ul>
<li><a href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%8E%9F%E7%90%86%E6%8E%8C%E6%8F%A1%E5%9F%BA%E4%BA%8E%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95">深入理解消息队列的原理，掌握基于消息队列的架构设计方法</a></li>
<li><a href="#%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E5%8E%9F%E7%90%86-%E9%80%89%E5%9E%8B%E7%AD%96%E7%95%A5%E4%BB%A5%E5%8F%8A%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%A4%9A%E7%A7%9F%E6%88%B7%E6%9E%B6%E6%9E%84">服务发现原理、选型策略，以及服务发现实现的微服务多租户架构</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"tags":["Golang","CheatSheat"],"path":"20180829_GoLang.md","title":"写给 Pythonista 的 Golang 入门指北","slug":"写给 Pythonista 的 Golang 入门指北","date":"2018-08-29","category":"Golang","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\u003cp\u003e原计划是去年 8 月份入 Golang 大法的，然后开一篇帖子进行写个入门指北来着。这一拖就拖到了今年。\u003c/p\u003e\n\u003cp\u003e同样是快速上手教程，这篇文章和其他的文章的不同点在于，完全假设你是 Pythonista 的入门。\u003c/p\u003e\n\u003ch2 id=\"0x00-前言\"\u003e\u003ca class=\"v-toc-item\" href=\"#0x00-前言\"\u003e#\u003c/a\u003e 0x00 前言\u003c/h2\u003e\n\u003ch2 id=\"0x01-安装\"\u003e\u003ca class=\"v-toc-item\" href=\"#0x01-安装\"\u003e#\u003c/a\u003e 0x01 安装\u003c/h2\u003e\n\u003cp\u003eGolang 安装\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# 如果你是在 mac 上，建议先安装下面的 SDK 以防不测\nopen /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg\n# 安装 golang\nbrew install golang\n# 配置环境变量\necho $GOPATH # /Users/twocucao/Codes/ReposGo\n\ncd /Users/twocucao/Codes/ReposPublic/\n\nmkcd thanos # mkdir \u0026amp;\u0026amp; cd\ngo mod init github.com/twocucao/thanos\ngit remote add origin git@github.com:twocucao/thanos.git\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e接下来，需要解决卡 \u003ca href=\"http://golang.org\"\u003egolang.org\u003c/a\u003e 的网络问题。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eexport GOPROXY=https://goproxy.io\ngo get -v -u github.com/hqpko/go-mod-tidy\ngo mod tidy\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e接下来就是随便找一些带有依赖库的代码。放到该文件夹下面。\u003c/p\u003e\n\u003cp\u003e你也可以直接从这里 \u003ca href=\"https://github.com/twocucao/thanos.git\"\u003ehttps://github.com/twocucao/thanos.git\u003c/a\u003e 拉取代码\u003c/p\u003e\n\u003ch2 id=\"0x01-基本概念\"\u003e\u003ca class=\"v-toc-item\" href=\"#0x01-基本概念\"\u003e#\u003c/a\u003e 0x01 基本概念\u003c/h2\u003e\n\u003ch3 id=\"工具链\"\u003e\u003ca class=\"v-toc-item\" href=\"#工具链\"\u003e#\u003c/a\u003e 工具链\u003c/h3\u003e\n\u003ch3 id=\"文档\"\u003e\u003ca class=\"v-toc-item\" href=\"#文档\"\u003e#\u003c/a\u003e 文档\u003c/h3\u003e\n\u003ch3 id=\"社区\"\u003e\u003ca class=\"v-toc-item\" href=\"#社区\"\u003e#\u003c/a\u003e 社区\u003c/h3\u003e\n\u003ch3 id=\"书籍\"\u003e\u003ca class=\"v-toc-item\" href=\"#书籍\"\u003e#\u003c/a\u003e 书籍\u003c/h3\u003e\n\u003ch3 id=\"内置简单类型\"\u003e\u003ca class=\"v-toc-item\" href=\"#内置简单类型\"\u003e#\u003c/a\u003e 内置简单类型\u003c/h3\u003e\n\u003cp\u003e对于一些基本的数据类型，操作为 加减乘除取余数位运算等等\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e数字类型\u003c/li\u003e\n\u003cli\u003e布尔类型\u003c/li\u003e\n\u003cli\u003e字符串类型\u003c/li\u003e\n\u003cli\u003e数组 / 列表\u003c/li\u003e\n\u003cli\u003e字典\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"内置复杂类型\"\u003e\u003ca class=\"v-toc-item\" href=\"#内置复杂类型\"\u003e#\u003c/a\u003e 内置复杂类型\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e集合结构 : 串\u003c/li\u003e\n\u003cli\u003e线性结构 : 线性表 （单链表，静态链表，循环链表，双向链表，\u003cstrong\u003e栈，队列\u003c/strong\u003e)\u003c/li\u003e\n\u003cli\u003e树形结构 : 树（二叉树，B+ 树，红黑树）\u003c/li\u003e\n\u003cli\u003e图形结构 : 图\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"对象\"\u003e\u003ca class=\"v-toc-item\" href=\"#对象\"\u003e#\u003c/a\u003e 对象\u003c/h3\u003e\n\u003ch3 id=\"字符串\"\u003e\u003ca class=\"v-toc-item\" href=\"#字符串\"\u003e#\u003c/a\u003e 字符串\u003c/h3\u003e\n\u003ch2 id=\"0x02-中级概念\"\u003e\u003ca class=\"v-toc-item\" href=\"#0x02-中级概念\"\u003e#\u003c/a\u003e 0x02 中级概念\u003c/h2\u003e\n\u003ch3 id=\"函数\"\u003e\u003ca class=\"v-toc-item\" href=\"#函数\"\u003e#\u003c/a\u003e 函数\u003c/h3\u003e\n\u003ch4 id=\"作用域\"\u003e\u003ca class=\"v-toc-item\" href=\"#作用域\"\u003e#\u003c/a\u003e 作用域\u003c/h4\u003e\n\u003ch3 id=\"模块\"\u003e\u003ca class=\"v-toc-item\" href=\"#模块\"\u003e#\u003c/a\u003e 模块\u003c/h3\u003e\n\u003cp\u003e模块，这个概念，可大可小，大的时候，把一个程序说成是模块，小的时候，可以把一个文件，甚至你说这一个函数是一个模块，也行。\u003c/p\u003e\n\u003cp\u003e这里的模块指的是一个包下的函数。\u003c/p\u003e\n\u003ch3 id=\"面向对象\"\u003e\u003ca class=\"v-toc-item\" href=\"#面向对象\"\u003e#\u003c/a\u003e 面向对象\u003c/h3\u003e\n\u003cp\u003e面向对象有三大概念：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e封装\u003c/li\u003e\n\u003cli\u003e继承\u003c/li\u003e\n\u003cli\u003e多态\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"错误-调试测试\"\u003e\u003ca class=\"v-toc-item\" href=\"#错误-调试测试\"\u003e#\u003c/a\u003e 错误 / 调试测试\u003c/h3\u003e\n\u003cp\u003e异常处理实际上可以考验一个程序员编写代码的健壮性。\u003c/p\u003e\n\u003cp\u003e事实上来说，代码写的健壮是一个程序员必备的素养。但其实在开发过程中，出于对项目进行赶工上线，需要对程序的健壮性做出一定的取舍。并且，在编写客户端，服务端，网页前端的时候基本上都会遇到这个问题。什么时候选择健壮的程序，什么时候选择是还可以的程序。需要自己的经验。\u003c/p\u003e\n\u003ch3 id=\"io-编程\"\u003e\u003ca class=\"v-toc-item\" href=\"#io-编程\"\u003e#\u003c/a\u003e IO 编程\u003c/h3\u003e\n\u003ch3 id=\"进程和线程\"\u003e\u003ca class=\"v-toc-item\" href=\"#进程和线程\"\u003e#\u003c/a\u003e 进程和线程\u003c/h3\u003e\n\u003ch4 id=\"多线程\"\u003e\u003ca class=\"v-toc-item\" href=\"#多线程\"\u003e#\u003c/a\u003e 多线程\u003c/h4\u003e\n\u003cblockquote\u003e\n\u003cp\u003eGo 多线程约等于并发。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch4 id=\"多进程\"\u003e\u003ca class=\"v-toc-item\" href=\"#多进程\"\u003e#\u003c/a\u003e 多进程\u003c/h4\u003e\n\u003ch5 id=\"协同式多任务处理\"\u003e\u003ca class=\"v-toc-item\" href=\"#协同式多任务处理\"\u003e#\u003c/a\u003e 协同式多任务处理\u003c/h5\u003e\n\u003cp\u003e如果有两个线程，同时进行 IO 请求，当其中一个线程连接之后，立即会\u003cstrong\u003e主动让出 GIL\u003c/strong\u003e, 其他线程就可以运行。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e当 N 个线程在网络 I/O 堵塞，或等待重新获取 GIL，而一个线程运行 Python。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e让出之后还要执行代码呀，所以要有个收回 GIL 的动作。\u003c/p\u003e\n\u003ch5 id=\"抢占式多任务处理\"\u003e\u003ca class=\"v-toc-item\" href=\"#抢占式多任务处理\"\u003e#\u003c/a\u003e 抢占式多任务处理\u003c/h5\u003e\n\u003ch5 id=\"线程安全\"\u003e\u003ca class=\"v-toc-item\" href=\"#线程安全\"\u003e#\u003c/a\u003e 线程安全\u003c/h5\u003e\n\u003cp\u003e原子操作：sort 之类不需要\u003cbr\u003e\n非原子操作：n=n+2 的字节码分为 加载 n , 加载 2 , 相加，存储 n, 四个步骤，由于不是原子性，很可能被由于 15 ms 而被打断。\u003c/p\u003e\n\u003cp\u003e当然，懒人一向是 : \u003cstrong\u003e优先级不决加括号，线程不决加 lock\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e对于 Java, 程序员努力在尽可能短的时间内加锁存取共享数据，减轻线程的争夺，实现最大并行。但 Python 中，线程无法并行运行，细粒度的锁就没有了优势。\u003c/p\u003e\n\u003ch3 id=\"正则表达式\"\u003e\u003ca class=\"v-toc-item\" href=\"#正则表达式\"\u003e#\u003c/a\u003e 正则表达式\u003c/h3\u003e\n\u003ch2 id=\"0x03-高级技巧\"\u003e\u003ca class=\"v-toc-item\" href=\"#0x03-高级技巧\"\u003e#\u003c/a\u003e 0x03 高级技巧\u003c/h2\u003e\n\u003ch2 id=\"0x04-标准库\"\u003e\u003ca class=\"v-toc-item\" href=\"#0x04-标准库\"\u003e#\u003c/a\u003e 0x04 标准库\u003c/h2\u003e\n\u003ch3 id=\"常用内建模块\"\u003e\u003ca class=\"v-toc-item\" href=\"#常用内建模块\"\u003e#\u003c/a\u003e 常用内建模块\u003c/h3\u003e\n\u003ch3 id=\"系统化模块\"\u003e\u003ca class=\"v-toc-item\" href=\"#系统化模块\"\u003e#\u003c/a\u003e 系统化模块\u003c/h3\u003e\n\u003ch2 id=\"0x05-第三方库\"\u003e\u003ca class=\"v-toc-item\" href=\"#0x05-第三方库\"\u003e#\u003c/a\u003e 0x05 第三方库\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eRequests : API 人性化\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"0x06-代码质量\"\u003e\u003ca class=\"v-toc-item\" href=\"#0x06-代码质量\"\u003e#\u003c/a\u003e 0x06 代码质量\u003c/h2\u003e\n\u003ch3 id=\"正确性\"\u003e\u003ca class=\"v-toc-item\" href=\"#正确性\"\u003e#\u003c/a\u003e 正确性\u003c/h3\u003e\n\u003ch3 id=\"可维护性\"\u003e\u003ca class=\"v-toc-item\" href=\"#可维护性\"\u003e#\u003c/a\u003e 可维护性\u003c/h3\u003e\n\u003ch3 id=\"可读性\"\u003e\u003ca class=\"v-toc-item\" href=\"#可读性\"\u003e#\u003c/a\u003e 可读性\u003c/h3\u003e\n\u003ch3 id=\"安全性\"\u003e\u003ca class=\"v-toc-item\" href=\"#安全性\"\u003e#\u003c/a\u003e 安全性\u003c/h3\u003e\n\u003ch3 id=\"性能\"\u003e\u003ca class=\"v-toc-item\" href=\"#性能\"\u003e#\u003c/a\u003e 性能\u003c/h3\u003e\n\u003ch2 id=\"0x07-常用命令\"\u003e\u003ca class=\"v-toc-item\" href=\"#0x07-常用命令\"\u003e#\u003c/a\u003e 0x07 常用命令\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003ego build\ngo install -v\ngo clean\ngo fmt\ngo get\ngo test\ngo tool fix . # 修复老代码到新版本\ngo tool vet directory|files\ngo tool yacc -o gopher.go -p parser gopher.y\ngodoc -http=:8080\ngo version 查看 go 当前的版本\ngo env 查看当前 go 的环境变量\ngo list 列出当前全部安装的 package\ngo run 编译并运行 Go 程序\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"0xee-文章更新\"\u003e\u003ca class=\"v-toc-item\" href=\"#0xee-文章更新\"\u003e#\u003c/a\u003e 0xEE 文章更新\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003e# 如果你是在 mac 上，建议先安装下面的 SDK 以防不测\nopen /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"golang\"\u003e\u003ca class=\"v-toc-item\" href=\"#golang\"\u003e#\u003c/a\u003e Golang\u003c/h1\u003e\n\u003ch2 id=\"模块-01go-语言实践-runtime\"\u003e\u003ca class=\"v-toc-item\" href=\"#模块-01go-语言实践-runtime\"\u003e#\u003c/a\u003e 模块 01：Go 语言实践 - Runtime\u003c/h2\u003e\n\u003ch3 id=\"goroutine-的调度原理\"\u003e\u003ca class=\"v-toc-item\" href=\"#goroutine-的调度原理\"\u003e#\u003c/a\u003e Goroutine 的调度原理\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eGoroutine 和线程的区别\u003c/li\u003e\n\u003cli\u003eGoroutine 的实现、GPM 调度模型、调度状态及流转、调度原理、协作式抢占以及和网络库的协作\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ca href=\"https://www.jianshu.com/p/105719434c29\"\u003ehttps://www.jianshu.com/p/105719434c29\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://zboya.github.io/post/go_scheduler/\"\u003ehttps://zboya.github.io/post/go_scheduler/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://studygolang.com/articles/16407\"\u003ehttps://studygolang.com/articles/16407\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"内存模型\"\u003e\u003ca class=\"v-toc-item\" href=\"#内存模型\"\u003e#\u003c/a\u003e 内存模型\u003c/h3\u003e\n\u003cp\u003eGo 的内存分配机制\u003cbr\u003e\nGo 内存分配的内部结构和分配机制\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://deepu.tech/memory-management-in-golang/\"\u003ehttps://deepu.tech/memory-management-in-golang/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://medium.com/a-journey-with-go/go-memory-management-and-allocation-a7396d430f44\"\u003ehttps://medium.com/a-journey-with-go/go-memory-management-and-allocation-a7396d430f44\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"gc垃圾回收的原理\"\u003e\u003ca class=\"v-toc-item\" href=\"#gc垃圾回收的原理\"\u003e#\u003c/a\u003e GC（垃圾回收）的原理\u003c/h3\u003e\n\u003cp\u003eGC 三色标记算法\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://blog.golang.org/ismmkeynote\"\u003ehttps://blog.golang.org/ismmkeynote\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eGC 介绍、三色标记的实现原理、GC 的流程以及 GC 的一些优化方案\u003c/p\u003e\n\u003ch3 id=\"channel-的消息通讯原理\"\u003e\u003ca class=\"v-toc-item\" href=\"#channel-的消息通讯原理\"\u003e#\u003c/a\u003e channel 的消息通讯原理\u003c/h3\u003e\n\u003cp\u003echannel 的底层实现\u003cbr\u003e\nchannel 的通讯机制、环形队列的结构、调度和唤醒的原理\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://stackoverflow.com/questions/19621149/how-are-go-channels-implemented\"\u003ehttps://stackoverflow.com/questions/19621149/how-are-go-channels-implemented\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"模块-02go-语言实践-并行编程\"\u003e\u003ca class=\"v-toc-item\" href=\"#模块-02go-语言实践-并行编程\"\u003e#\u003c/a\u003e 模块 02：Go 语言实践 - 并行编程\u003c/h2\u003e\n\u003ch3 id=\"memory-model\"\u003e\u003ca class=\"v-toc-item\" href=\"#memory-model\"\u003e#\u003c/a\u003e Memory Model\u003c/h3\u003e\n\u003cp\u003eGo 中内存模型和同步语义\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://zhuanlan.zhihu.com/p/110032965\"\u003ehttps://zhuanlan.zhihu.com/p/110032965\u003c/a\u003e\u003cbr\u003e\n\u003ca href=\"https://golang.org/ref/mem\"\u003ehttps://golang.org/ref/mem\u003c/a\u003e\u003cbr\u003e\n\u003ca href=\"https://golang.org/doc/\"\u003ehttps://golang.org/doc/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e内存模型：Happens Before、同步语义、channel 通讯、锁\u003c/p\u003e\n\u003ch3 id=\"并发特性并发编程模式\"\u003e\u003ca class=\"v-toc-item\" href=\"#并发特性并发编程模式\"\u003e#\u003c/a\u003e 并发特性并发编程模式\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://blog.golang.org/pipelines\"\u003ehttps://blog.golang.org/pipelines\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eTimeout、Pipeline、Cancellation、Fanout、errgroup 等模式\u003cbr\u003e\n利用 channel 完成并行开发的设计模式，包含超时控制、管道、扇出、errgroup 并发\u003cbr\u003e\n无法熟练使用基于 channel 通讯方式的并行编程模式\u003c/p\u003e\n\u003ch3 id=\"context-的原理并掌握其使用方法\"\u003e\u003ca class=\"v-toc-item\" href=\"#context-的原理并掌握其使用方法\"\u003e#\u003c/a\u003e Context 的原理并掌握其使用方法\u003c/h3\u003e\n\u003cp\u003eContext 传播式传递有什么意义\u003cbr\u003e\n使用 Go 标准库 Context 的原理和最佳实践，包含超时控制、元数据传递、生命周期控制\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://blog.golang.org/context\"\u003ehttps://blog.golang.org/context\u003c/a\u003e\u003cbr\u003e\n\u003ca href=\"https://levelup.gitconnected.com/context-in-golang-98908f042a57\"\u003ehttps://levelup.gitconnected.com/context-in-golang-98908f042a57\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"模块-03go-语言实践-网络编程\"\u003e\u003ca class=\"v-toc-item\" href=\"#模块-03go-语言实践-网络编程\"\u003e#\u003c/a\u003e 模块 03：Go 语言实践 - 网络编程\u003c/h2\u003e\n\u003ch3 id=\"golang-tcp-网络编程\"\u003e\u003ca class=\"v-toc-item\" href=\"#golang-tcp-网络编程\"\u003e#\u003c/a\u003e Golang TCP 网络编程\u003c/h3\u003e\n\u003cp\u003eGo 实现高性能的 TCP Server\u003c/p\u003e\n\u003cp\u003egoim 项目了解 Go 语言中 TCP Server 的基础库和性能优化方案\u003c/p\u003e\n\u003ch3 id=\"golang-http-网络编程\"\u003e\u003ca class=\"v-toc-item\" href=\"#golang-http-网络编程\"\u003e#\u003c/a\u003e Golang HTTP 网络编程\u003c/h3\u003e\n\u003cp\u003eHTTP 框架选型\u003cbr\u003e\n针对业务需求对 HTTP 框架做针对性的扩展\u003cbr\u003e\n结合 gin 项目了解 Go 语言中的 HTTP Server 的基础库和框架\u003c/p\u003e\n\u003ch2 id=\"模块-04go-语言实践-异常处理\"\u003e\u003ca class=\"v-toc-item\" href=\"#模块-04go-语言实践-异常处理\"\u003e#\u003c/a\u003e 模块 04：Go 语言实践 - 异常处理\u003c/h2\u003e\n\u003ch3 id=\"error-的处理方法\"\u003e\u003ca class=\"v-toc-item\" href=\"#error-的处理方法\"\u003e#\u003c/a\u003e error 的处理方法\u003c/h3\u003e\n\u003ch3 id=\"业务错误的处理方法\"\u003e\u003ca class=\"v-toc-item\" href=\"#业务错误的处理方法\"\u003e#\u003c/a\u003e 业务错误的处理方法\u003c/h3\u003e\n\u003cp\u003eerror 的处理复杂，不会正确使用\u003cbr\u003e\n业务错误定义和 error 整合难度较高\u003c/p\u003e\n\u003cp\u003eGo 语言中的 error 处理实践：检查错误、定义错误、追加上下文\u003cbr\u003e\nGo 项目中的业务错误码如何结合 error 的最佳实践\u003c/p\u003e\n\u003ch2 id=\"模块-05go-工程化实践\"\u003e\u003ca class=\"v-toc-item\" href=\"#模块-05go-工程化实践\"\u003e#\u003c/a\u003e 模块 05：Go 工程化实践\u003c/h2\u003e\n\u003ch3 id=\"良好的项目目录组织原则和规范\"\u003e\u003ca class=\"v-toc-item\" href=\"#良好的项目目录组织原则和规范\"\u003e#\u003c/a\u003e 良好的项目目录组织原则和规范\u003c/h3\u003e\n\u003ch3 id=\"api-的设计方法和规范\"\u003e\u003ca class=\"v-toc-item\" href=\"#api-的设计方法和规范\"\u003e#\u003c/a\u003e API 的设计方法和规范\u003c/h3\u003e\n\u003ch3 id=\"package-的管理和设计方法\"\u003e\u003ca class=\"v-toc-item\" href=\"#package-的管理和设计方法\"\u003e#\u003c/a\u003e Package 的管理和设计方法\u003c/h3\u003e\n\u003ch3 id=\"单元测试\"\u003e\u003ca class=\"v-toc-item\" href=\"#单元测试\"\u003e#\u003c/a\u003e 单元测试\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eGo 项目的标准化管理\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e设计 API\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e包管理\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e良好的 Go 项目中的分层目录结构组织和代码规范\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eGo 项目中 API 的设计原则和方法：定义、状态和业务错误码处理\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eGo 项目中包的设计和最佳实践、go mod 的使用\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ego test 工具链的使用方法、单元测试的最佳实践以及 Mock 技术\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"模块-06go-架构实践-分布式架构前端负载均衡\"\u003e\u003ca class=\"v-toc-item\" href=\"#模块-06go-架构实践-分布式架构前端负载均衡\"\u003e#\u003c/a\u003e 模块 06：Go 架构实践 - 分布式架构（前端负载均衡）\u003c/h2\u003e\n\u003ch3 id=\"高可用-dns-的最佳实践\"\u003e\u003ca class=\"v-toc-item\" href=\"#高可用-dns-的最佳实践\"\u003e#\u003c/a\u003e 高可用 DNS 的最佳实践\u003c/h3\u003e\n\u003ch3 id=\"cdn-的架构和应用场景\"\u003e\u003ca class=\"v-toc-item\" href=\"#cdn-的架构和应用场景\"\u003e#\u003c/a\u003e CDN 的架构和应用场景\u003c/h3\u003e\n\u003ch3 id=\"深入理解-47-层负载均衡的原理\"\u003e\u003ca class=\"v-toc-item\" href=\"#深入理解-47-层负载均衡的原理\"\u003e#\u003c/a\u003e 深入理解 4/7 层负载均衡的原理\u003c/h3\u003e\n\u003cp\u003e在线服务的全链路视野\u003cbr\u003e\n应用服务上层的负载均衡\u003c/p\u003e\n\u003cp\u003eDNS 的原理、防劫持的方法、HTTPDNS + IP 长连接\u003cbr\u003e\nCDN 的系统架构、应用领域以及保证数据一致性的方法\u003cbr\u003e\nLVS、Nginx 4/7 层负载均衡的原理和实践\u003c/p\u003e\n\u003ch2 id=\"模块-07go-架构实践-分布式架构数据分片\"\u003e\u003ca class=\"v-toc-item\" href=\"#模块-07go-架构实践-分布式架构数据分片\"\u003e#\u003c/a\u003e 模块 07：Go 架构实践 - 分布式架构（数据分片）\u003c/h2\u003e\n\u003ch3 id=\"数据-sharding-的设计原则\"\u003e\u003ca class=\"v-toc-item\" href=\"#数据-sharding-的设计原则\"\u003e#\u003c/a\u003e 数据 Sharding 的设计原则\u003c/h3\u003e\n\u003ch3 id=\"了解-hash-分片的算法和演进历史\"\u003e\u003ca class=\"v-toc-item\" href=\"#了解-hash-分片的算法和演进历史\"\u003e#\u003c/a\u003e 了解 Hash 分片的算法和演进历史\u003c/h3\u003e\n\u003cp\u003eSharding 的应用场景，不会合理使用\u003cbr\u003e\nHash 算法的使用场景\u003c/p\u003e\n\u003cp\u003e数据分片设计，如：分库分表、多活的 Shard 设计等等\u003cbr\u003e\n分片算法的 Hash 实现和演进：Hash 求余、一致性 Hash、有界负载一致性 Hash、节点映射\u003c/p\u003e\n\u003ch2 id=\"模块-08go-架构实践-微服务微服务概览与治理\"\u003e\u003ca class=\"v-toc-item\" href=\"#模块-08go-架构实践-微服务微服务概览与治理\"\u003e#\u003c/a\u003e 模块 08：Go 架构实践 - 微服务（微服务概览与治理）\u003c/h2\u003e\n\u003ch3 id=\"微服务的演进历史及优缺点\"\u003e\u003ca class=\"v-toc-item\" href=\"#微服务的演进历史及优缺点\"\u003e#\u003c/a\u003e 微服务的演进历史及优缺点\u003c/h3\u003e\n\u003ch3 id=\"微服务的设计方法\"\u003e\u003ca class=\"v-toc-item\" href=\"#微服务的设计方法\"\u003e#\u003c/a\u003e 微服务的设计方法\u003c/h3\u003e\n\u003ch3 id=\"微服务中-rpc-的底层原理\"\u003e\u003ca class=\"v-toc-item\" href=\"#微服务中-rpc-的底层原理\"\u003e#\u003c/a\u003e 微服务中 RPC 的底层原理\u003c/h3\u003e\n\u003cp\u003e微服务的服务角色：API Gateway、BFF 还是 Service？\u003cbr\u003e\n微服务拆分\u003cbr\u003e\nRPC 的原理，不知道如何进行微服务 RPC 框架的选型\u003c/p\u003e\n\u003cp\u003e微服务的原理、概念，以及微服务的实现细节\u003cbr\u003e\nAPI Gateway、BFF、Service 等概念精讲\u003cbr\u003e\n微服务通讯 RPC 框架的细节和选型\u003c/p\u003e\n\u003ch2 id=\"模块-09go-架构实践-微服务可用性设计\"\u003e\u003ca class=\"v-toc-item\" href=\"#模块-09go-架构实践-微服务可用性设计\"\u003e#\u003c/a\u003e 模块 09：Go 架构实践 - 微服务（可用性设计）\u003c/h2\u003e\n\u003ch3 id=\"可用性设计的最佳实践\"\u003e\u003ca class=\"v-toc-item\" href=\"#可用性设计的最佳实践\"\u003e#\u003c/a\u003e 可用性设计的最佳实践\u003c/h3\u003e\n\u003ch3 id=\"可用性设计的几大关键点隔离-超时控制-过载保护-限流-容错-重试\"\u003e\u003ca class=\"v-toc-item\" href=\"#可用性设计的几大关键点隔离-超时控制-过载保护-限流-容错-重试\"\u003e#\u003c/a\u003e 可用性设计的几大关键点：隔离、超时控制、过载保护、限流、容错 \u0026amp; 重试\u003c/h3\u003e\n\u003cp\u003e如何设计高可用的分布式服务\u003cbr\u003e\n何提升服务自愈能力\u003c/p\u003e\n\u003cp\u003e微服务的隔离实现，以及架构设计中的隔离实现\u003cbr\u003e\n进程内超时控制和跨进程超时控制\u003cbr\u003e\n程序自保护避免过载，抛弃一定的流量完成自适应限流\u003cbr\u003e\n单机限流、多租户场景的分布式限流\u003cbr\u003e\n节点故障的容错逻辑、重试容错的策略和设计\u003c/p\u003e\n\u003ch2 id=\"模块-10go-架构实践-中间件日志-指标-链路追踪\"\u003e\u003ca class=\"v-toc-item\" href=\"#模块-10go-架构实践-中间件日志-指标-链路追踪\"\u003e#\u003c/a\u003e 模块 10：Go 架构实践 - 中间件（日志、指标、链路追踪）\u003c/h2\u003e\n\u003ch3 id=\"日志收集\"\u003e\u003ca class=\"v-toc-item\" href=\"#日志收集\"\u003e#\u003c/a\u003e 日志收集\u003c/h3\u003e\n\u003ch3 id=\"监控指标体系\"\u003e\u003ca class=\"v-toc-item\" href=\"#监控指标体系\"\u003e#\u003c/a\u003e 监控指标体系\u003c/h3\u003e\n\u003ch3 id=\"分布式链路追踪\"\u003e\u003ca class=\"v-toc-item\" href=\"#分布式链路追踪\"\u003e#\u003c/a\u003e 分布式链路追踪\u003c/h3\u003e\n\u003cp\u003e如何解决微服务的可观测性难题\u003cbr\u003e\n怎么做微服务的可视化和标准化\u003cbr\u003e\n出故障后，难以对微服务进行问题诊断\u003c/p\u003e\n\u003cp\u003e实现一个可以集中收集所有微服务实例的日志，并能统一查看和检索的日志采集架构\u003cbr\u003e\n指标监控、使用 Prometheus 解决监控可视化、指标采集\u003cbr\u003e\n微服务中的跨服务性能问题诊断，结合 Jaeger 实现分布式链路追踪\u003c/p\u003e\n\u003ch2 id=\"模块-11go-架构实践-中间件缓存-数据库\"\u003e\u003ca class=\"v-toc-item\" href=\"#模块-11go-架构实践-中间件缓存-数据库\"\u003e#\u003c/a\u003e 模块 11：Go 架构实践 - 中间件（缓存、数据库）\u003c/h2\u003e\n\u003ch3 id=\"redis-memcache-的原理和实战技巧\"\u003e\u003ca class=\"v-toc-item\" href=\"#redis-memcache-的原理和实战技巧\"\u003e#\u003c/a\u003e Redis、Memcache 的原理和实战技巧\u003c/h3\u003e\n\u003ch3 id=\"mysql-的常用设计和优化方法\"\u003e\u003ca class=\"v-toc-item\" href=\"#mysql-的常用设计和优化方法\"\u003e#\u003c/a\u003e MySQL 的常用设计和优化方法\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e解决缓存的一致性问题\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e怎样合理地设计 MySQL 的表\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eRedis、Memcache 的应用场景、最佳实践，以及缓存的一致性设计\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eMySQL 的表设计、常用优化手段，以及如何解决分布式事务\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"模块-12go-架构实践-中间件消息队列-服务发现\"\u003e\u003ca class=\"v-toc-item\" href=\"#模块-12go-架构实践-中间件消息队列-服务发现\"\u003e#\u003c/a\u003e 模块 12：Go 架构实践 - 中间件（消息队列、服务发现）\u003c/h2\u003e\n\u003ch3 id=\"深入理解消息队列的原理掌握基于消息队列的架构设计方法\"\u003e\u003ca class=\"v-toc-item\" href=\"#深入理解消息队列的原理掌握基于消息队列的架构设计方法\"\u003e#\u003c/a\u003e 深入理解消息队列的原理，掌握基于消息队列的架构设计方法\u003c/h3\u003e\n\u003ch3 id=\"服务发现原理-选型策略以及服务发现实现的微服务多租户架构\"\u003e\u003ca class=\"v-toc-item\" href=\"#服务发现原理-选型策略以及服务发现实现的微服务多租户架构\"\u003e#\u003c/a\u003e 服务发现原理、选型策略，以及服务发现实现的微服务多租户架构\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e消息解耦的架构设计\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e如何实现服务发现对平滑发布的支持\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e怎样利用多租户实现多测试环境\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eKafka 的实现原理、异步消息系统的架构设计\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eRPC 服务发现、动态地址的选型和实现原理，以及基于服务发现的平滑重启和多租户架构\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003cp\u003eChangeLog:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e2018-08-22\u003c/strong\u003e 初始化接口\u003c/li\u003e\n\u003c/ul\u003e\n","toc":"\u003cul class=\"v-article-toc\"\u003e\n\u003cli\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#0x00-%E5%89%8D%E8%A8%80\"\u003e0x00 前言\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#0x01-%E5%AE%89%E8%A3%85\"\u003e0x01 安装\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#0x01-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"\u003e0x01 基本概念\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#%E5%B7%A5%E5%85%B7%E9%93%BE\"\u003e工具链\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E6%96%87%E6%A1%A3\"\u003e文档\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E7%A4%BE%E5%8C%BA\"\u003e社区\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E4%B9%A6%E7%B1%8D\"\u003e书籍\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E5%86%85%E7%BD%AE%E7%AE%80%E5%8D%95%E7%B1%BB%E5%9E%8B\"\u003e内置简单类型\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E5%86%85%E7%BD%AE%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B\"\u003e内置复杂类型\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E5%AF%B9%E8%B1%A1\"\u003e对象\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E5%AD%97%E7%AC%A6%E4%B8%B2\"\u003e字符串\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#0x02-%E4%B8%AD%E7%BA%A7%E6%A6%82%E5%BF%B5\"\u003e0x02 中级概念\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#%E5%87%BD%E6%95%B0\"\u003e函数\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#%E4%BD%9C%E7%94%A8%E5%9F%9F\"\u003e作用域\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E6%A8%A1%E5%9D%97\"\u003e模块\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1\"\u003e面向对象\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E9%94%99%E8%AF%AF-%E8%B0%83%E8%AF%95%E6%B5%8B%E8%AF%95\"\u003e错误 / 调试测试\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#io-%E7%BC%96%E7%A8%8B\"\u003eIO 编程\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B\"\u003e进程和线程\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#%E5%A4%9A%E7%BA%BF%E7%A8%8B\"\u003e多线程\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E5%A4%9A%E8%BF%9B%E7%A8%8B\"\u003e多进程\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#%E5%8D%8F%E5%90%8C%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86\"\u003e协同式多任务处理\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86\"\u003e抢占式多任务处理\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8\"\u003e线程安全\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F\"\u003e正则表达式\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#0x03-%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7\"\u003e0x03 高级技巧\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#0x04-%E6%A0%87%E5%87%86%E5%BA%93\"\u003e0x04 标准库\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#%E5%B8%B8%E7%94%A8%E5%86%85%E5%BB%BA%E6%A8%A1%E5%9D%97\"\u003e常用内建模块\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E7%B3%BB%E7%BB%9F%E5%8C%96%E6%A8%A1%E5%9D%97\"\u003e系统化模块\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#0x05-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93\"\u003e0x05 第三方库\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#0x06-%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F\"\u003e0x06 代码质量\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#%E6%AD%A3%E7%A1%AE%E6%80%A7\"\u003e正确性\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7\"\u003e可维护性\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E5%8F%AF%E8%AF%BB%E6%80%A7\"\u003e可读性\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E5%AE%89%E5%85%A8%E6%80%A7\"\u003e安全性\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E6%80%A7%E8%83%BD\"\u003e性能\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#0x07-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4\"\u003e0x07 常用命令\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#0xee-%E6%96%87%E7%AB%A0%E6%9B%B4%E6%96%B0\"\u003e0xEE 文章更新\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#golang\"\u003eGolang\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#%E6%A8%A1%E5%9D%97-01go-%E8%AF%AD%E8%A8%80%E5%AE%9E%E8%B7%B5-runtime\"\u003e模块 01：Go 语言实践 - Runtime\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#goroutine-%E7%9A%84%E8%B0%83%E5%BA%A6%E5%8E%9F%E7%90%86\"\u003eGoroutine 的调度原理\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B\"\u003e内存模型\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#gc%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%8E%9F%E7%90%86\"\u003eGC（垃圾回收）的原理\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#channel-%E7%9A%84%E6%B6%88%E6%81%AF%E9%80%9A%E8%AE%AF%E5%8E%9F%E7%90%86\"\u003echannel 的消息通讯原理\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E6%A8%A1%E5%9D%97-02go-%E8%AF%AD%E8%A8%80%E5%AE%9E%E8%B7%B5-%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B\"\u003e模块 02：Go 语言实践 - 并行编程\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#memory-model\"\u003eMemory Model\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E5%B9%B6%E5%8F%91%E7%89%B9%E6%80%A7%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F\"\u003e并发特性并发编程模式\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#context-%E7%9A%84%E5%8E%9F%E7%90%86%E5%B9%B6%E6%8E%8C%E6%8F%A1%E5%85%B6%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95\"\u003eContext 的原理并掌握其使用方法\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E6%A8%A1%E5%9D%97-03go-%E8%AF%AD%E8%A8%80%E5%AE%9E%E8%B7%B5-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B\"\u003e模块 03：Go 语言实践 - 网络编程\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#golang-tcp-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B\"\u003eGolang TCP 网络编程\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#golang-http-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B\"\u003eGolang HTTP 网络编程\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E6%A8%A1%E5%9D%97-04go-%E8%AF%AD%E8%A8%80%E5%AE%9E%E8%B7%B5-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86\"\u003e模块 04：Go 语言实践 - 异常处理\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#error-%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95\"\u003eerror 的处理方法\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E4%B8%9A%E5%8A%A1%E9%94%99%E8%AF%AF%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95\"\u003e业务错误的处理方法\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E6%A8%A1%E5%9D%97-05go-%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%AE%9E%E8%B7%B5\"\u003e模块 05：Go 工程化实践\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#%E8%89%AF%E5%A5%BD%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E7%BB%84%E7%BB%87%E5%8E%9F%E5%88%99%E5%92%8C%E8%A7%84%E8%8C%83\"\u003e良好的项目目录组织原则和规范\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#api-%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%E5%92%8C%E8%A7%84%E8%8C%83\"\u003eAPI 的设计方法和规范\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#package-%E7%9A%84%E7%AE%A1%E7%90%86%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95\"\u003ePackage 的管理和设计方法\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95\"\u003e单元测试\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E6%A8%A1%E5%9D%97-06go-%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5-%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E5%89%8D%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1\"\u003e模块 06：Go 架构实践 - 分布式架构（前端负载均衡）\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#%E9%AB%98%E5%8F%AF%E7%94%A8-dns-%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5\"\u003e高可用 DNS 的最佳实践\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#cdn-%E7%9A%84%E6%9E%B6%E6%9E%84%E5%92%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF\"\u003eCDN 的架构和应用场景\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-47-%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E5%8E%9F%E7%90%86\"\u003e深入理解 4/7 层负载均衡的原理\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E6%A8%A1%E5%9D%97-07go-%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5-%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87\"\u003e模块 07：Go 架构实践 - 分布式架构（数据分片）\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#%E6%95%B0%E6%8D%AE-sharding-%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99\"\u003e数据 Sharding 的设计原则\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E4%BA%86%E8%A7%A3-hash-%E5%88%86%E7%89%87%E7%9A%84%E7%AE%97%E6%B3%95%E5%92%8C%E6%BC%94%E8%BF%9B%E5%8E%86%E5%8F%B2\"\u003e了解 Hash 分片的算法和演进历史\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E6%A8%A1%E5%9D%97-08go-%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A6%82%E8%A7%88%E4%B8%8E%E6%B2%BB%E7%90%86\"\u003e模块 08：Go 架构实践 - 微服务（微服务概览与治理）\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%BC%94%E8%BF%9B%E5%8E%86%E5%8F%B2%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9\"\u003e微服务的演进历史及优缺点\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95\"\u003e微服务的设计方法\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%AD-rpc-%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86\"\u003e微服务中 RPC 的底层原理\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E6%A8%A1%E5%9D%97-09go-%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%8F%AF%E7%94%A8%E6%80%A7%E8%AE%BE%E8%AE%A1\"\u003e模块 09：Go 架构实践 - 微服务（可用性设计）\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#%E5%8F%AF%E7%94%A8%E6%80%A7%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5\"\u003e可用性设计的最佳实践\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E5%8F%AF%E7%94%A8%E6%80%A7%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%87%A0%E5%A4%A7%E5%85%B3%E9%94%AE%E7%82%B9%E9%9A%94%E7%A6%BB-%E8%B6%85%E6%97%B6%E6%8E%A7%E5%88%B6-%E8%BF%87%E8%BD%BD%E4%BF%9D%E6%8A%A4-%E9%99%90%E6%B5%81-%E5%AE%B9%E9%94%99-%E9%87%8D%E8%AF%95\"\u003e可用性设计的几大关键点：隔离、超时控制、过载保护、限流、容错 \u0026amp; 重试\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E6%A8%A1%E5%9D%97-10go-%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5-%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%97%A5%E5%BF%97-%E6%8C%87%E6%A0%87-%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA\"\u003e模块 10：Go 架构实践 - 中间件（日志、指标、链路追踪）\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86\"\u003e日志收集\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E7%9B%91%E6%8E%A7%E6%8C%87%E6%A0%87%E4%BD%93%E7%B3%BB\"\u003e监控指标体系\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA\"\u003e分布式链路追踪\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E6%A8%A1%E5%9D%97-11go-%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5-%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%BC%93%E5%AD%98-%E6%95%B0%E6%8D%AE%E5%BA%93\"\u003e模块 11：Go 架构实践 - 中间件（缓存、数据库）\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#redis-memcache-%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E6%88%98%E6%8A%80%E5%B7%A7\"\u003eRedis、Memcache 的原理和实战技巧\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#mysql-%E7%9A%84%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E5%92%8C%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95\"\u003eMySQL 的常用设计和优化方法\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E6%A8%A1%E5%9D%97-12go-%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5-%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0\"\u003e模块 12：Go 架构实践 - 中间件（消息队列、服务发现）\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%8E%9F%E7%90%86%E6%8E%8C%E6%8F%A1%E5%9F%BA%E4%BA%8E%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95\"\u003e深入理解消息队列的原理，掌握基于消息队列的架构设计方法\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E5%8E%9F%E7%90%86-%E9%80%89%E5%9E%8B%E7%AD%96%E7%95%A5%E4%BB%A5%E5%8F%8A%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%A4%9A%E7%A7%9F%E6%88%B7%E6%9E%B6%E6%9E%84\"\u003e服务发现原理、选型策略，以及服务发现实现的微服务多租户架构\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n"}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"写给 Pythonista 的 Golang 入门指北"},"buildId":"oDi_oBCBuu3qj6v7hDnrL","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>