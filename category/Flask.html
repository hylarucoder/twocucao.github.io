<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Flask | 海拉鲁编程客</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/49455a07b6dd33600cdf.css" as="style"/><link rel="stylesheet" href="/_next/static/css/49455a07b6dd33600cdf.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-a54b4f32bdc1ef890ddd.js"></script><script src="/_next/static/chunks/webpack-20d43e08bea62467b090.js" defer=""></script><script src="/_next/static/chunks/framework-0441fae7fd130f37dee1.js" defer=""></script><script src="/_next/static/chunks/main-4777350f2a9ff73ea2b0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-3050679c6e5142ffcaf5.js" defer=""></script><script src="/_next/static/chunks/ea88be26-9bcf6ead520f4ac26973.js" defer=""></script><script src="/_next/static/chunks/421-f2f33a86b546237f0325.js" defer=""></script><script src="/_next/static/chunks/pages/category/%5Bslug%5D-4d8847f86983258925d4.js" defer=""></script><script src="/_next/static/uCwe9m-iio9bnoWMgWDqE/_buildManifest.js" defer=""></script><script src="/_next/static/uCwe9m-iio9bnoWMgWDqE/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="v-page"><nav class="shadow"><div class="flex flex-col container mx-auto h-12 px-40 md:flex-row md:items-center md:justify-between"><div class="flex justify-between items-center"><div><a class="text-gray-800 text-xl md:text-xl leading-5" href="/">海拉鲁编程客</a></div><div><button type="button" class="block text-gray-800 hover:text-gray-600 focus:text-gray-600 focus:outline-none md:hidden"><svg viewBox="0 0 24 24" class="h-6 w-6 fill-current"><path d="M4 5h16a1 1 0 0 1 0 2H4a1 1 0 1 1 0-2zm0 6h16a1 1 0 0 1 0 2H4a1 1 0 0 1 0-2zm0 6h16a1 1 0 0 1 0 2H4a1 1 0 0 1 0-2z"></path></svg></button></div></div><div class="md:flex flex-col md:flex-row md:-mx-4 hidden"><a class="my-1 text-gray-800 hover:text-blue-500 md:mx-4 md:my-0" href="/">首页</a><a class="my-1 text-gray-800 hover:text-blue-500 md:mx-4 md:my-0" href="/archive">归档</a><a class="my-1 text-gray-800 hover:text-blue-500 md:mx-4 md:my-0" href="/about">关于我</a><button style="cursor:pointer;overflow:hidden;width:50px;height:23.5px;appearance:none;-moz-appearance:none;-webkit-appearance:none;border:none;background-color:transparent;padding:0" aria-hidden="true"><div style="display:flex;align-items:center;justify-content:center;margin-top:-28.749999999999996px;margin-left:-16px;width:82.5px;height:82.5px"><div></div></div></button></div></div></nav><div class="v-article">Flask<li>SQLAlchemy CheatSheet</li><li>Flask 文档阅读笔记</li><li>Flask 源码初步解读</li></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"category":{"name":"Flask","posts":[{"tags":["Flask","ORM"],"path":"20180331_SQLAlchemyCheatSheet.md","title":"SQLAlchemy CheatSheet","slug":"SQLAlchemy CheatSheet","date":"2018-03-31","category":"Flask","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\nSQLAlchemy 入门，看本文就好了\n\n## 0x00 前言\n\n大约一年前，工作从 Django 开发切到 Flask 开发，ORM 选用的是 SQLAlchemy, 用了大半年后，借着这个机会重新回顾一下 SQLAchemy 和 Django ORM, 补充一下文档。\n\n这篇文章算是笔记吧\n\nPython 圈内有两大 ORM 框架\n\n- SQLAlchemy\n- Django ORM\n\n当然，也有 peewee 之类的其他 ORM。\n\n## 0x01 ORM 解决了什么问题？\n\n了解一个框架，最好是从下面几处入手：\n\n- 官方 Tuorial\n- 官方 Example\n- 官方 Guide\n- 官方 APIDocument\n- 源码\n\n对框架掌握越深，就越需要使用者多多从上开始逐渐向下了解。\n\n其实还有一些途径：\n\n- Github 上面的 issue\n- Stack Overflow 的高 vote 常见问题\n- **如果作者有一些活跃的社区的话，可以火速前往**\n\n鉴于我们的目标在于入手，所以可以火速过一下：\n\n- 官方 Tuorial\n- 官方 Example\n- 官方 Guide\n- Github 上面的 issue\n- Stack Overflow 的高 vote 常见问题\n- **如果作者有一些活跃的社区的话，可以火速前往**\n\n## 0x02 SQLAlchemy 的基本功能\n\n### 2.0 SQLAlchemy VS DjangoORM\n\nORM 通常有 DataMapper 实现和 ActiveRecord 实现两种。\n\n依照我的经验，ActiveRecord 使用起来的更接近对象 (Object) 的操作，DataMapper 使用起来更接近 (Table) 的操作。\n\n\u003e SQLAlchemy 是 DataMapper 模式的实现，在该模式下，session 会暴露出来，即 Model 与 session 并不耦合。\n\n\u003e DjangoORM 是 ActivityRecord 模式的一种实现，在该模式下，session 并不暴露出来，即 Model 与 session 耦合。\n\n使用 Django ORM 的时候，往往是\n\n```\nb = Blog(**data)\nb.save()\n```\n\n使用 SQLAlchemy 的时候，往往是\n\n```\nb = Blog(**data)\nsession.add(b)\nsession.session(b)\n```\n\n由于 Django 帮你屏蔽了 session 的操作。\n\n在通常情况下，\n\n1. DjangoORM 使用起来更加接近 Object 的操作。\n2. SQLAlchemy 使用起来更加接近 Table 的操作。\n\n举个例子，\n\n一对多，Father 添加两个小孩（其中一个小孩是已经存在的）\n\n在 DjangoORM 里面， 这里更像是一个 Set 的 add 操作。\n\n```\nfather.children.add(new_child,exsit_child)\n```\n\n在 SQLAlchemy 里面，这里更像是一个 table 的 insert 操作。（麻蛋，你要说是一个 list 的 append 操作也行）\n\n```\nfor child in (new_child,exsit_child):\n    if child in father.children:\n        father.children.append(child)\n```\n\n\u003e 写 SQLAlchemy 更接近操作放在数据库里面的数据记录，而 DjangoORM 更接近操作一批放在数据库里面的对象。\n\n由于 session 的使用姿势不同，所以往往会有很多使用上面的区别。\n\n至于孰优孰劣，难以评判。\n\n- 技术老大 (Flask 和 React 大神）倾向于使用 SQLAlchemy, 他认为\n\n  - 对于一个技术『知其然，知其所以然』\n  - 对于 ORM\n    - 操作数据库，操作最好要落实在成 SQL\n    - 如果有可能的话，每一个 SQL 语句都要经过推敲，而且写这个 SQL 和 ORM 过程要反复练习\n  - 对于 Migration 机制\n    - Alembic 这个迁移工具是为了省事用的，甚至在某些情况下没必要用。完全可以写 SQL 代替\n\n- 我 (Django 和 Vue 弱鸡）倾向于使用 DjangoORM, 我认为\n  - 对于一个技术『先知其大致然，需要深入的时候知其所以然』\n  - 对于 ORM\n    - 操作数据，最好抽象为对对象的操作。\n    - 测试到位的情况下，快糙狠先出东西。到需要优化的时候该怎么 Profile 怎么 Profile\n  - 对于 Migration 机制\n    - 用起来啊，能操作对象为什么还要强行到数据库操作？\n\n### 2.1 模型定义\n\n先看一组模型\n\n```python\nfrom sqlalchemy.ext.declarative import declarative_base\nBase = declarative_base() # 模型基类\nfrom sqlalchemy import Column, Integer, String\nclass User(Base):\n    __tablename__ = 'users'\n\n    id = Column(Integer, primary_key=True) # 主键\n    name = Column(String)\n    fullname = Column(String)\n    password = Column(String)\n\n    def __repr__(self):\n       return \"\u003cUser(name='%s', fullname='%s', password='%s')\u003e\" % (\n                            self.name, self.fullname, self.password)\nBase.metadata.create_all(engine)\n```\n\n可以看出，包含如下的部分：\n\n1. Model 与 Model 内部的 Meta\n2. Field 与 Field 内部的 Options\n3. Model 与 Model 之间的关系\n4. 其他，比如索引\n\n#### Models 与 Meta\n\nhttps://github.com/zzzeek/sqlalchemy/blob/master/lib/sqlalchemy/sql/schema.py#L3685\n\n#### 关系\n\n##### One To Many\n\n母亲有若干个孩子，外键在孩子上。\n\n```\nclass Parent(Base):\n    #...\n    children = relationship(\"Child\", backref=\"parent\")\n\nclass Child(Base):\n    #...\n    parent_id = Column(Integer, ForeignKey('parent.id'))\n```\n\n##### Many To One\n\n多个母亲共享一个孩子，外键在母亲上。\n\n```\nclass Parent(Base):\n    child_id = Column(Integer, ForeignKey('child.id'))\n    child = relationship(\"Child\")\n\nclass Child(Base):\n    # ...\n```\n\n##### One To One\n\nOne to One 是 One to Many 或者是 Many to One 的简化版本\n\n```\n# Many To One\nclass Parent(Base):\n    # ...\n    child_id = Column(Integer, ForeignKey('child.id'))\n    child = relationship(\"Child\", backref=backref(\"parent\", uselist=False))\n\nclass Child(Base):\n    # ...\n\n# One To Many 改 One To One\nclass Parent(Base):\n    # ...\n\nclass Child(Base):\n    # ...\n    parent_id = Column(Integer, ForeignKey('parent.id'))\n    parent = relationship(\"Parent\", backref=backref(\"child\", uselist=False))\n```\n\n##### Many To Many\n\n```\nassociation_table = Table('association', Base.metadata,\n    Column('left_id', Integer, ForeignKey('left.id')),\n    Column('right_id', Integer, ForeignKey('right.id'))\n)\n\nclass Parent(Base):\n    # ...\n    children = relationship(\"Child\",\n                    secondary=association_table,\n                    backref=\"parents\")\n\nclass Child(Base):\n    # ...\n```\n\n注意事项\n\n执行删除 mapping 表的时候尽量这样。\n\n```bash\nmyparent.children.remove(somechild)\n```\n\n当你想干掉 somechild 的时候，会执行\n\n```\nsession.delete(somechild)\n```\n\n1. 假如 Child 没有 ref Parent 的话，Secondary Table 无删除，则无法删除。\n2. 假如 ref 了的话，则删除 secondary 里面的记录。\n3. TODO\n\n##### 邻接列表关系\n\n```\nclass Node(Base):\n    __tablename__ = 'node'\n    id = Column(Integer, primary_key=True)\n    parent_id = Column(Integer, ForeignKey('node.id'))\n    data = Column(String(50))\n    children = relationship(\"Node\",\n                backref=backref('parent', remote_side=[id])\n            )\n```\n\n##### relationship 详解\n\n### 2.1 Query\n\n#### Create\n\n```\nc1 = Child(name=\"苏轼\")\nsession.add(c1)\nsession.flush()\np = Parent(name=\"苏辙\")\np.best_child = c1\nfor c in [c1,c2,c3,c4]:\n    p.children.append(c)\nsession.add(c1)\nsession.commit()\n```\n\n#### Retrieve\n\n过滤\n\nfilter(\\*\\*kwargs)\nfilter(Singer.name == \"周杰伦\")\nfilter(Singer.name =! \"周杰棍\")\n\n##### 跨关系（跨表）查询\n\nsession.query(Entry).join(Blog,Blog.entry_id == Entry.id).filter(Blog.name = \"SqlAlchemy CheatSheet\")\n\n##### Limit / Offset / 分页\n\n- limit()\n- offset()\n\n##### 链式调用\n\n```\nquery = session.query(Order) # query = session.query(Order)\nquery = query.filter(Order.name.like(f\"%name%\"))\n```\n\n##### 二进制表达式\n\n我们先 type 一下表达式，找到 eq 的类型\n\n```python\ntype(model.column_name == 'asdf') → sqlalchemy.sql.elements.BinaryExpression\n```\n\n是一个二进制表达式。\n\n```python\n# 等于\nquery.filter(User.name == 'ed')\n# 不等于\nquery.filter(User.name != 'ed')\n# Like（有的数据库不区分大小写）\nquery.filter(User.name.like('%ed%'))\n# ILIKE (case-insensitive LIKE)\nquery.filter(User.name.ilike('%ed%'))\n# IN\nquery.filter(User.name.in_(['ed', 'wendy', 'jack']))\n# Not in\nquery.filter(~User.name.in_(['ed', 'wendy', 'jack']))\n# IS NULL\nquery.filter(User.name == None)\n## 如果你用了 pep8/linter 的话\nquery.filter(User.name.is_(None))\n# IS NOT NULL:\nquery.filter(User.name != None)\n## 如果你用了 pep8/linter 的话\nquery.filter(User.name.isnot(None))\n# AND\n## use and_()\nquery.filter(and_(User.name == 'ed', User.fullname == 'Ed Jones'))\n## or send multiple expressions to .filter()\nquery.filter(User.name == 'ed', User.fullname == 'Ed Jones')\n## or chain multiple filter()/filter_by() calls\nquery.filter(User.name == 'ed').filter(User.fullname == 'Ed Jones')\n# OR\nquery.filter(or_(User.name == 'ed', User.name == 'wendy'))\n# MATCH\nquery.filter(User.name.match('wendy'))\n```\n\n##### 执行查询\n\n```\nall()\nfirst()\none()\none_or_none()\nscalar()\n```\n\nYourModel.query.get((pk1, pk2))\n\n##### 比较\n\n\u003e 同一个 Session 下面，取到的某一条数据对应的 objects 应该是一样的？\n\n##### 复制 实例\n\n##### 其他\n\n```\n# 查询的是 SomeModel 里面所有的字段 即 select *\nquery = session.query(SomeModel)\n# 查询的是 SomeModel 里面部分的字段 即 select acol, bcol\nquery = session.query(SomeModel.acol,SomeModel.bcol)\n# 即 select acol , bcol\n# alias\nuser_alias = aliased(User, name='user_alias')\nfor row in session.query(user_alias, user_alias.name).all():\n    # 即相当于 select name as name_label\n    print(row.user_alias)\n\n# limit 和 offset\nfor u in session.query(User).order_by(User.id)[1:3]:\n    print(u)\n\n# distinct\nsession.query(model.Name).distinct(model.Name.value).order_by(model.Name.value)\n# order_by\nUser.query.order_by(User.popularity.desc(),User.date_created.desc()).limit(10).all()\n```\n\n#### Update\n\n单个 object 更新\n\n```\nblog.title = \"大宝天天见\"\nsession.add(blog)\nsession.commit()\n```\n\n批量更新\n\n```\nsession.query.filter(Blog.content.like(\"% 敏感词 %\")).update({\n    Blog.content: \"依照相关 XX 无法查看\"\n})\n```\n\n一对多的更新\n\n```\nappend\n```\n\n#### Delete\n\nquery.delete()\n\n#### JOIN\n\nhttps://stackoverflow.com/questions/6044309/sqlalchemy-how-to-join-several-tables-by-one-query\n\n##### 两表 InnerJoin\n\n```python\nfor u, a in session.query(User, Address).\\\n                    filter(User.id==Address.user_id).\\\n                    filter(Address.email_address=='jack@google.com').\\\n                    all():\n    print(u)\n    print(a)\n# \u003cUser(name='jack', fullname='Jack Bean', password='gjffdd')\u003e\n# \u003cAddress(email_address='jack@google.com')\u003e\n\n```\n\n##### 多表 InnerJoin + LeftJoin\n\n```\nquery.outerjoin(User.addresses)   # LEFT OUTER JOIN\n```\n\n#### 聚集查询\n\n```\nsession.query(User).filter(User.name.like('%ed')).count()\n```\n\n```\nfrom sqlalchemy import func\nsession.query(Table.column, func.count(Table.column)).group_by(Table.column).all()\n\nself.session.query(func.count(Table.column1),Table.column1, Table.column2).group_by(Table.column1, Table.column2).all()\n\nfrom sqlalchemy.sql import func\nsession.query(func.avg(Rating.field2).label('average')).filter(Rating.url==url_string.netloc)\n```\n\n#### 缓存机制\n\nQuery 对象，下文中，我会聊到这个 Query 对象。这里先跳过。\n\n### 2.2 原生查询\n\n```\nfrom sqlalchemy import text\n\nsql = text('select name from penguins')\nresult = db.engine.execute(sql)\nnames = []\nfor row in result:\n    names.append(row[0])\n\nprint names\n\nfrom collections import namedtuple\n\nRecord = namedtuple('Record', result.keys())\nrecords = [Record(*r) for r in result.fetchall()]\nfor r in records:\n    print(r)\n\nfrom sqlalchemy.sql import text\n\nconnection = engine.connect()\n\n# recommended\ncmd = 'select * from Employees where EmployeeGroup == :group'\nemployeeGroup = 'Staff'\nemployees = connection.execute(text(cmd), group = employeeGroup)\n\n```\n\nget_or_create\n\n```\ndef get_or_create(session, model, defaults=None, **kwargs):\n    instance = session.query(model).filter_by(**kwargs).first()\n    if instance:\n        return instance, False\n    else:\n        params = dict((k, v) for k, v in kwargs.iteritems() if not isinstance(v, ClauseElement))\n        params.update(defaults or {})\n        instance = model(**params)\n        session.add(instance)\n        return instance, True\n```\n\n### 2.3 更新查询\n\n```\nsession.query(Stuff).update({Stuff.foo: Stuff.foo + 1})\n```\n\n```\n1) for c in session.query(Stuff).all():\n       c.foo += 1\n   session.commit()\n\n2) session.query().\\\n       update({\"foo\": (Stuff.foo + 1)})\n   session.commit()\n\n3) conn = engine.connect()\n   stmt = Stuff.update().\\\n       values(Stuff.foo = (Stuff.foo + 1))\n   conn.execute(stmt)\n```\n\n```\n1) user.no_of_logins += 1\n   session.commit()\n\n2) session.query().\\\n       filter(User.username == form.username.data).\\\n       update({\"no_of_logins\": (User.no_of_logins +1)})\n   session.commit()\n\n3) conn = engine.connect()\n   stmt = User.update().\\\n       values(no_of_logins=(User.no_of_logins + 1)).\\\n       where(User.username == form.username.data)\n   conn.execute(stmt)\n\n4) setattr(user, 'no_of_logins', user.no_of_logins+1)\n   session.commit()\n```\n\n### 2.4 删除\n\nhttps://stackoverflow.com/questions/5033547/sqlalchemy-cascade-delete\n\n#### OnDelete\n\nondelete='CASCADE'))\n\n#### 批量操作\n\nmodels.User.query.delete()\n\n### 如何从 Object 到一个 ORM\n\n如何追踪 Object 的变化？\n\n## 0x03 SQLAlchemy 的高级特性\n\n### 表继承\n\nhttps://stackoverflow.com/questions/1337095/sqlalchemy-inheritance\n\n### 啥玩意\n\nFlush 和 commit\n\nhttps://stackoverflow.com/questions/4201455/sqlalchemy-whats-the-difference-between-flush-and-commit\n\n```\nx = Foo(bar=1)\nprint x.id\n# None\nsession.add(x)\nsession.flush()\n# BEGIN\n# INSERT INTO foo (bar) VALUES(1)\n# COMMIT\nprint x.id\n```\n\n```\nqry = DBSession.query(User).filter(\n        and_(User.birthday \u003c= '1988-01-17', User.birthday \u003e= '1985-01-17'))\n```\n\n## 0x04 SQLAlchemy 的基础特性 Under The Hood\n\n### Loading 策略\n\n#### Lazy Loading\n\n#### Eager Loading\n\n```\n\u003e\u003e\u003e from sqlalchemy.dialects import postgresql\n\u003e\u003e\u003e print str(q.statement.compile(dialect=postgresql.dialect()))\nWhere q is defined as:\n\n```\n\n## 0x05 SQLAlchemy 的高级特性 Under The Hood\n\n### 多线程\n\nhttps://stackoverflow.com/questions/6297404/multi-threaded-use-of-sqlalchemy\nhttps://stackoverflow.com/questions/9619789/sqlalchemy-proper-session-handling-in-multi-thread-applications\n\n```\n\nhttps://stackoverflow.com/questions/34322471/sqlalchemy-engine-connection-and-session-difference\nhttps://stackoverflow.com/questions/11769366/why-is-sqlalchemy-insert-with-sqlite-25-times-slower-than-using-sqlite3-directly\nhttps://stackoverflow.com/questions/12223335/sqlalchemy-creating-vs-reusing-a-session\nsession 是个容器\n\nhttps://stackoverflow.com/questions/18199053/example-of-what-sqlalchemy-can-do-and-django-orm-cannot\nhttps://stackoverflow.com/questions/7389759/memory-efficient-built-in-sqlalchemy-iterator-generator\n\n# 日志\nimport logging\nlogging.basicConfig()\nlogging.getLogger('sqlalchemy.engine').setLevel(logging.INFO)\n```\n\n## 0x06 DEBUG 和 Profile 技巧\n\n```\nSQLALCHEMY_TRACK_MODIFICATIONS = False\n```\n\n### 6.1 查看技巧\n\ndict(u)\nu.**dict**\n\nhttps://stackoverflow.com/questions/1171166/how-can-i-profile-a-sqlalchemy-powered-application\n\n如果用上 Flask+SQLAlchemy 一般也要带上，Flask-Migration 与 Flask-SQLAlchemy, 这两个库也是对 Alembic 和 SQLAlchemy 的浅封装。\n\n那么，对于这个 ORM 库还有那些通用性的知识需要了解？\n\n嗯，是时候了解本质了。\n\nhttp://derrickgilland.com/posts/demystifying-flask-sqlalchemy/\n\n## 0x07 ORM 的本质\n\nORM 的本质是 Data Access Layer 上的一层封装。如果你写原生 SQL, 即手写 DAL 的话，开发效率可能会大打折扣。\n\n### ORM 的两种类型 Active Record 与 Data Mappers\n\n```\n# ActiveRecord 风格写起来类似于 Django ORM, 大致是这样的\n\n## AR 的模型定义\n\nclass User(db.models):\n    name = db.StringField(verbose=\"xyz\")\n\n## AR 的新增\nuser = User()\nuser.name = \"123456\"\nuser.save() ## 正好对应数据库中的一行\n\n## AR 的查询\n\nusers = User.objects.filter(Q(name=\"黄老板的小姨子\")).all()\n\n# Data Mappers 风格写起来类似于 SQLAlchemy ORM, 大致是这样的\n\n## SA 的定义\n\nfrom sqlalchemy.ext.declarative import declarative_base\n\nBase = declarative_base()\n\nfrom sqlalchemy import Column, Integer, String\nclass User(Base):\n    __tablename__ = 'users'\n\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n\nBase.metadata.create_all(engine)\n\n## SA 的新增\n\nuser = User()\nuser.name = \"123456\"\nsession.add(user)\nsessoon.commit() ## 嗯？其实也是对应数据库中的一行。\n\n## SA 的查询\n\nsession.query(User).filter(User.name)\n\n```\n\n问题来了，这两者到底是什么，看起来似乎相差不大。\n\n```\nclass Person:\n\n    lastname\n    firstname\n    children\n\n    # 数据操作\n    def findone(self):\n        pass\n\n    def insert(self):\n        pass\n\n    def update(self):\n        pass\n\n    def delete(self):\n        pass\n\n    # 业务逻辑\n    def getChildrenTax(self):\n        pass\n\n```\n\nlastName firstName numberOfDependents\n\ninsert update delete\n\ngetExemption isFlaggedForAudit getTaxableEarnings\n\nAn object that wraps a row in a database table or view, encapsulates the database access, and adds domain logic on that data.\n\nThe essence of an Active Record is a Domain Model (116) in which the classes match very closely the record structure of an underlying database. Each Active Record is responsible for saving and loading to the database and also for any domain logic that acts on the data. This may be all the domain logic in the application, or you may ﬁnd that some domain logic is held in Transaction Scripts (110) with common and data-oriented code in the Active Record.\n\nThe data structure of the Active Record should exactly match that of the database: one ﬁeld in the class for each column in the table. Type the ﬁelds the way the SQL interface gives you the data—don’t do any conversion at this stage. You may consider Foreign Key Mapping (236), but you may also leave the foreign keys as they are. You can use views or tables with Active Record, although updates through views are obviously harder. Views are particularly useful for reporting purposes.\n\nobjects correspond directly to the database tables: an isomorphic schema. If your business logic is complex, you’ll soon want to use your object’s direct relationships, collections, inheritance, and so forth. These don’t map easily onto Active Record, and adding them piecemeal gets very messy. That’s what will lead you to use Data Mapper (165) instead.\n\nAnother argument against Active Record is the fact that it couples the object design to the database design. This makes it more difﬁcult to refactor either design as a project goes forward.\n\nActive Record is a good pattern to consider if you’re using Transaction Script (110) and are beginning to feel the pain of code duplication and the difﬁculty in updating scripts and tables that Transaction Script (110) often brings. In this case you can gradually start creating Active Records and then slowly refactor behavior into them. It often helps to wrap the tables as a Gateway (466) ﬁrst, and then start moving behavior so that the tables evolve to a Active Record.\n\n其实为什么不选择设计成 ActiveRecord , 而是选择设计成 Data Mapper, 其实就可以回答这个问题：\n\n\u003e 虽然要设计成 ORM, 考虑到数量和性能因素，SQL 数据库（多个表）并不应该是表现像 Object 集合那样（换言之，也就是 AR 表现的像 Object 的集合一样）。\n\u003e 同时，出于更好的抽象，object 集合也应该表现的像表以及行\n\n于是我们可以得出结论，可以在 SQLAlchemy 上面进行一定的封装，使得最后用起来非常的 Django ORM like，其实 SQLAlchemy 稍加定制还是可以很 Django ORM-like 的。\n\n:TODO: 有机会看看那本书再修改一下本小节\n\n这不，果然有人就这么搞了 https://github.com/absent1706/sqlalchemy-mixins\n\n## 0x09 踩坑集\n\n### 关系持久化坑\n\n1. Rows that point to themselves : 比如一个 insert 一个推荐自己的用户，则需要保存 id / ref_id , 但是在这个 user 插入之前，并不存在 id. 所以，一般情况下是先 insert, 然后保存 ref_id\n2. Mutually Dependent Rows\n\n### SQL 注入\n\nsession.query(MyClass).filter(\"foo={}\".format(getArgs['val']))\n\n## 0xEE 参考链接\n\n- https://www.eversql.com/django-vs-sqlalchemy-which-python-orm-is-better/\n- https://stackoverflow.com/questions/2546207/does-sqlalchemy-have-an-equivalent-of-djangos-get-or-create\n- 除了文档本身，作者在 Stack Overflow 上的回答都是非常值得阅读的。https://stackoverflow.com/users/34549/zzzeek\n- Patterns of Enterprise Application Architecture - Martin Fowler\n- http://aosabook.org/en/sqlalchemy.html\n\n  http://techspot.zzzeek.org/\n\n---\n\nChangeLog:\n\n- **2018-03-09** 重修文字\n"},{"tags":["Python","Flask"],"path":"20180309_Flask文档阅读笔记.md","title":"Flask 文档阅读笔记","slug":"Flask 文档阅读笔记","date":"2018-03-09","category":"Flask","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n因为最近需要新增一个 Flask 技术栈，所以准备趁这休息的时候更新关于 Flask 的两篇文章。\n\n前者是文档阅读笔记，后者是源码初步解析。\n\n\u003e 嗯，其实这篇就是做了一些搬运的活。\n\n## 0x01 文档\n\n由于 Flask 还依赖 Jinja2 与 Werkzeug, 并且往往大家在使用 Flask 的时候还是会使用 itsdangerous. 所以，当大家说 Flask 代码少的时候，我还是不服的。但如果你说，Flask 本身实现确实是简洁，扩展性强，我还是服气的。\n\nFlask 的文档有三种类型（其他框架类文档也是如此）：\n\n- Tutorial 类，即教程类\n- Guide 类，即指南类\n- API 类，即接口级别的文档\n\n当你是一个老手，还想快速上手一个框架的时候，认真读一读前两者，然后挑选一个项目多看几遍即可。\n\n但是当你深入到框架里面的设计与实现的时候，则必须要多读读 API Document , 由于通常情况下 API Document 的内容往往是代码中的注释，加上 Flask 代码量本来就不多。所以，有的时候阅读 Flask 代码代码也会比 API 好很多。\n\n## 0x02 Guide\n\n### 2.1 Templates\n\n快速 Get 模板语言无非就是掌握：\n\n1. 上下文变量\n2. 条件语法\n3. 列表语法\n4. 模板的继承 (extend 语法）与组合 (include)\n5. 额外的一些语法糖，比如 filter 的使用 / 组成\n\n### 2.2 Testing Flask Applications\n\n\u003e Something that is untested is broken.\n\n这里的测试，有哪些测试呢？\n\n1. 非 flask 相关逻辑的测试。比如，我对一小段无关于 View 层的纯粹的逻辑进行测试，我比较喜欢使用 pytest 进行测试。\n2. Flask 相关\n\n- Setup\n- TearDown\n- 登录前 / 登陆后\n\n### 2.3 Application Errors\n\n比如测试请求与响应结果。比如测试路由。测试某个与 View 层绑定的数据操作是否执行成功。\n\n首先，大致扫一眼 tutorial ，知道了 Flask 的教程讲了如下的东西：\n\n1. 路由\n2. 静态文件\n3. 模板渲染\n4. 接触请求数据\n5. 重定向和错误\n6. 响应\n7. Session\n8. Message Flash\n9. 日志\n10. 扩展\n\n当然，我们都是老手了，肯定是挑重点来看了。\n\nRouting, 发现现在的问题在于\n\nFlask 有两个主要依赖：\n\n- 路由、调试、WSGI\n- 模板\n\n## 0x02 社区支持\n\n## 0x04 读文档产生的疑问\n\n1.\n\nFor web applications it’s crucial to react to the data a client sends to the server. In Flask this information is provided by the global request object. If you have some experience with Python you might be wondering how that object can be global and how Flask manages to still be threadsafe. The answer is context locals:\n\nContext Locals\nInsider Information\nIf you want to understand how that works and how you can implement tests with context locals, read this section, otherwise just skip it.\n\nCertain objects in Flask are global objects, but not of the usual kind. These objects are actually proxies to objects that are local to a specific context. What a mouthful. But that is actually quite easy to understand.\n\nImagine the context being the handling thread. A request comes in and the web server decides to spawn a new thread (or something else, the underlying object is capable of dealing with concurrency systems other than threads). When Flask starts its internal request handling it figures out that the current thread is the active context and binds the current application and the WSGI environments to that context (thread). It does that in an intelligent way so that one application can invoke another application without breaking.\n\nSo what does this mean to you? Basically you can completely ignore that this is the case unless you are doing something like unit testing. You will notice that code which depends on a request object will suddenly break because there is no request object. The solution is creating a request object yourself and binding it to the context. The easiest solution for unit testing is to use the test_request_context() context manager. In combination with the with statement it will bind a test request so that you can interact with it. Here is an example:\n\n### Thread Local\n\nOne of the design decisions in Flask was that simple tasks should be simple; they should not take a lot of code and yet they should not limit you. Because of that, Flask has a few design choices that some people might find surprising or unorthodox. For example, Flask uses thread-local objects internally so that you don’t have to pass objects around from function to function within a request in order to stay threadsafe. This approach is convenient, but requires a valid request context for dependency injection or when attempting to reuse code which uses a value pegged to the request. The Flask project is honest about thread-locals, does not hide them, and calls out in the code and documentation where they are used.\n"},{"tags":["Python","Flask"],"path":"20180309_Flask源码解析.md","title":"Flask 源码初步解读","slug":"Flask 源码初步解读","date":"2018-03-09","category":"Flask","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n系列文章先暂时停更一下。今天换换口味。\n\n久闻 Flask 是众多 Pythonist 喜欢的框架。这次借着换工作的机会熟悉一下 Flask\n\n1. 本文先分享我阅读代码的一些小经验\n2. 接着通过最简单的一个 WSGI APP 开始，带着**如何设计一个 Web 框架**这个问题，先头脑风暴，从而脑补（而不是实现）出一个 Web 框架的基本要素。\n3. 从源码角度理解，Flask 从启动到接受第一个请求、返回第一个响应期间都发生了什么。\n4. 最后交代一些自己在这个过程中的一些突发的想法。\n\n\u003e 将解读 Flask 的源码放在一篇文章里，势必会造成广度有余而深度不足。所以本想定位于 Flask 源码初步解读。\n\n## 0x01 阅读 Flask 代码的一种较好的姿势\n\n之前在 https://www.zhihu.com/question/28509408/answer/299763091 分享过自己一点阅读代码的粗浅的经验，是以阅读一个 Django 的应用为案例的。这里借着读 Flask 本身分享一下我的看法。\n\n读源码，是一个技术活。一是忌讳要想读懂全部，另一个忌讳是以为自己能一下子毫无障碍的读懂全部代码。\n\n0. 建议 0 : 看源码的时候，**务必务必带着问题去读**。每一次阅读其实都是在尝试回答或小或大的问题（当然，读书看文章莫不如是）。\n1. 建议 1 : 先读现成的文档，不要上来就对着代码一通瞎看。\n2. 建议 2 : 所谓『横看成岭侧成峰，远近高低都不同』 你需要从不同的角度来读源码。\n3. 建议 3 : 抓大放小，该略读就略读（比如知道 Nginx 的大致作用就好，做优化请求响应的时候再翻看文档），该精读则精读（具体一个关键的功能）。\n\n\u003e 好，坐好，预备，开车。\n\n## 0x02 问题 1: 如何设计一个 Web 框架\n\n### 头脑风暴\n\nFlask 是一个微 Web 框架，换而言之，代码量少的 Web 框架。当然，其实 Flask 框架是一个微框架，但『常规的 Flask 应用』本身的代码加起来一点都不比『Django 应用』少。这个地方我们后面会讲到。\n\n在阅读 Flask 相关代码的之前，先头脑风暴一下：\n\n\u003e 如何设计一个 Web 框架？\n\n当心中对这个问题有一定的了解之后，读 Flask 代码会更好。\n\n首先，Web 框架是为了提升 Web 开发的。(XX 框架是为了提升 XX 开发的）, 这种提升可能会是 开发体验 / 性能。\n\n我们来看看那个 Python 世界最基础的 wsgi app 相关代码。\n\n```python\ndef application(environ, start_response):\n    start_response('200 OK', [('Content-Type', 'text/plain')])\n    return ['Hello World!']\n```\n\n在之前的文章，我也借 Django 的 DRF 提到过这个极简的代码。\n\n但这个简单的 webapp，显然是啥玩意都不够用的。比如说：\n\n- 没有路由，我访问啥玩意都是 hello world。\n- 单线程 IO 阻塞模型基本上啥都不能干。你比如说，启动这个 webapp 的时候在 return 数据之前直接 sleep 十秒，然后请求都进不来。\n- 没有数据存取，连个数据库链接 CURDE 啥玩意都没有\n- environ 太过于底层，如果是判断 headers 啥的太麻烦，要是像 django 里面一样能拿到一个 request 对象返回一个 response 对象就好了。\n- 没有模板语言\n- 还有其他能够提升开发体验的东西，比如自带 http server 代码热加载之类。\n\n```python\ndef application(environ, start_response):\n    # 直接 thread local 支持多个请求。\n    # 依据 environ 判断路由\n    # 依据 路由 执行相关 view 层方法\n    # 在相关 view 层方法内执行相关逻辑\n    start_response('200 OK', [('Content-Type', 'text/plain')])\n    # 返回对应响应\n    return response\n```\n\n当然，思路是这么个思路，这个思路也确实非常的命令式，非常的面向过程。\n\n至于我们如何把这个面向过程的思路变成面向对象的设计与实现，则需要更加细致的思考这些问题。\n\n1. 能不能把 request 和 response 封装一下？方便在 view 里面处理？\n2. 能不能有个 URLDisparch 之类的东西，帮你解决 url 和 view 的 mapping 问题。或者路由能不能直接搞成 装饰器类型的比如 @router(\"/\") 直接放在 view 层的 function 上。\n3. 能不能有个方便对数据库进行 CURDE 的东西？比如 ORM/ODM\n4. 这玩意会不会线程不安全，假如我想每一个请求都有单独的变量集合的话，线程怎么管理？\n5. ......\n\n### 设计 Web 框架\n\n利用 Flask 作者的另一个库 werkzeug 的案例中有这么一个东西。\n\nhttps://github.com/pallets/werkzeug/blob/master/examples/shortly/shortly.py\n\n几百行代码就不贴在这里了。仔细看看还是挺有趣的。 这个可以算作另一个超简的 Webapp 了。\n\nFlask 算作在这个基础上进行一定的扩展而成。\n\n看完上面这个就可以出去吹牛逼可以自己写一个极简 Web 框架了。\n\n那么，你可能有疑问，为何有了 Flask 之后，是否需要看这个更底层的 Werkzeug 的库，当然，有必要咯，Python 世界除了老牌的比较流行的 Django/Flask, 还有一个新星，叫做 APIStar\n\nhttps://github.com/encode/apistar\n\n## 0x02 问题 2: 请求流程是怎么样的\n\n我们就拿这个 flask 的极简案例，进行**首次**阅读 Flask 代码。\n\n```python\n# hello.py\nfrom flask import Flask\n\napp = Flask(__name__)\n\n@app.route('/')\ndef hello():\n    return 'Hello, World!'\n\n$ FLASK_APP=hello.py flask run\n```\n\n\u003e 从请求到响应的整个流程，Flask 的是怎么处理请求的？\n\n### 2.1 服务器是怎么起来的\n\n首先 flask run 之后，发生了什么？\n\n先初始化环境变量，然后导入 dotenv 文件，然后执行 run_command 方法，找到 hello.py 然后导入\n\n```python\n#cli.py#run_command 方法\napp = DispatchingApp(info.load_app, use_eager_loading=eager_loading)\n# 上一行代表着其实我们每次在本地 flask run 的时候，起的服务并不是 flask_app, 而是被 DispatchingApp 包装了一层的 flask app\n\nfrom werkzeug.serving import run_simple\nrun_simple(host, port, app, use_reloader=reload, use_debugger=debugger,\n            threaded=with_threads, ssl_context=cert)\n```\n\n进行这层包装之后，就可以显示 WERKZEUG 的所谓在浏览器中的 报错信息了。\n\n通常开发时这里的 run_simple 最后会调用 run_with_reloader , 每当程序退出的时候，reloader 就依照策略重新跑一次 reload 一次。\n\n```python\ndef run_with_reloader(main_func, extra_files=None, interval=1,\n                      reloader_type='auto'):\n    \"\"\"Run the given function in an independent python interpreter.\"\"\"\n    import signal\n    reloader = reloader_loops[reloader_type](extra_files, interval)\n    signal.signal(signal.SIGTERM, lambda *args: sys.exit(0))\n    try:\n        if os.environ.get('WERKZEUG_RUN_MAIN') == 'true':\n            t = threading.Thread(target=main_func, args=())\n            t.setDaemon(True)\n            t.start()\n            reloader.run()\n        else:\n            sys.exit(reloader.restart_with_reloader())\n    except KeyboardInterrupt:\n        pass\n```\n\n好，服务起来了。\n\n### 2.2 请求-响应的流程\n\n我们先看 Flask 类里面的比较关键的两个方法：\n\n```python\nclass Flask(_PackageBoundObject):\n    # 一些方法 ......\n    def full_dispatch_request(self):\n        # 主要是执行一些方法，最后返回响应\n        self.try_trigger_before_first_request_functions()\n        try:\n            request_started.send(self)\n            rv = self.preprocess_request()\n            if rv is None:\n                rv = self.dispatch_request()\n        except Exception as e:\n            rv = self.handle_user_exception(e)\n        # ??? TODO\n        return self.finalize_request(rv)\n\n    # 这里是我们熟悉的 environ, 和 start_response\n    def wsgi_app(self, environ, start_response):\n        \"\"\"\n        :param environ: a WSGI environment\n        :param start_response: a callable accepting a status code,\n                               a list of headers and an optional\n                               exception context to start the response\n        \"\"\"\n        # 在这里对 environ 进行封装，创建请求上下文\n        ctx = self.request_context(environ)\n        error = None\n        try:\n            try:\n                # 这里将请求上下文压入 _request_ctx_stack\n                ctx.push()\n                response = self.full_dispatch_request()\n            except Exception as e:\n                error = e\n                response = self.handle_exception(e)\n            except:\n                error = sys.exc_info()[1]\n                raise\n            return response(environ, start_response)\n        finally:\n            if self.should_ignore_error(error):\n                error = None\n            # 这里将创建的请求上下文从中 _request_ctx_stack pop 出来\n            ctx.auto_pop(error)\n```\n\n从 wsgi_app 泪看，就可以看到我们之前在当时在开脑洞时候看到的。\n\n1. 把 request 和 response 封装一下？方便在 view 里面处理？\n2. 有个 URLDisparch 之类的东西，帮你解决 url 和 view 的 mapping 问题。\n\n话说回来？\n\n\u003e 这个 ctx 是啥？\n\u003e 当然，flask 不带 ORM, 这我们也就不研究了。\n\n-- TODO: 在这里需要重构一下\n\n不过话说回来 请求上下文的容器 request_ctx_stack 到底是啥？\n\n\u003e 另一种本地数据存储方式。\n\n在多线程的情况下，每一个请求都会创建一个线程，从这个请求被发起到销毁，我想拥有单独的变量（修改这个变量不会影响到其他变量），比如 sessions 之类。\n\n显然，在多线程的情况下，以上的需求完全可以通过 threadlocal 来实现。\n\n翻了 werkzeug 的文档，找到了原因：\n\n\u003e 因为 python 里面的并发模型并不只有多线程一种。比如 greenlets, 每一个请求，都在一个线程里面。\n\n## 0x02 问题 2: Flask 中 Context 机制\n\n在 Django 完成一个 View 层的逻辑是这样的，Django 封装好了请求，请求经过 middleware 的处理，最后调用 login 函数，并且传入 request 方便 view 函数进行处理。\n\n```python\ndef login(request):\n    if request.method == 'POST':\n        error = someerror\n    return render_template('login.html', error=error)\n```\n\n在 Flask 完成一个 View 层的逻辑是这样的\n\n```python\nfrom flask import request\n@app.route('/login', methods=['POST', 'GET'])\ndef login():\n    if request.method == 'POST':\n        error = someerror\n    return render_template('login.html', error=error)\n```\n\n假如我是一个爱问问题的年轻人，这里肯定会有疑惑：\n\n\u003e 从外部 import 过来，那就是利用了 python 自带的 import 单例模式。 那么线程和线程之间拿到的肯定是同一个 request 呀。但 Django 里面每个 request 都是不一样的，否则一些很基础功能的比如已经认证的用户就无法拿到了。\n\n我已经不是那个爱问问题的年轻人，因为年纪已经不小了。逃...\n\n显然，每一次在 view 层引用的 request 肯定不是同一个 request , 那么，这是如何做到的呢？比如用 ThreadLocal , ThreadLocal 通过每个线程不同的 ID 拿到的本地变量，于是我们查看一下对应的实现。 这个 request 来自于 global.py , 使用了一个 werkzeug.local 里面的 LocalProxy\n\n```python\nfrom functools import partial\nfrom werkzeug.local import LocalStack, LocalProxy\n\ndef _lookup_req_object(name):\n    top = _request_ctx_stack.top\n    if top is None:\n        raise RuntimeError(_request_ctx_err_msg)\n    return getattr(top, name)\n\ndef _lookup_app_object(name):\n    top = _app_ctx_stack.top\n    if top is None:\n        raise RuntimeError(_app_ctx_err_msg)\n    return getattr(top, name)\n\ndef _find_app():\n    top = _app_ctx_stack.top\n    if top is None:\n        raise RuntimeError(_app_ctx_err_msg)\n    return top.app\n\n# context locals\n_request_ctx_stack = LocalStack()\n_app_ctx_stack = LocalStack()\ncurrent_app = LocalProxy(_find_app)\n# 这就是我们需要的注意的地方，LocalProxy\nrequest = LocalProxy(partial(_lookup_req_object, 'request'))\nsession = LocalProxy(partial(_lookup_req_object, 'session'))\ng = LocalProxy(partial(_lookup_app_object, 'g'))\n```\n\n看到这里一阵蛋疼，貌似没有 threadlocal ？再次查看相关实现最后还是定位到了如何区分不同的 request 的核心代码。\n\n```python\n# since each thread has its own greenlet we can just use those as identifiers\n# for the context.  If greenlets are not available we fall back to the\n# current thread ident depending on where it is.\ntry:\n    from greenlet import getcurrent as get_ident\n    # greenlet 的代码是 C, 时间长没看 C 代码了，看了半天没看明白\n    # 翻了文档返回当前的 greenlet, 也就是返回调用此函数的 greenlet\nexcept ImportError:\n    try:\n        from thread import get_ident\n    except ImportError:\n        from _thread import get_ident\n\nclass Local(object):\n    __slots__ = ('__storage__', '__ident_func__')\n\n    def __init__(self):\n        object.__setattr__(self, '__storage__', {})\n        # 这里传递的 ident 就可以直接\n        object.__setattr__(self, '__ident_func__', get_ident)\n\nclass LocalStack:\n    # 用 local 实现的栈\n\nclass LocalProxy:\n    # 一个 local 的代理器\n    def __getattr__(self, name):\n    if name == '__members__':\n        return dir(self._get_current_object())\n    return getattr(self._get_current_object(), name)\n```\n\n即：\n\n1. 当 Flask 以多线程模型运行的时候，则使用的是 threadlocal 方式\n2. 当 Flask 以 greenlet 的模型运行的时候，则使用的是 greenlet 区分不同\n\n接下来回头看一下处理 request 的逻辑\n\n```python\nfrom flask import request\n@app.route('/login', methods=['POST', 'GET'])\ndef login():\n    # 这个 request 哪里来？\n    if request.method == 'POST':\n        error = someerror\n    return render_template('login.html', error=error)\n```\n\n于是，我们就知道了，当引用 request 这个 LocalProxy 的时候，引用的确实是同一个名称为 request 变量，并且这个变量也确实是 LocalProxy 的实例\n\n\u003e 但是当使用 request.method 的时候，LocalProxy 重载了 取到的则是另一个『请求对象』的 method.\n\n于是拿到当前请求的信息。\n\n当然，其实我们也可以依据利用这个技巧写一个 currentuser 的 ProxyLocal, 然后在每个 view 层里面使用 user.has_something 进行操作。\n\n## 0x03 问题 3: Flask 中官方的机制\n\n## 0x04 问题 3: Flask 中是如何做到优雅扩展的\n\n## 0x05 其他问题\n\n### Flask 应用\n\n---\n\nChangeLog:\n\n- **2018-03-09** 重修文字\n"}],"total":3}},"__N_SSG":true},"page":"/category/[slug]","query":{"slug":"Flask"},"buildId":"uCwe9m-iio9bnoWMgWDqE","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>