<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>DevOps | 海拉鲁编程客</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/49455a07b6dd33600cdf.css" as="style"/><link rel="stylesheet" href="/_next/static/css/49455a07b6dd33600cdf.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-a54b4f32bdc1ef890ddd.js"></script><script src="/_next/static/chunks/webpack-20d43e08bea62467b090.js" defer=""></script><script src="/_next/static/chunks/framework-0441fae7fd130f37dee1.js" defer=""></script><script src="/_next/static/chunks/main-4777350f2a9ff73ea2b0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-3050679c6e5142ffcaf5.js" defer=""></script><script src="/_next/static/chunks/ea88be26-9bcf6ead520f4ac26973.js" defer=""></script><script src="/_next/static/chunks/421-f2f33a86b546237f0325.js" defer=""></script><script src="/_next/static/chunks/pages/category/%5Bslug%5D-4d8847f86983258925d4.js" defer=""></script><script src="/_next/static/oDi_oBCBuu3qj6v7hDnrL/_buildManifest.js" defer=""></script><script src="/_next/static/oDi_oBCBuu3qj6v7hDnrL/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="v-page"><nav class="shadow"><div class="flex flex-col container mx-auto h-12 px-40 md:flex-row md:items-center md:justify-between"><div class="flex justify-between items-center"><div><a class="text-gray-800 text-xl md:text-xl leading-5" href="/">海拉鲁编程客</a></div><div><button type="button" class="block text-gray-800 hover:text-gray-600 focus:text-gray-600 focus:outline-none md:hidden"><svg viewBox="0 0 24 24" class="h-6 w-6 fill-current"><path d="M4 5h16a1 1 0 0 1 0 2H4a1 1 0 1 1 0-2zm0 6h16a1 1 0 0 1 0 2H4a1 1 0 0 1 0-2zm0 6h16a1 1 0 0 1 0 2H4a1 1 0 0 1 0-2z"></path></svg></button></div></div><div class="md:flex flex-col md:flex-row md:-mx-4 hidden"><a class="my-1 text-gray-800 hover:text-blue-500 md:mx-4 md:my-0" href="/">首页</a><a class="my-1 text-gray-800 hover:text-blue-500 md:mx-4 md:my-0" href="/archive">归档</a><a class="my-1 text-gray-800 hover:text-blue-500 md:mx-4 md:my-0" href="/about">关于我</a><button style="cursor:pointer;overflow:hidden;width:50px;height:23.5px;appearance:none;-moz-appearance:none;-webkit-appearance:none;border:none;background-color:transparent;padding:0" aria-hidden="true"><div style="display:flex;align-items:center;justify-content:center;margin-top:-28.749999999999996px;margin-left:-16px;width:82.5px;height:82.5px"><div></div></div></button></div></div></nav><div class="v-article">DevOps<li>Python 自动化工具 Fabric 支持 Python3</li><li>Docker CheatSheet</li><li>ElasticSearch CheatSheet</li><li>PostgreSQL CheatSheat</li><li>Redis Cheatsheet</li><li>MongoDB Cheatsheet</li><li>MySQL CheatSheet</li></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"category":{"name":"DevOps","posts":[{"tags":["Python","DevOps"],"path":"20180523_Fabric2.md","title":"Python 自动化工具 Fabric 支持 Python3","slug":"Python 自动化工具 Fabric 支持 Python3","date":"2018-05-23","category":"DevOps","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n当大家还在纠结 Python2 与 Python3 的时候，我其实早就入了 python3 的门了。\n\n后来\n\n- \u003cdel\u003e我总算学会了如何去爱。\u003cdel\u003e\n- 我喜欢的工具陆陆续续支持了 Python3\n- Scrapy 支持了 Python3\n- Ansible 支持了 Python3\n\n只有 Fabric 这个工具，死撑着没有支持 Python3 的的迹象。\n\n2018-05-08 的时候，Fabric 悄悄升级了 2.0 版本。\n\n而就在前两天，我升级网站的时候，突然发现 fabric (1.14 版本） 不能用了。\n\n查了一下版本，发现 fabric 更新到了 2.0 版本，支持了 python3.4\n\n在发现这个问题之后，火速刷了一波官方文档，把手头 Fabric 1.14 版本的脚本做了一些升级。\n\n### 从 V1 到 V2\n\nFabric v2 基于 invoke 和 paramiko 两个库构建而成。\n\n- invoke 库提供了 subprocess command execution 和 command-line\n- paramiko 提供了 ssh 协议实现\n\n在这两者的基础上，做了一些扩展。\n\n甚至，如果你只用其中的本地功能，你都完全不需要使用 fabric, 直接用 invoke 即可。没错，我已经打算把我的本地脚本全部使用 invoke Python3 化了。\n\nv1 版本和 v2 版本初步用起来，个人觉得 v1 用起来 API 更加符合直觉一些。\n\n这东西怎么用呢？\n\n我们先定义 fabfile\n\n```\n# fabfile.py\nfrom invoke import task\n\ndef expand_path(c, path):\n    return '\"$(echo %s)\"' % path\n\ndef exists(c, path):\n    cmd = 'stat %s' % expand_path(c, path)\n    return c.run(cmd, warn=True, hide=True).ok\n\n@task\ndef deploy(c):\n    c.local(\"youcmd\")\n    c.put()\n    c.get()\n    c.run()\n    c.run(\"sudo youcmd\")\n    ......\n\n@task\ndef other_stuff(c):\n    ......\n```\n\n需要注意的是，invoke 里面默认的 replace_env 设置为了 False ,fabric 里面给 runner 设置了 replace_env 为 True , 这也就意味着默认情况下，执行 c.local 的时候会找不到自定义的环境变量，这意味着：\n\n1. 你的 PATH 被重置了，这意味着你用 brew 安装的软件可能已经完全找不到了。\n2. 你的环境变量 LANG 并不一定是 en_US.UTF-8 了\n\n于是设置一下。\n\n```\n# ~/.fabric.py\n#!/usr/bin/env python\n# encoding: utf-8\n\nrun = {\n    \"replace_env\": False\n}\n```\n\n当我要部署的时候直接执行\n\n```\nfab -H webserver01,webserver02,webserver03,webserver04 deploy\n```\n\n到这里大家基本上看出来了，我并没有在文件中 import fabric 只是简单了配置了一个配置文件和执行一下 fab 命令。\n\n这个 v2 版本的 fabric 相当于 invoke 的包装。但我们也可以显式的 import fabric 里面的东西进行更加进阶的操作。\n"},{"tags":["CheatSheet"],"path":"20180210_DockerCheatSheet.md","title":"Docker CheatSheet","slug":"Docker CheatSheet","date":"2018-02-10","category":"DevOps","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n本文为 Cheatsheet 类型文章，用于记录我在日常编程中经常使用的 Docker 相关和命令。\n\n- Docker 相关概念\n- Docker 配套工具\n- Django PostgreSQL RabbitMQ Redis ElasticSearch Sentry 集群 Docker 化\n- Docker 踩坑记录\n\n不定期更新。\n\n\u003c!-- more --\u003e\n\n## 0x01 Docker 相关概念\n\n### 1.1 Docker 是什么？\n\n在认知 Docker 这种相对而言比较新概念的时候，只要从以往的经验中拿出一个词语来概括新词汇即可。\n\n于是，我们便可以这么理解：\n\n\u003e Docker 是一种比虚拟机轻量的用来存放职责比较单一的应用的容器。\n\n也就是三点：\n\n- 比虚拟机轻量\n- 用来存放职责单一的应用\n- 容器\n\n显然这是一种理解，而不是一种定义。\n\n### 1.2 Docker 是用来做什么的？\n\n新技术本质是什么？工具也。\n每一个新的技术都是为了提升效率才被创造出来，那么，究竟 Docker 可以从哪些方面提升我们的效率呢？\n\n我们知道开发一个有些规模的网站的话，需要严格遵守如下的开发流程：\n\n- 编码\n- 测试\n- 集成到系统中\n- 部署\n\n但如果人员比较多，则会出现问题，有的人喜欢用 MacOS, 有的人喜欢用 Ubuntu, 开发测试环境怎么统一呢？如果开发人员明明使用的是某个版本的 PostgreSQL, 用了最新的功能，但是测试和运维用的就是老版本的功能怎么办？\n\n部署环境也会有问题，比如，开发部突然想使用更高版本的软件，比如突然需要更多的 Django 应用来负担海量请求的怎么办？Hadoop 不够用怎么办？\n\n当然，思路很简单，开发的时候使用虚拟机，拷贝给大家一起用，部署的时候多创建一些机器，然后上 Ansible 远程操控。即可。\n\n并不是不行，但是 Docker 由于更加轻量，操作粒度更加细腻，我可以销毁镜像，上传镜像，定制镜像，很轻松调整镜像包并且安装挂载文件。\n\n## 0x02 Docker 初始配置\n\n```\ndocker-machine create --driver=virtualbox default\ndocker-machine ls\neval \"$(docker-machine env default)\"\n```\n\n## 0x03 Django 技术栈 Docker 化\n\n为了理解这个过程，下面我将我 Docker 化 django 应用的流程按照一定步骤演示出来。我将我使用 Django 的部分经验搞出来，做成了一个 django-bpc ，即 django best practice。如果诸位有兴趣研究的话，拿来看看源码倒是倒是非常好。\n\n```bash\n# 演示环境为 MAC, 在此之前，务必安装好 docker for mac 以及 virualbox\n# xxxxxx 为 阿里云分配的容器 registry\ndocker-machine create --engine-registry-mirror=https://xxxxxx.mirror.aliyuncs.com -d virtualbox default\n\n```\n\n```bash\n├── AUTHORS.md\n├── HISTORY.md\n├── LICENSE\n├── MANIFEST.in\n├── Makefile\n├── README.md\n├── assets\n├── compose\n│   ├── django\n│   ├── elasticsearch\n│   ├── nginx\n│   ├── postgres\n│   ├── rabbitmq\n│   └── redis\n├── config\n│   ├── __init__.py\n│   ├── settings\n│   ├── urls.py\n│   └── wsgi.py\n├── dev.yml\n├── docker-compose.yml\n├── docs\n│   ├── Makefile\n│   ├── exts\n│   ├── make.bat\n│   ├── make_pdf.sh\n│   └── source\n├── manage.py\n├── pytest.ini\n├── requirements\n│   ├── base.txt\n│   ├── local.txt\n│   ├── production.txt\n│   └── test.txt\n├── scripts\n├── setup.cfg\n├── tests\n│   ├── __init__.py\n│   ├── conftest.py\n│   └── test_basics.py\n└── yadjangoblog\n    ├── __init__.py\n    ├── contrib\n    ├── static\n    ├── templates\n    ├── yaaccounts\n    ├── yaadmin\n    ├── yaapi\n    ├── yablog\n    ├── yacommon\n    └── yataskapp\n```\n\n### 3.1 开发时\n\n#### 1. 运行所需组件\n\n在开发时候需要使用几个后台的组件\n\n- PostgreSQL 用于做数据存储\n- Redis 用于做缓存 和 Session 等等\n- RedditMQ 用于消息队列\n- ElasticSearch 用于做搜索与推荐\n\n目录中的组件基本上都在这儿了。\n\n```\n├── compose\n│   ├── django\n│   ├── elasticsearch\n│   ├── nginx\n│   ├── postgres\n│   ├── rabbitmq\n│   └── redis\n```\n\n进行初步的封装和添加脚本，不直接采用官网的配置需要是因为添加一些的定制版本。\n\n#### 2. Vue.JS 运行环境\n\nVue.JS 使用 Vue-Cli 搭建的脚手架还是挺方便的，这个就无需 Docker 化了，需要注意的是，建议配置一下开发时候请求的 API 地址。\n\n我本人用于请求本地地址的 8080 端口，并且 8080 端口映射到 Docker 容器里面的 Django App\n\n#### 3. Django App\n\n配置 Django, 我使用的是 ubuntu 16.04 基础镜像，然后安装必备的依赖。\n\n接着指定 workdir 为当前目录\n\n需要注意的是，Django App 里面需要等待 PostgreSQL 初始化完毕才能进行正常的运行接下来需要运行的命令，比如 runserver 之类的命令。\n\nentrypoint 的左右即是放在命令执行之前，这样的话，重写掉 entrypoint 文件，就可以实现上面的功能了\n\n```python\n# 本段代码来自 cookiecutter Django\nfunction postgres_ready(){\npython \u003c\u003c END\nimport sys\nimport psycopg2\ntry:\n    conn = psycopg2.connect(dbname=\"$POSTGRES_USER\", user=\"$POSTGRES_USER\", password=\"$POSTGRES_PASSWORD\", host=\"postgres\")\nexcept psycopg2.OperationalError:\n    sys.exit(-1)\nsys.exit(0)\nEND\n}\n\nuntil postgres_ready; do\n  \u003e\u00262 echo \"Postgres is unavailable - sleeping\"\n  sleep 1\ndone\n```\n\n最后封装一些命令到，比如启动 Celery 之类的。\n\n#### 4. Celery 运行环境\n\n#### 5. 其他零散的重要配置\n\n### 3.2 具体开发\n\n我编写了一整套 makefile 的命令，我会先进入项目 YaDjangoBlog , 然后执行 make ; 执行 make 之后，显示了我编写的一些便于开发测试的命令如下：\n\n```\nsep--sep-a           ========== 开发时命令 ==============\ndjango-build-up      build and compose up\nforce_djnago_build-up django / pg / es\ndjango-before-up     e.g pg / es / redis\ndjango-runserver     runserver\ndjango-celerybeat    celerybeat\ndjango-celeryworker  celeryworker\ndjango-just-up       build and up\ndjango-manager       Enter python manage.py\ndjango-console       Enter Django Console\nshell                Enter Shell\ndbshell              Enter psql as yadjangoweb\nsep--sep-b           ========== 测试与代码质量 ==============\nlint                 check style with flake8\ntest                 run tests quickly with the default Python\ncoverage             check code coverage quickly with the default Python\nsep--sep-c           ========== 文档生成相关 ==============\ndocs                 generate Sphinx HTML documentation, including API docs\nservedocs            compile the docs watching for changes\nsep--sep-d           ========== 程序发布相关 ==============\nrelease              package and upload a release\ndist                 builds source and wheel package\ninstall              install the package to the active Python's site-packages\nsep--sep-e           ========== Docker 镜像相关 ==============\nbuild-postgres       \u003e Postgres\nforce-build-postgres \u003e Postgres\nbuild-ubuntu         \u003e base ubuntu\nforce_build-ubuntu   \u003e base ubuntu\nbuild-django         \u003e base django\nforce_build-django   \u003e base django\nsep--sep-f           ========== 文件清理相关 ==============\nclean                remove all build, test, coverage and Python artifacts\nclean-build          remove build artifacts\nclean-pyc            remove Python file artifacts\nclean-test           remove test and coverage artifacts\n```\n\n#### 1. 构建镜像\n\n执行 build 命令即可。\n\n#### 2. 使用 Tmuxinator 批量运行命令\n\n现在，我有这么一个需求，就是在 iterm 中开启如下的终端：\n\n- 第 1 个终端，运行的命令是 Vue.JS 的启动命令 npm run dev。\n- 第 2 个终端，有两个分屏，其一用于构建 iconfont 字体文件的命令，其二用于 Gulp 动态编译 SCSS 文件的命令。\n- 第 3 个终端，运行的命令是 Django 的 runserver 的命令。\n- 第 4 个终端，有两个分屏，一个是 Django 容器的 bash 环境，另一个是 PostgreSQL 的 命令行环境。\n- 第 5 个终端，有两个分屏，一者运行 Celery Beat，另一者则是运行 Celery Worker.\n\n\u003e 当然，目前没有添加 redis 和 RabbitMQ 的命令行环境\n\n#### 3. 使用 PyCharm 进行开发\n\n### 3.3 部署时\n\nDocker 部署需要解决的问题，是裸机部署的 Docker 化。\n\n\u003e TODO: 目前 Docker 部署的脚本还在编写中，这部分的文字可能后期会调整\n\n#### 0. Django 生产环境和开发环境之间的区别\n\n生产环境和开发环境除了一些文字配置上的不同，还有一些不同，比如：\n\n1. 新增了 uwsgi / gunicorn 作为新的 web 容器\n2. 新增了 Ngnix 作为反向代理\n3. Celery Worker 数量的变化\n4. Supervisor 进程守护\n\n首先说第一点带来的区别，我们使用 Django 内置的 runserver 的时候，其实这个命令可以用于做生产环境的 Web 服务器。\n\n比如，只需如此 python manage.py runserver 0.0.0.0:8888\n\n可以用，但不推荐用。没什么负载量。这时候就需要 gunicorn 了。你可以理解 Gunicorn 是进阶的 runserver,\n\n可以参考：https://docs.djangoproject.com/en/2.0/howto/deployment/wsgi/gunicorn/\n\n同时，Gunicorn 可以进行颗粒度更细致的操作，但负载量不如 uwsgi, 毕竟前者 python 写的，后者是 C 写的。\n\n一般 Gunicorn 也会配上 NGNIX,\n\n简单来说，Nginx 至少可以解决下面的问题：\n\n- 匹配域名\n- 转发请求\n  - 设置请求头\n  - 转发本地的静态文件 (static / media）\n  - 映射部分请求到 gunicorn , 然后 gunicorn 开启一个线程到 Django\n  - 负载均衡\n\n需要注意的是 gunicorn 这种关键性的进程，一定要用 Supervisor 进行守护，否则挂掉了就完蛋了，\n\n#### 1. 裸机部署 Django 程序\n\n#### 2. Docker 部署\n\n## 0x04 Docker 踩坑记录\n\n### 4.1 PostgreSQL 的初始化\n\n当 Docker 化 PostgreSQL 的时候，必须要把一些初始化脚本放在 docker-entrypoint-initdb.d 中，才能初始化，笔者在进行测试的时候多次发现无法进行初始化，究其原因，经过查找，如果没有及时删除 Volume 的话，则无论怎么初始化，或者 Build, 每一次都会挂载原来的文件夹。\n\n```bash\nADD init_django_db.sh /docker-entrypoint-initdb.d/init_django_db.sh\n```\n\n### 4.2 清空所有 Image\n\n```bash\n# Delete all containers\ndocker rm $(docker ps -a -q)\n# Delete all images\ndocker rmi $(docker images -q)\n# Force delete\ndocker rmi $(docker images -q) -f\n# Delete Unused Volume\ndocker volume prune\n```\n\n### 4.3 时区\n\n```\n# Alpine\nRUN apk --no-cache add tzdata \u0026\u0026 ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \u0026\u0026 echo \"Asia/Shanghai\" \u003e /etc/timezone\n# Ubuntu\nRUN echo \"Asia/Shanghai\" \u003e /etc/timezone \u0026\u0026 dpkg-reconfigure -f noninteractive tzdata\n# Centos\nRUN echo \"Asia/shanghai\" \u003e /etc/timezone\n```\n\n# 0xEE 参考链接\n\n- https://github.com/wsargent/docker-cheat-sheet\n\n---\n\nChangeLog:\n\n- **2017-01-20** 初始化本文\n"},{"tags":["Pandas","Numpy","CheatSheet"],"path":"20180210_ElasticSearchCheatSheet.md","title":"ElasticSearch CheatSheet","slug":"ElasticSearch CheatSheet","date":"2018-02-10","category":"DevOps","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n本文为 Cheatsheet 类型文章，用于记录我在日常编程中经常使用的 ElasticSearch 相关和命令。\n\n\u003e 最早使用 ElasticSearch 是两年前了。最近准备用 Django 写一个全栈式的应用，借用强大的 ES 来做搜索。\n\n这是我在写程序之余写这篇笔记的原因。最近因为换工作的事情耽误了教程更新，就把这篇笔记放出来吧。不定期更新。\n\n官网介绍 ElasticSearch 不仅仅是全文搜索，也可以结构化搜索（这里用结构化查询会更准确一些），处理人类语言，地理位置，以及关系。\n\n然而，我在项目使用过程中还是主要用到了全文搜索以及推荐。\n\n不用其他的主要原因是因为 ES 尺有所短寸有所长：\n\n1. geo 处理方面 postgis 完全就是神一般的存在。为什么还要用 ES 呢？\n2. 关系型数据库的核心不就是处理关系？复杂的关系肯定还是放在关系数据库里面。\n\n- highlighted search\n- search-as-you-type\n- did-you-mean suggestions\n\n我对 ElasticSearch 在后台组件里的作用在于搜索与推荐：\n\n1. 整站的搜索功能\n\n- 全文搜索\n\n2. 推荐\n\n- 依据某几个维度的数据进行排序\n\n知乎的文章居然不支持 toc, 实在是太蛋疼了。\n\n文章目录如下\n\n```\n  ▼ 0x00 前言 : section\n  ▼ 0x01 安装，配置，基本 shell 命令 : section\n      1. 安装 : section\n      2. 配置 : section\n      3. 插件 : section\n    0x02 ElasticSearch 配套工具 : section\n  ▼ 0x03 ElasticSearch 基础概念 : section\n    ▼ 3.1 Elasticsearch CRUDE 以及基本操作 : section\n        CURDE : section\n        普通搜索 : section\n        聚集搜索 : section\n  ▼ 0x04 全文搜索的基本概念 : section\n      4.1 全文搜索遇到的挑战 : section\n    ▼ 4.2 全文搜索的索引时与查询时 : section\n        1. 索引时 ES 做了什么？ : section\n        2. 查询时 ES 做了什么？ : section\n        3. 全文搜索调优之中文分词 : section\n        4. 全文搜索调优之停止词 : section\n        5. 全文搜索调优之同义词 : section\n        6. 全文搜索调优之拼写错误 : section\n      ▼ 7. 全文搜索调优之相关性 : section\n          索引时三因素 : section\n          查询时 : section\n          计算公式 : section\n    0x05 搜索语法 : section\n    0x06 Python SDK : section\n    0x07 踩坑集 : section\n    0xEE 参考链接 : section\n```\n\n\u003c!-- more --\u003e\n\n## 0x01 安装，配置，基本 shell 命令\n\n### 1. 安装\n\n具体在项目中的配置建议看一下我写的配置文章 https://zhuanlan.zhihu.com/p/33920401 和并且参考现有代码 https://github.com/twocucao/YaDjangoBlog\n\n```\n# 执行如下的命令\ncurl 'http://localhost:9200/?pretty'\n# 输出结果\n{\n  \"name\" : \"XOGvo8a\",\n  \"cluster_name\" : \"docker-cluster\",\n  \"cluster_uuid\" : \"fAwp341bQzalzBxRFyD1YA\",\n  \"version\" : {\n    \"number\" : \"6.2.1\",\n    \"build_hash\" : \"7299dc3\",\n    \"build_date\" : \"2018-02-07T19:34:26.990113Z\",\n    \"build_snapshot\" : false,\n    \"lucene_version\" : \"7.2.1\",\n    \"minimum_wire_compatibility_version\" : \"5.6.0\",\n    \"minimum_index_compatibility_version\" : \"5.0.0\"\n  },\n  \"tagline\" : \"You Know, for Search\"\n}\n```\n\n### 2. 配置\n\n配置略\n\n### 3. 插件\n\nES 的插件有很多，截止笔者写这篇文章的时候，ES 最新的版本是 6.2.1 版本。\n\n\u003e PS: 两年前我用的还是 2.3.3 版本。新版本有很多插件配置起来已经有所不同了。比如说 head 现在已经被独立出来作为一个单纯的网页，chrome 商店可以直接下载。\n\n需要配 ik-analyser. 如果你在 YaDjangoBlog 中起了这个命令，则已经配置完毕。\n\n## 0x02 ElasticSearch 配套工具\n\n建议使用 Head 插件来进行简单的查询与调试。\n\n## 0x03 ElasticSearch 基础概念\n\n### 3.1 Elasticsearch CRUDE 以及基本操作\n\n详细的搜索见 Python SDK\n\n#### CURDE\n\nES 使用的是 RESTFUL API 接口\n\n这也就意味着：\n\n- PUT 创建记录\n- GET 获取记录\n- POST 更新记录\n- DELETE 删除记录\n- HEAD 是否存在\n\n#### 结构化搜索\n\nES 写复杂查询的时候，语法乱，这个过程需要多翻看 guide 和手册。\n\nhttps://www.elastic.co/guide/en/elasticsearch/guide/current/structured-search.html\n\n#### 全文搜索\n\n全文搜索包含两个重要方面：\n\n- 相关性：通过 TF/IDF , 距离 , 模糊相似度，以及其他算法\n- 分析：大文本 token 化，用于形成倒排索引。这个过程见 4.2\n\nhttps://www.elastic.co/guide/en/elasticsearch/guide/current/full-text-search.html\n\n#### 聚集搜索\n\nhttps://www.elastic.co/guide/en/elasticsearch/guide/current/aggregations.html\n\n## 0x04 全文搜索的基本概念\n\n### 4.1 全文搜索遇到的挑战\n\n在最初开源搜索引擎技术还不是很成熟的时候，我们一般都会使用 RDBMS 进行简单搜索。\n\n简单搜索，也就是我们常常使用的 like 查询（当然，有的数据库可以使用正则表达式）\n\n这种方式是简单暴力的查询方式，优点是实现起来简单暴力。缺点是在这个场景下性能和准确度很差。\n\n举例：\n\n- 假如站点里文章数量比较大，并且文章内容比较长，则进行一次全表查询，效率可想而知。当然，做好分库分表读写分离也是能用的。\n- 如果我要对搜索到的词语进行高亮，则实现方式就只能是把查询到的文章放在应用层里面进行批量替换。\n- RDBMS 似乎完全不懂语言与语言之间的区别。比如说：\n  - 『停止词 / 常用词』有的字我是不需要的，比如南京的狗，其实我想搜的是南京狗，这里的『的』就不是我需要的。\n  - 『同义词』有的字我需要的是他的同义词，比如日本黄狗，其实我想搜的是柴犬。\n  - 『附加符号』假如说我们搜索一个声调 [nǐ], 总不能让用户打出 [nǐ] 进行搜索吧？总归要转为 ni 才能方便搜索\n  - 『词根形式』对于一个单词，假如是动词可能有时态上的区分，如果是名词，可能有单复数的区分。假如我搜 mice, 其实同样的 mouse 也应该被搜索出来。但有事用这种方式也会矫枉过正，比如 organizations 的 原型其实并不是 organization 而是，organ. （当然，overstemming 和 understemming 也是两个不可忽视的问题）\n    - Number: fox, foxes\n    - Tense: pay, paid, paying\n    - Gender: waiter, waitress\n    - Person: hear, hears\n    - Case: I, me, my\n    - Aspect: ate, eaten\n    - Mood: so be it, were it so\n    - PS: 万幸的是，中文处理中木词根这个概念。我也就不深入这块了。\n  - 『拼写问题』 周杰棍与周杰伦\n  - 『分词 / 识别词』中文不像英文，词和词之间是完全没有空格的，也就是说，中文天然要比英文多一个关于分词的步骤。\n\n是的，我们需要一种新的姿势，来进行搜索。也就是本文所说的全文搜索。\n\n### 4.2 全文搜索的索引时与查询时\n\n本小节先搞清楚两个点，\n\n1. 索引时 ES 做了什么？\n2. 查询时 ES 做了什么？\n\n- 索引时，指的是 ElasticSearch 在存储文档的阶段。\n- 查询时，指的是 ElasticSearch 在查询文档的阶段。\n\n#### 1. 索引时 ES 做了什么？\n\n\u003e 这里我们略过定义 index,type,document 仅仅指某个 field 被赋值 document 被保存的时候针对这个被赋值的 text 类型 field 的处理。\n\n- 第一步：**文本经过 analyzer 处理**\n- 第二步：**形成倒排索引**\n\n先看第一步：\n\n通常在定义 field 的时候显式指定 analyzer（分析器）.\n\n这个 analyzer 一般的作用如下：\n\n- STEP 1: 令牌化文本为独立的词\n- STEP 2: 词语转小写\n- STEP 3: 去除常见的停止词\n- STEP 4: 获取词的词根的原型\n\n不同的 analyzer 作用大同小异，拿我们常用的 https://github.com/medcl/elasticsearch-analysis-ik 的话，则也是类似的步骤（下面步骤是我猜测的，没看源码）\n\n1. 令牌化文本为独立的词语 - 分词，并且令牌化文本为独立的词汇\n2. 除去常见的停止词\n3. 匹配同义词\n4. ....\n\n可以定义字段的时候可以指定 analyzer（索引时） 与 search_analyzer（查询时）\n\n先看经过第一步之后，就可以进入第二步形成倒排索引了，此时，倒排索引之于 ElasticSearch 可以类比于 btree 之于 MySQL 或者 Gist 之于 PostgreSQL.\n\n那么，倒排索引包含哪些东西呢？\n\n- **Terms dictionary**\n  - 已排序完毕的 terms, 以及包含这些 terms 的 documents 的数量。\n- **Postings List**\n  - 哪些 document 包含这些词\n- **Terms frequency**\n  - 每个 term 在这些文章的频率\n- **Position**\n  - 每个 term 在每个 document 的位置，这是为了便于 phrase query 和 proximity query\n  - 高频词的 phrase query 可能导致 上 G 的数据被读取。虽然有 cache, 但是远远不够。\n- **Offsets**\n  - 每个 term 在每个 document 的开始和结束，便于高亮\n- **Norms**\n  - 用于给短 field 更多权重的因素.(TODO: 啥玩意）\n\n减少停止词仅仅可以减少少部分 terms dictionary 和 postings list , 但是 positions 和 offsets data 对 index 的影响则是非常大的。\n\n#### 2. 查询时 ES 做了什么？\n\n- 第一步：**文本经过 analyzer 处理**\n- 第二步：**查询倒排索引**\n\n其实搜索的就是这个玩意。\n\n- **Terms dictionary**\n- **Postings List**\n- **Terms frequency**\n- **Position**\n- **Offsets**\n- **Norms**\n\n于是，我们就必须关注如何更好的查询文档了。下面几个小节，你就知道全文搜索是比较难调优的了。好，一个一个来。\n\n#### 3. 全文搜索调优之中文分词\n\n中文分词以前是个难点，现在基本有成熟的解决方案，在没有更加牛逼的分词技术解决方案之前，现在分词效果主要是拼词典。\n\n\u003e TODO: 这个话题可能比较大，先挖坑，以后填\n\n#### 4. 全文搜索调优之停止词\n\n使用停止词是减少索引大小的一种方式（减小索引效果不明显），那么，哪些词语可以呗当做停止词呢？\n\n- 低频词语：低频词语具备高权重\n- 高频词语：高频词语具备低权重\n\n当然，是否是高频词语依据个人经验主要依据两点来判断：\n\n- 具体场景：比如在英文中，and/the 之类的会比较多，但是中文会比较少。同样的，中文里面其他语言的东西会少一些。正文八经的文章出现不正经的词汇的概率会低。在技术问里面，『数据库』属于高频词汇，但是在比如简书之类的，可能梦想 / 鸡汤 / 超级 / 震惊会多一些。掘金的『前端』两个字绝壁是高频词。\n- 抽样跑新词发现的程序。社区里多的是新词发现的脚本。对文章内容或者从搜索框记录下来的搜索词跑一下新词发现的程序，然后人工筛选，应该可以发现更多的高频和低频的词汇。\n\n是不是用上停止词就好了呢？并不是。\n\n比如：\n\n- 假如停止词里面包含了 not , 那么 happy 和 not happy 搜索出来的结果则一致。\n- 假如停止词里面包含了或，那么，如果有个乐队名字叫做『或或』, 则搜索不出来。\n- 假如停止词里面包含了 to / be / not / or , 则莎士比亚的名言 『To be, or not to be』 则搜索不出来。\n\n#### 5. 全文搜索调优之同义词\n\n同义词也有很多种：\n\n1. 平级关系：插、戳、刺、扎\n2. 包含关系：成人包含男人和女人\n3. 不容易分清楚关系：\n\n- 炒，煎，贴，烹，炸，溜\n  　- 汆，涮，煮，炖，煨，焐\n  　- 蒸，鲊\n  　- 卤，酱，熏，烤，炝，腌，拌，焗\n\n随着场景的不同，上面有些同义词也是不能轻而易举同义的。\n\n| -        | 索引时                                                                           | 查询时                                 |\n| -------- | -------------------------------------------------------------------------------- | -------------------------------------- |\n| 索引大小 | 耗时变多，同义词被索引，大小更大                                                 | 耗时几乎不变                           |\n| 相关性   | 准确度下降，所有同义词相同 IDF, 则在所有文档的索引记录中，常用词和冷门词权重相同 | 准确度提升，每个同义词的 IDF 将被校正  |\n| 性能     | 性能下降，查询需要涨到                                                           | 性能下降，查询被重写，用于查找同义词   |\n| 灵活性   | 变差，同义词法则不改变已存在记录，需重新索引                                     | 不变，同义词法则可被更新，无需重新索引 |\n\n由此可见，大部分场景下的索引时如果没有特别的需求，**谨慎使用同义词**。\n\n\u003e 同义词使用自定义 filter , 并且在新建 analyzer 并指定 filter 即可。\n\n#### 6. 全文搜索调优之拼写错误\n\n有的时候，用户也会输入错误：\n\n- 手误，把『周杰伦』拼成『周杰棍』\n\n这个时候，搜索引擎应该提示一下，您搜索的是不是『周杰伦』呢？\n\n这里面就遇到了一个问题，我们显然知道周杰棍和周杰伦是是相似的，为什么呢？或者说，直观上感知的详细，能用数学方式表达出来吗？\n\n有人说，正则匹配 / 通配符匹配呗。这是一个思路。\n\nVladimir Levenshtein 和 frederic damerau 给出了一种相似度算法 https://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance\n\n一个词组通过转换到另一个词的步数就是其距离：\n\n- 替换：『周杰伦』到『周杰棍』\n- 插入：『周杰』到『周杰棍』\n- 删除：『周杰伦』到『周杰』\n- 相邻字符转换：『周伦杰』和『周杰伦』 , 但是『周杰棍的双节伦』到『周杰伦的双节棍』 并不是相邻字符转换\n\n用法：\n\n\u003e 指定 \"fuzziness\": step 即可\n\n当 step \u003e=2 的时候，ES 进行查询的时候，每次查询都会遍历 terms 字典，所以，如果 fuzziness 大于 2 的时候遍历 terms 的数量则非常惊人了。\n\n- 方法一：设置 prefix_length, 单词的前面一定长度不进行 fuzzy 匹配。一般设置为 3 （估计这是属于英文的匹配，中文环境做不了参考）;\n- 方法二：设置 max_expansins, 类似于 RDBMS 的 limit, 查询到一定记录之后停止查询。\n\nfuzzy match query 也是支持的，比如说，假如你指定 \"fuzziness\" 为 1, 搜索周杰棍，则将周杰伦，周杰全搜索出来了。似乎搜索的很全面呀，但是问题来了：\n\n\u003e 依据 TF/IDF 的高频低权重，低频高权重的计算方式，**周杰棍由于出现次数极少，反而获得了极高的权重。**\n\n跑个题，这种因为『出现次数少，查询的时候反而显得权重较高』的情况。并不仅仅出现在 TF/IDF 算法上。\n\n这方面搜索引擎和人是一样一样的\n\n- 小孩子听腻了家长们所说的『带着脑子去学习』, 反而觉得以前没出现的新词叫『刻意学习』牛逼到爆。\n- 美女听腻了直男癌说的『漂亮』, 反而觉得夸她『品质 / 品味』的话语词词入心。\n\n回到正题\n\n所以，一般情况下还是建议拼写错误主要还是用于：\n\n- Search as you type : completion suggester\n- Did you mean : phrase suggester\n\n#### 7. 全文搜索调优之相关性\n\n我们在接触 RDBMS 的时候系统是没有相关性的说法的，比如说，2017 年 12 月份 xxx 用户的订单，就是直接 select 出来这些订单。因为 where 语句后面包含了界限明确的条件，而全文搜索则不然。\n\n这个时候一个人拍着桌子站起来，说：不对呀，我要搜索包含周杰伦的所有文章。这咋没有条件边界。\n\n嗯，稍等，『选出所有包含周杰伦的文章』条件很清晰。但问题是，排序怎么做？按照日期排？按照点击率排？这篇文章上周已经在在搜索靠前了，已经『长江后浪推前浪了』上了，这周是不是该差不多『前浪死在沙滩上』了？\n\nElasticsearch 中使用的计算 score 的公式叫做 practical scoring function, 这个公式借鉴于 TF/TDF 以及 矢量空间模型，但有更多的特征比如，条件因素，字段长度正态化，term / query clause boosting\n\n全文搜索不仅仅找到匹配的 documents, 并且按照相关性进行排序（其实就是打分 score)。\n\n为什么需要打分呢？从相亲角度来说，上海内环有房肯定是个超级大加分项。同样是录入信息，在上海内环有房的权重值可是设置的高一些。\n\n嗯，其实相关性的调优是最难的部分。\n\n##### 索引时三因素\n\n先看前两个因素 TF/IDF\n\n- tf(t in d) = sqrt(frequency)\n- idf(t) = 1 + log (numDocs / (docFreq + 1))\n\n再看后一个因素 Field-Length norm\n\n标题越短，这个词对这个 field 的代表性越强\n\n- norm(d) = 1 / sqrt(numTerms)\n\n##### 查询时\n\n几个词 -\u003e 几维度 -\u003e 寻求最佳匹配以及近似匹配\n\n- 最佳匹配应该是通过计算长度（应该是，但不确定）\n- 近似匹配，计算距离最近的 cos 值。\n\n##### 计算公式\n\n这个公式调优的时候需要用到\n\n```bash\nscore(q,d)  = queryNorm(q)\n                ·coord(q,d)\n                ·∑(tf(t in d)·idf(t)²·t.getBoost()·norm(t,d)) (t in q)\n```\n\n## 0x05 搜索语法\n\nSingle document APIs\n\n- Index API\n- Get API\n- Delete API\n- Update API\n- Multi-document APIs\n\nMulti Get API\n\n- Bulk API\n- Delete By Query API\n- Update By Query API\n- Reindex API\n\n## 0x06 Python SDK\n\n官方提供了两个 SDK 方便我们进行日常的开发：\n\n- elasticsearch\n- elasticsearch_dsl\n\n我更喜欢 elasticsearch , 而不是 elasticsearch_dsl, 因为写起来更容易结合 elasticsearch-head 进行 profile\n\n前者偏底层一些，后者偏高层一些，高底层关系的有点类似于 sql 和 sqlalchemy core 之间的关系。\n\n## 0x07 踩坑集\n\n## 0xEE 参考链接\n\n- https://www.zhihu.com/question/19645541\n\n---\n\nChangeLog:\n\n- **2018-02-15** 重修文字\n"},{"tags":["PostgreSQL"],"path":"20170105_PostgreSQLCheatSheet.md","title":"PostgreSQL CheatSheat","slug":"PostgreSQL CheatSheat","date":"2017-01-05","category":"DevOps","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n## 0x00 前言\n\n本文为 Cheatsheet 类型文章，用于记录我在日常编程中经常使用的 PostgreSQL 相关和命令。\n\nPostGIS 相关的资料参考文章 [Geo Processing With Python](/2016/10/05/UbuntuCheatsheet/)\n\n- 安装与基本配置\n- PostgreSQL 配套工具\n- PostgreSQL SQL 常用代码片段\n- Python Driver : psycopg2 , 与两个 ORM ( Django ORM / SQLAlchemy )\n\n不定期更新。\n\n\u003c!-- more --\u003e\n\n## 0x01 安装，配置，基本 shell 命令\n\n### 安装\n\n### 配置\n\n### 基本 Shell 命令\n\n```\n# 开启关闭\npg_ctl -D /usr/local/var/postgres -l /usr/local/var/postgres/server.log start\npg_ctl -D /usr/local/var/postgres -l /usr/local/var/postgres/server.log stop\npg_ctl -D /usr/local/var/postgres start\npg_ctl -D /usr/local/var/postgres stop -s -m fast\n```\n\n### 数据的导入导出\n\n```bash\npg_dump -C -Fp -f dump.sql -U twocucao QCS -h 192.168.2.175\npg_dump -C -Fp -f 20160602-150144-dump.sql -U twocucao QCS --column-inserts --data-only --table=users_table -h 192.168.2.175\n# 插入数据\npsql -U twocucao -d QCS -a -f insert_doc_ids.sql -h 192.168.2.175\npg_restore --verbose --clean --no-acl --no-owner -h localhost example.dump\n```\n\n## 0x02 PostgreSQL 配套工具\n\n- JetBrain 的 Datagrip 作为 编写大段 SQL 语句的 IDE\n- 通过网络或者 Dash 查看文档\n- PostgreSQL 官方自带工具\n\n## 0x03 PostgreSQL SQL 常用代码\n\n### 3.1 PostgreSQL 相关\n\n```sql\n-- 强行中断连接到此数据库的 session\nSELECT\n    pg_terminate_backend(pid)\nFROM\n    pg_stat_activity\nWHERE\n    -- don't kill my own connection!\n    pid \u003c\u003e pg_backend_pid()\n    -- don't kill the connections to other databases\n    AND datname = 'demoweb' ;\n```\n\n### 3.2 DCL ( Data Control Languge )\n\n```sql\n-- 创建只读用户\n\\c demoweb\nCREATE ROLE ro_user WITH LOGIN ENCRYPTED PASSWORD 'xxx123456';\nGRANT CONNECT ON DATABASE demoweb TO ro_user;\n-- This assumes you're actually connected to mydb..\nGRANT USAGE ON SCHEMA public TO ro_user;\nGRANT SELECT ON ALL TABLES IN SCHEMA public TO ro_user;\nGRANT SELECT ON ALL SEQUENCES IN SCHEMA public TO ro_user;\n\n-- 撤销数据库连接 ()\nREVOKE CONNECT ON DATABASE demoweb FROM PUBLIC, demoweb;\n```\n\n### 3.3 DDL ( Data Definition Language )\n\nCREATE\nALTER\nDROP\nTRUNCATE\nCOMMENT\nRENAME\n\n### 3.4 DML ( Data Manipulation Languge )\n\nSELECT\nINSERT\nUPDATE\nDELETE\nMERGE\nCALL\nEXPLAIN PLAN\nLOCK TABLE\n\n### 3.5 TCL ( Transaction Control Languge )\n\n## 0x04. 常用代码片段\n\n### 4.1. Tips And Hacks\n\n#### Recursive Query\n\n```bash\nWITH cte_name(\n    CTE_query_definition -- non-recursive term\n    UNION [ALL]\n    CTE_query_definition -- recursive term\n) SELECT * FROM cte_name;\n```\n\n### 4.2. 大数据量运算技巧\n\n### 4.3 备份还原技巧\n\n```bash\n# 需要备份的机器\nDB_NAME='xxxdb'\nDUMP_DB_FILE='latest_dump.sql.gz'\nsudo -u postgres pg_dump $DB_NAME | gzip -9 \u003e $DUMP_DB_FILE\nTARGET_HOSTNAME='xxx.org'\nTARGET_PATH='/webapps/'\nscp $DUMP_DB_FILE root@$TARGET_HOSTNAME:/webapps/\n\n# 需要还原的机器\nDB_NAME='xxxdb'\nDUMP_DB_FILE='latest_dump.sql.gz'\nsudo -u postgres dropdb $DB_NAME\nsudo -u postgres createdb $DB_NAME\ngunzip \u003c $DUMP_DB_FILE | sudo -u postgres psql $DB_NAME\n```\n\n## 0x05. 并发优化技巧\n\n\u003e 优化技巧请参考我关于 MySQL 的一片文章。\n\n### 5.1 ACID\n\n- Atomicity : 行不行，给个准话\n- Consistency : 完成时候，数据保持一致（多版本并发控制）\n- Isolation : 事务与事务之间是隔离的。即一事务无法查看另一个事务正在修改的数据（默认，如果不默认这玩意，则隔离程度是可以设置的）\n- Durablity : 就是存下来了。\n\n#### 多版本并发控制模型\n\n- Each query sees only transactions completed before it started\n- On query start, PostgreSQL records:\n  - the transaction counter\n  - all transaction id’s that are in-process\n- In a multi-statement transaction, a transaction’s own previous queries are also visible\n- The above assumes the default read committed isolation level\n\n使用 MVCC 多版本并发控制比锁定模型的主要优点是在 MVCC 里， 对检索（读）数据的锁要求与写数据的锁要求不冲突， 所以读不会阻塞写，而写也从不阻塞读。\n在数据库里也有表和行级别的锁定机制， 用于给那些无法轻松接受 MVCC 行为的应用。 不过，恰当地使用 MVCC 总会提供比锁更好地性能。\n\n### 5.2 DDL 事务\n\nDDL 可以多条放在一起，然后直接 DDL, 据说可以在 sharding 时候用....\n\n### 5.3 事务使用\n\n```sql\nbegin;\n-- insert_somethings;\nsavepoint my_savepoint01;\n-- wrong ops\nrollback to my_savepoint01;\ncommit;\n```\n\n### 5.4 事务隔离级别\n\n- READ UNCOMMITED\n- READ COMMITED\n- REPEATABLE READ\n- SEARLIZABLE\n\n- 脏读 : 和程序的并发一致 默认是不可能的。\n- 不可重复读 : 一个事物重新读取前面读过的数，但是发现被改过了。能读原来则是可重复读。读新的，则是不可重复读。\n- 幻读 : （举一个为赋新词强说愁的例子）比如，先 count 一下，然后依照 count 值遍历 cursor, 结果发现数量发生变化。\n\n读已提交，是默认。在这里，脏读（不会）、不可重复读（可能）、幻读（可能）。\n\n### 5.5 锁机制\n\n- 表级锁模式\n- 行级锁模式\n\n### 5.6 死锁\n\n死锁的典型案例就是：\n\n1. 当你找你爸要钱的时候，你爸说，要是你妈给你钱，我就给你钱。\n2. 当你找你妈要钱的时候，你妈说，要是你爸给你钱，我就给你钱。\n\n死锁的四个必要条件：\n\n- 互斥条件\n- 请求和保持条件\n- 不剥夺条件\n- 环路等待条件\n\n避免死锁的方式，一般是按照顺序来。\n\n当然，数据库可以自动检测出死锁，但是由于捕获死锁需要一定的代价。可能会导致应用程序过久地持有排他锁。\n\n\u003e 慎用排他锁。\n\n## 0x07. 踩坑集\n\n- 序列问题\n"},{"tags":["PostgreSQL"],"path":"20161211_RedisCheatSheet.md","title":"Redis Cheatsheet","slug":"Redis Cheatsheet","date":"2016-12-11","category":"DevOps","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n# Redis Cheatsheet\n\n## 0x00. 前言\n\n本文为 Cheatsheet 类型文章，用于记录我在日常编程中经常使用的 MongoDB 相关命令。\n\n- Redis Shell\n- Redis 配套工具\n- Redis-Py\n- 常见问题\n- 踩坑记录\n\n不定期更新。\n\n\u003c!-- more --\u003e\n\n## 0x01 Redis Shell\n\n- RedisClient\n- 通过网络或者 Dash 查看文档\n- Redis 官方自带工具\n\n## 0x02 Redis 使用场景\n\n1. 记录点赞数 hash\n2. 记录最近帖子列表 便于快速显示 zset\n3. 记录帖子的点赞人，和去重 zset\n4. 相关内容。list\n5. 计数器，用于分配 ID\n\n### 分布式锁\n\n基本用法就是\n\n```\nset lock:upgdatenewprofile true ex 5 nx\nTODO: 搞事情\ndel lock:upgdatenewprofile\n```\n\n但是呢？这个逻辑还是有问题的，比如第一个线程的搞事情的时间大于 5s, 那么第二个线程就会加个锁，然后第一个线程释放掉锁。\n\n于是第三个线程一看，哟，没锁，就开始搞事情。\n\n这种情况可以使用可重入锁.（但可重入锁本身就会增加代码的复杂度）\n\n### 延时队列\n\n```\nbrpop\nblpop\n```\n\nblocking 本身也会爆异常，所以，也要处理好异常。\n\n## 0x03 Redis-Py\n\n### 基本类型与其操作\n\n- string\n- hash\n- set\n- zset 有序集合\n\n```\nset/get\nmget name1,name2,name3\nmset name1 value1 name2 value2\nexpire name1 5\nsetex name1 5 value1\n```\n\n```\n# 队列\nrpush queue item1 item2 item3\nllen queue\nlpop queue\n```\n\n```\n# 栈\nrpush stack item1 item2 item3\nllen stack\nrpop stack\n```\n\n慢操作\n\n```\nlindex # O(n)\n\nlrange queue 0 -1\n```\n\n```\n# hash 操作\nhgetall\nhlen\nhget\nhset\nhmset\n```\n\n```\n# 有序列表\nzadd\nxrange\nzrevrange\nzcard\n```\n\n### 高级类型与其操作\n\n## 0x04 常见问题\n\n```\nbgsave 镜像全量持久化 耗时长\nbgsave 子进程创建之后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开.fork / cow\naof 增量持久化，定期 aof 重写，redis4.0 混合了 bgsave 和 aof, 效果更好\naof 如果每条数据 sync 一下，那么就会不丢数据。然而，鬼才会这么做。\n```\n\n## 0x05 踩坑记录\n\n### 1. 无法磁盘持久化\n\n用 scrapy 配合 scrapy-redis 抓取网页并且存储到 MongoDB 里面。\n\n由于 scrapy-redis 重写了 scrapy 的几个核心模块，借助 redis 来实现多个 scrapy 节点从而实现分布式。\n\n默认的 scrapy 设置会把 items 放在 redis 从而方便程序对 items 进行后续处理。这个设计很完美，只是美中不足的是，我常常需要抓取大量页面直接缓存到数据库中。这就导致了 redis 很快就满了。\n\n于是很容易报出这么一个错误。\n\n\u003e (error) MISCONF Redis is configured to save RDB snapshots, but is currently not able to persist on disk. Commands that may modify the data set are disabled. Please check Redis logs for details about the error.\n\n出错原因如同提示所言，无法磁盘持久化。\n\n基本上问题可能就是：\n\n1. 磁盘满了。\n2. redis 本身在某个地方配置了磁盘缓存的大小。\n3. 其他权限之类的问题。\n\n最快的解决方式就是删除占用磁盘的部分。\n\n```bash\n# 进入 redis-cli 删除 items\nconfig set stop-writes-on-bgsave-error no\ndel xxx_html:items\nconfig set stop-writes-on-bgsave-error yes\n# 到 bash 下面检查磁盘，我的机器瞬间释放了 3GB 的磁盘空间\ndf -hl\n```\n\n备注：del 一次即可，因为有程序正在运行，所以当 del 之后，原来阻塞的程序接着开始运行。 xxx_html:items 会不断出现新的值。\n\nScrapy 立马就开始工作了（无需重启）\n\n但是这也不是没有弊端的，依据官方文档所言，只有你完全不 care 数据持久化的情况下才可以使用这种方式\n\n最好的方式当然是让 bgsave 完全 work 了\n\n```\n# redis-cli\n127.0.0.1:6379\u003e CONFIG SET dir /data/tmp\nOK\n127.0.0.1:6379\u003e CONFIG SET dbfilename temp.rdb\nOK\n127.0.0.1:6379\u003e BGSAVE\nBackground saving started\n127.0.0.1:6379\u003e\n```\n\n---\n\nChangeLog:\n\n- **2016-12-11** 重修文字\n- **2018-08-28** 常用场景\n"},{"tags":["PostgreSQL"],"path":"20161209_MongoCheatSheet.md","title":"MongoDB Cheatsheet","slug":"MongoDB Cheatsheet","date":"2016-12-09","category":"DevOps","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n# MongoDB Cheatsheet\n\n## 0x01 前言\n\n本文为 Cheatsheet 类型文章，用于记录我在日常编程中经常使用的 MongoDB 相关命令。\n\n- Mongo Shell\n- Mongo 配套工具\n- Python API\n\n不定期更新。\n\n\u003c!-- more --\u003e\n\n## 0x02 安装\n\n```bash\n# MacOS 安装\nbrew install mongodb\nbrew services start mongodb\n# Ubuntu Server 16.04\nsudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv EA312927\necho \"deb http://repo.mongodb.org/apt/ubuntu xenial/mongodb-org/3.2 multiverse\" | sudo tee /etc/apt/sources.list.d/mongodb-org-3.2.list\napt-get update -y\napt-get install -y mongodb-org\nservice mongod start\n```\n\n## 0x03 配置\n\n### IP 地址\n\n## MongoDB 配套工具\n\n- RoboMongo\n- 通过网络或者 Dash 查看文档\n- Mongo 官方自带工具\n\n## MongoDB Shell\n\n## 基本查询\n\ndb.users.find({\"name\": /._m._/})\ndb.users.find({'name': {'$regex': 'sometext'}})\n\nhttps://docs.mongodb.com/manual/\n\n### 增删改查\n\nuse myNewDatabase\ndb.myCollection.insert( { x: 1 } );\n\n### 聚合操作\n\n## PyMongo\n\n```bash\n# 建索引的时候，会阻塞当前的操作，甚至是查询操作\n# 据说转为 background 方式不会阻塞但是，没有实践过\n\"msg\" : \"Index Build Index Build: 167413/751748 22%\",\n\"progress\" : {\n\t\"done\" : 167413,\n\t\"total\" : 751748\n},\n```\n"},{"tags":["MySQL"],"path":"20160912_MySQLCheatSheet.md","title":"MySQL CheatSheet","slug":"MySQL CheatSheet","date":"2016-09-02","category":"DevOps","lastMod":"2020-01-01","description":"这篇文章展示了基本的 Markdown 语法和格式.","thumbnail":"","content":"\n# MySQL CheatSheet\n\n## 0x00 前言\n\n本文为 Cheatsheet 类型文章，用于记录我在日常编程中经常使用的 MySQL 相关命令。主要包含：\n\n- MySQL Shell, 其实就是 SQL 命令。\n- MySQL 配套工具\n- Python API\n\n不定期更新。\n\n\u003c!-- more --\u003e\n\n## 0x01 安装，配置，基本 shell 命令\n\n### 字符编码\n\n\u003e UTF-8 , Please\n\n真的很讨厌那些用 GBK 的程序员啊！\n\n```bash\n# 注意，下面的设置 MySQL 是无法保存 emoji 的 /\n[mysql]\ndefault-character-set=utf8\n\n[mysqld]\ncollation-server = utf8_general_ci\ninit-connect='SET NAMES utf8'\ncharacter-set-server = utf8\n```\n\n然后在 mysql console 执行：\n\n```bash\nshow variables like \"%character%\";show variables like \"%collation%\";\n```\n\n如下即可\n\n## 0x02 MySQL 配套工具\n\n- JetBrain 的 Datagrip 作为 编写大段 SQL 语句的 IDE\n- 通过网络或者 Dash 查看文档\n- 强烈推荐 mycli 作为正常情况下的 MySQL 命令的替代品。\n- MySQL 官方自带工具\n\n只挑选几个重要的，常用的说一说。\n\n```bash\n# 启动 MYSQL\n\n# 常规 mysql\nmysql -u username -p password\n## 命令的用户名和密码最好与命令合在一起\nmysqlshow -uroot -psomepass some_db;\n# 导入数据\nmysql -u username -p password \u003c filename\n# 优雅的导入数据，可以查看进度条的 Hacks\npv -i 1 -p -t -e /Users/twocucao/Codes/update_new_date.sql | mysql -uadmin -p123456 -h 192.168.2.254 --port=3306 some_db\n# 导出数据\nmysqldump -u username -p password database [tables] \u003e filename\nmysqldump database table_bame --where=\"date_column BETWEEN '2012-07-01 00:00:00' and '2012-12-01 00:00:00'\"\n\n# ref : http://dev.mysql.com/doc/refman/5.7/en/mysqldump.html#option_mysqldump_where\n```\n\n## 0x03 MySQL 常用代码\n\n```bash\nSHOW DATABASES;\nCREATE DATABASE database;\nUSE database;\nSHOW TABLES;\nDESCRIBE table;\nSHOW COLUMN FROM table;\nDROP DATEBASE;\n```\n\n## 0x04 常用代码片段\n\n### 1. 数据清洗常用脚本\n\n```sql\n-- 少量去重\nCREATE TABLE everyday_info_temp AS SELECT * FROM  everyday_info GROUP BY id,date,numbers;\n-- 大量去重\nCREATE TABLE everyday_info_temp AS SELECT * FROM  everyday_info GROUP BY id,date,numbers ORDER BY null;\n```\n\nhttp://stackoverflow.com/questions/16568228/how-to-transpose-mysql-table-rows-into-columns\n\n```\n  SELECT @max := MAX(ID)+ 1 FROM ABC;\n\n  PREPARE stmt FROM 'ALTER TABLE ABC AUTO_INCREMENT = ?';\n  EXECUTE stmt USING @max;\n\n  DEALLOCATE PREPARE stmt;\n```\n\nmysql\u003e delete from shophtml;\nQuery OK, 117141 rows affected (4 min 2.92 sec)\nTRUNCATE shophtml;\n\n### 2. 用户管理常用脚本\n\n```bash\nSELECT User FROM mysql.user;\n```\n\n### 3. 备份迁移常用脚本\n\n```\n#! /bin/bash\n\nTIMESTAMP=$(date +\"%F\")\nBACKUP_DIR=\"/mnt/$TIMESTAMP\"\nMYSQL_USER=\"root\"\nMYSQL=/usr/bin/mysql\nMYSQL_PASSWORD=\"password\"\nMYSQLDUMP=/usr/bin/mysqldump\nDATABASE=\"cyjoycity\"\n\nmkdir -p \"$BACKUP_DIR/mysql\"\n\nfor t in $($MYSQL -NBA -u $MYSQL_USER -p$MYSQL_PASSWORD -D $DATABASE -e 'show tables')\ndo\n    echo \"DUMPING TABLE: $DB.$t\"\n    $MYSQLDUMP --force --opt --user=$MYSQL_USER -p$MYSQL_PASSWORD $DATABASE $t | gzip \u003e \"$BACKUP_DIR/mysql/$t.sql.gz\"\ndone\n\n```\n\n### 4. 性能优化常用脚本\n\nSHOW FULL PROCESSLIST;\n\n### 6. 远程连接\n\n```mysql\n\n/etc/mysql/my.cnf\n\n# bind-address = 127.0.0.1\n\nGRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'password' WITH GRANT OPTION;\nFLUSH PRIVILEGES;\n```\n\n### 5. 其他脚本\n\n```sql\n\n# 6. 随机选择 10 组记录\n-- 慢速\nSELECT * FROM Table_Name ORDER BY RAND() LIMIT 0,10;\n\n-- 快速\nSELECT name\n  FROM random AS r1 JOIN\n       (SELECT CEIL(RAND() *\n                     (SELECT MAX(id)\n                        FROM random)) AS id)\n        AS r2\n WHERE r1.id \u003e= r2.id\n ORDER BY r1.id ASC\n LIMIT 1\n```\n\n```sql\n\n# 1. 查询时间\nselect date_format(create_time, '%Y-%m-%d') as day from table_name\nselect from_unixtime(create_time, '%Y-%m-%d') as day from table_name\n\n# 2. CASE WHEN 案例\n\n## 2.1 返回同一列多个结果\n\n## 2.2 行列值颠倒\n\n# 3. 替换某字段内容\nupdate table_name set content = REPLACE(content, 'aaa', 'bbb')  where (content like '%aaa%')\n\n# 4. 获取表中某字段包含某字符串的数据\nSELECT * FROM `表名` WHERE LOCATE('关键字', 字段名）\n\n# 5. 字符串处理\nSELECT SUBSTRING（字段名，1,4) FROM 表名\n\n# 6. 求解数字的连续范围\n\nselect min(number) start_range,max(number) end_range\nfrom\n(\n    select number,rn,number-rn diff from\n    (\n        select number,@number:=@number+1 rn from test_number,(select @number:=0) as number\n    ) b\n) c group by diff;\n\n```\n\n## 0x05 性能优化切入点\n\n应用的切入点也比较简单和暴力：\n\n1. 优化应用层面的查询。\n2. 优化数据库的 SQL 查询。\n3. 优化数据库的存储结构。\n4. 优化单个数据库服务器的性能。\n5. 遵循『机多运算大』的原则，上几台机器。\n6. 更好的机器，即加内存条，上好的 CPU。\n\n优化前三点，则需要理解取数据的客户端从发送 SQL 语句到接受数据之间都发生了什么？流程如下：\n\n1. 开启连接\n2. 发送查询给服务器\n3. 分析查询\n4. 执行查询\n5. 传输数据\n6. 关闭连接\n\n### 优化应用层面的查询\n\n在同样工作量的情况下不断的减少数据库的连接，将多个动作放在一起使用 TRANSACTION 可以显著提高速度。\n\n1. 对于 OLTP 类型的数据库设计的数据库，一些耗时查询往往是可以在应用层面查询进行优化的，比如在手写代码应用级缓存，借助外部组件 (redis) 应用内缓存。\n2. 对于一些有性能要求的场景，不要使用 select \\* from xxx 这种查询，服务器到客户端传输也是需要时间的，而是要选择需要的字段。\n3. 如果有必要，不要在循环内部进行数据库查询，而是直接取出来放在内存中进行运算。学过的算法与数据结构用起来！!\n\n### 优化数据库的 SQL 查询\n\n如同前文所见，到了 SQL 命令这层切入点能够优化的地方只有步骤 4.\n\n对于查找，效率取决于：\n\n1. 取记录数量\n2. 搜索到这些记录的时间。\n\n对于插入，执行查询则插入记录和更新索引两个部分，也是插入的瓶颈所在：\n\n1. 插入记录 速度取决于记录数量，记录大小\n2. 更新索引 速度取决于索引数量。\n\n对于更新，执行查询则有查找，更新记录和更新索引两个部分，也是更新的瓶颈所在：\n\n1. 查找 需要参考查找\n2. 更新记录 速度取决于记录数量，记录大小\n3. 更新索引 速度取决于更新索引字段的数量。\n\n对于删除，执行查询则有查找，删除记录和删除索引两个部分，也是删除的瓶颈所在：\n\n1. 查找 需要参考查找\n2. 删除记录 速度取决于记录数量，记录大小\n3. 更新索引 速度取决于更新索引字段的数量。\n\n#### 查询的优化\n\n#### 索引的代价\n\n\u003e 在计算机这个神奇的世界里面，没有一个算法与数据结构的挑选是没有代价的。便于查询，则不便于插入更新。\n\n有的人把索引比作字典。说字典的索引页面就好像是数据表中的索引。\n\n这个比方很贴切，可以用在索引的比方上，也可以用在索引的代价上。\n\n- 一个没有索引的页面，即是一个只有页码，编号的字典。当我们查询一个新字的时候，只能从第一页翻到结尾，效率很低。\n- 一个有一个索引的页面，即是一个有页码，编号，拼音索引的字典。当我们查询一个新字的时候，先查询索引，然后从索引查页码，于是很快找到字。当我们**增加 / 删除 / 更新**一个字之后，还需要更新拼音索引。\n- 一个有多个索引的页面，即是一个有页码，编号，拼音索引和部首索引以及其他索引的字典。当我们**增加 / 删除 / 更新**一个字之后，还需要更新拼音索引，部首索引等等索引。\n\n\u003e **计算机世界就是这样，没有完美的算法，也没有完美的模型。**\n\n### 数据存储结构\n\n### 硬件优化\n\n留空，这个可能比较接近运维或者 DBA 的工作\n\n### 配置优化\n\n留空，这个可能比较接近运维或者 DBA 的工作\n\n## 0x06 常见问题\n\n### 密码忘了怎么办？\n\n```bash\n/etc/init.d/mysql stop\nmysqld_safe --skip-grant-tables \u0026\n# 在另一个终端 输入 mysql 进入终端\n在另一端执行 SQL 命令\nUPDATE mysql.user SET password=PASSWORD('nouveau') WHERE user='root';\n## Kill mysqld_safe from the terminal, using Control + \\\n/etc/init.d/mysql start\n```\n\n## 0xEE 参考链接\n\n关于 SQL 与数据库的有趣解释\n\n1. [Inner Join 和 Outer Join](http://stackoverflow.com/questions/38549/what-is-the-difference-between-inner-join-and-outer-join)\n2. [如何防止 SQL 注入](http://stackoverflow.com/questions/60174/how-can-i-prevent-sql-injection-in-php)\n3. [索引是怎么工作的](http://stackoverflow.com/questions/1108/how-does-database-indexing-work)\n4. [Mysql 常用 SQL 语句集锦（本文部分 SQL 语句取自此博文）](https://gold.xitu.io/post/584e7b298d6d81005456eb53)\n\nhttp://stackoverflow.com/questions/194852/concatenate-many-rows-into-a-single-text-string\n"}],"total":7}},"__N_SSG":true},"page":"/category/[slug]","query":{"slug":"DevOps"},"buildId":"oDi_oBCBuu3qj6v7hDnrL","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>