<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Python 项目代码健壮性和性能 - 分类 - 海拉鲁编程客</title>
        <link>http://twocucao.xyz/categories/python-%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E5%81%A5%E5%A3%AE%E6%80%A7%E5%92%8C%E6%80%A7%E8%83%BD/</link>
        <description>Python 项目代码健壮性和性能 - 分类 - 海拉鲁编程客</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-cn</language><managingEditor>twocucao@gmail.com (twocucao)</managingEditor>
            <webMaster>twocucao@gmail.com (twocucao)</webMaster><lastBuildDate>Tue, 24 Sep 2019 21:57:40 &#43;0800</lastBuildDate><atom:link href="http://twocucao.xyz/categories/python-%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E5%81%A5%E5%A3%AE%E6%80%A7%E5%92%8C%E6%80%A7%E8%83%BD/" rel="self" type="application/rss+xml" /><item>
    <title>如何写出整洁的 Python 代码 下</title>
    <link>http://twocucao.xyz/posts/20190924_pycode_08/</link>
    <pubDate>Tue, 24 Sep 2019 21:57:40 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://twocucao.xyz/posts/20190924_pycode_08/</guid>
    <description><![CDATA[0x00 前言 本文是《提升你的 Python 项目代码健壮性和性能》系列的第八篇文章。
本文是《整洁下篇》，本文的诞生，要感谢我前公司的技术主管豪蔚老师和产品主管刚哥，在上海工作这几年，总是和能优秀的人工作，确实是我幸运的地方。
这篇文章憋了很久，思考了许久，《整洁下篇》干脆就聊聊编程中，不是写代码的部分；
如果说，写代码是硬技能，那么本期就是来聊软技能的。更确切的说，是复盘几年的工作经验中，我发现的一些有趣的，影响效率的事情以及我的解决方案。
 凡用兵之法，全国为上，破国次之；全军为上，破军次之；全旅为上，破旅次之；全卒为上，破卒次之；全伍为上，破伍次之。是故百战百胜，非善之善者也；不战而屈人之兵，善之善者也。 &mdash; 《孙子兵法·谋攻篇》
 什么叫做有效率，不战而屈人之兵，善之善者也。
 最整洁的代码，是少写代码，甚至不写代码。
 如何做到？
几年的工作经验下来，我发现我处理的往往不是技术问题，而是大量的非技术性问题以及伴随着非技术问题带来的成倍的技术问题。
 因需求的变化的返工。 因追求完美而为了不必要优化的地方而优化。 因沟通不到位导致的加班加点。 因缺乏单元测试导致的重构没有底气，甚至懒得重构。 因缺乏话语权导致的被动开发。 因考虑不周到而导致的硬着头皮加班。 因命名不够规范，代码可维护性低下，导致后面定位问题的时间指数性上升。  应然如此？实然如此！
0x01 处理需求的姿势 以前呢，我自以为编程水平还算不错，撸起代码来像是一道春天的闪电。但时间长了，发现技术行，但总体产出不高效。为什么呢？
比如有如下的问题：
 问题一：战术上很勤奋，一个需求过来，我的第一反应是把这个功能『通过系统』做出来。 问题二：没有深入和产品运营沟通，于是后期被动的应对需求的变动 问题三：没有三思而行，做项目没有计划性，想到哪里做到哪里。 问题一的结果：这导致了很多时候，把这个功能『通过系统』做出来了，但是其实是个伪需求。或者，是个没必要做到系统里面的需求。 问题二的结果：导致了一些过度设计或者过于粗糙的设计。最后忙于返工，以及各种数据迁移和逻辑修改 问题三的结果：没有做好足够的规划，『码在当下』, 没有前瞻性。   速度再快，也要返工，唯一不变的就是变化本身。
 我想了很久，才意识到，很多时候，产品在传递需求的时候是存在很多的信息损失的。
背后的原因，可能来源于产品的态度和能力上，可能是产品的上一级需求传递过来的问题，也可能是团队对待产品以及自己的错误的态度上。
经验告诉我，作为对项目负责的程序员千万不要跟着产品经理的思路走。
如果是新功能，一定要就要展开一番对话。
 问清楚为什么要做这个需求 / 变动，藏在后面的思路是什么。对于用户、对于产品有什么价值。 和产品经理互杠，用户的具体使用场景是什么。 看看是不是一定要放在系统里面解决。如果放在系统里面解决，那么应该怎么做。让产品方给出一个粗糙的方案。 化简这个方案后再次和产品互杠。 确定方案后分解安排任务。 任务上线之后如何确定这个功能是有效果的。  还记得上面的话么？不战而屈人之兵。
要做的需求，如果产品经理不能简单清晰的描述，做出来一定是一坨。
作为合格的工程师，则是必须要将不清晰、不合理的、拍脑袋的需求拒掉。所谓上梁不正下梁歪，出题人的思路是混乱的，解答者的思路肯定不会清晰到哪里去。
当然，这也存在一些例外的情况，如果你到了一个工作地方，没什么话语权，认真推进事情发展也没什么暖用的地方的话，好好反思一下自己为什么在这种地方干活，然后认真修炼自己。
早些年，我还以为有时间不够的情况，后来也逐渐明白，没有开发不了的任务，程序写到后面都是妥协，无非就多快好省的妥协
 多 - 功能的数量和完成度 快 - 完工时间 好 - 软件最终质量，满意程度 省 - 成本，花多少个人力和精力  鱼和熊掌不能得兼]]></description>
</item><item>
    <title>如何写出整洁的 Python 代码 中</title>
    <link>http://twocucao.xyz/posts/20190526_pycode_07/</link>
    <pubDate>Sun, 26 May 2019 21:57:40 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://twocucao.xyz/posts/20190526_pycode_07/</guid>
    <description><![CDATA[0x00 前言 本文是《提升你的 Python 项目代码健壮性和性能》系列的第七篇文章。
上篇《如何写出整洁的代码 上》 从变量命名 / 函数 / 注释整洁 / 格式整洁上写出干净的代码
https://zhuanlan.zhihu.com/p/59510165
本文还是通过代码上的一些小技巧和一些原则来让代码更加整齐。
0x01 避免过深的缩进 场景，你在做一个 B2B2C 的商城系统。商家的活动需要在某些比较严格的条件下才能参与（假设有五个字段吧）。
如果不动手捋一捋判断的路径，上来就动手写代码，则很容易写出如下的代码。
if cond1: dosomething() if cond2: dosomething() if cond3 and cond4: dosomething() else: dosomething() if condx: dosomething() else: if cond2: dosomething() if cond3 and cond4: dosomething() if condx: dosomething() 想想你这个时候才判断了 5 个字段&hellip; 如果想都不想就开始写这种代码的话，就做好修改的时候崩溃吧。
当你写出 if 超过两层缩进的时候，代码的复杂度就值得注意了。
这个时候，应该火速的拿出纸和笔出来，快速的捋一捋所有的变量和情况，
『以减少缩进为目标』
能提前判断掉的就提前判断掉
# 能提前判断掉的就提前判断掉 if cond2: raise AlreadPaid(): if cond3: raise ActivityExhaused(): if cond4: raise ActivityCancel(): 代码的缩进越浅，代表着代码越容易维护，用学长的话说，老手才知道『九浅一深』的奥妙&hellip;&hellip;]]></description>
</item><item>
    <title>如何写出整洁的 Python 代码 上</title>
    <link>http://twocucao.xyz/posts/20190525_pycode_06/</link>
    <pubDate>Sat, 25 May 2019 21:57:40 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://twocucao.xyz/posts/20190525_pycode_06/</guid>
    <description><![CDATA[本文是《提升你的 Python 项目代码健壮性和性能》系列的第六篇文章。
接下来的三篇，围绕另一个主题
 如何写出整洁的代码
 『整洁』三篇是基于**『代码整洁之道』和『架构整洁之道』**的一些切身的理解和体会。
感谢这两本书的作者 Bob 大叔。
 PPS: 某东读书 VIP 会员有不少 IT 资源类的书籍可以免费看，比如『代码整洁之道』
 0x00 前言 软件系统的腐败之路 随着项目代码行数的增加，不可避免的遇到软件架构腐败的问题。
具体表现为：随着每一次产品版本的发布，对现有流程进行优化和修改就格外的费事和吃力。工程师的生产力就开始直线下降。
所谓
 眼看他起朱楼，眼看他宴宾客，眼看他楼塌了。 清 孔尚任《桃花扇》
 0x01 讨论 为什么会出现腐败的系统 原因可能是多方面的，比如常见的场景：
步骤 1. 领域建模的人对业务里概念的理解不到位，流程不深入了解。 步骤 2. 工程师在实现的时候，按照自己的理解，没有梳理整个流程。就开始动手实现。并且全程人肉测试。 步骤 3. 需求变动，流程更改。 第一步容易埋下坑点：
 对『该领域』理解的不到位，导致『流程』就不清晰，也导致原型设计等同于 Axure 画的『表单』。 『关键概念』没有解释，『关键字段』没有解释，也没有『流程图』，也没有关于业务主体『状态图』，前后端面向表单开发。(Form Oriented Programming)  接着，领域理解不到位就会带来另一个问题。
 对于需要『建模的实施者』一般是后端工程师，将花费比较多的时间来梳理流程。 前后端代码结构不清晰。比如，前端页面的路由命名不清晰，Page 组件命名不清晰，请求 API 接口不清晰。比如，后端路由命名不清晰，view func 不清晰，serializer 不清晰，table 命名不清晰。  经验老道的程序员会通过一些手段，比如让这些命名不清晰的东西统一一下，然后等概念清晰了。再改回来。
第二步容易埋下坑点：
 全程口头对需求，『没有文档』落下来，产品之间和开发之间**『缺乏共通的文档理解指南』**。  当更改已有流程或者是出问题的时候，除了一脸懵逼就还剩下甩锅了。]]></description>
</item><item>
    <title>如何通过测试提升 Python 代码的健壮性</title>
    <link>http://twocucao.xyz/posts/20190216_pycode_02/</link>
    <pubDate>Sat, 23 Mar 2019 21:57:40 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://twocucao.xyz/posts/20190216_pycode_02/</guid>
    <description><![CDATA[0x00 前言 本文是《提升你的 Python 项目代码健壮性和性能》系列的第二篇文章。
本文的测试更多专注于 Python 后端的程序员。
在上一篇文章中，我提到了代码覆盖率，即测试的一种指标。
本期就聊聊测试这件小事情。
0x01 测试的分类 测试有很多种，
按照测试设计的方法可以分为：
1. 黑盒 2. 白盒
按照测试目的：
1. 功能测试
单元测试 功能测试 集成测试 场景测试 A/B 测试 2. 非功能测试 压力测试 安全性测试 可访问性测试 其他
回归测试 易用性测试 还有不少，懒得去整理了..... 代码覆盖率顾名思义，就是测试用例覆盖运行代码的比重。
后端主要关注哪些测试  单元测试 功能测试 端对端测试 性能测试  0x02 为什么要写测试 来讲讲测试的优点。
为什么要写测试来覆盖代码。
 适当的测试可以让发布代码的时候更加有底气。 适当的测试可以让新手更快的了解代码。 适当的测试可以让程序更容易重构。 适当的测试可以加快团队的开发速度。  既不是不写，也不是狂写一气。看到这里你可能有些疑惑？写测试还加快速度？Are you kidding?
一个一个来解释吧。
举个简化版本的例子，『用户下单』到『用户收货』。
 用户『查询产品』 用户『使用优惠券』下单 用户『在线支付』。当然，用户也可以让不付款，让订单失效。或者直接取消订单。 商家『确认发货』。 物流公司更新运单『发货中』。 用户『确认收货』。当然，用户也可以发起退款。  让新手更快的了解代码 测试用例里的数据，往往是能跑通某段代码的最佳测试数据集合。
假如，有个程序员写了 『下单-在线支付-确认收货』的集成测试。作为刚接手这段代码的人。可以在最短的时间内，通过阅读测试代码从而理解整个流程。]]></description>
</item><item>
    <title>为你的项目快速搭建 ELKFA 日志系统</title>
    <link>http://twocucao.xyz/posts/20190310_pycode_05/</link>
    <pubDate>Sun, 10 Mar 2019 21:57:40 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://twocucao.xyz/posts/20190310_pycode_05/</guid>
    <description><![CDATA[本文是《提升你的 Python 项目代码健壮性和性能》系列的第五篇文章。
讲的是日志系统 ELKFA 的搭建
0x00 前言 什么是 ELKFA?
这五个字母分别代表着五个开源软件
 E - ElasticSearch L - Logstash K - Kibana F - FileBeat A - APM-Server  利用这五个软件的组合，我们可以在比较短的时间打造两个系统：
 日志系统，分析 Nginx 日志，Gunicorn 日志，Flask 日志，Django 日志 APM 系统，解决两个问题 2.1 Metric 分析：Flask 是否正常运行，接口请求信息定期发送到 APMServer 这边，方便我观察服务是否正常，接口和业务逻辑的执行的时间是否在预期范围内。 2.2 Trouble Shooting: 如果程序报了异常，我想把需要报的异常堆栈信息打出。方便我快速的 Trouble Shooting  0x01 任务 1: 分析 Nginx 日志 Nginx 众所周知，Nginx 日志是个宝库，所以本文选取了 Nginx 作为日志分析的案例。
对于 Nginx 日志，可以采用 FileBeat 上传到 Logstash, 由 Logstash 对文件进行解析，并存储到 ElasticSearch]]></description>
</item><item>
    <title>如何保证 Django 项目的数据一致性</title>
    <link>http://twocucao.xyz/posts/20190308_pycode_03/</link>
    <pubDate>Fri, 08 Mar 2019 21:57:40 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://twocucao.xyz/posts/20190308_pycode_03/</guid>
    <description><![CDATA[0x00 前言 本文是《提升你的 Python 项目代码健壮性和性能》系列的第三篇文章。
 第一篇，讲的是如何 用 Type Annotation 提升你的 Python 代码健壮性 第二篇，讲的是如何通过测试提升 Python 代码的健壮性  第三篇，即本文，我们来谈谈 Django 项目并发可能带来的问题以及如何保持 Django 项目的数据一致性。
本文目录如下：
0x00 前言 : section ▼ 0x01 背景知识 : section 并发会带来数据不一致 : section ▼ 0x02 Django 项目如何解决项目 : section 悲观的方式 : section 乐观的方式 : section 没有银弹 : section 0x03 解决超卖问题 : section ▼ 0x04 番外篇 数据库隔离级别 : section READ-UNCOMMITTED : section READ-COMMITTED : section REPEATABLE-READ : section SERIALIZABLE : section 0xEE 参考链接 : section 本文讨论的场景如下：]]></description>
</item><item>
    <title>这几招，让你快速提升 Python 项目的性能</title>
    <link>http://twocucao.xyz/posts/20190309_pycode_04/</link>
    <pubDate>Tue, 05 Mar 2019 21:57:40 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://twocucao.xyz/posts/20190309_pycode_04/</guid>
    <description><![CDATA[0x00 前言 本文是《提升你的 Python 项目代码健壮性和性能》系列的第四篇文章。
本文主要目的在于介绍一些 Python 项目常规的性能优化的姿势与技巧。
0x01 勿要过早优化 优化的最简单的途径就是，没用户 + 调用次数少
嗯？但这种优化方式&hellip;&hellip; 实在是没什么好说的。
 优化口诀 1: 先做对，布监控，再做好。 优化口诀 2: 过早优化是万恶之源。 优化口诀 3: 去优化那些需要优化的地方。  即
 Step 1. Get it right. Step 2. Test it&rsquo;s right. Step 3. Monitor. Step 4. Profile if slow. Step 5. Try Optimize. Step 6. Repeat from 2.  有的人站出来说，我写程序就是要一步到位，把能优化的点一次性搞定。
请不要听他的，因为优化是无止境的。唯快不破。
能一次写出优雅清晰而且性能高的代码的人，一般很少见到。毕竟需要考虑的点太多了。
基于上面的认知，代码的可维护性是第一位的。
 写代码的首先应该是代码很清晰，非常容易维护。 然后在没有过分降低可维护性的情况下，作出性能的优化。  0x02 问题与定位问题 代码运行之后，通过各种途径的反馈，最终你知道了写的代码有点问题
这类问题一般如下
 耗时长 占内存 逻辑错误   PS: 其实还有其他问题，比如语法错误，业务问题（这个场景下产品这么设计容易被薅羊毛）等等这类不在讨论之列。]]></description>
</item><item>
    <title>用 Type Anotation 提升你的 Python 代码健壮性</title>
    <link>http://twocucao.xyz/posts/20181210_pycode_01/</link>
    <pubDate>Mon, 10 Dec 2018 21:57:40 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://twocucao.xyz/posts/20181210_pycode_01/</guid>
    <description><![CDATA[0x00 前言 本文是《提升你的 Python 项目代码健壮性和性能》系列的第一篇文章。
当我刚知道 Python 要添加类型的时候，我的内心是拒绝的。
Why, Why, Why? 就是因为不喜欢类型，也不喜欢特别动态的语言。
但是，尝试了俩个疗程之后，腰也不疼了，腿也不疼了，走起路来都有劲了
 嗯，真香。
 0x01 Why Type Annotation 人们常说
 动态类型一时爽，代码重构火葬场。
 在刚写 Python 的前两年里并没有感受很深。
直到，开始和别人协作的时候，才发现各种莫名其妙的问题。
 大量的使用魔法方法 flake8 分析出某个函数过于复杂 send_message 里面有不少的参数，一不小心就传参错误 None 值  动态类型给人极大的灵活性，写的时候很爽，但如果解放了双手，撸起袖子一通写，自己写起来爽了，自己重构的时候或者其他人来看代码的时候，头发就会加速掉落。
聪明的你很容易反问，只要我们团队不犯这些错误，不就好了么？
是的，当我们讨论 Python Annotation 的时候，往往陷入类型之争。
我并不想讨论静态类型和动态类型孰好孰坏。
我想讨论的是加了 Typing 极大的提升代码的健壮性。
先从 Gradual Typing 说起吧。
0x02 Gradual Typing 在你刚入门一门编程语言的时候，我们常常说，Java 是强类型静态语言，Python 是强类型动态语言
从这两位诞生开始，静态类型和动态类型就一直进行旷日持久的圣战。
然而，而现在的发展趋势是：
 静态类型的语言觉得自己太过静态，以至于写起来很啰嗦。于是引入了很多类型推断。 Java / Go 动态类型的语言觉得自己太过动态，以至于协作的过程中总是出现低级错误。于是引入了 Gradual Typing , Typescript / Flow / Python Type Annotation  什么是 Gradual Typing?]]></description>
</item></channel>
</rss>
