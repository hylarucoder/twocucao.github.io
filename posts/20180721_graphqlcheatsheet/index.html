<!DOCTYPE html>
<html lang="zh-cn">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>GraphQL 的一些项目经验 - 海拉鲁编程客</title><meta name="Description" content="这篇文章展示了基本的 Markdown 语法和格式."><meta property="og:title" content="GraphQL 的一些项目经验" />
<meta property="og:description" content="这篇文章展示了基本的 Markdown 语法和格式." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://twocucao.xyz/posts/20180721_graphqlcheatsheet/" />
<meta property="article:published_time" content="2020-12-02T21:57:40+08:00" />
<meta property="article:modified_time" content="2020-01-01T16:45:40+08:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="GraphQL 的一些项目经验"/>
<meta name="twitter:description" content="这篇文章展示了基本的 Markdown 语法和格式."/>
<meta name="application-name" content="海拉鲁编程客">
<meta name="apple-mobile-web-app-title" content="海拉鲁编程客"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="http://twocucao.xyz/posts/20180721_graphqlcheatsheet/" /><link rel="prev" href="http://twocucao.xyz/posts/20201202_react_stack/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "GraphQL 的一些项目经验",
        "inLanguage": "zh-cn",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "http:\/\/twocucao.xyz\/posts\/20180721_graphqlcheatsheet\/"
        },"genre": "posts","keywords": "GraphQL, Restful","wordcount":  953 ,
        "url": "http:\/\/twocucao.xyz\/posts\/20180721_graphqlcheatsheet\/","datePublished": "2020-12-02T21:57:40+08:00","dateModified": "2020-01-01T16:45:40+08:00","publisher": {
            "@type": "Organization",
            "name": "twocucao"},"author": {
                "@type": "Person",
                "name": "twocucao"
            },"description": "这篇文章展示了基本的 Markdown 语法和格式."
    }
    </script></head>
    <body header-desktop="" header-mobile=""><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : '' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="海拉鲁编程客">海拉鲁编程客</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/categories/"> 分类 </a><a class="menu-item" href="/posts/"> 存档 </a><a class="menu-item" href="/tags/"> 标签 </a><span class="menu-item delimiter"></span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="海拉鲁编程客">海拉鲁编程客</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><a class="menu-item" href="/categories/" title="">分类</a><a class="menu-item" href="/posts/" title="">存档</a><a class="menu-item" href="/tags/" title="">标签</a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">GraphQL 的一些项目经验</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="http://twocucao.xyz" title="Author" target="_blank" rel="noopener noreffer author" class="author"><i class="fas"></i>twocucao</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"><i class="far fa-folder fa-fw"></i>系统设计</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2020-12-02">2020-12-02</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 953 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 5 分钟&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#0x00-前言">0x00 前言</a>
      <ul>
        <li><a href="#名词约定">名词约定</a></li>
      </ul>
    </li>
    <li><a href="#0x01-流水的技术方案铁打的需求">0x01 流水的技术方案，铁打的需求。</a></li>
    <li><a href="#0x02-restful-的缺点">0x02 RESTful 的缺点</a>
      <ul>
        <li><a href="#语义不明确">语义不明确</a></li>
        <li><a href="#得到即是失去---gets-loss">得到即是失去 - Get&rsquo;s loss</a></li>
        <li><a href="#未很好解决的问题">未很好解决的问题</a></li>
      </ul>
    </li>
    <li><a href="#0x03-graphql-是新的颠覆者么">0x03 GraphQL 是新的颠覆者么？</a>
      <ul>
        <li><a href="#graphql-是什么">GraphQL 是什么？</a></li>
        <li><a href="#graphql-给消费端带来的好处">GraphQL 给消费端带来的好处</a></li>
      </ul>
    </li>
    <li><a href="#0x04-graphql-给生产端带来的挑战">0x04 GraphQL 给生产端带来的挑战</a>
      <ul>
        <li><a href="#view-层代码组织剧变">View 层代码组织剧变</a></li>
        <li><a href="#权限问题">权限问题</a></li>
        <li><a href="#版本更迭">版本更迭</a></li>
        <li><a href="#required-vs-nullable-vs-blank">required vs nullable vs blank</a></li>
        <li><a href="#服务端缓存">服务端缓存</a></li>
        <li><a href="#嵌套式-api">嵌套式 API</a></li>
        <li><a href="#n1-问题">N+1 问题</a></li>
        <li><a href="#为名所困">为名所困</a></li>
      </ul>
    </li>
    <li><a href="#0x05-如何应对挑战">0x05 如何应对挑战</a>
      <ul>
        <li><a href="#顺应-restful-like-的-view-层组织方式">顺应 restful like 的 view 层组织方式</a></li>
        <li><a href="#版本更迭-1">版本更迭</a></li>
        <li><a href="#服务端缓存-1">服务端缓存</a></li>
        <li><a href="#n1-问题-1">N+1 问题</a></li>
        <li><a href="#required-vs-nullable-vs-blank-1">required vs nullable vs blank</a></li>
        <li><a href="#结论">结论</a></li>
      </ul>
    </li>
    <li><a href="#0x05-其他思考点">0x05 其他思考点</a>
      <ul>
        <li><a href="#rest-or-graphql-无法解决的问题">Rest Or GraphQL 无法解决的问题</a></li>
      </ul>
    </li>
    <li><a href="#0xee-参考链接">0xEE 参考链接</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h2 id="0x00-前言">0x00 前言</h2>
<p>本文最早行文于 2018 年中，那时 GraphQL 的生态尚未成熟，也缺乏社区总结的一些经验。</p>
<p>2020 年末，复盘一下 GraphQL 的一些使用经验。</p>
<h3 id="名词约定">名词约定</h3>
<ul>
<li>接口生产端 / 服务端 下面统一称「生产端」</li>
<li>接口消费端 / 客户端 下面统一称「消费端」</li>
</ul>
<h2 id="0x01-流水的技术方案铁打的需求">0x01 流水的技术方案，铁打的需求。</h2>
<p>年幼时看笑傲江湖，华山派两派居然为了剑宗和气宗争个你死我活。</p>
<p>觉得甚是幼稚。</p>
<p>年纪渐大之后发现社会处处充满着这种荒谬的争论。</p>
<ul>
<li>剑宗 or 气宗</li>
<li>自然美 or 人造美</li>
<li>Java or Python</li>
<li>Editor or IDE</li>
<li>Rest or GraphQL</li>
<li>单体应用 or 微服务</li>
</ul>
<blockquote>
<p>剑招是死的，人是活的。</p>
</blockquote>
<p>打个比方，当讨论问题的时候，下面两个问题意义可能并不是很大。</p>
<ul>
<li>用剑宗初学者和气宗高手比，或者相反，这个完全没有多大意义？</li>
<li>用剑宗初学者和气宗初学者比，有一点意义，但意义也不是很大。</li>
</ul>
<p>GraphQL 作为挑战者，下面几个问题是很有意义的。</p>
<p>GraphQL 相比于原先成熟稳定的方案，GraphQL</p>
<ul>
<li>现有方案存在哪些问题？</li>
<li>新方案解决了哪些原先没有解决的问题。</li>
<li>新方案更低成本解决了哪些问题。</li>
<li>现有的痛点是否存在一些新老方案都无法解决的问题。</li>
<li>有无前车之鉴，有无社区最佳实践。</li>
<li>迁移成本和学习成本是多少。</li>
<li>回滚成本多少。</li>
</ul>
<h2 id="0x02-restful-的缺点">0x02 RESTful 的缺点</h2>
<p>RESTful 有很多接口上最佳实践，但生搬硬套就会使得接口比较诡异。</p>
<p>这里只说生搬硬套 RESTFul 的带来的缺点，对于大部分公司来说，这些缺点远远抵不上带来的优点。</p>
<blockquote>
<p>剑招是死的，人是活的。</p>
</blockquote>
<h3 id="语义不明确">语义不明确</h3>
<p>比如，业务具备一定复杂性的时候，语义容易不明确。</p>
<p>预览订单和下单两个接口，如果遵循如下的标准</p>
<ol>
<li>接口路径使用名词而非动词</li>
<li>GET 不修改，POST/PUT/DELETE 修改状态</li>
<li>使用子字段来表述关系，查询订单 GET /shop/711/orders/</li>
</ol>
<p>严格遵循 RESTful 的话，接口就会成这个样子</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">GET</span> <span class="o">/</span><span class="n">shops</span><span class="o">/</span><span class="mi">1</span><span class="o">/</span><span class="n">order</span>

<span class="p">{</span>
  <span class="s2">&#34;products&#34;</span><span class="p">:</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span>
<span class="p">}</span>

<span class="n">PUT</span> <span class="o">/</span><span class="n">shops</span><span class="o">/</span><span class="mi">1</span><span class="o">/</span><span class="n">order</span>

<span class="p">{</span>
  <span class="s2">&#34;products&#34;</span><span class="p">:</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div><p>反正我是看不出来这是一坨啥玩意的，至于如果你硬性规范 PUT order 就是创建订单，就会出现接下来两个接口完全不知道该怎么写</p>
<ol>
<li>支付订单 （用 patch /shop/1/order)</li>
<li>取消订单 （用 delete 方法，也没有 delete 呀）</li>
</ol>
<ul>
<li>产品上，用户删除了一台机器，那就是删除了一台机器？这里是软删。</li>
<li>产品上，管理员删除了一台机器，那就是删除了一台机器？机器记录还在的。</li>
</ul>
<blockquote>
<p>剑招是死的，人是活的。</p>
</blockquote>
<p>不严格遵循 RESTful 的时候可以这么写。</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">POST</span> <span class="o">/</span><span class="n">preview_order</span>

<span class="p">{</span>
  <span class="s2">&#34;shop_id&#34;</span><span class="p">:</span> <span class="mi">123</span><span class="p">,</span>
  <span class="s2">&#34;products&#34;</span><span class="p">:</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span>
<span class="p">}</span>

<span class="n">POST</span> <span class="o">/</span><span class="n">make_order</span>

<span class="p">{</span>
  <span class="s2">&#34;shop_id&#34;</span><span class="p">:</span> <span class="mi">123</span><span class="p">,</span>
  <span class="s2">&#34;products&#34;</span><span class="p">:</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span>
<span class="p">}</span>

<span class="n">POST</span> <span class="o">/</span><span class="n">pay_order</span>

<span class="p">{</span>
  <span class="s2">&#34;order_id&#34;</span><span class="p">:</span> <span class="s2">&#34;202012001231237&#34;</span><span class="p">,</span>
  <span class="s2">&#34;balance&#34;</span><span class="p">:</span> <span class="s2">&#34;20.20&#34;</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">POST</span> <span class="o">/</span><span class="n">cancel_order</span>

<span class="p">{</span>
  <span class="s2">&#34;order_id&#34;</span><span class="p">:</span> <span class="s2">&#34;202012001231237&#34;</span>
<span class="p">}</span>
</code></pre></div><p>至于第三点的子字段表述关系，是一个典型的反面教材</p>
<p>引用 Python 之禅来表达</p>
<pre><code>Flat is better than nested.
扁平优于嵌套
</code></pre><h3 id="得到即是失去---gets-loss">得到即是失去 - Get&rsquo;s loss</h3>
<p>GET 让问题变得复杂</p>
<p>Rest 时代一个有代表性的问题就是如何在 GET 方法里处理以下四个问题</p>
<ol>
<li>过滤 filter</li>
<li>排序 sort</li>
<li>字段裁剪 field selections</li>
<li>分页 pagination</li>
</ol>
<p>为了解决这个问题，一个稍微复杂的查询接口就成了如下的样子</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">GET /cars?seats&lt;<span class="o">=</span>2<span class="p">&amp;</span><span class="nv">sort</span><span class="o">=</span>-manufactorer,+model<span class="p">&amp;</span><span class="nv">fields</span><span class="o">=</span>manufacturer,model,id,color<span class="p">&amp;</span><span class="nv">page</span><span class="o">=</span>1<span class="p">&amp;</span><span class="nv">per_page</span><span class="o">=</span><span class="m">10</span>
</code></pre></div><p>可阅读性较差</p>
<p>而如果这么写，则前端无需把原先的 queryparams 转化成逗号结尾的字符串，后端也需要跟着解析并且转成自己想要的格式</p>
<p>如果按照如下的写法，后端则可以直接使用 json 标准库里的数据类型。</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">POST</span> <span class="o">/</span><span class="n">cars</span>
<span class="p">{</span>
  <span class="s2">&#34;filters&#34;</span><span class="p">:</span> <span class="p">[</span>
    <span class="p">{</span>
      <span class="s2">&#34;seat__lt&#34;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">]</span>
  <span class="s2">&#34;sort&#34;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&#34;-manufactorer&#34;</span><span class="p">,</span> <span class="s2">&#34;+model&#34;</span><span class="p">],</span>
  <span class="s2">&#34;fields&#34;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&#34;manufacturer&#34;</span><span class="p">,</span><span class="s2">&#34;model&#34;</span><span class="p">,</span><span class="s2">&#34;id&#34;</span><span class="p">,</span><span class="s2">&#34;color&#34;</span><span class="p">],</span>
  <span class="s2">&#34;pagination&#34;</span><span class="p">:</span> <span class="p">{</span>
    <span class="s2">&#34;page&#34;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="s2">&#34;per_page&#34;</span><span class="p">:</span> <span class="mi">10</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="未很好解决的问题">未很好解决的问题</h3>
<h4 id="细粒度和正交性">细粒度和正交性</h4>
<p>RESTFul 接口提倡的是细粒度、正交性。</p>
<p>这样的接口是为了更加方便的复用多个接口来组成页面，但是并非没有问题。 细粒度和正交性意味着接口是 building block, 而 building block 组合起来是交给前端来做的。 这意味着前端为了组合多个资源，则需要发起多次请求。</p>
<p>这带来了额外的<strong>网络开销成本</strong>（随着大家都使用上 http2 之后可能开销问题会极大的减少）和<strong>响应内容拼装成本</strong></p>
<blockquote>
<p>HTTP 2 解决了首部开销、多路复用等 HTTP 1.1 面临的问题，还做到了完全向后兼容。</p>
</blockquote>
<p>请求多个接口带来的另一个问题是</p>
<ul>
<li>服务端给的怎么这么少</li>
<li>服务端给的实在是太多了</li>
</ul>
<h4 id="文档的滞后性">文档的滞后性</h4>
<p>接口开出来是没有文档的。而维护文档则会带来一定的成本，文档本身也具备一定的滞后性。</p>
<h2 id="0x03-graphql-是新的颠覆者么">0x03 GraphQL 是新的颠覆者么？</h2>
<h3 id="graphql-是什么">GraphQL 是什么？</h3>
<p>GraphQL 也不是什么革命性的产品，不过是一种新的开 Web 接口的方式罢了。</p>
<p>而请求接口提交的参数也变成了包含参数的一种查询语言。</p>
<p>官方宣传的 GraphQL 搞好了，只需如此：</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="err">#</span> <span class="nx">Step1</span><span class="p">.</span> <span class="nx">描述你的数据</span>

<span class="nx">type</span> <span class="nx">Project</span> <span class="p">{</span>
  <span class="nx">name</span><span class="o">:</span> <span class="nb">String</span>
  <span class="nx">tagline</span><span class="o">:</span> <span class="nb">String</span>
  <span class="nx">contributors</span><span class="o">:</span> <span class="p">[</span><span class="nx">User</span><span class="p">]</span>
<span class="p">}</span>

<span class="err">#</span> <span class="nx">Step2</span><span class="p">.</span> <span class="nx">请求所需数据</span><span class="err">。</span>

<span class="p">{</span>
  <span class="nx">project</span><span class="p">(</span><span class="nx">name</span><span class="o">:</span> <span class="s2">&#34;GraphQL&#34;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">tagline</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="err">#</span> <span class="nx">Step3</span><span class="p">.</span> <span class="nx">拿到所需数据</span><span class="err">。</span>

<span class="p">{</span>
  <span class="s2">&#34;project&#34;</span><span class="o">:</span> <span class="p">{</span>
    <span class="s2">&#34;tagline&#34;</span><span class="o">:</span> <span class="s2">&#34;A query language for APIs&#34;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>嗯，是不是和 SQL 看起来有点像？当然咯，都是查询语言 (QL) 嘛。</p>
<h3 id="graphql-给消费端带来的好处">GraphQL 给消费端带来的好处</h3>
<p>GraphQL 的好处，自然是接口消费端写起来就是一个字，爽。</p>
<p>比如我们使用 Github 的 API 做一个简单的查询</p>
<p>地址如下 <a href="https://developer.github.com/v4/explorer/">https://developer.github.com/v4/explorer/</a></p>
<p>查询如下</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">query</span> <span class="p">{</span>
  <span class="nx">viewer</span> <span class="p">{</span>
    <span class="nx">login</span>
    <span class="nx">bio</span>
    <span class="nx">repositories</span><span class="p">(</span><span class="nx">first</span><span class="o">:</span><span class="mi">10</span><span class="p">,</span> <span class="nx">orderBy</span> <span class="o">:</span> <span class="p">{</span> <span class="nx">field</span><span class="o">:</span> <span class="nx">STARGAZERS</span><span class="p">,</span> <span class="nx">direction</span><span class="o">:</span> <span class="nx">DESC</span><span class="p">}</span>   <span class="p">)</span> <span class="p">{</span>
      <span class="nx">nodes</span> <span class="p">{</span>
        <span class="nx">nameWithOwner</span>
        <span class="nx">viewerHasStarred</span>
        <span class="nx">watchers</span> <span class="p">{</span>
          <span class="nx">totalCount</span>
        <span class="p">}</span>
        <span class="nx">stargazers</span> <span class="p">{</span>
          <span class="nx">totalCount</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="nx">totalCount</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>结果如下</p>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
  <span class="nt">&#34;data&#34;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&#34;viewer&#34;</span><span class="p">:</span> <span class="p">{</span>
      <span class="nt">&#34;login&#34;</span><span class="p">:</span> <span class="s2">&#34;twocucao&#34;</span><span class="p">,</span>
      <span class="nt">&#34;bio&#34;</span><span class="p">:</span> <span class="s2">&#34;Pythonist In Shanghai.&#34;</span><span class="p">,</span>
      <span class="nt">&#34;repositories&#34;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&#34;nodes&#34;</span><span class="p">:</span> <span class="p">[</span>
          <span class="p">{</span>
            <span class="nt">&#34;nameWithOwner&#34;</span><span class="p">:</span> <span class="s2">&#34;twocucao/danmu.fm&#34;</span><span class="p">,</span>
            <span class="nt">&#34;viewerHasStarred&#34;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
            <span class="nt">&#34;watchers&#34;</span><span class="p">:</span> <span class="p">{</span>
              <span class="nt">&#34;totalCount&#34;</span><span class="p">:</span> <span class="mi">22</span>
            <span class="p">},</span>
            <span class="nt">&#34;stargazers&#34;</span><span class="p">:</span> <span class="p">{</span>
              <span class="nt">&#34;totalCount&#34;</span><span class="p">:</span> <span class="mi">282</span>
            <span class="p">}</span>
          <span class="p">},</span>
          <span class="p">{</span>
            <span class="nt">&#34;nameWithOwner&#34;</span><span class="p">:</span> <span class="s2">&#34;twocucao/YaDjangoBlog&#34;</span><span class="p">,</span>
            <span class="nt">&#34;viewerHasStarred&#34;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
            <span class="nt">&#34;watchers&#34;</span><span class="p">:</span> <span class="p">{</span>
              <span class="nt">&#34;totalCount&#34;</span><span class="p">:</span> <span class="mi">9</span>
            <span class="p">},</span>
            <span class="nt">&#34;stargazers&#34;</span><span class="p">:</span> <span class="p">{</span>
              <span class="nt">&#34;totalCount&#34;</span><span class="p">:</span> <span class="mi">120</span>
            <span class="p">}</span>
          <span class="p">},</span>
          <span class="p">{</span>
            <span class="nt">&#34;nameWithOwner&#34;</span><span class="p">:</span> <span class="s2">&#34;twocucao/danmu&#34;</span><span class="p">,</span>
            <span class="nt">&#34;viewerHasStarred&#34;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
            <span class="nt">&#34;watchers&#34;</span><span class="p">:</span> <span class="p">{</span>
              <span class="nt">&#34;totalCount&#34;</span><span class="p">:</span> <span class="mi">5</span>
            <span class="p">},</span>
            <span class="nt">&#34;stargazers&#34;</span><span class="p">:</span> <span class="p">{</span>
              <span class="nt">&#34;totalCount&#34;</span><span class="p">:</span> <span class="mi">64</span>
            <span class="p">}</span>
          <span class="p">}</span>
        <span class="p">],</span>
        <span class="nt">&#34;totalCount&#34;</span><span class="p">:</span> <span class="mi">33</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>如果你说，我还要看看这个 repo 的主要语言，那么增加一行查询即可。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">query</span> <span class="p">{</span>
  <span class="nx">viewer</span> <span class="p">{</span>
    <span class="nx">login</span>
    <span class="nx">bio</span>
    <span class="nx">repositories</span><span class="p">(</span><span class="nx">first</span><span class="o">:</span><span class="mi">3</span><span class="p">,</span> <span class="nx">orderBy</span> <span class="o">:</span> <span class="p">{</span> <span class="nx">field</span><span class="o">:</span> <span class="nx">STARGAZERS</span><span class="p">,</span> <span class="nx">direction</span><span class="o">:</span> <span class="nx">DESC</span><span class="p">}</span>   <span class="p">)</span> <span class="p">{</span>
      <span class="nx">nodes</span> <span class="p">{</span>
        <span class="nx">nameWithOwner</span>
        <span class="nx">viewerHasStarred</span>
        <span class="nx">languages</span><span class="p">(</span><span class="nx">first</span><span class="o">:</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span> <span class="err">#</span> <span class="nx">在这里增加查询编程语言</span>
          <span class="nx">nodes</span> <span class="p">{</span>
            <span class="nx">name</span>
          <span class="p">}</span>
        <span class="p">}</span>
        <span class="nx">watchers</span> <span class="p">{</span>
          <span class="nx">totalCount</span>
        <span class="p">}</span>
        <span class="nx">stargazers</span> <span class="p">{</span>
          <span class="nx">totalCount</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="nx">totalCount</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>依照这个简单的查询，可以看出 GraphQL 的便捷之处。后端编写完毕之后，前端基本上就可以对着 Schemas 里面的 query 查询完毕了。</p>
<p>查询这么搞可以，增删改查之类的操作呢？</p>
<p>GraphQL 里面还有 Mutation 可以帮你解决这个问题，在后端定义完 Mutation , 前端在 Mutation 里面可以直接传参。</p>
<h2 id="0x04-graphql-给生产端带来的挑战">0x04 GraphQL 给生产端带来的挑战</h2>
<p>消费端爽了，是否意味着生产端会爽呢？</p>
<p>并不是</p>
<ol>
<li>对于前端来说，如果要消费 graphql api, 相对容易一些。 只需将原先的 api 层改为 graphqlfetch 即可</li>
<li>对于后端来说，如果要生产 graphql api, 则麻烦了不少。</li>
</ol>
<p>下文我会以 graphene 这个 graphql python 库来说明带来的一些挑战</p>
<p><a href="https://github.com/graphql-python/graphene">https://github.com/graphql-python/graphene</a></p>
<p>有的挑战是和 graphql 相关的，有的挑战则是来自 graphene 库，或许其他库有更好的解决方案。</p>
<p>大致有下面的挑战</p>
<ul>
<li>View 层代码组织剧变</li>
<li>权限问题</li>
<li>版本更迭</li>
<li>required vs nullable vs blank</li>
<li>服务端缓存</li>
<li>嵌套式 API</li>
<li>N+1 问题</li>
<li>为名所困</li>
</ul>
<h3 id="view-层代码组织剧变">View 层代码组织剧变</h3>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">graphene</span>

<span class="k">class</span> <span class="nc">PersonInput</span><span class="p">(</span><span class="n">graphene</span><span class="o">.</span><span class="n">InputObjectType</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">graphene</span><span class="o">.</span><span class="n">String</span><span class="p">(</span><span class="n">required</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">age</span> <span class="o">=</span> <span class="n">graphene</span><span class="o">.</span><span class="n">Int</span><span class="p">(</span><span class="n">required</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">CreatePerson</span><span class="p">(</span><span class="n">graphene</span><span class="o">.</span><span class="n">Mutation</span><span class="p">):</span>
    <span class="k">class</span> <span class="nc">Arguments</span><span class="p">:</span>
        <span class="n">person_data</span> <span class="o">=</span> <span class="n">PersonInput</span><span class="p">(</span><span class="n">required</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="n">person</span> <span class="o">=</span> <span class="n">graphene</span><span class="o">.</span><span class="n">Field</span><span class="p">(</span><span class="n">Person</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">mutate</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">person_data</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">person</span> <span class="o">=</span> <span class="n">Person</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="n">person_data</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="n">age</span><span class="o">=</span><span class="n">person_data</span><span class="o">.</span><span class="n">age</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">CreatePerson</span><span class="p">(</span><span class="n">person</span><span class="o">=</span><span class="n">person</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Person</span><span class="p">(</span><span class="n">graphene</span><span class="o">.</span><span class="n">ObjectType</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">graphene</span><span class="o">.</span><span class="n">String</span><span class="p">()</span>
    <span class="n">age</span> <span class="o">=</span> <span class="n">graphene</span><span class="o">.</span><span class="n">Int</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">MyMutations</span><span class="p">(</span><span class="n">graphene</span><span class="o">.</span><span class="n">ObjectType</span><span class="p">):</span>
    <span class="n">create_person</span> <span class="o">=</span> <span class="n">CreatePerson</span><span class="o">.</span><span class="n">Field</span><span class="p">()</span>

<span class="c1"># We must define a query for our schema</span>
<span class="k">class</span> <span class="nc">Query</span><span class="p">(</span><span class="n">graphene</span><span class="o">.</span><span class="n">ObjectType</span><span class="p">):</span>
    <span class="n">person</span> <span class="o">=</span> <span class="n">graphene</span><span class="o">.</span><span class="n">Field</span><span class="p">(</span><span class="n">Person</span><span class="p">)</span>

<span class="n">schema</span> <span class="o">=</span> <span class="n">graphene</span><span class="o">.</span><span class="n">Schema</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="n">Query</span><span class="p">,</span> <span class="n">mutation</span><span class="o">=</span><span class="n">MyMutations</span><span class="p">)</span>
</code></pre></div><p>同样的逻辑用原先的方法只需如此即可。</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="nd">@bp.get</span><span class="p">(</span><span class="s2">&#34;/person&#34;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">get_person</span><span class="p">():</span>
  <span class="c1"># do get person</span>
  <span class="k">return</span> <span class="n">data</span>

<span class="k">class</span> <span class="nc">DataValidator</span><span class="p">(</span><span class="n">validator</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="n">constr</span><span class="p">(</span><span class="n">min_length</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_length</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">age</span><span class="p">:</span> <span class="n">conint</span><span class="p">(</span><span class="n">gte</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">lte</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>

<span class="nd">@bp.post</span><span class="p">(</span><span class="s2">&#34;/person_create&#34;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">person_create</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">DataValidator</span><span class="p">):</span>
  <span class="c1"># do create person</span>
  <span class="k">return</span> <span class="n">data</span>
</code></pre></div><p>带来的挑战如下</p>
<pre><code>1. 原先简单清晰的代码变成了非常冗长的代码。
  - 为了提升输入速度，则需要使用 code generator 或者 snippet 。
  - 提升了输入速度，但是由于写完之后代码阅读带来较多无效阅读，反而造成了诸多不便。
2. 校验层没了。而增加校验层变得比较麻烦。
3. 随着代码量上升，相同业务逻辑的物理距离变得比较长，query 和 mutation 需要拆分到两个文件或者一个文件的上部分和下部分。
  - 假设你写的是一个商城，从上到下阅读代码会发现一会儿是商品基本信息，一会儿是分类，一会儿是订单，一会儿又是分类，或者 order 的逻辑查看在一个文件的犄角旮旯，修改在另一个文件的犄角旮旯。
  - 假设查询订单和修改订单两个接口查询，查看与修改所查询的业务逻辑是一样的。由于物理距离过于远，则大概率会写两遍这个代码。Same Logic, Write Everywhere
</code></pre><h3 id="权限问题">权限问题</h3>
<p>接口的正交性带来的是细粒度的控制，而聚合起来之后，权限则不是很好管控。</p>
<p>一个请求打过来包含了越权和非越权的请求。</p>
<p>服务端需要如何判断？</p>
<blockquote>
<p>保大保小？</p>
</blockquote>
<h3 id="版本更迭">版本更迭</h3>
<p>随着业务的变更，往往需要新增 / 废弃一些接口。</p>
<ul>
<li>接口新增只需要考虑 v2 版本</li>
<li>接口移除通过监控接口的请求次数来解决这个问题。</li>
</ul>
<p>graphql 社区推荐的是不废弃接口&hellip;.</p>
<h3 id="required-vs-nullable-vs-blank">required vs nullable vs blank</h3>
<ul>
<li>not required 表示这个字段不是必须的，可传可不传。</li>
<li>required 表示这个字段是必须的，但可为 null/none, 也可不为。</li>
<li>not nullable 表示这个字段是必须的，但是不能为 null/none</li>
<li>nullable 表示这个字段是必须的，但可为 null/none, 也可不为。</li>
<li>not blank 表示这个字段是可为空的
<ul>
<li>对于字符串，则必须要不为 &quot;&quot;</li>
<li>对于列表，则必须要存在至少一个 item</li>
</ul>
</li>
</ul>
<p>举个例子来说明，如果要表示如下的响应内容</p>
<p>订单没有支付状态，就没有支付方式，即不应该有支付方式这个字段。</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="c1"># 未支付订单</span>
<span class="p">{</span>
  <span class="s2">&#34;status&#34;</span><span class="p">:</span> <span class="s2">&#34;NOT_PAID&#34;</span>
<span class="p">}</span>

<span class="c1"># 已支付订单</span>
<span class="p">{</span>
  <span class="s2">&#34;status&#34;</span><span class="p">:</span> <span class="s2">&#34;PAID&#34;</span><span class="p">,</span>
  <span class="s2">&#34;pay_method&#34;</span><span class="p">:</span> <span class="s2">&#34;WECHAT&#34;</span>
<span class="p">}</span>
</code></pre></div><p>graphene 没法做到未支付订单无 pay_method 这种情况，在响应体里 pay_method 总是为 null</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="c1"># 未支付订单</span>
<span class="p">{</span>
  <span class="s2">&#34;status&#34;</span><span class="p">:</span> <span class="s2">&#34;NOT_PAID&#34;</span>
  <span class="s2">&#34;pay_method&#34;</span><span class="p">:</span> <span class="n">null</span>
<span class="p">}</span>
</code></pre></div><p>对于消费 API 的客户端，需要按照具体情况来判断 null 值的现实意义是否存在。</p>
<h3 id="服务端缓存">服务端缓存</h3>
<p>要查什么，往往不可知（无法预知查询语句），随前端来定。</p>
<p>而通过 URI 定位资源，Http 协议无状态，非常容易实现对应用层透明的缓存。</p>
<p>而 GraphQL 重新定义了资源的定位方式，</p>
<p>于是乎，我在设计缓存的时候往往不知道该怎么设计。</p>
<h3 id="嵌套式-api">嵌套式 API</h3>
<p>因为过度讲究复用，node 和 node 之间连接关系较为复杂。</p>
<p>比如，设计应用的初期你有这么一个商品 api</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">product</span> <span class="p">{</span>
  <span class="nx">template</span> <span class="p">{</span>
    <span class="nx">id</span>
    <span class="nx">name</span>
    <span class="nx">price</span>
    <span class="nx">category</span> <span class="p">{</span>
      <span class="nx">id</span>
      <span class="nx">name</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="nx">id</span>
<span class="p">}</span>
</code></pre></div><p>随着业务变得越来越复杂，product 很可能和 template 模板解耦，</p>
<p>在这种情况下，最好的做法当然是新增一个接口。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">productV2</span> <span class="p">{</span>
  <span class="nx">id</span>
  <span class="nx">name</span>
  <span class="nx">price</span>
  <span class="nx">category</span> <span class="p">{</span>
    <span class="nx">id</span>
    <span class="nx">name</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>但老接口总不能挂掉吧。那么为了解决这个问题，后端需要向后兼容代码重写 product-&gt;template 里面的 name、price</p>
<p>但在 graphql 的场景下，重写 resolver 是一个非常的影响是未知的。</p>
<p>因为，你不知道有多少个 query 用了这个 field, 为了知道这个问题，你还得打点知道有多少个场景的 query 嘛。</p>
<p>你以为打点就知道有多少个场景的 query 嘛？前端起名字都不通知你的。</p>
<p>现实生活中情况可能复杂一些。这个例子旨在说明，存在一些改动的心智负担比较严重。 比如，前端不便，所有商家级别的数据落到店铺级别。</p>
<p>这个例子正确的解法是联合前端一起升级到 V2</p>
<h3 id="n1-问题">N+1 问题</h3>
<p>有的时候需要看情况来解决不同的 N+1 问题，也是比较迷惑的&hellip;.</p>
<p>因为客户端不见得会按照你的要求来查询。</p>
<h3 id="为名所困">为名所困</h3>
<p>项目写了半年之后，我只记得我一直在各种起名困难症中度过。</p>
<p>明明业务流程都差不多，但最后结果全是在改各种各样的的名字前缀。</p>
<h2 id="0x05-如何应对挑战">0x05 如何应对挑战</h2>
<p>经过实践，我最后得出的结论是，对用户端的请求做一部分的裁剪，写成 restful like 的 graphql</p>
<ol>
<li>减少接口的嵌套，尽量在 2~3 层，不超过 5 层。</li>
<li>使用 Pydantic 作为接口校验，并且自动生成 ObjectType 与 InputObjectType</li>
</ol>
<h3 id="顺应-restful-like-的-view-层组织方式">顺应 restful like 的 view 层组织方式</h3>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="nd">@router.item</span><span class="p">(</span><span class="s2">&#34;/person&#34;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">get_person</span><span class="p">(</span><span class="nb">id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
  <span class="c1"># do get person</span>
  <span class="k">return</span> <span class="n">data</span>

<span class="k">class</span> <span class="nc">AParams</span><span class="p">(</span><span class="n">Params</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="n">constr</span><span class="p">(</span><span class="n">min_length</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_length</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">age</span><span class="p">:</span> <span class="n">conint</span><span class="p">(</span><span class="n">gte</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">lte</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>

<span class="nd">@router.list</span><span class="p">(</span><span class="s2">&#34;/persons&#34;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">get_persons</span><span class="p">(</span><span class="n">params</span><span class="p">:</span> <span class="n">AParams</span><span class="p">):</span>
  <span class="c1"># do get persons</span>
  <span class="k">return</span> <span class="n">data</span>

<span class="k">class</span> <span class="nc">BParams</span><span class="p">(</span><span class="n">PageParams</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="n">constr</span><span class="p">(</span><span class="n">min_length</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_length</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">age</span><span class="p">:</span> <span class="n">conint</span><span class="p">(</span><span class="n">gte</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">lte</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>

<span class="nd">@router.paginate</span><span class="p">(</span><span class="s2">&#34;/person_pagination&#34;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">get_person_pagination</span><span class="p">(</span><span class="n">params</span><span class="p">:</span> <span class="n">BParams</span><span class="p">):</span>
  <span class="c1"># do get persons</span>
  <span class="k">return</span> <span class="n">data</span>

<span class="k">class</span> <span class="nc">CParams</span><span class="p">(</span><span class="n">validator</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="n">constr</span><span class="p">(</span><span class="n">min_length</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_length</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">age</span><span class="p">:</span> <span class="n">conint</span><span class="p">(</span><span class="n">gte</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">lte</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>

<span class="nd">@route.mutation</span><span class="p">(</span><span class="s2">&#34;/person_create&#34;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">person_create</span><span class="p">(</span><span class="n">params</span><span class="p">:</span> <span class="n">CParams</span><span class="p">):</span>
  <span class="c1"># do create person</span>
  <span class="k">return</span> <span class="n">data</span>
</code></pre></div><p>通过这种方式，可以保持原先的代码结构，减少原先从 Restful 过来的迁移成本。</p>
<h3 id="版本更迭-1">版本更迭</h3>
<p>版本照常更迭，V1/V2 也用上。</p>
<h3 id="服务端缓存-1">服务端缓存</h3>
<p>直接序列化塞到 redis 里面</p>
<h3 id="n1-问题-1">N+1 问题</h3>
<ul>
<li>
<p><a href="https://yacine.org/2017/02/27/graphqlgraphene-sqlalchemy-and-the-n1-problem/">https://yacine.org/2017/02/27/graphqlgraphene-sqlalchemy-and-the-n1-problem/</a></p>
</li>
<li>
<p><a href="https://github.com/graphql-python/graphene-sqlalchemy/issues/35">https://github.com/graphql-python/graphene-sqlalchemy/issues/35</a></p>
</li>
</ul>
<h3 id="required-vs-nullable-vs-blank-1">required vs nullable vs blank</h3>
<p>比如对于一个 Mutation 来说</p>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
  <span class="nt">&#34;a&#34;</span><span class="p">:</span> <span class="mi">1</span>
<span class="p">}</span>
</code></pre></div><p>表示的是设置 a 为 1</p>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
  <span class="nt">&#34;a&#34;</span><span class="p">:</span> <span class="kc">null</span>
<span class="p">}</span>
</code></pre></div><p>表示的是设置 a 为 null</p>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
<span class="p">}</span>
</code></pre></div><p>表示的是不设置 a</p>
<p>blank 交给 validator 来做</p>
<p>对于消费 API 的客户端，则需要按照具体情况来判断 null 值的现实意义是否存在。</p>
<h3 id="结论">结论</h3>
<p>这样组织代码，代码量比原先少了很多。一番实践下来，手贱率导致的问题直线下降。</p>
<h2 id="0x05-其他思考点">0x05 其他思考点</h2>
<h3 id="rest-or-graphql-无法解决的问题">Rest Or GraphQL 无法解决的问题</h3>
<blockquote>
<p>业务逻辑的沟通问题</p>
</blockquote>
<p>抛开前后端分离所带来的优点，前后端分离的一大问题就是，前后端人员的分离。</p>
<p>如果你的公司规模不是很大，开发的项目需要一定的背景知识，团队开发比较（经常）敏（调整）捷（需求）, 沟通上就会有些问题，</p>
<p>具体表现为，后端理解了需求，还需要和前端讲清楚，而刚讲清楚没几天，产品又跑过来说，这个业务我们需要调整一下。几次折腾下来，就会出现一个尴尬的局面。</p>
<p>前后端有的时候对业务理解出现来偏差。在以前不区分前后端的时候，一个东西到实现基本上一个人就可以 Cover 掉，只要这个人理解了业务逻辑，就行了。现在前后端分离，就要求前后端对需求的理解</p>
<p>如果需求不明确，就会出现如下情况，前端一脸懵逼的问后端与产品『眼前的黑不是黑，你说的白是什么白』</p>
<p>当然，这个不属于技术问题，只是提一下。</p>
<h2 id="0xee-参考链接">0xEE 参考链接</h2>
<hr>
<p>ChangeLog:</p>
<ul>
<li><strong>2017-01-20</strong> 初始化本文</li>
</ul>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2020-01-01</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/graphql/">GraphQL</a>,&nbsp;<a href="/tags/restful/">Restful</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/20201202_react_stack/" class="prev" rel="prev" title="React Stack"><i class="fas fa-angle-left fa-fw"></i>React Stack</a></div>
</div>
</article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.79.0">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2020</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="http://twocucao.xyz" target="_blank">twocucao</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><script type="text/javascript" src="/lib/smooth-scroll/smooth-scroll.min.js"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
