<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>所有文章 - 海拉鲁编程客</title>
        <link>http://twocucao.xyz/posts/</link>
        <description>所有文章 | 海拉鲁编程客</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-cn</language><managingEditor>twocucao@gmail.com (twocucao)</managingEditor>
            <webMaster>twocucao@gmail.com (twocucao)</webMaster><lastBuildDate>Wed, 02 Dec 2020 21:57:40 &#43;0800</lastBuildDate><atom:link href="http://twocucao.xyz/posts/" rel="self" type="application/rss+xml" /><item>
    <title>GraphQL 的一些项目经验</title>
    <link>http://twocucao.xyz/posts/20180721_graphqlcheatsheet/</link>
    <pubDate>Wed, 02 Dec 2020 21:57:40 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://twocucao.xyz/posts/20180721_graphqlcheatsheet/</guid>
    <description><![CDATA[0x00 前言 本文最早行文于 2018 年中，那时 GraphQL 的生态尚未成熟，也缺乏社区总结的一些经验。
2020 年末，复盘一下 GraphQL 的一些使用经验。
名词约定  接口生产端 / 服务端 下面统一称「生产端」 接口消费端 / 客户端 下面统一称「消费端」  0x01 流水的技术方案，铁打的需求。 年幼时看笑傲江湖，华山派两派居然为了剑宗和气宗争个你死我活。
觉得甚是幼稚。
年纪渐大之后发现社会处处充满着这种荒谬的争论。
 剑宗 or 气宗 自然美 or 人造美 Java or Python Editor or IDE Rest or GraphQL 单体应用 or 微服务   剑招是死的，人是活的。
 打个比方，当讨论问题的时候，下面两个问题意义可能并不是很大。
 用剑宗初学者和气宗高手比，或者相反，这个完全没有多大意义？ 用剑宗初学者和气宗初学者比，有一点意义，但意义也不是很大。  GraphQL 作为挑战者，下面几个问题是很有意义的。
GraphQL 相比于原先成熟稳定的方案，GraphQL
 现有方案存在哪些问题？ 新方案解决了哪些原先没有解决的问题。 新方案更低成本解决了哪些问题。 现有的痛点是否存在一些新老方案都无法解决的问题。 有无前车之鉴，有无社区最佳实践。 迁移成本和学习成本是多少。 回滚成本多少。  0x02 RESTful 的缺点 RESTful 有很多接口上最佳实践，但生搬硬套就会使得接口比较诡异。]]></description>
</item><item>
    <title>React Stack</title>
    <link>http://twocucao.xyz/posts/20201202_react_stack/</link>
    <pubDate>Wed, 02 Dec 2020 18:59:58 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://twocucao.xyz/posts/20201202_react_stack/</guid>
    <description><![CDATA[0x00 前言 16 年~20 年先后折腾过
 vue 2 angular 4 react class component angular 4 react hooks vue 3  综合考虑了
 开发工具链 社区生态 跨端方案 与 Typescript 的结合程度  最后形成了较为稳定的 react 技术栈
0x01 桌面端 https://github.com/twocucao/react-starter
 react hooks typescript mobx css tailwindcss format with prettier lint with eslint  0x02 移动端 https://github.com/twocucao/react-starter
0x03 小程序端 https://github.com/twocucao/react-starter-remaxjs
https://github.com/twocucao/react-starter-taro
 All Feature Supported By RemaxJS Type Hint - Typescript for better multi-user developing experience style management - tailwind like utils which called minimal.]]></description>
</item><item>
    <title>Modern Shell</title>
    <link>http://twocucao.xyz/posts/20201201_modern_shell/</link>
    <pubDate>Mon, 30 Nov 2020 18:19:17 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://twocucao.xyz/posts/20201201_modern_shell/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://user-images.githubusercontent.com/5625783/100601457-8efe8a80-333d-11eb-803e-861352bd1715.jpg" referrerpolicy="no-referrer">
            </div>0x01 更好的替代品 find -&gt; fd {}: A placeholder token that will be replaced with the path of the search result (documents/images/party.jpg). {.}: Like {}, but without the file extension (documents/images/party). {/}: A placeholder that will be replaced by the basename of the search result (party.jpg). {//}: Uses the parent of the discovered path (documents/images). {/.}: Uses the basename, with the extension removed (party). # Convert all jpg files to png files: fd -e jpg -x convert {} {.]]></description>
</item><item>
    <title>Python Profiling/Tracing Tools</title>
    <link>http://twocucao.xyz/posts/20201201_pythonprofiling/</link>
    <pubDate>Mon, 30 Nov 2020 18:14:14 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://twocucao.xyz/posts/20201201_pythonprofiling/</guid>
    <description><![CDATA[Profiling 定位与优化耗时、内存使用、CPU 使用 Tracing 用于追踪内存布局  0x00 前言 本篇讨论的是优化
当我们在谈优化的的时候，首先要背诵下面三个口诀
优化口诀 1: 先做对，布监控，再做好。 优化口诀 2: 过早优化是万恶之源。 优化口诀 3: 去优化那些需要优化的地方。  可以参考之前的文章 https://zhuanlan.zhihu.com/p/58754459
本文讨论的是基于现有代码的诊断。也顺带讨论了无侵入线上 trace 的原理和技巧
优化分为两种：
 侵入性诊断 侵入性诊断  0x01 侵入性诊断 基础工具  print logging timeit  Profile vs cProfile cProfile overhead 较高，
import cProfile import re cProfile.run(&#39;re.compile(&#34;foo|bar&#34;)&#39;) 197 function calls (192 primitive calls) in 0.002 seconds Ordered by: standard name ncalls tottime percall cumtime percall filename:lineno(function) 1 0.]]></description>
</item><item>
    <title>开源认证基础服务</title>
    <link>http://twocucao.xyz/posts/20201130_ory/</link>
    <pubDate>Mon, 30 Nov 2020 18:03:01 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://twocucao.xyz/posts/20201130_ory/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://user-images.githubusercontent.com/5625783/100601457-8efe8a80-333d-11eb-803e-861352bd1715.jpg" referrerpolicy="no-referrer">
            </div>0x00 前言 随着业务的增长，往往需要统一体系内的服务的账户。
经过一番调研，决定尝试一下 ory 的开源认证基础服务
0x01 ORY 尝试解决问题？ ORY 提供了四个主要项目，每个项目着力于解决一个边界清晰的认证 / 鉴权问题
 ORY Kratos 提供了用户认证服务 ORY Hydra 提供了 OAuth 2.0 &amp; OpenID Connect provider. ORY Keto 提供了 访问控制 ORY Oathkeeper 提供了认证访问代理  0x02 用户认证服务 Kratos 常见方案  方案 1, 选择全栈式解决方案 - 比如 Java 社区的 JGroups 方案 2, 选择 IDaas - 比如 Login With Apple, Google 方案 3, 选择自己来 - 比如 Java 社区的 JGroups  三种方案各有利弊
 全栈式解决方案上手极快，但  扩展性不强 绑定 Java 技术栈 数据模型固定 登陆流程固定     更新迭代慢  Login With Google 虽然方便，但是并没有解决如下的问题   更新 Profile  添加第二个恢复邮箱 2FA 存储管理 Sessions   全局登出  自己来，需要处理事情也挺多   方案二遇到的问题，一个不会少 加密算法  流程可能较为复杂，比如先用邮箱注册，然后用 Sign Up Using Google, 或者先用 Sign Up Google, 然后使用邮箱登陆。(PS: 我国的登陆姿势就更多了）    是不是某种方案是最好的呢？其实未必]]></description>
</item><item>
    <title>如何写出整洁的 Python 代码 下</title>
    <link>http://twocucao.xyz/posts/20190924_pycode_08/</link>
    <pubDate>Tue, 24 Sep 2019 21:57:40 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://twocucao.xyz/posts/20190924_pycode_08/</guid>
    <description><![CDATA[本文是《提升你的 Python 项目代码健壮性和性能》系列的第八篇文章。
 第一篇，讲的是如何 用 Type Annotation 提升你的 Python 代码健壮性 第二篇，讲的是 如何通过测试提升 Python 代码的健壮性 第三篇，讲的是在一定并发量的情况下，如何保证 Django 项目的数据一致性 第四篇，讲的是如何定位性能问题 这几招，让你快速提升 Python 项目的性能 第五篇，讲的是 为你的项目快速搭建 ELKFA 日志系统 第六篇，为《整洁上篇》讲的是 从变量命名 / 函数 / 注释整洁 / 格式整洁上写出干净的代码 第七篇，为《整洁中篇》讲的是 一些的编程时候的基本原则，比如，避免过深的缩进，SOLID 法则，边界  本文是《整洁下篇》，本文的诞生，要感谢我前公司的技术主管豪蔚老师和产品主管刚哥，在上海工作这几年，总是和能优秀的人工作，确实是我幸运的地方。
目录如下
▼ 如何写出整洁的 Python 代码 下篇 : section 0x00 前言 : section 0x01 处理需求的姿势 : section ▼ 0x02 敏捷开发 : section 看板和晨会 : section 敏捷的时间安排：周一到周五 : section 人员安排 : section ▼ 0x03 代码全局观 : section 起个好名字 : section 本质复杂度和偶然复杂度 : section 0xEE 后记 : section 0x00 前言 这篇文章憋了很久，思考了许久，《整洁下篇》干脆就聊聊编程中，不是写代码的部分；]]></description>
</item><item>
    <title>如何写出整洁的 Python 代码 中</title>
    <link>http://twocucao.xyz/posts/20190526_pycode_07/</link>
    <pubDate>Sun, 26 May 2019 21:57:40 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://twocucao.xyz/posts/20190526_pycode_07/</guid>
    <description><![CDATA[本文是《提升你的 Python 项目代码健壮性和性能》系列的第七篇文章。
 第一篇，讲的是如何 用 Type Annotation 提升你的 Python 代码健壮性 第二篇，讲的是 如何通过测试提升 Python 代码的健壮性 第三篇，讲的是在一定并发量的情况下，如何保证 Django 项目的数据一致性 第四篇，讲的是如何定位性能问题 这几招，让你快速提升 Python 项目的性能 第五篇，讲的是 为你的项目快速搭建 ELKFA 日志系统 第六篇，《如何写出整洁的代码 上》 从变量命名 / 函数 / 注释整洁 / 格式整洁上写出干净的代码  目录
▼ 如何写出整洁的 Python 代码 中 : section 0x00 前言 : section 0x01 避免过深的缩进 : section 0x02 使用异常 : section 0x03 类与 OOP : section ▼ 0x04 SOLID 设计原则 : section 单一职责 : section 开闭原则 : section 里氏替换原则 : section 接口隔离原则 : section 依赖反转原则 : section 0x05 边界和第三方库的挑选 : section 0xDD 结论 : section 0xEE 参考 : section 0x00 前言 上篇地址在这里 https://zhuanlan.]]></description>
</item><item>
    <title>如何写出整洁的 Python 代码 上</title>
    <link>http://twocucao.xyz/posts/20190525_pycode_06/</link>
    <pubDate>Sat, 25 May 2019 21:57:40 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://twocucao.xyz/posts/20190525_pycode_06/</guid>
    <description><![CDATA[本文是《提升你的 Python 项目代码健壮性和性能》系列的第六篇文章。
 第一篇，讲的是如何 用 Type Annotation 提升你的 Python 代码健壮性 第二篇，讲的是 如何通过测试提升 Python 代码的健壮性 第三篇，讲的是在一定并发量的情况下，如何保证 Django 项目的数据一致性 第四篇，讲的是如何定位性能问题 这几招，让你快速提升 Python 项目的性能 第五篇，讲的是 为你的项目快速搭建 ELKFA 日志系统  接下来的三篇，围绕另一个主题
 如何写出整洁的代码
 『整洁』三篇是基于**『代码整洁之道』和『架构整洁之道』**的一些切身的理解和体会。
感谢这两本书的作者 Bob 大叔。
 PPS: 某东读书 VIP 会员有不少 IT 资源类的书籍可以免费看，比如『代码整洁之道』
 本文目录如下
▼ 如何写出整洁代码 上篇 : section ▼ 0x00 前言 : section 软件系统的腐败之路 : section ▼ 0x01 讨论 : section 为什么会出现腐败的系统 : section 衡量系统的两个指标 : section 代码是写出来的吗？ : section 好代码的标准 : section ▼ 0x02 变量命名之道 : section 使用业务领域命名 : section 代码命名 : section ▼ 0x03 函数整洁之道 : section 短小精悍 : section 调用层次清晰 : section 控制参数 : section 如何写函数 : section 0x04 注释整洁之道 : section ▼ 0x05 格式整洁之道 : section 排版整齐 : section 上下文相关 : section 0xEE 参考连接 : section 0x00 前言 软件系统的腐败之路 随着项目代码行数的增加，不可避免的遇到软件架构腐败的问题。]]></description>
</item><item>
    <title>Python ORM</title>
    <link>http://twocucao.xyz/posts/20190412_pythonorm/</link>
    <pubDate>Fri, 12 Apr 2019 21:57:40 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://twocucao.xyz/posts/20190412_pythonorm/</guid>
    <description><![CDATA[0x00 前言 Python 圈内三大 ORM SQLAlchemy VS Django ORM VS Peewee
 SQLAlchemy 复杂程度最高，同时，这也意味着 SQLAlchemy 可以做更多的事情。使用 DataMapper 方式实现 Django ORM 个人最喜欢，使用 ActiveRecord 实现 如果不是因为现在 Flask 项目已经是用了 SQLAlchemy , 否则的话我甚至会考虑将 Django ORM 配置到 Flask 项目中。当然，也有蛋疼的 SqlAlchemy 使用者已经移植给 django 配置了 SQLAlchemy 的库。 Peewee 没用过，不好评论。以后有机会试试。  0x01 如何访问数据库 那，既然已经可以访问数据库，本着『如无必要，勿增实体』的原则，为什么要不辞劳苦的用个库呢？
0x02 数据库抽象的两种理论 理论一：Active Record 理论二：Data Mapper 0x03 数据库抽象的两种实现 实现一：Django ORM 实现二：Sqlalchemy 0x04 工具的强弱 https://www.thoughtfulcode.com/orm-active-record-vs-data-mapper/
2.0 SQLAlchemy VS DjangoORM ORM 通常有 DataMapper 实现和 ActiveRecord 实现两种。]]></description>
</item><item>
    <title>如何优雅的使用 Windows 10</title>
    <link>http://twocucao.xyz/posts/20190413_%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E4%BD%BF%E7%94%A8windows10/</link>
    <pubDate>Wed, 03 Apr 2019 21:57:40 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://twocucao.xyz/posts/20190413_%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E4%BD%BF%E7%94%A8windows10/</guid>
    <description><![CDATA[0x00 前言 最近入手了 SP6, 于是把 2015 年写的这篇文章修订为 2019 版
 笔者已过了爱折腾的年纪，仅从提升工作效率方面来说。
 背景：
Pythonista &amp;&amp; Nodejs 工作机 MBP 2017 款机器 生活机 Surface Pro 6, 轻办公，有时也用来调试 Windows 上的程序。  本文目录
▼ 0x00 前言 : section 0x01 文件整理 : section ▼ 0x02 自带功能 : section 2.1 快捷键 : section 2.2 触摸板 : section 2.3 Win+R -- 运行 : section ▼ 0x03 必备软件 : section 3.1 文件管理 : section 3.2 资讯浏览 : section 3.]]></description>
</item></channel>
</rss>
